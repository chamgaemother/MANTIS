[
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.DefaultingXmlTypeResolverBuilder",
    "methodName": "init",
    "signature": "com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder init(com.fasterxml.jackson.\u0027annotation\u0027.JsonTypeInfo$Id,com.fasterxml.jackson.databind.jsontype.TypeIdResolver)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r3 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultingXmlTypeResolverBuilder\n  JsonTypeInfo$Id\n  TypeIdResolver\n  r0.init(r1, r2)\n  $r3 \u003d String _typeProperty\u003e\n  if ($r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d String _typeProperty\u003e\n  $r5 \u003d StaxUtil.sanitizeXmlTypeName($r4)\n  String _typeProperty\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.DefaultingXmlTypeResolverBuilder",
    "methodName": "typeProperty",
    "signature": "com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder typeProperty(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // ok to have null/empty; will restore to use defaults\r\n    if (typeIdPropName \u003d\u003d null || typeIdPropName.length() \u003d\u003d 0) {\r\n        typeIdPropName \u003d _idType.getDefaultPropertyName();\r\n    }\r\n    _typeProperty \u003d StaxUtil.sanitizeXmlTypeName(typeIdPropName);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DefaultingXmlTypeResolverBuilder\n  String\n  if (r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d r2.length()\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d JsonTypeInfo$Id _idType\u003e\n  r2 \u003d $r1.getDefaultPropertyName()\n}",
      "B3 {\n  $r3 \u003d StaxUtil.sanitizeXmlTypeName(r2)\n  String _typeProperty\u003e \u003d $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  FromXmlParser$Feature\n  $i0 \u003d FromXmlParser: int _formatFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser configure(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  FromXmlParser$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "addVirtualWrapping",
    "signature": "void addVirtualWrapping(java.util.Set,boolean)",
    "visibility": "public",
    "body": "{\r\n    //System.out.printf(\"addVirtualWrapping(%s) at \u0027%s\u0027 [case-insensitive? %s]\\n\", namesToWrap0, _parsingContext.pathAsPointer(), caseInsensitive);\r\n    final Set\u003cString\u003e namesToWrap \u003d caseInsensitive ? CaseInsensitiveNameSet.construct(namesToWrap0) : namesToWrap0;\r\n    // 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\r\n    //   problems with Lists-in-Lists properties\r\n    // 12-May-2020, tatu: But as per [dataformat-xml#86] NOT for root element\r\n    //   (would still like to know why work-around needed ever, but...)\r\n    if (!_parsingContext.inRoot() \u0026\u0026 !_parsingContext.getParent().inRoot()) {\r\n        String name \u003d _xmlTokens.getLocalName();\r\n        if ((name !\u003d null) \u0026\u0026 namesToWrap.contains(name)) {\r\n            //System.out.println(\"REPEAT from addVirtualWrapping() for \u0027\"+name+\"\u0027\");\r\n            _xmlTokens.repeatStartElement();\r\n        }\r\n    }\r\n    _parsingContext.setNamesToWrap(namesToWrap);\r\n}",
    "nodes": 9,
    "edges": 13,
    "cc": 6,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($z1 !\u003d 0) → B4 | else → B8",
      "B4 : If($z2 !\u003d 0) → B5 | else → B8",
      "B5 : If(r7 \u003d\u003d null) → B6 | else → B8",
      "B6 : If($z3 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  Set\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d CaseInsensitiveNameSet.construct(r0)\n  goto B3\n}",
      "B2 {\n  $r9 \u003d r0\n}",
      "B3 {\n  r1 \u003d $r9\n  $r3 \u003d XmlReadContext _parsingContext\u003e\n  $z1 \u003d $r3.inRoot()\n  if ($z1 !\u003d 0) goto B4 else B8\n}",
      "B4 {\n  $r4 \u003d XmlReadContext _parsingContext\u003e\n  $r5 \u003d $r4.getParent()\n  $z2 \u003d $r5.inRoot()\n  if ($z2 !\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $r6 \u003d XmlTokenStream _xmlTokens\u003e\n  r7 \u003d $r6.getLocalName()\n  if (r7 \u003d\u003d null) goto B6 else B8\n}",
      "B6 {\n  $z3 \u003d $r9.contains(r7)\n  if ($z3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r8 \u003d XmlTokenStream _xmlTokens\u003e\n  $r8.repeatStartElement()\n}",
      "B8 {\n  $r10 \u003d XmlReadContext _parsingContext\u003e\n  $r10.setNamesToWrap(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "currentName",
    "signature": "java.lang.String currentName()",
    "visibility": "public",
    "body": "{\r\n    // start markers require information from parent\r\n    String name;\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        XmlReadContext parent \u003d _parsingContext.getParent();\r\n        name \u003d parent.getCurrentName();\r\n    } else {\r\n        name \u003d _parsingContext.getCurrentName();\r\n    }\r\n    // sanity check\r\n    if (name \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Missing name, in state: \" + _currToken);\r\n    }\r\n    return name;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B2",
      "B1 : If($r9 !\u003d $r8) → B2 | else → B3",
      "B4 : If(r12 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken START_OBJECT\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d JsonToken _currToken\u003e\n  $r8 \u003d JsonToken START_ARRAY\u003e\n  if ($r9 !\u003d $r8) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d XmlReadContext _parsingContext\u003e\n  $r11 \u003d $r3.getParent()\n  r12 \u003d $r11.getCurrentName()\n  goto B4\n}",
      "B3 {\n  $r10 \u003d XmlReadContext _parsingContext\u003e\n  r12 \u003d $r10.getCurrentName()\n}",
      "B4 {\n  if (r12 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d IllegalStateException\n  $r5 \u003d JsonToken _currToken\u003e\n  $r6 \u003d String.valueOf($r5)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalStateException($r7)\n  throw $r4\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "overrideCurrentName",
    "signature": "void overrideCurrentName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // Simple, but need to look for START_OBJECT/ARRAY\u0027s \"off-by-one\" thing:\r\n    XmlReadContext ctxt \u003d _parsingContext;\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        ctxt \u003d ctxt.getParent();\r\n    }\r\n    ctxt.setCurrentName(name);\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B2",
      "B1 : If($r5 !\u003d $r4) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  String\n  r6 \u003d XmlReadContext _parsingContext\u003e\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken START_OBJECT\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d JsonToken _currToken\u003e\n  $r4 \u003d JsonToken START_ARRAY\u003e\n  if ($r5 !\u003d $r4) goto B2 else B3\n}",
      "B2 {\n  r6 \u003d r6.getParent()\n}",
      "B3 {\n  r6.setCurrentName(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!_closed) {\r\n        _closed \u003d true;\r\n        try {\r\n            if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\r\n                _xmlTokens.closeCompletely();\r\n            } else {\r\n                _xmlTokens.close();\r\n            }\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsParseException(e, this);\r\n        } finally {\r\n            // Also, internal buffer(s) can now be released as well\r\n            _releaseBuffers();\r\n        }\r\n        _ioContext.close();\r\n    }\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B9",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $z0 \u003d FromXmlParser: boolean _closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B9\n}",
      "B1 {\n  FromXmlParser: boolean _closed\u003e \u003d 1\n  $r1 \u003d IOContext _ioContext\u003e\n  $z1 \u003d $r1.isResourceManaged()\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d JsonParser$Feature AUTO_CLOSE_SOURCE\u003e\n  $z2 \u003d r0.isEnabled($r4)\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d XmlTokenStream _xmlTokens\u003e\n  $r2.closeCompletely()\n  goto B5\n}",
      "B4 {\n  $r5 \u003d XmlTokenStream _xmlTokens\u003e\n  $r5.close()\n}",
      "B5 {\n  r0._releaseBuffers()\n  goto B8\n}",
      "B6 {\n  $r7 :\u003d @caughtexception\n  StaxUtil.throwAsParseException($r7, r0)\n  r0._releaseBuffers()\n  goto B8\n}",
      "B7 {\n  $r6 :\u003d @caughtexception\n  r0._releaseBuffers()\n  throw $r6\n}",
      "B8 {\n  $r3 \u003d IOContext _ioContext\u003e\n  $r3.close()\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B9",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B8",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "FromXmlParser#_releaseBuffers(...0)",
        "body": "{\r\n    // anything we can/must release? Underlying parser should do all of it, for now?\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "isExpectedStartArrayToken",
    "signature": "boolean isExpectedStartArrayToken()",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        try {\r\n            _updateToken(JsonToken.START_ARRAY);\r\n        } catch (StreamConstraintsException e) {\r\n            throw new UncheckedIOException(e);\r\n        }\r\n        // Ok: must replace current context with array as well\r\n        _parsingContext.convertToArray();\r\n        //System.out.println(\" FromXmlParser.isExpectedArrayStart(): OBJ-\u003eArray\");\r\n        // And just in case a field name was to be returned, wipe it\r\n        // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\r\n        if (_nextToken \u003d\u003d JsonToken.END_OBJECT) {\r\n            _nextToken \u003d JsonToken.END_ARRAY;\r\n        } else {\r\n            _nextToken \u003d null;\r\n        }\r\n        // and last thing, [dataformat-xml#33], better ignore attributes\r\n        _xmlTokens.skipAttributes();\r\n        return true;\r\n    }\r\n    //System.out.println(\" FromXmlParser.isExpectedArrayStart?: t\u003d\"+t);\r\n    return (t \u003d\u003d JsonToken.START_ARRAY);\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d $r2) → B1 | else → B7",
      "B3 : If($r7 !\u003d $r6) → B4 | else → B5",
      "B7 : If(r1 !\u003d $r3) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken START_OBJECT\u003e\n  if (r1 !\u003d $r2) goto B1 else B7\n}",
      "B1 {\n  $r4 \u003d JsonToken START_ARRAY\u003e\n  r0._updateToken($r4)\n  goto B3\n}",
      "B2 {\n  $r10 :\u003d @caughtexception\n  $r11 \u003d UncheckedIOException\n  new UncheckedIOException($r10)\n  throw $r11\n}",
      "B3 {\n  $r5 \u003d XmlReadContext _parsingContext\u003e\n  $r5.convertToArray()\n  $r7 \u003d JsonToken _nextToken\u003e\n  $r6 \u003d JsonToken END_OBJECT\u003e\n  if ($r7 !\u003d $r6) goto B4 else B5\n}",
      "B4 {\n  $r9 \u003d JsonToken END_ARRAY\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  goto B6\n}",
      "B5 {\n  JsonToken _nextToken\u003e \u003d null\n}",
      "B6 {\n  $r8 \u003d XmlTokenStream _xmlTokens\u003e\n  $r8.skipAttributes()\n  return\n}",
      "B7 {\n  $r3 \u003d JsonToken START_ARRAY\u003e\n  if (r1 !\u003d $r3) goto B8 else B9\n}",
      "B8 {\n  $z0 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z0 \u003d 0\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "isExpectedNumberIntToken",
    "signature": "boolean isExpectedNumberIntToken()",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n        final String text \u003d _currText.trim();\r\n        final int len \u003d _isIntNumber(text);\r\n        try {\r\n            if (len \u003e 0) {\r\n                if (len \u003c\u003d 9) {\r\n                    _numberInt \u003d NumberInput.parseInt(text);\r\n                    _numTypesValid \u003d NR_INT;\r\n                    _updateToken(JsonToken.VALUE_NUMBER_INT);\r\n                    return true;\r\n                }\r\n                if (len \u003c\u003d 18) {\r\n                    // definitely in long range\r\n                    long l \u003d NumberInput.parseLong(text);\r\n                    if (len \u003d\u003d 10) {\r\n                        int asInt \u003d (int) l;\r\n                        long l2 \u003d (long) asInt;\r\n                        if (l \u003d\u003d l2) {\r\n                            _numberInt \u003d asInt;\r\n                            _numTypesValid \u003d NR_INT;\r\n                            _updateToken(JsonToken.VALUE_NUMBER_INT);\r\n                            return true;\r\n                        }\r\n                    }\r\n                    _numberLong \u003d l;\r\n                    _numTypesValid \u003d NR_LONG;\r\n                    _updateToken(JsonToken.VALUE_NUMBER_INT);\r\n                    return true;\r\n                }\r\n                // Might still fit within `long`\r\n                if (len \u003d\u003d 19) {\r\n                    final boolean stillLong;\r\n                    if (text.charAt(0) \u003d\u003d \u0027-\u0027) {\r\n                        stillLong \u003d NumberInput.inLongRange(text.substring(1), true);\r\n                    } else {\r\n                        stillLong \u003d NumberInput.inLongRange(text, false);\r\n                    }\r\n                    if (stillLong) {\r\n                        _numberLong \u003d NumberInput.parseLong(text);\r\n                        _numTypesValid \u003d NR_LONG;\r\n                        _updateToken(JsonToken.VALUE_NUMBER_INT);\r\n                        return true;\r\n                    }\r\n                }\r\n                // finally, need BigInteger\r\n                streamReadConstraints().validateIntegerLength(text.length());\r\n                _numberBigInt \u003d NumberInput.parseBigInteger(text, isEnabled(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER));\r\n                _numTypesValid \u003d NR_BIGINT;\r\n                _updateToken(JsonToken.VALUE_NUMBER_INT);\r\n                return true;\r\n            }\r\n        } catch (StreamConstraintsException e) {\r\n            // Ugh. This method in API ought to expose IOException\r\n            throw new UncheckedIOException(e);\r\n        }\r\n    }\r\n    return (t \u003d\u003d JsonToken.VALUE_NUMBER_INT);\r\n}",
    "nodes": 22,
    "edges": 25,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r1 !\u003d $r2) → B1 | else → B18",
      "B1 : If(i0 \u003c\u003d 0) → B2 | else → B16",
      "B2 : If(i0 \u003e 9) → B3 | else → B4",
      "B4 : If(i0 \u003e 18) → B5 | else → B9",
      "B5 : If(i0 !\u003d 10) → B6 | else → B8",
      "B6 : If($b6 !\u003d 0) → B7 | else → B8",
      "B9 : If(i0 !\u003d 19) → B10 | else → B15",
      "B10 : If($i9 !\u003d 45) → B11 | else → B12",
      "B13 : If(z1 \u003d\u003d false) → B14 | else → B15",
      "B18 : If(r1 !\u003d $r3) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_STRING\u003e\n  if (r1 !\u003d $r2) goto B1 else B18\n}",
      "B1 {\n  $r4 \u003d String _currText\u003e\n  r5 \u003d $r4.trim()\n  i0 \u003d r0._isIntNumber(r5)\n  if (i0 \u003c\u003d 0) goto B2 else B16\n}",
      "B2 {\n  if (i0 \u003e 9) goto B3 else B4\n}",
      "B3 {\n  $i7 \u003d NumberInput.parseInt(r5)\n  FromXmlParser: int _numberInt\u003e \u003d $i7\n  FromXmlParser: int _numTypesValid\u003e \u003d 1\n  $r14 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  r0._updateToken($r14)\n  return\n}",
      "B4 {\n  if (i0 \u003e 18) goto B5 else B9\n}",
      "B5 {\n  l8 \u003d NumberInput.parseLong(r5)\n  if (i0 !\u003d 10) goto B6 else B8\n}",
      "B6 {\n  i4 \u003d (int) l8\n  l5 \u003d (long) i4\n  $b6 \u003d l8 cmp l5\n  if ($b6 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  FromXmlParser: int _numberInt\u003e \u003d i4\n  FromXmlParser: int _numTypesValid\u003e \u003d 1\n  $r13 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  r0._updateToken($r13)\n  return\n}",
      "B8 {\n  FromXmlParser: long _numberLong\u003e \u003d l8\n  FromXmlParser: int _numTypesValid\u003e \u003d 2\n  $r12 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  r0._updateToken($r12)\n  return\n}",
      "B9 {\n  if (i0 !\u003d 19) goto B10 else B15\n}",
      "B10 {\n  $c2 \u003d r5.charAt(0)\n  $i9 \u003d (int) $c2\n  if ($i9 !\u003d 45) goto B11 else B12\n}",
      "B11 {\n  $r11 \u003d r5.substring(1)\n  z1 \u003d NumberInput.inLongRange($r11, 1)\n  goto B13\n}",
      "B12 {\n  z1 \u003d NumberInput.inLongRange(r5, 0)\n}",
      "B13 {\n  if (z1 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $l3 \u003d NumberInput.parseLong(r5)\n  FromXmlParser: long _numberLong\u003e \u003d $l3\n  FromXmlParser: int _numTypesValid\u003e \u003d 2\n  $r10 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  r0._updateToken($r10)\n  return\n}",
      "B15 {\n  $r6 \u003d r0.streamReadConstraints()\n  $i1 \u003d r5.length()\n  $r6.validateIntegerLength($i1)\n  $r7 \u003d StreamReadFeature USE_FAST_BIG_NUMBER_PARSER\u003e\n  $z0 \u003d r0.isEnabled($r7)\n  $r8 \u003d NumberInput.parseBigInteger(r5, $z0)\n  BigInteger _numberBigInt\u003e \u003d $r8\n  FromXmlParser: int _numTypesValid\u003e \u003d 4\n  $r9 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  r0._updateToken($r9)\n  return\n}",
      "B16 {\n  goto B18\n}",
      "B17 {\n  $r15 :\u003d @caughtexception\n  $r17 \u003d UncheckedIOException\n  new UncheckedIOException($r15)\n  throw $r17\n}",
      "B18 {\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r1 !\u003d $r3) goto B19 else B20\n}",
      "B19 {\n  $z2 \u003d 1\n  goto B21\n}",
      "B20 {\n  $z2 \u003d 0\n}",
      "B21 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B18",
      "B1 --\u003e B2",
      "B1 --\u003e B16",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "FromXmlParser#_isIntNumber(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    if (len \u003e 0) {\r\n        char c \u003d text.charAt(0);\r\n        // skip leading negative sign, do NOT allow leading plus\r\n        final int start \u003d (c \u003d\u003d \u0027-\u0027) ? 1 : 0;\r\n        for (int i \u003d start; i \u003c len; ++i) {\r\n            int ch \u003d text.charAt(i);\r\n            if (ch \u003e \u00279\u0027 || ch \u003c \u00270\u0027) {\r\n                return -1;\r\n            }\r\n        }\r\n        return len - start;\r\n    }\r\n    return 0;\r\n}"
      },
      {
        "name": "FromXmlParser#streamReadConstraints(...0)",
        "body": "(source not found)"
      },
      {
        "name": "FromXmlParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    _binaryValue \u003d null;\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    //System.out.println(\"FromXmlParser.nextToken0: _nextToken \u003d \"+_nextToken);\r\n    if (_nextToken !\u003d null) {\r\n        final JsonToken t \u003d _updateToken(_nextToken);\r\n        _nextToken \u003d null;\r\n        switch(t) {\r\n            case START_OBJECT:\r\n                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                break;\r\n            case START_ARRAY:\r\n                _parsingContext \u003d _parsingContext.createChildArrayContext(-1, -1);\r\n                break;\r\n            case END_OBJECT:\r\n            case END_ARRAY:\r\n                _parsingContext \u003d _parsingContext.getParent();\r\n                break;\r\n            case FIELD_NAME:\r\n                // 29-Mar-2021, tatu: [dataformat-xml#442]: special case of leading\r\n                //    mixed text added\r\n                if (_nextIsLeadingMixed) {\r\n                    _nextIsLeadingMixed \u003d false;\r\n                    _parsingContext.setCurrentName(_cfgNameForTextElement);\r\n                    _nextToken \u003d JsonToken.VALUE_STRING;\r\n                } else {\r\n                    _parsingContext.setCurrentName(_xmlTokens.getLocalName());\r\n                }\r\n                break;\r\n            default:\r\n                // VALUE_STRING, VALUE_NULL\r\n                // 13-May-2020, tatu: [dataformat-xml#397]: advance `index` anyway; not\r\n                //    used for Object contexts, updated automatically by \"createChildXxxContext\"\r\n                _parsingContext.valueStarted();\r\n        }\r\n        return t;\r\n    }\r\n    int token \u003d _nextToken();\r\n    // Need to have a loop just because we may have to eat/convert\r\n    // a start-element that indicates an array element.\r\n    while (token \u003d\u003d XmlTokenStream.XML_START_ELEMENT) {\r\n        // If we thought we might get leaf, no such luck\r\n        if (_mayBeLeaf) {\r\n            // leave _mayBeLeaf set, as we start a new context\r\n            _nextToken \u003d JsonToken.FIELD_NAME;\r\n            _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        }\r\n        if (_parsingContext.inArray()) {\r\n            // Yup: in array, so this element could be verified; but it won\u0027t be\r\n            // reported anyway, and we need to process following event.\r\n            token \u003d _nextToken();\r\n            _mayBeLeaf \u003d true;\r\n            continue;\r\n        }\r\n        String name \u003d _xmlTokens.getLocalName();\r\n        _parsingContext.setCurrentName(name);\r\n        // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\r\n        // Couple of ways to do it; but start by making _xmlTokens replay the thing...\r\n        if (_parsingContext.shouldWrap(name)) {\r\n            _xmlTokens.repeatStartElement();\r\n        }\r\n        _mayBeLeaf \u003d true;\r\n        // Ok: in array context we need to skip reporting field names.\r\n        // But what\u0027s the best way to find next token?\r\n        return _updateToken(JsonToken.FIELD_NAME);\r\n    }\r\n    // Ok; beyond start element, what do we get?\r\n    while (true) {\r\n        switch(token) {\r\n            case XmlTokenStream.XML_END_ELEMENT:\r\n                // Simple, except that if this is a leaf, need to suppress end:\r\n                if (_mayBeLeaf) {\r\n                    _mayBeLeaf \u003d false;\r\n                    if (_parsingContext.inArray()) {\r\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\r\n                        //    expose as empty Object, not null\r\n                        _nextToken \u003d JsonToken.END_OBJECT;\r\n                        _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                        return _updateToken(JsonToken.START_OBJECT);\r\n                    }\r\n                    // 07-Sep-2019, tatu: for [dataformat-xml#353], must NOT return second null\r\n                    if (_currToken !\u003d JsonToken.VALUE_NULL) {\r\n                        // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n                        _parsingContext.valueStarted();\r\n                        return _updateToken(JsonToken.VALUE_NULL);\r\n                    }\r\n                }\r\n                _updateToken(_parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\r\n                _parsingContext \u003d _parsingContext.getParent();\r\n                return _currToken;\r\n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\r\n                // If there was a chance of leaf node, no more...\r\n                if (_mayBeLeaf) {\r\n                    _mayBeLeaf \u003d false;\r\n                    _nextToken \u003d JsonToken.FIELD_NAME;\r\n                    _currText \u003d _xmlTokens.getText();\r\n                    _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                    return _updateToken(JsonToken.START_OBJECT);\r\n                }\r\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\r\n                return _updateToken(JsonToken.FIELD_NAME);\r\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\r\n                _currText \u003d _xmlTokens.getText();\r\n                // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n                _parsingContext.valueStarted();\r\n                return _updateToken(JsonToken.VALUE_STRING);\r\n            case XmlTokenStream.XML_TEXT:\r\n                _currText \u003d _xmlTokens.getText();\r\n                if (_mayBeLeaf) {\r\n                    _mayBeLeaf \u003d false;\r\n                    // One more refinement (pronounced like \"hack\") is that if\r\n                    // we had an empty String (or all white space), and we are\r\n                    // deserializing an array, we better hide the empty text.\r\n                    // Also: must skip following END_ELEMENT\r\n                    // 05-Jun-2020, tatu: ... if there is one; we may actually alternatively\r\n                    //   get START_ELEMENT for \"mixed content\" case; if so, need to change to\r\n                    //   expose \"XmlText\" as separate property\r\n                    token \u003d _nextToken();\r\n                    if (token \u003d\u003d XmlTokenStream.XML_END_ELEMENT) {\r\n                        if (_parsingContext.inArray()) {\r\n                            if (XmlTokenStream._allWs(_currText)) {\r\n                                // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\r\n                                //    expose as empty Object, not null (or, worse, as used to\r\n                                //    be done, by swallowing the token)\r\n                                _nextToken \u003d JsonToken.END_OBJECT;\r\n                                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                                return _updateToken(JsonToken.START_OBJECT);\r\n                            }\r\n                        }\r\n                        return _updateToken(JsonToken.VALUE_STRING);\r\n                    }\r\n                    if (token !\u003d XmlTokenStream.XML_START_ELEMENT) {\r\n                        throw new JsonParseException(this, String.format(\"Internal error: Expected END_ELEMENT (%d) or START_ELEMENT (%d), got event of type %d\", XmlTokenStream.XML_END_ELEMENT, XmlTokenStream.XML_START_ELEMENT, token));\r\n                    }\r\n                    // fall-through, except must create new context AND push back\r\n                    // START_ELEMENT we just saw:\r\n                    _xmlTokens.pushbackCurrentToken();\r\n                    _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                }\r\n                // [dataformat-xml#177]: empty text may also need to be skipped\r\n                // but... [dataformat-xml#191]: looks like we can\u0027t short-cut, must\r\n                // loop over again\r\n                if (_parsingContext.inObject()) {\r\n                    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n                        // 29-Mar-2021, tatu: [dataformat-xml#442]: need special handling for\r\n                        //    leading mixed content; requires 3-token sequence for which _nextToken\r\n                        //    along is not enough.\r\n                        _nextIsLeadingMixed \u003d true;\r\n                        _nextToken \u003d JsonToken.FIELD_NAME;\r\n                        return _updateToken(JsonToken.START_OBJECT);\r\n                    } else if (XmlTokenStream._allWs(_currText)) {\r\n                        token \u003d _nextToken();\r\n                        continue;\r\n                    }\r\n                } else if (_parsingContext.inArray()) {\r\n                    // [dataformat-xml#319] Aaaaand for Arrays too\r\n                    if (XmlTokenStream._allWs(_currText)) {\r\n                        token \u003d _nextToken();\r\n                        continue;\r\n                    }\r\n                    // 29-Mar-2021, tatu: This seems like an error condition...\r\n                    //   How should we indicate it? As of 2.13, report as unexpected state\r\n                    /*\r\n                    throw _constructError(\r\n\"Unexpected non-whitespace text (\u0027\"+_currText+\"\u0027) in Array context: should not occur (or should be handled)\"\r\n);\r\n                    */\r\n                    // [dataformat-xml#509] 2.13 introduced a defect in which an Exception was thrown above, breaking\r\n                    // parsing of mixed content arrays (https://github.com/FasterXML/jackson-dataformat-xml/issues/509).\r\n                    // This exception case was removed to enable continued support of that functionality, but more\r\n                    // robust state handling may be in order.\r\n                    // See comment https://github.com/FasterXML/jackson-dataformat-xml/pull/604\r\n                }\r\n                // If not a leaf (or otherwise ignorable), need to transform into property...\r\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\r\n                _nextToken \u003d JsonToken.VALUE_STRING;\r\n                return _updateToken(JsonToken.FIELD_NAME);\r\n            case XmlTokenStream.XML_END:\r\n                return _updateTokenToNull();\r\n            default:\r\n                return _internalErrorUnknownToken(token);\r\n        }\r\n    }\r\n}",
    "nodes": 53,
    "edges": 67,
    "cc": 16,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B10",
      "B1 : If(switch-on $i1) → B2 | else → B3",
      "B5 : If($z14 \u003d\u003d false) → B6 | else → B7",
      "B11 : If(i2 !\u003d 1) → B12 | else → B19",
      "B12 : If($z11 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($z12 \u003d\u003d false) → B15 | else → B16",
      "B16 : If($z13 \u003d\u003d false) → B17 | else → B18",
      "B19 : If(switch-on i2) → B20 | else → B29",
      "B20 : If($z8 \u003d\u003d false) → B21 | else → B25",
      "B21 : If($z10 \u003d\u003d false) → B22 | else → B23",
      "B23 : If($r55 \u003d\u003d $r54) → B24 | else → B25",
      "B25 : If($z9 \u003d\u003d false) → B26 | else → B27",
      "B29 : If($z7 \u003d\u003d false) → B30 | else → B31",
      "B33 : If($z0 \u003d\u003d false) → B34 | else → B42",
      "B34 : If(i3 !\u003d 2) → B35 | else → B39",
      "B35 : If($z5 \u003d\u003d false) → B36 | else → B38",
      "B36 : If($z6 \u003d\u003d false) → B37 | else → B38",
      "B39 : If(i3 \u003d\u003d 1) → B40 | else → B41",
      "B42 : If($z1 \u003d\u003d false) → B43 | else → B47",
      "B43 : If($r9 !\u003d $r8) → B44 | else → B45",
      "B45 : If($z4 \u003d\u003d false) → B46 | else → B50",
      "B47 : If($z2 \u003d\u003d false) → B48 | else → B50",
      "B48 : If($z3 \u003d\u003d false) → B49 | else → B50"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  FromXmlParser: byte[] _binaryValue\u003e \u003d null\n  FromXmlParser: int _numTypesValid\u003e \u003d 0\n  $r1 \u003d JsonToken _nextToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B10\n}",
      "B1 {\n  $r80 \u003d JsonToken _nextToken\u003e\n  r95 \u003d r0._updateToken($r80)\n  JsonToken _nextToken\u003e \u003d null\n  $r81 \u003d FromXmlParser$1: int[] $SwitchMap$com$fasterxml$jackson$core$JsonToken\u003e\n  $i0 \u003d r95.ordinal()\n  $i1 \u003d $r81[$i0]\n  XmlReadContext _parsingContext\u003e; }\n}",
      "B2 {\n  $r92 \u003d XmlReadContext _parsingContext\u003e\n  $i5 \u003d (int) -1\n  $i7 \u003d (int) -1\n  $r93 \u003d $r92.createChildObjectContext($i5, $i7)\n  XmlReadContext _parsingContext\u003e \u003d $r93\n  goto B9\n}",
      "B3 {\n  $r90 \u003d XmlReadContext _parsingContext\u003e\n  $i9 \u003d (int) -1\n  $i11 \u003d (int) -1\n  $r91 \u003d $r90.createChildArrayContext($i9, $i11)\n  XmlReadContext _parsingContext\u003e \u003d $r91\n  goto B9\n}",
      "B4 {\n  $r88 \u003d XmlReadContext _parsingContext\u003e\n  $r89 \u003d $r88.getParent()\n  XmlReadContext _parsingContext\u003e \u003d $r89\n  goto B9\n}",
      "B5 {\n  $z14 \u003d FromXmlParser: boolean _nextIsLeadingMixed\u003e\n  if ($z14 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  FromXmlParser: boolean _nextIsLeadingMixed\u003e \u003d 0\n  $r86 \u003d XmlReadContext _parsingContext\u003e\n  $r85 \u003d String _cfgNameForTextElement\u003e\n  $r86.setCurrentName($r85)\n  $r87 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r87\n  goto B9\n}",
      "B7 {\n  $r83 \u003d XmlReadContext _parsingContext\u003e\n  $r82 \u003d XmlTokenStream _xmlTokens\u003e\n  $r84 \u003d $r82.getLocalName()\n  $r83.setCurrentName($r84)\n  goto B9\n}",
      "B8 {\n  $r94 \u003d XmlReadContext _parsingContext\u003e\n  $r94.valueStarted()\n}",
      "B9 {\n  return\n}",
      "B10 {\n  i2 \u003d r0._nextToken()\n}",
      "B11 {\n  if (i2 !\u003d 1) goto B12 else B19\n}",
      "B12 {\n  $z11 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z11 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $r75 \u003d JsonToken FIELD_NAME\u003e\n  JsonToken _nextToken\u003e \u003d $r75\n  $r76 \u003d XmlReadContext _parsingContext\u003e\n  $i13 \u003d (int) -1\n  $i15 \u003d (int) -1\n  $r77 \u003d $r76.createChildObjectContext($i13, $i15)\n  XmlReadContext _parsingContext\u003e \u003d $r77\n  $r78 \u003d JsonToken START_OBJECT\u003e\n  $r79 \u003d r0._updateToken($r78)\n  return\n}",
      "B14 {\n  $r67 \u003d XmlReadContext _parsingContext\u003e\n  $z12 \u003d $r67.inArray()\n  if ($z12 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  i2 \u003d r0._nextToken()\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 1\n  goto B11\n}",
      "B16 {\n  $r68 \u003d XmlTokenStream _xmlTokens\u003e\n  r69 \u003d $r68.getLocalName()\n  $r70 \u003d XmlReadContext _parsingContext\u003e\n  $r70.setCurrentName(r69)\n  $r71 \u003d XmlReadContext _parsingContext\u003e\n  $z13 \u003d $r71.shouldWrap(r69)\n  if ($z13 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r74 \u003d XmlTokenStream _xmlTokens\u003e\n  $r74.repeatStartElement()\n}",
      "B18 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 1\n  $r72 \u003d JsonToken FIELD_NAME\u003e\n  $r73 \u003d r0._updateToken($r72)\n  return\n}",
      "B19 {\n  Integer valueOf(int)\u003e(i2); }\n}",
      "B20 {\n  $z8 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z8 \u003d\u003d false) goto B21 else B25\n}",
      "B21 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  $r53 \u003d XmlReadContext _parsingContext\u003e\n  $z10 \u003d $r53.inArray()\n  if ($z10 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $r59 \u003d JsonToken END_OBJECT\u003e\n  JsonToken _nextToken\u003e \u003d $r59\n  $r60 \u003d XmlReadContext _parsingContext\u003e\n  $i17 \u003d (int) -1\n  $i19 \u003d (int) -1\n  $r61 \u003d $r60.createChildObjectContext($i17, $i19)\n  XmlReadContext _parsingContext\u003e \u003d $r61\n  $r62 \u003d JsonToken START_OBJECT\u003e\n  $r63 \u003d r0._updateToken($r62)\n  return\n}",
      "B23 {\n  $r55 \u003d JsonToken _currToken\u003e\n  $r54 \u003d JsonToken VALUE_NULL\u003e\n  if ($r55 \u003d\u003d $r54) goto B24 else B25\n}",
      "B24 {\n  $r56 \u003d XmlReadContext _parsingContext\u003e\n  $r56.valueStarted()\n  $r57 \u003d JsonToken VALUE_NULL\u003e\n  $r58 \u003d r0._updateToken($r57)\n  return\n}",
      "B25 {\n  $r49 \u003d XmlReadContext _parsingContext\u003e\n  $z9 \u003d $r49.inArray()\n  if ($z9 \u003d\u003d false) goto B26 else B27\n}",
      "B26 {\n  $r96 \u003d JsonToken END_ARRAY\u003e\n  goto B28\n}",
      "B27 {\n  $r96 \u003d JsonToken END_OBJECT\u003e\n}",
      "B28 {\n  r0._updateToken($r96)\n  $r50 \u003d XmlReadContext _parsingContext\u003e\n  $r51 \u003d $r50.getParent()\n  XmlReadContext _parsingContext\u003e \u003d $r51\n  $r52 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B29 {\n  $z7 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z7 \u003d\u003d false) goto B30 else B31\n}",
      "B30 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  $r42 \u003d JsonToken FIELD_NAME\u003e\n  JsonToken _nextToken\u003e \u003d $r42\n  $r43 \u003d XmlTokenStream _xmlTokens\u003e\n  $r44 \u003d $r43.getText()\n  String _currText\u003e \u003d $r44\n  $r45 \u003d XmlReadContext _parsingContext\u003e\n  $i21 \u003d (int) -1\n  $i23 \u003d (int) -1\n  $r46 \u003d $r45.createChildObjectContext($i21, $i23)\n  XmlReadContext _parsingContext\u003e \u003d $r46\n  $r47 \u003d JsonToken START_OBJECT\u003e\n  $r48 \u003d r0._updateToken($r47)\n  return\n}",
      "B31 {\n  $r38 \u003d XmlReadContext _parsingContext\u003e\n  $r37 \u003d XmlTokenStream _xmlTokens\u003e\n  $r39 \u003d $r37.getLocalName()\n  $r38.setCurrentName($r39)\n  $r40 \u003d JsonToken FIELD_NAME\u003e\n  $r41 \u003d r0._updateToken($r40)\n  return\n}",
      "B32 {\n  $r32 \u003d XmlTokenStream _xmlTokens\u003e\n  $r33 \u003d $r32.getText()\n  String _currText\u003e \u003d $r33\n  $r34 \u003d XmlReadContext _parsingContext\u003e\n  $r34.valueStarted()\n  $r35 \u003d JsonToken VALUE_STRING\u003e\n  $r36 \u003d r0._updateToken($r35)\n  return\n}",
      "B33 {\n  $r3 \u003d XmlTokenStream _xmlTokens\u003e\n  $r4 \u003d $r3.getText()\n  String _currText\u003e \u003d $r4\n  $z0 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z0 \u003d\u003d false) goto B34 else B42\n}",
      "B34 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  i3 \u003d r0._nextToken()\n  if (i3 !\u003d 2) goto B35 else B39\n}",
      "B35 {\n  $r23 \u003d XmlReadContext _parsingContext\u003e\n  $z5 \u003d $r23.inArray()\n  if ($z5 \u003d\u003d false) goto B36 else B38\n}",
      "B36 {\n  $r26 \u003d String _currText\u003e\n  $z6 \u003d XmlTokenStream._allWs($r26)\n  if ($z6 \u003d\u003d false) goto B37 else B38\n}",
      "B37 {\n  $r27 \u003d JsonToken END_OBJECT\u003e\n  JsonToken _nextToken\u003e \u003d $r27\n  $r28 \u003d XmlReadContext _parsingContext\u003e\n  $i25 \u003d (int) -1\n  $i27 \u003d (int) -1\n  $r29 \u003d $r28.createChildObjectContext($i25, $i27)\n  XmlReadContext _parsingContext\u003e \u003d $r29\n  $r30 \u003d JsonToken START_OBJECT\u003e\n  $r31 \u003d r0._updateToken($r30)\n  return\n}",
      "B38 {\n  $r24 \u003d JsonToken VALUE_STRING\u003e\n  $r25 \u003d r0._updateToken($r24)\n  return\n}",
      "B39 {\n  if (i3 \u003d\u003d 1) goto B40 else B41\n}",
      "B40 {\n  $r102 \u003d JsonParseException\n  $r18 \u003d Object)[3]\n  $r19 \u003d Integer.valueOf(2)\n  $r18[0] \u003d $r19\n  $r20 \u003d Integer.valueOf(1)\n  $r18[1] \u003d $r20\n  $r21 \u003d Integer.valueOf(i3)\n  $r18[2] \u003d $r21\n  $r22 \u003d String.format(\"Internal error: Expected END_ELEMENT (%d) or START_ELEMENT (%d), got event of type %d\", $r18)\n  new JsonParseException(r0, $r22)\n  throw $r102\n}",
      "B41 {\n  $r14 \u003d XmlTokenStream _xmlTokens\u003e\n  $r14.pushbackCurrentToken()\n  $r15 \u003d XmlReadContext _parsingContext\u003e\n  $i29 \u003d (int) -1\n  $i31 \u003d (int) -1\n  $r16 \u003d $r15.createChildObjectContext($i29, $i31)\n  XmlReadContext _parsingContext\u003e \u003d $r16\n}",
      "B42 {\n  $r5 \u003d XmlReadContext _parsingContext\u003e\n  $z1 \u003d $r5.inObject()\n  if ($z1 \u003d\u003d false) goto B43 else B47\n}",
      "B43 {\n  $r9 \u003d JsonToken _currToken\u003e\n  $r8 \u003d JsonToken FIELD_NAME\u003e\n  if ($r9 !\u003d $r8) goto B44 else B45\n}",
      "B44 {\n  FromXmlParser: boolean _nextIsLeadingMixed\u003e \u003d 1\n  $r11 \u003d JsonToken FIELD_NAME\u003e\n  JsonToken _nextToken\u003e \u003d $r11\n  $r12 \u003d JsonToken START_OBJECT\u003e\n  $r13 \u003d r0._updateToken($r12)\n  return\n}",
      "B45 {\n  $r10 \u003d String _currText\u003e\n  $z4 \u003d XmlTokenStream._allWs($r10)\n  if ($z4 \u003d\u003d false) goto B46 else B50\n}",
      "B46 {\n  i2 \u003d r0._nextToken()\n  goto B19\n}",
      "B47 {\n  $r6 \u003d XmlReadContext _parsingContext\u003e\n  $z2 \u003d $r6.inArray()\n  if ($z2 \u003d\u003d false) goto B48 else B50\n}",
      "B48 {\n  $r7 \u003d String _currText\u003e\n  $z3 \u003d XmlTokenStream._allWs($r7)\n  if ($z3 \u003d\u003d false) goto B49 else B50\n}",
      "B49 {\n  i2 \u003d r0._nextToken()\n  goto B19\n}",
      "B50 {\n  $r97 \u003d XmlReadContext _parsingContext\u003e\n  $r98 \u003d String _cfgNameForTextElement\u003e\n  $r97.setCurrentName($r98)\n  $r99 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r99\n  $r100 \u003d JsonToken FIELD_NAME\u003e\n  $r101 \u003d r0._updateToken($r100)\n  return\n}",
      "B51 {\n  $r2 \u003d r0._updateTokenToNull()\n  return\n}",
      "B52 {\n  $r64 \u003d Integer.valueOf(i2)\n  $r65 \u003d r0._internalErrorUnknownToken($r64)\n  $r66 \u003d JsonToken) $r65\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B4",
      "B1 --\u003e B5",
      "B1 --\u003e B8",
      "B2 --\u003e B9",
      "B3 --\u003e B9",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B19",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B11",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B29",
      "B19 --\u003e B32",
      "B19 --\u003e B33",
      "B19 --\u003e B52",
      "B19 --\u003e B51",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e [EXIT]",
      "B33 --\u003e B34",
      "B33 --\u003e B42",
      "B34 --\u003e B35",
      "B34 --\u003e B39",
      "B35 --\u003e B36",
      "B35 --\u003e B38",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e [EXIT]",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e [EXIT]",
      "B41 --\u003e B42",
      "B42 --\u003e B43",
      "B42 --\u003e B47",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e [EXIT]",
      "B45 --\u003e B46",
      "B45 --\u003e B50",
      "B46 --\u003e B19",
      "B47 --\u003e B48",
      "B47 --\u003e B50",
      "B48 --\u003e B49",
      "B48 --\u003e B50",
      "B49 --\u003e B19",
      "B50 --\u003e [EXIT]",
      "B51 --\u003e [EXIT]",
      "B52 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_internalErrorUnknownToken(...1)",
        "body": "{\r\n    throw new IllegalStateException(\"Internal error: unrecognized XmlTokenStream token: \" + token);\r\n}"
      },
      {
        "name": "FromXmlParser#_nextToken(...0)",
        "body": "{\r\n    try {\r\n        return _xmlTokens.next();\r\n    } catch (XMLStreamException e) {\r\n        return StaxUtil.throwAsParseException(e, this);\r\n    } catch (IllegalStateException e) {\r\n        // 08-Apr-2021, tatu: Should improve on this, wrt better information\r\n        //   on issue.\r\n        throw new JsonParseException(this, e.getMessage(), e);\r\n    }\r\n}"
      },
      {
        "name": "FromXmlParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "FromXmlParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "nextTextValue",
    "signature": "java.lang.String nextTextValue()",
    "visibility": "public",
    "body": "{\r\n    _binaryValue \u003d null;\r\n    if (_nextToken !\u003d null) {\r\n        final JsonToken t \u003d _updateToken(_nextToken);\r\n        _nextToken \u003d null;\r\n        // expected case; yes, got a String\r\n        if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n            // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n            _parsingContext.valueStarted();\r\n            return _currText;\r\n        }\r\n        _updateState(t);\r\n        return null;\r\n    }\r\n    int token \u003d _nextToken();\r\n    // mostly copied from \u0027nextToken()\u0027\r\n    while (token \u003d\u003d XmlTokenStream.XML_START_ELEMENT) {\r\n        if (_mayBeLeaf) {\r\n            _nextToken \u003d JsonToken.FIELD_NAME;\r\n            _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n            _updateToken(JsonToken.START_OBJECT);\r\n            return null;\r\n        }\r\n        if (_parsingContext.inArray()) {\r\n            token \u003d _nextToken();\r\n            _mayBeLeaf \u003d true;\r\n            continue;\r\n        }\r\n        String name \u003d _xmlTokens.getLocalName();\r\n        _parsingContext.setCurrentName(name);\r\n        if (_parsingContext.shouldWrap(name)) {\r\n            //System.out.println(\"REPEAT from nextTextValue()\");\r\n            _xmlTokens.repeatStartElement();\r\n        }\r\n        _mayBeLeaf \u003d true;\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        return null;\r\n    }\r\n    // Ok; beyond start element, what do we get?\r\n    switch(token) {\r\n        case XmlTokenStream.XML_END_ELEMENT:\r\n            if (_mayBeLeaf) {\r\n                _mayBeLeaf \u003d false;\r\n                // 18-Mar-2023, tatu: [dataformat-xml#584 / #585] in 2.14 and before\r\n                //    returned VALUE_STRING on assumption we never expose `null`s if\r\n                //    asked text value -- but that seems incorrect. Hoping this won\u0027t\r\n                //    break anything in 2.15+\r\n                _updateToken(JsonToken.VALUE_NULL);\r\n                // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n                _parsingContext.valueStarted();\r\n                return (_currText \u003d null);\r\n            }\r\n            _updateToken(_parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\r\n            _parsingContext \u003d _parsingContext.getParent();\r\n            break;\r\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\r\n            // If there was a chance of leaf node, no more...\r\n            if (_mayBeLeaf) {\r\n                _mayBeLeaf \u003d false;\r\n                _nextToken \u003d JsonToken.FIELD_NAME;\r\n                _currText \u003d _xmlTokens.getText();\r\n                _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n                _updateToken(JsonToken.START_OBJECT);\r\n            } else {\r\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\r\n                _updateToken(JsonToken.FIELD_NAME);\r\n            }\r\n            break;\r\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\r\n            _updateToken(JsonToken.VALUE_STRING);\r\n            // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n            _parsingContext.valueStarted();\r\n            return (_currText \u003d _xmlTokens.getText());\r\n        case XmlTokenStream.XML_TEXT:\r\n            _currText \u003d _xmlTokens.getText();\r\n            if (_mayBeLeaf) {\r\n                _mayBeLeaf \u003d false;\r\n                // Also: must skip following END_ELEMENT\r\n                _skipEndElement();\r\n                // NOTE: this is different from nextToken() -- NO work-around\r\n                // for otherwise empty List/array\r\n                // 13-May-2020, tatu: [dataformat-xml#397]: advance `index`\r\n                _parsingContext.valueStarted();\r\n                _updateToken(JsonToken.VALUE_STRING);\r\n                return _currText;\r\n            }\r\n            // If not a leaf, need to transform into property...\r\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\r\n            _nextToken \u003d JsonToken.VALUE_STRING;\r\n            _updateToken(JsonToken.FIELD_NAME);\r\n            break;\r\n        case XmlTokenStream.XML_END:\r\n            _updateTokenToNull();\r\n        default:\r\n            return _internalErrorUnknownToken(token);\r\n    }\r\n    return null;\r\n}",
    "nodes": 30,
    "edges": 36,
    "cc": 8,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B1 : If(r48 !\u003d $r45) → B2 | else → B3",
      "B5 : If(i0 !\u003d 1) → B6 | else → B13",
      "B6 : If($z4 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z5 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z6 \u003d\u003d false) → B11 | else → B12",
      "B13 : If(switch-on i0) → B14 | else → B20",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B16",
      "B16 : If($z3 \u003d\u003d false) → B17 | else → B18",
      "B20 : If($z1 \u003d\u003d false) → B21 | else → B22",
      "B24 : If($z0 \u003d\u003d false) → B25 | else → B26"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  FromXmlParser: byte[] _binaryValue\u003e \u003d null\n  $r1 \u003d JsonToken _nextToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r44 \u003d JsonToken _nextToken\u003e\n  r48 \u003d r0._updateToken($r44)\n  JsonToken _nextToken\u003e \u003d null\n  $r45 \u003d JsonToken VALUE_STRING\u003e\n  if (r48 !\u003d $r45) goto B2 else B3\n}",
      "B2 {\n  $r46 \u003d XmlReadContext _parsingContext\u003e\n  $r46.valueStarted()\n  $r47 \u003d String _currText\u003e\n  return\n}",
      "B3 {\n  r0._updateState(r48)\n  return\n}",
      "B4 {\n  i0 \u003d r0._nextToken()\n}",
      "B5 {\n  if (i0 !\u003d 1) goto B6 else B13\n}",
      "B6 {\n  $z4 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z4 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r40 \u003d JsonToken FIELD_NAME\u003e\n  JsonToken _nextToken\u003e \u003d $r40\n  $r41 \u003d XmlReadContext _parsingContext\u003e\n  $i2 \u003d (int) -1\n  $i4 \u003d (int) -1\n  $r42 \u003d $r41.createChildObjectContext($i2, $i4)\n  XmlReadContext _parsingContext\u003e \u003d $r42\n  $r43 \u003d JsonToken START_OBJECT\u003e\n  r0._updateToken($r43)\n  return\n}",
      "B8 {\n  $r33 \u003d XmlReadContext _parsingContext\u003e\n  $z5 \u003d $r33.inArray()\n  if ($z5 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  i0 \u003d r0._nextToken()\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 1\n  goto B5\n}",
      "B10 {\n  $r34 \u003d XmlTokenStream _xmlTokens\u003e\n  r35 \u003d $r34.getLocalName()\n  $r36 \u003d XmlReadContext _parsingContext\u003e\n  $r36.setCurrentName(r35)\n  $r37 \u003d XmlReadContext _parsingContext\u003e\n  $z6 \u003d $r37.shouldWrap(r35)\n  if ($z6 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r39 \u003d XmlTokenStream _xmlTokens\u003e\n  $r39.repeatStartElement()\n}",
      "B12 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 1\n  $r38 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r38)\n  return\n}",
      "B13 {\n  Integer valueOf(int)\u003e(i0); }\n}",
      "B14 {\n  $z2 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z2 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  $r31 \u003d JsonToken VALUE_NULL\u003e\n  r0._updateToken($r31)\n  $r32 \u003d XmlReadContext _parsingContext\u003e\n  $r32.valueStarted()\n  String _currText\u003e \u003d null\n  return\n}",
      "B16 {\n  $r28 \u003d XmlReadContext _parsingContext\u003e\n  $z3 \u003d $r28.inArray()\n  if ($z3 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r49 \u003d JsonToken END_ARRAY\u003e\n  goto B19\n}",
      "B18 {\n  $r49 \u003d JsonToken END_OBJECT\u003e\n}",
      "B19 {\n  r0._updateToken($r49)\n  $r29 \u003d XmlReadContext _parsingContext\u003e\n  $r30 \u003d $r29.getParent()\n  XmlReadContext _parsingContext\u003e \u003d $r30\n  goto B29\n}",
      "B20 {\n  $z1 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z1 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  $r22 \u003d JsonToken FIELD_NAME\u003e\n  JsonToken _nextToken\u003e \u003d $r22\n  $r23 \u003d XmlTokenStream _xmlTokens\u003e\n  $r24 \u003d $r23.getText()\n  String _currText\u003e \u003d $r24\n  $r25 \u003d XmlReadContext _parsingContext\u003e\n  $i6 \u003d (int) -1\n  $i8 \u003d (int) -1\n  $r26 \u003d $r25.createChildObjectContext($i6, $i8)\n  XmlReadContext _parsingContext\u003e \u003d $r26\n  $r27 \u003d JsonToken START_OBJECT\u003e\n  r0._updateToken($r27)\n  goto B29\n}",
      "B22 {\n  $r19 \u003d XmlReadContext _parsingContext\u003e\n  $r18 \u003d XmlTokenStream _xmlTokens\u003e\n  $r20 \u003d $r18.getLocalName()\n  $r19.setCurrentName($r20)\n  $r21 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r21)\n  goto B29\n}",
      "B23 {\n  $r14 \u003d JsonToken VALUE_STRING\u003e\n  r0._updateToken($r14)\n  $r15 \u003d XmlReadContext _parsingContext\u003e\n  $r15.valueStarted()\n  $r16 \u003d XmlTokenStream _xmlTokens\u003e\n  $r17 \u003d $r16.getText()\n  String _currText\u003e \u003d $r17\n  return\n}",
      "B24 {\n  $r5 \u003d XmlTokenStream _xmlTokens\u003e\n  $r6 \u003d $r5.getText()\n  String _currText\u003e \u003d $r6\n  $z0 \u003d FromXmlParser: boolean _mayBeLeaf\u003e\n  if ($z0 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  FromXmlParser: boolean _mayBeLeaf\u003e \u003d 0\n  r0._skipEndElement()\n  $r11 \u003d XmlReadContext _parsingContext\u003e\n  $r11.valueStarted()\n  $r12 \u003d JsonToken VALUE_STRING\u003e\n  r0._updateToken($r12)\n  $r13 \u003d String _currText\u003e\n  return\n}",
      "B26 {\n  $r8 \u003d XmlReadContext _parsingContext\u003e\n  $r7 \u003d String _cfgNameForTextElement\u003e\n  $r8.setCurrentName($r7)\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  $r10 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r10)\n  goto B29\n}",
      "B27 {\n  r0._updateTokenToNull()\n}",
      "B28 {\n  $r2 \u003d Integer.valueOf(i0)\n  $r3 \u003d r0._internalErrorUnknownToken($r2)\n  $r4 \u003d String) $r3\n  return\n}",
      "B29 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B5",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B20",
      "B13 --\u003e B23",
      "B13 --\u003e B24",
      "B13 --\u003e B28",
      "B13 --\u003e B27",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B29",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B29",
      "B22 --\u003e B29",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B29",
      "B27 --\u003e B28",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_updateState(...1)",
        "body": "{\r\n    switch(t) {\r\n        case START_OBJECT:\r\n            _parsingContext \u003d _parsingContext.createChildObjectContext(-1, -1);\r\n            break;\r\n        case START_ARRAY:\r\n            _parsingContext \u003d _parsingContext.createChildArrayContext(-1, -1);\r\n            break;\r\n        case END_OBJECT:\r\n        case END_ARRAY:\r\n            _parsingContext \u003d _parsingContext.getParent();\r\n            break;\r\n        case FIELD_NAME:\r\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\r\n            break;\r\n        default:\r\n            _internalErrorUnknownToken(t);\r\n    }\r\n}"
      },
      {
        "name": "FromXmlParser#_internalErrorUnknownToken(...1)",
        "body": "{\r\n    throw new IllegalStateException(\"Internal error: unrecognized XmlTokenStream token: \" + token);\r\n}"
      },
      {
        "name": "FromXmlParser#_skipEndElement(...0)",
        "body": "{\r\n    try {\r\n        _xmlTokens.skipEndElement();\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsParseException(e, this);\r\n    } catch (Exception e) {\r\n        throw new JsonParseException(this, e.getMessage(), e);\r\n    }\r\n}"
      },
      {
        "name": "FromXmlParser#_nextToken(...0)",
        "body": "{\r\n    try {\r\n        return _xmlTokens.next();\r\n    } catch (XMLStreamException e) {\r\n        return StaxUtil.throwAsParseException(e, this);\r\n    } catch (IllegalStateException e) {\r\n        // 08-Apr-2021, tatu: Should improve on this, wrt better information\r\n        //   on issue.\r\n        throw new JsonParseException(this, e.getMessage(), e);\r\n    }\r\n}"
      },
      {
        "name": "FromXmlParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "FromXmlParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getText",
    "signature": "java.lang.String getText()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(_currToken) {\r\n        case FIELD_NAME:\r\n            return currentName();\r\n        case VALUE_STRING:\r\n            return _currText;\r\n        default:\r\n            return _currToken.asString();\r\n    }\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If(switch-on $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d FromXmlParser$1: int[] $SwitchMap$com$fasterxml$jackson$core$JsonToken\u003e\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.ordinal()\n  $i1 \u003d $r3[$i0]\n  JsonToken _currToken\u003e; }\n}",
      "B3 {\n  $r5 \u003d r0.currentName()\n  return\n}",
      "B4 {\n  $r4 \u003d String _currText\u003e\n  return\n}",
      "B5 {\n  $r6 \u003d JsonToken _currToken\u003e\n  $r7 \u003d $r6.asString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#currentName(...0)",
        "body": "{\r\n    // start markers require information from parent\r\n    String name;\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        XmlReadContext parent \u003d _parsingContext.getParent();\r\n        name \u003d parent.getCurrentName();\r\n    } else {\r\n        name \u003d _parsingContext.getCurrentName();\r\n    }\r\n    // sanity check\r\n    if (name \u003d\u003d null) {\r\n        throw new IllegalStateException(\"Missing name, in state: \" + _currToken);\r\n    }\r\n    return name;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getTextCharacters",
    "signature": "char[] getTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    String text \u003d getText();\r\n    return (text \u003d\u003d null) ? null : text.toCharArray();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  r1 \u003d r0.getText()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1.toCharArray()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(_currToken) {\r\n        case FIELD_NAME:\r\n            return currentName();\r\n        case VALUE_STRING:\r\n            return _currText;\r\n        default:\r\n            return _currToken.asString();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getTextLength",
    "signature": "int getTextLength()",
    "visibility": "public",
    "body": "{\r\n    String text \u003d getText();\r\n    return (text \u003d\u003d null) ? 0 : text.length();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  r1 \u003d r0.getText()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $i0 \u003d r1.length()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(_currToken) {\r\n        case FIELD_NAME:\r\n            return currentName();\r\n        case VALUE_STRING:\r\n            return _currText;\r\n        default:\r\n            return _currToken.asString();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getText",
    "signature": "int getText(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    String str \u003d getText();\r\n    if (str \u003d\u003d null) {\r\n        return 0;\r\n    }\r\n    writer.write(str);\r\n    return str.length();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  Writer\n  r1 \u003d r0.getText()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2.write(r1)\n  $i0 \u003d r1.length()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(_currToken) {\r\n        case FIELD_NAME:\r\n            return currentName();\r\n        case VALUE_STRING:\r\n            return _currText;\r\n        default:\r\n            return _currToken.asString();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getBinaryValue",
    "signature": "byte[] getBinaryValue(com.fasterxml.jackson.core.Base64Variant)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING \u0026\u0026 (_currToken !\u003d JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue \u003d\u003d null)) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    /* To ensure that we won\u0027t see inconsistent data, better clear up\r\n         * state...\r\n         */\r\n    if (_binaryValue \u003d\u003d null) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B4",
      "B1 : If($r7 !\u003d $r6) → B2 | else → B3",
      "B2 : If($r11 !\u003d null) → B3 | else → B4",
      "B4 : If($r17 !\u003d null) → B5 | else → B7"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  Base64Variant\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $r7 \u003d JsonToken _currToken\u003e\n  $r6 \u003d JsonToken VALUE_EMBEDDED_OBJECT\u003e\n  if ($r7 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $r11 \u003d FromXmlParser: byte[] _binaryValue\u003e\n  if ($r11 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d JsonToken _currToken\u003e\n  $r9 \u003d String.valueOf($r8)\n  $r10 \u003d dynInvoke makeConcatWithConstants($r9)\n  r0._reportError($r10)\n}",
      "B4 {\n  $r17 \u003d FromXmlParser: byte[] _binaryValue\u003e\n  if ($r17 !\u003d null) goto B5 else B7\n}",
      "B5 {\n  $r5 \u003d r0._decodeBase64(r4)\n  FromXmlParser: byte[] _binaryValue\u003e \u003d $r5\n  goto B7\n}",
      "B6 {\n  $r12 :\u003d @caughtexception\n  $r14 \u003d String.valueOf(r4)\n  $r13 \u003d $r12.getMessage()\n  $r15 \u003d dynInvoke makeConcatWithConstants($r14, $r13)\n  $r16 \u003d r0._constructError($r15)\n  throw $r16\n}",
      "B7 {\n  $r3 \u003d FromXmlParser: byte[] _binaryValue\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_decodeBase64(...1)",
        "body": "{\r\n    ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n    final String str \u003d getText();\r\n    _decodeBase64(str, builder, b64variant);\r\n    return builder.toByteArray();\r\n}"
      },
      {
        "name": "FromXmlParser#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "FromXmlParser#_constructError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getNumberType",
    "signature": "com.fasterxml.jackson.core.JsonParser$NumberType getNumberType()",
    "visibility": "public",
    "body": "{\r\n    if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n        // will also check event type\r\n        _checkNumericValue(NR_UNKNOWN);\r\n    }\r\n    // Only integer types supported so...\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        return NumberType.INT;\r\n    }\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        return NumberType.LONG;\r\n    }\r\n    return NumberType.BIG_INTEGER;\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i2 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i4 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0._checkNumericValue(0)\n}",
      "B2 {\n  $i1 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i2 \u003d $i1 \u0026 1\n  if ($i2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d JsonParser$NumberType INT\u003e\n  return\n}",
      "B4 {\n  $i3 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 2\n  if ($i4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r2 \u003d JsonParser$NumberType LONG\u003e\n  return\n}",
      "B6 {\n  $r1 \u003d JsonParser$NumberType BIG_INTEGER\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getNumberValue",
    "signature": "java.lang.Number getNumberValue()",
    "visibility": "public",
    "body": "{\r\n    if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n        // will also check event type\r\n        _checkNumericValue(NR_UNKNOWN);\r\n    }\r\n    // Only integer types supported so...\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        return _numberInt;\r\n    }\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        return _numberLong;\r\n    }\r\n    if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        return _numberBigInt;\r\n    }\r\n    _throwInternal();\r\n    return null;\r\n}",
    "nodes": 9,
    "edges": 9,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i2 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i4 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($i6 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0._checkNumericValue(0)\n}",
      "B2 {\n  $i1 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i2 \u003d $i1 \u0026 1\n  if ($i2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i8 \u003d FromXmlParser: int _numberInt\u003e\n  $r3 \u003d Integer.valueOf($i8)\n  return\n}",
      "B4 {\n  $i3 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 2\n  if ($i4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $l7 \u003d FromXmlParser: long _numberLong\u003e\n  $r2 \u003d Long.valueOf($l7)\n  return\n}",
      "B6 {\n  $i5 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i6 \u003d $i5 \u0026 4\n  if ($i6 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r1 \u003d BigInteger _numberBigInt\u003e\n  return\n}",
      "B8 {\n  r0._throwInternal()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_throwInternal(...0)",
        "body": "(source not found)"
      },
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getIntValue",
    "signature": "int getIntValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            // not parsed at all\r\n            // will also check event type\r\n            _checkNumericValue(NR_INT);\r\n        }\r\n        if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n            // wasn\u0027t an int natively?\r\n            // let\u0027s make it so, if possible\r\n            _convertNumberToInt();\r\n        }\r\n    }\r\n    return _numberInt;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B5",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3",
      "B3 : If($i4 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(1)\n}",
      "B3 {\n  $i3 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0._convertNumberToInt()\n}",
      "B5 {\n  $i5 \u003d FromXmlParser: int _numberInt\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      },
      {
        "name": "FromXmlParser#_convertNumberToInt(...0)",
        "body": "{\r\n    // First, converting from long ought to be easy\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        // Let\u0027s verify it\u0027s lossless conversion by simple roundtrip\r\n        int result \u003d (int) _numberLong;\r\n        if (((long) result) !\u003d _numberLong) {\r\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\r\n        }\r\n        _numberInt \u003d result;\r\n    } else if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        if (BI_MIN_INT.compareTo(_numberBigInt) \u003e 0 || BI_MAX_INT.compareTo(_numberBigInt) \u003c 0) {\r\n            reportOverflowInt();\r\n        }\r\n        _numberInt \u003d _numberBigInt.intValue();\r\n    } else {\r\n        _throwInternal();\r\n    }\r\n    _numTypesValid |\u003d NR_INT;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getLongValue",
    "signature": "long getLongValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_LONG) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            _checkNumericValue(NR_LONG);\r\n        }\r\n        if ((_numTypesValid \u0026 NR_LONG) \u003d\u003d 0) {\r\n            _convertNumberToLong();\r\n        }\r\n    }\r\n    return _numberLong;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B5",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3",
      "B3 : If($i4 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 2\n  if ($i1 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(2)\n}",
      "B3 {\n  $i3 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 2\n  if ($i4 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0._convertNumberToLong()\n}",
      "B5 {\n  $l5 \u003d FromXmlParser: long _numberLong\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_convertNumberToLong(...0)",
        "body": "{\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        _numberLong \u003d (long) _numberInt;\r\n    } else if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        if (BI_MIN_LONG.compareTo(_numberBigInt) \u003e 0 || BI_MAX_LONG.compareTo(_numberBigInt) \u003c 0) {\r\n            reportOverflowLong();\r\n        }\r\n        _numberLong \u003d _numberBigInt.longValue();\r\n    } else {\r\n        _throwInternal();\r\n    }\r\n    _numTypesValid |\u003d NR_LONG;\r\n}"
      },
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getBigIntegerValue",
    "signature": "java.math.BigInteger getBigIntegerValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_BIGINT) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            _checkNumericValue(NR_BIGINT);\r\n        }\r\n        if ((_numTypesValid \u0026 NR_BIGINT) \u003d\u003d 0) {\r\n            _convertNumberToBigInteger();\r\n        }\r\n    }\r\n    return _numberBigInt;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B5",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3",
      "B3 : If($i4 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 4\n  if ($i1 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(4)\n}",
      "B3 {\n  $i3 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 4\n  if ($i4 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0._convertNumberToBigInteger()\n}",
      "B5 {\n  $r1 \u003d BigInteger _numberBigInt\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_convertNumberToBigInteger(...0)",
        "body": "{\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        _numberBigInt \u003d BigInteger.valueOf(_numberLong);\r\n    } else if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        _numberBigInt \u003d BigInteger.valueOf(_numberInt);\r\n    } else {\r\n        _throwInternal();\r\n    }\r\n    _numTypesValid |\u003d NR_BIGINT;\r\n}"
      },
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getFloatValue",
    "signature": "float getFloatValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_FLOAT) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            _checkNumericValue(NR_FLOAT);\r\n        }\r\n    }\r\n    return _convertNumberToFloat();\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B3",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 32\n  if ($i1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(32)\n}",
      "B3 {\n  $f0 \u003d r0._convertNumberToFloat()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_convertNumberToFloat(...0)",
        "body": "{\r\n    // Note: this MUST start with more accurate representations, since we don\u0027t know which\r\n    //  value is the original one (others get generated when requested)\r\n    if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        return _numberBigInt.floatValue();\r\n    }\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        return (float) _numberLong;\r\n    }\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        return (float) _numberInt;\r\n    }\r\n    _throwInternal();\r\n    return 0.0f;\r\n}"
      },
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getDoubleValue",
    "signature": "double getDoubleValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_DOUBLE) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            _checkNumericValue(NR_DOUBLE);\r\n        }\r\n    }\r\n    return _convertNumberToDouble();\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B3",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 8\n  if ($i1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(8)\n}",
      "B3 {\n  $d0 \u003d r0._convertNumberToDouble()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_convertNumberToDouble(...0)",
        "body": "{\r\n    // same as above, start from more to less accurate\r\n    if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        return _numberBigInt.doubleValue();\r\n    }\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        return (double) _numberLong;\r\n    }\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        return (double) _numberInt;\r\n    }\r\n    _throwInternal();\r\n    return 0.0;\r\n}"
      },
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
    "methodName": "getDecimalValue",
    "signature": "java.math.BigDecimal getDecimalValue()",
    "visibility": "public",
    "body": "{\r\n    if ((_numTypesValid \u0026 NR_BIGDECIMAL) \u003d\u003d 0) {\r\n        if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n            _checkNumericValue(NR_BIGDECIMAL);\r\n        }\r\n    }\r\n    return _convertNumberToBigDecimal();\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B3",
      "B1 : If($i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  FromXmlParser\n  $i0 \u003d FromXmlParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 16\n  if ($i1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d FromXmlParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0._checkNumericValue(16)\n}",
      "B3 {\n  $r1 \u003d r0._convertNumberToBigDecimal()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FromXmlParser#_checkNumericValue(...1)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n        return;\r\n    }\r\n    _reportError(\"Current token (\" + currentToken() + \") not numeric, can not use numeric value accessors\");\r\n}"
      },
      {
        "name": "FromXmlParser#_convertNumberToBigDecimal(...0)",
        "body": "{\r\n    if ((_numTypesValid \u0026 NR_BIGINT) !\u003d 0) {\r\n        return new BigDecimal(_numberBigInt);\r\n    }\r\n    if ((_numTypesValid \u0026 NR_LONG) !\u003d 0) {\r\n        return BigDecimal.valueOf(_numberLong);\r\n    }\r\n    if ((_numTypesValid \u0026 NR_INT) !\u003d 0) {\r\n        return BigDecimal.valueOf(_numberInt);\r\n    }\r\n    _throwInternal();\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.WrapperHandlingDeserializer",
    "methodName": "createContextual",
    "signature": "com.fasterxml.jackson.databind.JsonDeserializer createContextual(com.fasterxml.jackson.databind.DeserializationContext,com.fasterxml.jackson.databind.BeanProperty)",
    "visibility": "public",
    "body": "{\r\n    JavaType vt \u003d _type;\r\n    if (vt \u003d\u003d null) {\r\n        vt \u003d ctxt.constructType(_delegatee.handledType());\r\n    }\r\n    JsonDeserializer\u003c?\u003e del \u003d ctxt.handleSecondaryContextualization(_delegatee, property, vt);\r\n    BeanDeserializerBase newDelegatee \u003d _verifyDeserType(del);\r\n    // Let\u0027s go through the properties now...\r\n    Iterator\u003cSettableBeanProperty\u003e it \u003d newDelegatee.properties();\r\n    HashSet\u003cString\u003e unwrappedNames \u003d null;\r\n    while (it.hasNext()) {\r\n        SettableBeanProperty prop \u003d it.next();\r\n        // First things first: only consider array/Collection types\r\n        // (not perfect check, but simplest reasonable check)\r\n        JavaType type \u003d prop.getType();\r\n        if (!TypeUtil.isIndexedType(type)) {\r\n            continue;\r\n        }\r\n        PropertyName wrapperName \u003d prop.getWrapperName();\r\n        // skip anything with wrapper (should work as is)\r\n        if ((wrapperName !\u003d null) \u0026\u0026 (wrapperName !\u003d PropertyName.NO_NAME)) {\r\n            continue;\r\n        }\r\n        if (unwrappedNames \u003d\u003d null) {\r\n            unwrappedNames \u003d new HashSet\u003cString\u003e();\r\n        }\r\n        // not optimal; should be able to use PropertyName...\r\n        unwrappedNames.add(prop.getName());\r\n        for (PropertyName alias : prop.findAliases(ctxt.getConfig())) {\r\n            unwrappedNames.add(alias.getSimpleName());\r\n        }\r\n    }\r\n    // Ok: if nothing to take care of, just return the delegatee...\r\n    if (unwrappedNames \u003d\u003d null) {\r\n        return newDelegatee;\r\n    }\r\n    // Otherwise, create the thing that can deal with virtual wrapping\r\n    return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\r\n}",
    "nodes": 18,
    "edges": 24,
    "cc": 8,
    "flowSummary": [
      "B0 : If(r23 !\u003d null) → B1 | else → B2",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B15",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B6 : If(r8 \u003d\u003d null) → B7 | else → B9",
      "B7 : If(r8 \u003d\u003d $r17) → B8 | else → B9",
      "B9 : If(r24 !\u003d null) → B10 | else → B11",
      "B12 : If($z2 \u003d\u003d false) → B13 | else → B14",
      "B15 : If(r24 !\u003d null) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  WrapperHandlingDeserializer\n  DeserializationContext\n  BeanProperty\n  r23 \u003d JavaType _type\u003e\n  if (r23 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r18 \u003d JsonDeserializer _delegatee\u003e\n  $r19 \u003d $r18.handledType()\n  r23 \u003d r1.constructType($r19)\n}",
      "B2 {\n  $r3 \u003d JsonDeserializer _delegatee\u003e\n  $r20 \u003d r1.handleSecondaryContextualization($r3, r2, r23)\n  $r21 \u003d r0._verifyDeserType($r20)\n  $r22 \u003d $r21.properties()\n  r24 \u003d null\n}",
      "B3 {\n  $z1 \u003d $r22.hasNext()\n  if ($z1 \u003d\u003d false) goto B4 else B15\n}",
      "B4 {\n  $r5 \u003d $r22.next()\n  r6 \u003d SettableBeanProperty) $r5\n  r7 \u003d r6.getType()\n  $z0 \u003d TypeUtil.isIndexedType(r7)\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r8 \u003d r6.getWrapperName()\n  if (r8 \u003d\u003d null) goto B7 else B9\n}",
      "B7 {\n  $r17 \u003d PropertyName NO_NAME\u003e\n  if (r8 \u003d\u003d $r17) goto B8 else B9\n}",
      "B8 {\n  goto B3\n}",
      "B9 {\n  if (r24 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  $r15 \u003d HashSet\n  new HashSet()\n  r24 \u003d $r15\n}",
      "B11 {\n  $r9 \u003d r6.getName()\n  r24.add($r9)\n  $r10 \u003d r1.getConfig()\n  $r11 \u003d r6.findAliases($r10)\n  $r16 \u003d $r11.iterator()\n}",
      "B12 {\n  $z2 \u003d $r16.hasNext()\n  if ($z2 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $r12 \u003d $r16.next()\n  r13 \u003d PropertyName) $r12\n  $r14 \u003d r13.getSimpleName()\n  r24.add($r14)\n  goto B12\n}",
      "B14 {\n  goto B3\n}",
      "B15 {\n  if (r24 !\u003d null) goto B16 else B17\n}",
      "B16 {\n  return\n}",
      "B17 {\n  $r4 \u003d WrapperHandlingDeserializer\n  new WrapperHandlingDeserializer($r21, r24)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B15",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B12",
      "B14 --\u003e B3",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WrapperHandlingDeserializer#_verifyDeserType(...1)",
        "body": "{\r\n    if (!(deser instanceof BeanDeserializerBase)) {\r\n        throw new IllegalArgumentException(\"Can not change delegate to be of type \" + deser.getClass().getName());\r\n    }\r\n    return (BeanDeserializerBase) deser;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier",
    "methodName": "updateProperties",
    "signature": "java.util.List updateProperties(com.fasterxml.jackson.databind.DeserializationConfig,com.fasterxml.jackson.databind.BeanDescription,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    final AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\r\n    int changed \u003d 0;\r\n    for (int i \u003d 0, propCount \u003d propDefs.size(); i \u003c propCount; ++i) {\r\n        BeanPropertyDefinition prop \u003d propDefs.get(i);\r\n        AnnotatedMember acc \u003d prop.getPrimaryMember();\r\n        // should not be null, but just in case:\r\n        if (acc \u003d\u003d null) {\r\n            continue;\r\n        }\r\n        /* First: handle \"as text\"? Such properties\r\n             * are exposed as values of \u0027unnamed\u0027 fields; so one way to\r\n             * map them is to rename property to have name \"\"... (and\r\n             * hope this does not break other parts...)\r\n             */\r\n        Boolean b \u003d AnnotationUtil.findIsTextAnnotation(config, intr, acc);\r\n        if (b !\u003d null \u0026\u0026 b.booleanValue()) {\r\n            // unwrapped properties will appear as \u0027unnamed\u0027 (empty String)\r\n            BeanPropertyDefinition newProp \u003d prop.withSimpleName(_cfgNameForTextValue);\r\n            if (newProp !\u003d prop) {\r\n                propDefs.set(i, newProp);\r\n            }\r\n            continue;\r\n        }\r\n        // second: do we need to handle wrapping (for Lists)?\r\n        PropertyName wrapperName \u003d prop.getWrapperName();\r\n        if (wrapperName !\u003d null \u0026\u0026 wrapperName !\u003d PropertyName.NO_NAME) {\r\n            String localName \u003d wrapperName.getSimpleName();\r\n            if ((localName !\u003d null \u0026\u0026 localName.length() \u003e 0) \u0026\u0026 !localName.equals(prop.getName())) {\r\n                // make copy-on-write as necessary\r\n                if (changed \u003d\u003d 0) {\r\n                    propDefs \u003d new ArrayList\u003cBeanPropertyDefinition\u003e(propDefs);\r\n                }\r\n                ++changed;\r\n                propDefs.set(i, prop.withSimpleName(localName));\r\n                continue;\r\n            }\r\n            // otherwise unwrapped; needs handling but later on\r\n        }\r\n    }\r\n    return propDefs;\r\n}",
    "nodes": 18,
    "edges": 28,
    "cc": 12,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B17",
      "B2 : If(r4 !\u003d null) → B3 | else → B4",
      "B4 : If(r5 \u003d\u003d null) → B5 | else → B8",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B8",
      "B6 : If(r16 \u003d\u003d r3) → B7 | else → B16",
      "B8 : If($r11 \u003d\u003d null) → B9 | else → B16",
      "B9 : If($r11 \u003d\u003d $r6) → B10 | else → B16",
      "B10 : If(r7 \u003d\u003d null) → B11 | else → B16",
      "B11 : If($i1 \u003c\u003d 0) → B12 | else → B16",
      "B12 : If($z0 !\u003d 0) → B13 | else → B16",
      "B13 : If(i2 !\u003d 0) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  XmlBeanDeserializerModifier\n  DeserializationConfig\n  BeanDescription\n  List\n  r1 \u003d r0.getAnnotationIntrospector()\n  i2 \u003d 0\n  i3 \u003d 0\n  i0 \u003d r15.size()\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B17\n}",
      "B2 {\n  $r2 \u003d r15.get(i3)\n  r3 \u003d BeanPropertyDefinition) $r2\n  r4 \u003d r3.getPrimaryMember()\n  if (r4 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  goto B16\n}",
      "B4 {\n  r5 \u003d AnnotationUtil.findIsTextAnnotation(r0, r1, r4)\n  if (r5 \u003d\u003d null) goto B5 else B8\n}",
      "B5 {\n  $z1 \u003d r5.booleanValue()\n  if ($z1 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r13 \u003d String _cfgNameForTextValue\u003e\n  r16 \u003d r3.withSimpleName($r13)\n  if (r16 \u003d\u003d r3) goto B7 else B16\n}",
      "B7 {\n  r15.set(i3, r16)\n  goto B16\n}",
      "B8 {\n  $r11 \u003d r3.getWrapperName()\n  if ($r11 \u003d\u003d null) goto B9 else B16\n}",
      "B9 {\n  $r6 \u003d PropertyName NO_NAME\u003e\n  if ($r11 \u003d\u003d $r6) goto B10 else B16\n}",
      "B10 {\n  r7 \u003d $r11.getSimpleName()\n  if (r7 \u003d\u003d null) goto B11 else B16\n}",
      "B11 {\n  $i1 \u003d r7.length()\n  if ($i1 \u003c\u003d 0) goto B12 else B16\n}",
      "B12 {\n  $r8 \u003d r3.getName()\n  $z0 \u003d r7.equals($r8)\n  if ($z0 !\u003d 0) goto B13 else B16\n}",
      "B13 {\n  if (i2 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r10 \u003d ArrayList\n  new ArrayList(r15)\n  r15 \u003d $r10\n}",
      "B15 {\n  i2 \u003d i2 + 1\n  $r9 \u003d r3.withSimpleName(r7)\n  r15.set(i3, $r9)\n  goto B16\n}",
      "B16 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B17",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B16",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B16",
      "B7 --\u003e B16",
      "B8 --\u003e B9",
      "B8 --\u003e B16",
      "B9 --\u003e B10",
      "B9 --\u003e B16",
      "B10 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B16 --\u003e B1",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier",
    "methodName": "modifyDeserializer",
    "signature": "com.fasterxml.jackson.databind.JsonDeserializer modifyDeserializer(com.fasterxml.jackson.databind.DeserializationConfig,com.fasterxml.jackson.databind.BeanDescription,com.fasterxml.jackson.databind.JsonDeserializer)",
    "visibility": "public",
    "body": "{\r\n    if (!(deser0 instanceof BeanDeserializerBase)) {\r\n        return deser0;\r\n    }\r\n    /* 17-Aug-2013, tatu: One important special case first: if we have one \"XML Text\"\r\n         * property, it may be exposed as VALUE_STRING token (depending on whether any attribute\r\n         * values are exposed): and to deserialize from that, we need special handling unless POJO\r\n         * has appropriate single-string creator method.\r\n         */\r\n    BeanDeserializerBase deser \u003d (BeanDeserializerBase) deser0;\r\n    // Heuristics are bit tricky; but for now let\u0027s assume that if POJO\r\n    // can already work with VALUE_STRING, it\u0027s ok and doesn\u0027t need extra support\r\n    ValueInstantiator inst \u003d deser.getValueInstantiator();\r\n    // 03-Aug-2017, tatu: [dataformat-xml#254] suggests we also should\r\n    //    allow passing `int`/`Integer`/`long`/`Long` cases, BUT\r\n    //    unfortunately we can not simply use default handling. Would need\r\n    //    coercion.\r\n    // 30-Apr-2020, tatu: Complication from [dataformat-xml#318] as we now\r\n    //    have a delegate too...\r\n    if (!inst.canCreateFromString()) {\r\n        SettableBeanProperty textProp \u003d _findSoleTextProp(config, deser.properties());\r\n        if (textProp !\u003d null) {\r\n            return new XmlTextDeserializer(deser, textProp);\r\n        }\r\n    }\r\n    return new WrapperHandlingDeserializer(deser);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 !\u003d 0) → B3 | else → B5",
      "B3 : If(r7 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  XmlBeanDeserializerModifier\n  DeserializationConfig\n  BeanDescription\n  JsonDeserializer\n  $z0 \u003d BeanDeserializerBase\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d BeanDeserializerBase) r0\n  r2 \u003d r1.getValueInstantiator()\n  $z1 \u003d r2.canCreateFromString()\n  if ($z1 !\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $r6 \u003d r1.properties()\n  r7 \u003d r4._findSoleTextProp(r5, $r6)\n  if (r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d XmlTextDeserializer\n  new XmlTextDeserializer(r1, r7)\n  return\n}",
      "B5 {\n  $r3 \u003d WrapperHandlingDeserializer\n  new WrapperHandlingDeserializer(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlBeanDeserializerModifier#_findSoleTextProp(...2)",
        "body": "{\r\n    final AnnotationIntrospector ai \u003d config.getAnnotationIntrospector();\r\n    SettableBeanProperty textProp \u003d null;\r\n    while (propIt.hasNext()) {\r\n        SettableBeanProperty prop \u003d propIt.next();\r\n        AnnotatedMember m \u003d prop.getMember();\r\n        if (m !\u003d null) {\r\n            // Ok, let\u0027s use a simple check: we should have renamed it earlier so:\r\n            PropertyName n \u003d prop.getFullName();\r\n            if (_cfgNameForTextValue.equals(n.getSimpleName())) {\r\n                // should we verify we only got one?\r\n                textProp \u003d prop;\r\n                continue;\r\n            }\r\n            // as-attribute are ok as well\r\n            Boolean b \u003d AnnotationUtil.findIsAttributeAnnotation(config, ai, m);\r\n            if (b !\u003d null \u0026\u0026 b.booleanValue()) {\r\n                continue;\r\n            }\r\n        }\r\n        // Otherwise, it\u0027s something else; no go\r\n        return null;\r\n    }\r\n    return textProp;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlDeserializationContext",
    "methodName": "readRootValue",
    "signature": "java.lang.Object readRootValue(com.fasterxml.jackson.core.JsonParser,com.fasterxml.jackson.databind.JavaType,com.fasterxml.jackson.databind.JsonDeserializer,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // 18-Sep-2021, tatu: Complicated mess; with 2.12, had [dataformat-xml#374]\r\n    //    to disable handling. With 2.13, via [dataformat-xml#485] undid this change\r\n    if (_config.useRootWrapping()) {\r\n        return _unwrapAndDeserialize(p, valueType, deser, valueToUpdate);\r\n    }\r\n    if (valueToUpdate \u003d\u003d null) {\r\n        return deser.deserialize(p, this);\r\n    }\r\n    return deser.deserialize(p, this, valueToUpdate);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(r2 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  XmlDeserializationContext\n  JsonParser\n  JavaType\n  JsonDeserializer\n  Object\n  $r1 \u003d DeserializationConfig _config\u003e\n  $z0 \u003d $r1.useRootWrapping()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0._unwrapAndDeserialize(r4, r7, r3, r2)\n  return\n}",
      "B2 {\n  if (r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r3.deserialize(r4, r0)\n  return\n}",
      "B4 {\n  $r5 \u003d r3.deserialize(r4, r0, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlDeserializationContext#_unwrapAndDeserialize(...4)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlDeserializationContext",
    "methodName": "extractScalarFromObject",
    "signature": "java.lang.String extractScalarFromObject(com.fasterxml.jackson.core.JsonParser,com.fasterxml.jackson.databind.JsonDeserializer,java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    // Only called on START_OBJECT, should not need to check, but JsonParser we\r\n    // get may or may not be `FromXmlParser` so traverse using regular means\r\n    String text \u003d \"\";\r\n    while (p.nextToken() \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // Couple of ways to find \"real\" textual content. One is to look for\r\n        // \"XmlText\"... but for that would need to know configuration. Alternatively\r\n        // could hold on to last text seen -- but this might be last attribute, for\r\n        // empty element. So for now let\u0027s simply hard-code check for empty String\r\n        // as marker and hope for best\r\n        final String propName \u003d p.currentName();\r\n        JsonToken t \u003d p.nextToken();\r\n        if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n            if (propName.equals(\"\")) {\r\n                text \u003d p.getText();\r\n            }\r\n        } else {\r\n            p.skipChildren();\r\n        }\r\n    }\r\n    return text;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B1 : If($r2 !\u003d $r1) → B2 | else → B7",
      "B2 : If(r4 !\u003d $r5) → B3 | else → B5",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B6"
    ],
    "blockList": [
      "B0 {\n  XmlDeserializationContext\n  JsonParser\n  JsonDeserializer\n  Class\n  r9 \u003d \"\"\n}",
      "B1 {\n  $r2 \u003d r0.nextToken()\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B2 else B7\n}",
      "B2 {\n  r3 \u003d r0.currentName()\n  r4 \u003d r0.nextToken()\n  $r5 \u003d JsonToken VALUE_STRING\u003e\n  if (r4 !\u003d $r5) goto B3 else B5\n}",
      "B3 {\n  $z0 \u003d r3.equals(\"\")\n  if ($z0 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  r9 \u003d r0.getText()\n  goto B6\n}",
      "B5 {\n  r0.skipChildren()\n}",
      "B6 {\n  goto B1\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B1",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext",
    "methodName": "createChildArrayContext",
    "signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext createChildArrayContext(int,int)",
    "visibility": "public",
    "body": "{\r\n    // not needed for Object, but does not hurt so no need to check curr type\r\n    ++_index;\r\n    XmlReadContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new XmlReadContext(this, _nestingDepth + 1, TYPE_ARRAY, lineNr, colNr);\r\n        return ctxt;\r\n    }\r\n    ctxt.reset(TYPE_ARRAY, lineNr, colNr);\r\n    return ctxt;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlReadContext\n  i2 :\u003d @parameter0: int\n  i3 :\u003d @parameter1: int\n  $i0 \u003d XmlReadContext: int _index\u003e\n  $i1 \u003d $i0 + 1\n  XmlReadContext: int _index\u003e \u003d $i1\n  r2 \u003d XmlReadContext _child\u003e\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d XmlReadContext\n  $i4 \u003d XmlReadContext: int _nestingDepth\u003e\n  $i5 \u003d $i4 + 1\n  new XmlReadContext(r0, $i5, 1, i2, i3)\n  XmlReadContext _child\u003e \u003d $r1\n  return\n}",
      "B2 {\n  r2.reset(1, i2, i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext",
    "methodName": "createChildObjectContext",
    "signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext createChildObjectContext(int,int)",
    "visibility": "public",
    "body": "{\r\n    // not needed for Object, but does not hurt so no need to check curr type\r\n    ++_index;\r\n    XmlReadContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\r\n        return ctxt;\r\n    }\r\n    ctxt.reset(TYPE_OBJECT, lineNr, colNr);\r\n    return ctxt;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlReadContext\n  i2 :\u003d @parameter0: int\n  i3 :\u003d @parameter1: int\n  $i0 \u003d XmlReadContext: int _index\u003e\n  $i1 \u003d $i0 + 1\n  XmlReadContext: int _index\u003e \u003d $i1\n  r2 \u003d XmlReadContext _child\u003e\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d XmlReadContext\n  new XmlReadContext(r0, 2, i2, i3)\n  XmlReadContext _child\u003e \u003d $r1\n  return\n}",
      "B2 {\n  r2.reset(2, i2, i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext",
    "methodName": "hasCurrentName",
    "signature": "boolean hasCurrentName()",
    "visibility": "public",
    "body": "{\r\n    return _currentName !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlReadContext\n  $r1 \u003d String _currentName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext",
    "methodName": "shouldWrap",
    "signature": "boolean shouldWrap(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return (_namesToWrap !\u003d null) \u0026\u0026 _namesToWrap.contains(localName);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  XmlReadContext\n  String\n  $r1 \u003d Set _namesToWrap\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d Set _namesToWrap\u003e\n  $z0 \u003d $r3.contains(r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    StringBuilder sb \u003d new StringBuilder(64);\r\n    switch(_type) {\r\n        case TYPE_ROOT:\r\n            sb.append(\"/\");\r\n            break;\r\n        case TYPE_ARRAY:\r\n            sb.append(\u0027[\u0027);\r\n            sb.append(getCurrentIndex());\r\n            sb.append(\u0027]\u0027);\r\n            break;\r\n        case TYPE_OBJECT:\r\n            sb.append(\u0027{\u0027);\r\n            if (_currentName !\u003d null) {\r\n                sb.append(\u0027\"\u0027);\r\n                CharTypes.appendQuoted(sb, _currentName);\r\n                sb.append(\u0027\"\u0027);\r\n            } else {\r\n                sb.append(\u0027?\u0027);\r\n            }\r\n            sb.append(\u0027}\u0027);\r\n            break;\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If(switch-on $i0) → B1 | else → B2",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  XmlReadContext\n  $r0 \u003d StringBuilder\n  new StringBuilder(64)\n  $i0 \u003d XmlReadContext: int _type\u003e\n  String toString()\u003e(); }\n}",
      "B1 {\n  $r0.append(\"/\")\n  goto B7\n}",
      "B2 {\n  $r0.append(91)\n  $i1 \u003d r1.getCurrentIndex()\n  $r0.append($i1)\n  $r0.append(93)\n  goto B7\n}",
      "B3 {\n  $r0.append(123)\n  $r2 \u003d String _currentName\u003e\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r0.append(34)\n  $r3 \u003d String _currentName\u003e\n  CharTypes.appendQuoted($r0, $r3)\n  $r0.append(34)\n  goto B6\n}",
      "B5 {\n  $r0.append(63)\n}",
      "B6 {\n  $r0.append(125)\n}",
      "B7 {\n  $r4 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B7",
      "B1 --\u003e B7",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlReadContext#getCurrentIndex(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer",
    "methodName": "deserialize",
    "signature": "java.lang.Object deserialize(com.fasterxml.jackson.core.JsonParser,com.fasterxml.jackson.databind.DeserializationContext)",
    "visibility": "public",
    "body": "{\r\n    if (p.getCurrentToken() \u003d\u003d JsonToken.VALUE_STRING) {\r\n        Object bean \u003d _valueInstantiator.createUsingDefault(ctxt);\r\n        _xmlTextProperty.deserializeAndSet(p, ctxt, bean);\r\n        return bean;\r\n    }\r\n    return _delegatee.deserialize(p, ctxt);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlTextDeserializer\n  JsonParser\n  DeserializationContext\n  $r2 \u003d r0.getCurrentToken()\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d ValueInstantiator _valueInstantiator\u003e\n  r8 \u003d $r7.createUsingDefault(r4)\n  $r9 \u003d SettableBeanProperty _xmlTextProperty\u003e\n  $r9.deserializeAndSet(r0, r4, r8)\n  return\n}",
      "B2 {\n  $r5 \u003d JsonDeserializer _delegatee\u003e\n  $r6 \u003d $r5.deserialize(r0, r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlTextDeserializer",
    "methodName": "deserialize",
    "signature": "java.lang.Object deserialize(com.fasterxml.jackson.core.JsonParser,com.fasterxml.jackson.databind.DeserializationContext,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (p.getCurrentToken() \u003d\u003d JsonToken.VALUE_STRING) {\r\n        _xmlTextProperty.deserializeAndSet(p, ctxt, bean);\r\n        return bean;\r\n    }\r\n    return ((JsonDeserializer\u003cObject\u003e) _delegatee).deserialize(p, ctxt, bean);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlTextDeserializer\n  JsonParser\n  DeserializationContext\n  Object\n  $r2 \u003d r0.getCurrentToken()\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d SettableBeanProperty _xmlTextProperty\u003e\n  $r8.deserializeAndSet(r0, r4, r5)\n  return\n}",
      "B2 {\n  $r6 \u003d JsonDeserializer _delegatee\u003e\n  $r7 \u003d $r6.deserialize(r0, r4, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream",
    "methodName": "initialize",
    "signature": "int initialize()",
    "visibility": "public",
    "body": "{\r\n    // Let\u0027s ensure we point to START_ELEMENT...\r\n    if (_xmlReader.getEventType() !\u003d XMLStreamConstants.START_ELEMENT) {\r\n        throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\" + XMLStreamConstants.START_ELEMENT + \"), instead got \" + _xmlReader.getEventType());\r\n    }\r\n    // sets _attributeCount, _nextAttributeIndex\r\n    _checkXsiAttributes();\r\n    _decodeElementName(_xmlReader.getNamespaceURI(), _xmlReader.getLocalName());\r\n    // 02-Jul-2020, tatu: Two choices: if child elements OR attributes, expose\r\n    //    as Object value; otherwise expose as Text\r\n    // 06-Sep-2022, tatu: Actually expose as Object in almost every situation\r\n    //    as of 2.14: otherwise we have lots of issues with empty POJOs,\r\n    //    Lists, Maps\r\n    if (_xmlReader.isEmptyElement() \u0026\u0026 FromXmlParser.Feature.EMPTY_ELEMENT_AS_NULL.enabledIn(_formatFeatures) \u0026\u0026 !_xsiNilFound \u0026\u0026 _attributeCount \u003c 1) {\r\n        // 06-Sep-2022, tatu: In fact the only special case of null conversion\r\n        //    of the root empty element\r\n        _textValue \u003d null;\r\n        _startElementAfterText \u003d false;\r\n        return (_currentState \u003d XML_ROOT_TEXT);\r\n    }\r\n    return (_currentState \u003d XML_START_ELEMENT);\r\n    // 06-Sep-2022, tatu: This code was used in 2.12, 2.13, may be\r\n    //   removed after 2.14 if/when no longer needed\r\n    // copied from START_ELEMENT section of _next():\r\n    /*\r\n        final String text \u003d _collectUntilTag();\r\n        if (text \u003d\u003d null) {\r\n            // 30-Nov-2020, tatu: [dataformat-xml#435], this is tricky\r\n            //   situation since we got coerced `null`... but at least for\r\n            //   now will have to report as \"root String\" (... with null contents)\r\n            _textValue \u003d null;\r\n            _startElementAfterText \u003d false;\r\n            return (_currentState \u003d XML_ROOT_TEXT);\r\n        }\r\n\r\n        final boolean startElementNext \u003d _xmlReader.getEventType() \u003d\u003d XMLStreamReader.START_ELEMENT;\r\n        // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\r\n        if (startElementNext) {\r\n            if (_allWs(text)) {\r\n                _textValue \u003d null;\r\n                return (_currentState \u003d XML_DELAYED_START_ELEMENT);\r\n            }\r\n            _textValue \u003d text;\r\n            return (_currentState \u003d XML_DELAYED_START_ELEMENT);\r\n        }\r\n        _startElementAfterText \u003d false;\r\n        _textValue \u003d text;\r\n        return (_currentState \u003d XML_ROOT_TEXT);\r\n        */\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B7",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B7",
      "B4 : If($z2 !\u003d 0) → B5 | else → B7",
      "B5 : If($i2 \u003e\u003d 1) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  XmlTokenStream\n  $r1 \u003d XMLStreamReader2 _xmlReader\u003e\n  $i0 \u003d $r1.getEventType()\n  if ($i0 \u003d\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  $r9 \u003d XMLStreamReader2 _xmlReader\u003e\n  $i3 \u003d $r9.getEventType()\n  $r10 \u003d dynInvoke makeConcatWithConstants($i3)\n  new IllegalArgumentException($r10)\n  throw $r8\n}",
      "B2 {\n  r0._checkXsiAttributes()\n  $r2 \u003d XMLStreamReader2 _xmlReader\u003e\n  $r5 \u003d $r2.getNamespaceURI()\n  $r3 \u003d XMLStreamReader2 _xmlReader\u003e\n  $r4 \u003d $r3.getLocalName()\n  r0._decodeElementName($r5, $r4)\n  $r6 \u003d XMLStreamReader2 _xmlReader\u003e\n  $z0 \u003d $r6.isEmptyElement()\n  if ($z0 \u003d\u003d false) goto B3 else B7\n}",
      "B3 {\n  $r7 \u003d FromXmlParser$Feature EMPTY_ELEMENT_AS_NULL\u003e\n  $i1 \u003d XmlTokenStream: int _formatFeatures\u003e\n  $z1 \u003d $r7.enabledIn($i1)\n  if ($z1 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  $z2 \u003d XmlTokenStream: boolean _xsiNilFound\u003e\n  if ($z2 !\u003d 0) goto B5 else B7\n}",
      "B5 {\n  $i2 \u003d XmlTokenStream: int _attributeCount\u003e\n  if ($i2 \u003e\u003d 1) goto B6 else B7\n}",
      "B6 {\n  String _textValue\u003e \u003d null\n  XmlTokenStream: boolean _startElementAfterText\u003e \u003d 0\n  XmlTokenStream: int _currentState\u003e \u003d 7\n  return\n}",
      "B7 {\n  XmlTokenStream: int _currentState\u003e \u003d 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlTokenStream#_checkXsiAttributes(...0)",
        "body": "{\r\n    int count \u003d _xmlReader.getAttributeCount();\r\n    _attributeCount \u003d count;\r\n    // [dataformat-xml#354]: xsi:nil handling; at first only if first attribute\r\n    if (count \u003e\u003d 1) {\r\n        // [dataformat-xml#468]: may disable xsi:nil processing\r\n        if (_cfgProcessXsiNil \u0026\u0026 \"nil\".equals(_xmlReader.getAttributeLocalName(0))) {\r\n            if (XSI_NAMESPACE.equals(_xmlReader.getAttributeNamespace(0))) {\r\n                // need to skip, regardless of value\r\n                _nextAttributeIndex \u003d 1;\r\n                // but only mark as nil marker if enabled\r\n                _xsiNilFound \u003d \"true\".equals(_xmlReader.getAttributeValue(0));\r\n                //System.out.println(\" XMLTokenStream._checkXsiAttributes(), _xsiNilFound: \"+_xsiNilFound);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _nextAttributeIndex \u003d 0;\r\n    _xsiNilFound \u003d false;\r\n}"
      },
      {
        "name": "XmlTokenStream#_decodeElementName(...2)",
        "body": "{\r\n    // 31-Jan-2024, tatu: [dataformat-xml#634] Need to convert \u0027xsi:type\u0027?\r\n    //    (not 100% sure if needed for elements but let\u0027s do for now)\r\n    if (_cfgProcessXsiType) {\r\n        if (localName.equals(\"type\") \u0026\u0026 XSI_NAMESPACE.equals(namespaceURI)) {\r\n            _localName \u003d \"xsi:type\";\r\n            // or could leave as it was?\r\n            _namespaceURI \u003d \"\";\r\n            return;\r\n        }\r\n    }\r\n    _nameToDecode.namespace \u003d namespaceURI;\r\n    _nameToDecode.localPart \u003d localName;\r\n    _nameProcessor.decodeName(_nameToDecode);\r\n    _namespaceURI \u003d _nameToDecode.namespace;\r\n    _localName \u003d _nameToDecode.localPart;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream",
    "methodName": "next",
    "signature": "int next()",
    "visibility": "public",
    "body": "{\r\n    if (_repeatCurrentToken) {\r\n        _repeatCurrentToken \u003d false;\r\n        return _currentState;\r\n    }\r\n    if (_repeatElement !\u003d 0) {\r\n        return (_currentState \u003d _handleRepeatElement());\r\n    }\r\n    return _next();\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  XmlTokenStream\n  $z0 \u003d XmlTokenStream: boolean _repeatCurrentToken\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  XmlTokenStream: boolean _repeatCurrentToken\u003e \u003d 0\n  $i3 \u003d XmlTokenStream: int _currentState\u003e\n  return\n}",
      "B2 {\n  $i0 \u003d XmlTokenStream: int _repeatElement\u003e\n  if ($i0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i2 \u003d r0._handleRepeatElement()\n  XmlTokenStream: int _currentState\u003e \u003d $i2\n  return\n}",
      "B4 {\n  $i1 \u003d r0._next()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlTokenStream#_handleRepeatElement(...0)",
        "body": "{\r\n    //System.out.println(\" XMLTokenStream._handleRepeatElement()\");\r\n    int type \u003d _repeatElement;\r\n    _repeatElement \u003d 0;\r\n    if (type \u003d\u003d REPLAY_START_DUP) {\r\n        //System.out.println(\" XMLTokenStream._handleRepeatElement() for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\r\n        // important: add the virtual element second time, but not with name to match\r\n        // lgtm [java/dereferenced-value-may-be-null]\r\n        _currentWrapper \u003d _currentWrapper.intermediateWrapper();\r\n        return XML_START_ELEMENT;\r\n    }\r\n    if (type \u003d\u003d REPLAY_END) {\r\n        //System.out.println(\" XMLTokenStream._handleRepeatElement() for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\r\n        _decodeElementName(_xmlReader.getNamespaceURI(), _xmlReader.getLocalName());\r\n        if (_currentWrapper !\u003d null) {\r\n            _currentWrapper \u003d _currentWrapper.getParent();\r\n        }\r\n        return XML_END_ELEMENT;\r\n    }\r\n    if (type \u003d\u003d REPLAY_START_DELAYED) {\r\n        if (_currentWrapper !\u003d null) {\r\n            _currentWrapper \u003d _currentWrapper.intermediateWrapper();\r\n        }\r\n        _decodeElementName(_nextNamespaceURI, _nextLocalName);\r\n        _nextLocalName \u003d null;\r\n        _nextNamespaceURI \u003d null;\r\n        //System.out.println(\" XMLTokenStream._handleRepeatElement() for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\r\n        return XML_START_ELEMENT;\r\n    }\r\n    throw new IllegalStateException(\"Unrecognized type to repeat: \" + type);\r\n}"
      },
      {
        "name": "XmlTokenStream#_next(...0)",
        "body": "{\r\n    //System.out.println(\" XmlTokenStream._next(), state: \"+_currentStateDesc());\r\n    switch(_currentState) {\r\n        case XML_ATTRIBUTE_VALUE:\r\n            ++_nextAttributeIndex;\r\n        // fall through\r\n        case // attributes to return?\r\n        XML_START_ELEMENT:\r\n            // 06-Sep-2019, tatu: `xsi:nil` to induce \"real\" null value?\r\n            if (_xsiNilFound) {\r\n                _xsiNilFound \u003d false;\r\n                // 08-Jul-2021, tatu: as per [dataformat-xml#467] just skip anything\r\n                //   element might have, no need to ensure it was empty\r\n                _xmlReader.skipElement();\r\n                //System.out.println(\" XmlTokenStream._next(): Got xsi:nil, skipping element\");\r\n                return _handleEndElement();\r\n            }\r\n            if (_nextAttributeIndex \u003c _attributeCount) {\r\n                //System.out.println(\" XmlTokenStream._next(): Got attr(s)!\");\r\n                _decodeAttributeName(_xmlReader.getAttributeNamespace(_nextAttributeIndex), _xmlReader.getAttributeLocalName(_nextAttributeIndex));\r\n                _textValue \u003d _xmlReader.getAttributeValue(_nextAttributeIndex);\r\n                return (_currentState \u003d XML_ATTRIBUTE_NAME);\r\n            }\r\n            // otherwise need to find START/END_ELEMENT or text\r\n            String text \u003d _collectUntilTag();\r\n            //System.out.println(\" XmlTokenStream._next(): _collectUntilTag -\u003e \u0027\"+text+\"\u0027\");\r\n            final boolean startElementNext \u003d _xmlReader.getEventType() \u003d\u003d XMLStreamReader.START_ELEMENT;\r\n            //System.out.println(\" XmlTokenStream._next(): startElementNext? \"+startElementNext);\r\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\r\n            if (startElementNext) {\r\n                if (_allWs(text)) {\r\n                    _startElementAfterText \u003d false;\r\n                    return _initStartElement();\r\n                }\r\n                _startElementAfterText \u003d true;\r\n                _textValue \u003d text;\r\n                return (_currentState \u003d XML_TEXT);\r\n            }\r\n            // For END_ELEMENT we will return text, if any\r\n            if (text !\u003d null) {\r\n                _startElementAfterText \u003d false;\r\n                _textValue \u003d text;\r\n                return (_currentState \u003d XML_TEXT);\r\n            }\r\n            _startElementAfterText \u003d false;\r\n            return _handleEndElement();\r\n        /*\r\n        case XML_DELAYED_START_ELEMENT: // since 2.12, to support scalar Root Value\r\n            // Two cases: either \"simple\" with not text\r\n           if (_textValue \u003d\u003d null) {\r\n               return _initStartElement();\r\n           }\r\n           // or one where there is first text (to translate into \"\":\u003ctext\u003e key/value entry)\r\n           // then followed by start element\r\n           _startElementAfterText \u003d true;\r\n           return (_currentState \u003d XML_TEXT);\r\n           */\r\n        case XML_ATTRIBUTE_NAME:\r\n            // if we just returned name, will need to just send value next\r\n            return (_currentState \u003d XML_ATTRIBUTE_VALUE);\r\n        case XML_TEXT:\r\n            // mixed text with other elements\r\n            if (_startElementAfterText) {\r\n                _startElementAfterText \u003d false;\r\n                return _initStartElement();\r\n            }\r\n            // text followed by END_ELEMENT\r\n            return _handleEndElement();\r\n        case XML_ROOT_TEXT:\r\n            close();\r\n            return (_currentState \u003d XML_END);\r\n        case XML_END:\r\n            return XML_END;\r\n    }\r\n    // Ok: must be END_ELEMENT; see what tag we get (or end)\r\n    switch(_skipAndCollectTextUntilTag()) {\r\n        case XMLStreamConstants.END_DOCUMENT:\r\n            close();\r\n            return (_currentState \u003d XML_END);\r\n        case XMLStreamConstants.END_ELEMENT:\r\n            // 24-May-2020, tatu: Need to see if we have \"mixed content\" to offer\r\n            if (!_allWs(_textValue)) {\r\n                // _textValue already set\r\n                return (_currentState \u003d XML_TEXT);\r\n            }\r\n            return _handleEndElement();\r\n    }\r\n    // 24-May-2020, tatu: Need to see if we have \"mixed content\" to offer\r\n    if (!_allWs(_textValue)) {\r\n        // _textValue already set\r\n        _startElementAfterText \u003d true;\r\n        return (_currentState \u003d XML_TEXT);\r\n    }\r\n    // START_ELEMENT...\r\n    return _initStartElement();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream",
    "methodName": "skipEndElement",
    "signature": "void skipEndElement()",
    "visibility": "public",
    "body": "{\r\n    int type \u003d next();\r\n    if (type !\u003d XML_END_ELEMENT) {\r\n        throw new IOException(String.format(\"Internal error: Expected END_ELEMENT, got event of type %s\", _stateDesc(type)));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d 2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlTokenStream\n  i0 \u003d r0.next()\n  if (i0 \u003d\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IOException\n  $r2 \u003d Object)[1]\n  $r3 \u003d r0._stateDesc(i0)\n  $r2[0] \u003d $r3\n  $r4 \u003d String.format(\"Internal error: Expected END_ELEMENT, got event of type %s\", $r2)\n  new IOException($r4)\n  throw $r1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlTokenStream#next(...0)",
        "body": "{\r\n    if (_repeatCurrentToken) {\r\n        _repeatCurrentToken \u003d false;\r\n        return _currentState;\r\n    }\r\n    if (_repeatElement !\u003d 0) {\r\n        return (_currentState \u003d _handleRepeatElement());\r\n    }\r\n    return _next();\r\n}"
      },
      {
        "name": "XmlTokenStream#_stateDesc(...1)",
        "body": "{\r\n    switch(state) {\r\n        case XML_START_ELEMENT:\r\n            return \"XML_START_ELEMENT\";\r\n        case XML_END_ELEMENT:\r\n            return \"XML_END_ELEMENT\";\r\n        case XML_ATTRIBUTE_NAME:\r\n            return \"XML_ATTRIBUTE_NAME\";\r\n        case XML_ATTRIBUTE_VALUE:\r\n            return \"XML_ATTRIBUTE_VALUE\";\r\n        case XML_TEXT:\r\n            return \"XML_TEXT\";\r\n        // case XML_DELAYED_START_ELEMENT:\r\n        //    return \"XML_START_ELEMENT_DELAYED\";\r\n        case XML_ROOT_TEXT:\r\n            return \"XML_ROOT_TEXT\";\r\n        case XML_END:\r\n            return \"XML_END\";\r\n    }\r\n    return \"N/A (\" + _currentState + \")\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "findWrapperName",
    "signature": "com.fasterxml.jackson.databind.PropertyName findWrapperName(com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    JacksonXmlElementWrapper w \u003d _findAnnotation(ann, JacksonXmlElementWrapper.class);\r\n    if (w !\u003d null) {\r\n        // Special case: wrapping explicitly blocked?\r\n        if (!w.useWrapping()) {\r\n            return PropertyName.NO_NAME;\r\n        }\r\n        // also: need to ensure we use marker:\r\n        String localName \u003d w.localName();\r\n        if (localName \u003d\u003d null || localName.length() \u003d\u003d 0) {\r\n            return PropertyName.USE_DEFAULT;\r\n        }\r\n        return PropertyName.construct(w.localName(), w.namespace());\r\n    }\r\n    // 09-Sep-2012, tatu: In absence of configuration we need to use our\r\n    //   default settings...\r\n    if (_cfgDefaultUseWrapper) {\r\n        return PropertyName.USE_DEFAULT;\r\n    }\r\n    return null;\r\n}",
    "nodes": 10,
    "edges": 10,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B7",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B3 : If(r5 \u003d\u003d null) → B4 | else → B5",
      "B4 : If($i0 !\u003d 0) → B5 | else → B6",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  Annotated\n  $r2 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlElementWrapper;\")\n  r3 \u003d JacksonXmlElementWrapper) $r2\n  if (r3 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $z1 \u003d r3.useWrapping()\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r10 \u003d PropertyName NO_NAME\u003e\n  return\n}",
      "B3 {\n  r5 \u003d r3.localName()\n  if (r5 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $i0 \u003d r5.length()\n  if ($i0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d PropertyName USE_DEFAULT\u003e\n  return\n}",
      "B6 {\n  $r8 \u003d r3.localName()\n  $r7 \u003d r3.namespace()\n  $r9 \u003d PropertyName.construct($r8, $r7)\n  return\n}",
      "B7 {\n  $z0 \u003d JacksonXmlAnnotationIntrospector: boolean _cfgDefaultUseWrapper\u003e\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r4 \u003d PropertyName USE_DEFAULT\u003e\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findAnnotation(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "findRootName",
    "signature": "com.fasterxml.jackson.databind.PropertyName findRootName(com.fasterxml.jackson.databind.introspect.AnnotatedClass)",
    "visibility": "public",
    "body": "{\r\n    JacksonXmlRootElement root \u003d _findAnnotation(ac, JacksonXmlRootElement.class);\r\n    if (root !\u003d null) {\r\n        String local \u003d root.localName();\r\n        String ns \u003d root.namespace();\r\n        if (local.length() \u003d\u003d 0 \u0026\u0026 ns.length() \u003d\u003d 0) {\r\n            return PropertyName.USE_DEFAULT;\r\n        }\r\n        return new PropertyName(local, ns);\r\n    }\r\n    return super.findRootName(ac);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B5",
      "B1 : If($i0 !\u003d 0) → B2 | else → B4",
      "B2 : If($i1 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  AnnotatedClass\n  $r2 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlRootElement;\")\n  r3 \u003d JacksonXmlRootElement) $r2\n  if (r3 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  r5 \u003d r3.localName()\n  r6 \u003d r3.namespace()\n  $i0 \u003d r5.length()\n  if ($i0 !\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $i1 \u003d r6.length()\n  if ($i1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d PropertyName USE_DEFAULT\u003e\n  return\n}",
      "B4 {\n  $r7 \u003d PropertyName\n  new PropertyName(r5, r6)\n  return\n}",
      "B5 {\n  $r4 \u003d r0.findRootName(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findAnnotation(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "findNamespace",
    "signature": "java.lang.String findNamespace(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    String ns1 \u003d null;\r\n    JacksonXmlProperty xmlProp \u003d _findAnnotation(ann, JacksonXmlProperty.class);\r\n    if (xmlProp !\u003d null) {\r\n        ns1 \u003d xmlProp.namespace();\r\n    }\r\n    // 14-Nov-2020, tatu: 2.12 adds namespace for this too\r\n    JsonProperty jprop \u003d _findAnnotation(ann, JsonProperty.class);\r\n    String ns2 \u003d null;\r\n    if (jprop !\u003d null) {\r\n        ns2 \u003d jprop.namespace();\r\n    }\r\n    if (ns1 \u003d\u003d null) {\r\n        return ns2;\r\n    }\r\n    if (ns2 \u003d\u003d null) {\r\n        return ns1;\r\n    }\r\n    if (ns1.isEmpty()) {\r\n        return ns2;\r\n    }\r\n    return ns1;\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r5 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(r7 !\u003d null) → B5 | else → B6",
      "B6 : If(r8 !\u003d null) → B7 | else → B8",
      "B8 : If($z0 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  MapperConfig\n  Annotated\n  r7 \u003d null\n  $r2 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlProperty;\")\n  r3 \u003d JacksonXmlProperty) $r2\n  if (r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r7 \u003d r3.namespace()\n}",
      "B2 {\n  $r4 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/annotation/JsonProperty;\")\n  $r5 \u003d JsonProperty) $r4\n  r8 \u003d null\n  if ($r5 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  r8 \u003d $r5.namespace()\n}",
      "B4 {\n  if (r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  if (r8 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z0 \u003d r7.isEmpty()\n  if ($z0 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findAnnotation(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "isOutputAsAttribute",
    "signature": "java.lang.Boolean isOutputAsAttribute(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    JacksonXmlProperty prop \u003d _findAnnotation(ann, JacksonXmlProperty.class);\r\n    if (prop !\u003d null) {\r\n        return prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B5",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  MapperConfig\n  Annotated\n  $r2 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlProperty;\")\n  r3 \u003d JacksonXmlProperty) $r2\n  if (r3 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  $z0 \u003d r3.isAttribute()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Boolean TRUE\u003e\n  goto B4\n}",
      "B3 {\n  $r5 \u003d Boolean FALSE\u003e\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findAnnotation(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "isOutputAsText",
    "signature": "java.lang.Boolean isOutputAsText(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    JacksonXmlText prop \u003d _findAnnotation(ann, JacksonXmlText.class);\r\n    if (prop !\u003d null) {\r\n        return prop.value() ? Boolean.TRUE : Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B5",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  MapperConfig\n  Annotated\n  $r2 \u003d r0._findAnnotation(r1, class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlText;\")\n  r3 \u003d JacksonXmlText) $r2\n  if (r3 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  $z0 \u003d r3.value()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Boolean TRUE\u003e\n  goto B4\n}",
      "B3 {\n  $r5 \u003d Boolean FALSE\u003e\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findAnnotation(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "isOutputAsCData",
    "signature": "java.lang.Boolean isOutputAsCData(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    JacksonXmlCData prop \u003d ann.getAnnotation(JacksonXmlCData.class);\r\n    if (prop !\u003d null) {\r\n        return prop.value() ? Boolean.TRUE : Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B5",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  MapperConfig\n  Annotated\n  $r1 \u003d r0.getAnnotation(class \"Lcom/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlCData;\")\n  r2 \u003d JacksonXmlCData) $r1\n  if (r2 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  $z0 \u003d r2.value()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Boolean TRUE\u003e\n  goto B4\n}",
      "B3 {\n  $r5 \u003d Boolean FALSE\u003e\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "findNameForSerialization",
    "signature": "com.fasterxml.jackson.databind.PropertyName findNameForSerialization(com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    PropertyName pn \u003d PropertyName.merge(_findXmlName(a), super.findNameForSerialization(a));\r\n    if (pn \u003d\u003d null) {\r\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_XML_PROP)) {\r\n            return PropertyName.USE_DEFAULT;\r\n        }\r\n    }\r\n    return pn;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  Annotated\n  $r3 \u003d r0._findXmlName(r1)\n  $r2 \u003d r0.findNameForSerialization(r1)\n  r4 \u003d PropertyName.merge($r3, $r2)\n  if (r4 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r5 \u003d Class[] ANNOTATIONS_TO_INFER_XML_PROP\u003e\n  $z0 \u003d r0._hasOneOf(r1, $r5)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d PropertyName USE_DEFAULT\u003e\n  return\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findXmlName(...1)",
        "body": "{\r\n    JacksonXmlProperty pann \u003d _findAnnotation(a, JacksonXmlProperty.class);\r\n    if (pann !\u003d null) {\r\n        return PropertyName.construct(pann.localName(), pann.namespace());\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "JacksonXmlAnnotationIntrospector#_hasOneOf(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector",
    "methodName": "findNameForDeserialization",
    "signature": "com.fasterxml.jackson.databind.PropertyName findNameForDeserialization(com.fasterxml.jackson.databind.introspect.Annotated)",
    "visibility": "public",
    "body": "{\r\n    PropertyName pn \u003d PropertyName.merge(_findXmlName(a), super.findNameForDeserialization(a));\r\n    if (pn \u003d\u003d null) {\r\n        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_XML_PROP)) {\r\n            return PropertyName.USE_DEFAULT;\r\n        }\r\n    }\r\n    return pn;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlAnnotationIntrospector\n  Annotated\n  $r3 \u003d r0._findXmlName(r1)\n  $r2 \u003d r0.findNameForDeserialization(r1)\n  r4 \u003d PropertyName.merge($r3, $r2)\n  if (r4 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r5 \u003d Class[] ANNOTATIONS_TO_INFER_XML_PROP\u003e\n  $z0 \u003d r0._hasOneOf(r1, $r5)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d PropertyName USE_DEFAULT\u003e\n  return\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JacksonXmlAnnotationIntrospector#_findXmlName(...1)",
        "body": "{\r\n    JacksonXmlProperty pann \u003d _findAnnotation(a, JacksonXmlProperty.class);\r\n    if (pann !\u003d null) {\r\n        return PropertyName.construct(pann.localName(), pann.namespace());\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "JacksonXmlAnnotationIntrospector#_hasOneOf(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule",
    "methodName": "setupModule",
    "signature": "void setupModule(com.fasterxml.jackson.databind.Module$SetupContext)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d \"\") → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JacksonXmlModule\n  Module$SetupContext\n  $r1 \u003d XmlBeanSerializerModifier\n  new XmlBeanSerializerModifier()\n  r0.addBeanSerializerModifier($r1)\n  $r2 \u003d XmlBeanDeserializerModifier\n  $r4 \u003d String _cfgNameForTextElement\u003e\n  new XmlBeanDeserializerModifier($r4)\n  r0.addBeanDeserializerModifier($r2)\n  $r5 \u003d r3._constructIntrospector()\n  r0.insertAnnotationIntrospector($r5)\n  $r6 \u003d String _cfgNameForTextElement\u003e\n  if ($r6 \u003d\u003d \"\") goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d r0.getOwner()\n  r8 \u003d XmlMapper) $r7\n  $r9 \u003d String _cfgNameForTextElement\u003e\n  r8.setXMLTextElementName($r9)\n}",
      "B2 {\n  r3.setupModule(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "initGenerator",
    "signature": "void initGenerator()",
    "visibility": "public",
    "body": "{\r\n    if (_initialized) {\r\n        return;\r\n    }\r\n    _initialized \u003d true;\r\n    try {\r\n        boolean xmlDeclWritten;\r\n        if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures) || Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\r\n            String xmlVersion \u003d Feature.WRITE_XML_1_1.enabledIn(_formatFeatures) ? \"1.1\" : \"1.0\";\r\n            String encoding \u003d \"UTF-8\";\r\n            if (Feature.WRITE_STANDALONE_YES_TO_XML_DECLARATION.enabledIn(_formatFeatures)) {\r\n                _xmlWriter.writeStartDocument(xmlVersion, encoding, true);\r\n            } else {\r\n                _xmlWriter.writeStartDocument(encoding, xmlVersion);\r\n            }\r\n            xmlDeclWritten \u003d true;\r\n        } else {\r\n            xmlDeclWritten \u003d false;\r\n        }\r\n        // as per [dataformat-xml#172], try adding indentation\r\n        if (xmlDeclWritten \u0026\u0026 (_xmlPrettyPrinter !\u003d null)) {\r\n            // ... but only if it is likely to succeed:\r\n            if (!_stax2Emulation) {\r\n                _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\r\n            }\r\n        }\r\n        if (Feature.AUTO_DETECT_XSI_TYPE.enabledIn(_formatFeatures)) {\r\n            _xmlWriter.setPrefix(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI);\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 21,
    "edges": 28,
    "cc": 9,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4",
      "B3 : If($z5 \u003d\u003d false) → B4 | else → B11",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B7 : If($z3 \u003d\u003d false) → B8 | else → B9",
      "B12 : If(z6 \u003d\u003d false) → B13 | else → B16",
      "B13 : If($r6 \u003d\u003d null) → B14 | else → B16",
      "B14 : If($z4 !\u003d 0) → B15 | else → B16",
      "B16 : If($z7 \u003d\u003d false) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $z0 \u003d ToXmlGenerator: boolean _initialized\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  ToXmlGenerator: boolean _initialized\u003e \u003d 1\n  $r1 \u003d ToXmlGenerator$Feature WRITE_XML_1_1\u003e\n  $i0 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z1 \u003d $r1.enabledIn($i0)\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r10 \u003d ToXmlGenerator$Feature WRITE_XML_DECLARATION\u003e\n  $i3 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z5 \u003d $r10.enabledIn($i3)\n  if ($z5 \u003d\u003d false) goto B4 else B11\n}",
      "B4 {\n  $r2 \u003d ToXmlGenerator$Feature WRITE_XML_1_1\u003e\n  $i1 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z2 \u003d $r2.enabledIn($i1)\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r15 \u003d 1\"\n  $r14 \u003d 1\"\n  goto B7\n}",
      "B6 {\n  $r15 \u003d 0\"\n  $r14 \u003d 0\"\n}",
      "B7 {\n  $r3 \u003d ToXmlGenerator$Feature WRITE_STANDALONE_YES_TO_XML_DECLARATION\u003e\n  $i2 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z3 \u003d $r3.enabledIn($i2)\n  if ($z3 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeStartDocument($r14, \"UTF-8\", 1)\n  goto B10\n}",
      "B9 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4.writeStartDocument(\"UTF-8\", $r15)\n}",
      "B10 {\n  z6 \u003d 1\n  goto B12\n}",
      "B11 {\n  z6 \u003d 0\n}",
      "B12 {\n  if (z6 \u003d\u003d false) goto B13 else B16\n}",
      "B13 {\n  $r6 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B14 else B16\n}",
      "B14 {\n  $z4 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z4 !\u003d 0) goto B15 else B16\n}",
      "B15 {\n  $r8 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r7 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writePrologLinefeed($r7)\n}",
      "B16 {\n  $r13 \u003d ToXmlGenerator$Feature AUTO_DETECT_XSI_TYPE\u003e\n  $i4 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z7 \u003d $r13.enabledIn($i4)\n  if ($z7 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5.setPrefix(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\")\n}",
      "B18 {\n  goto B20\n}",
      "B19 {\n  $r11 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r11, r0)\n}",
      "B20 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B11",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "setPrettyPrinter",
    "signature": "com.fasterxml.jackson.core.JsonGenerator setPrettyPrinter(com.fasterxml.jackson.core.PrettyPrinter)",
    "visibility": "public",
    "body": "{\r\n    _cfgPrettyPrinter \u003d pp;\r\n    _xmlPrettyPrinter \u003d (pp instanceof XmlPrettyPrinter) ? (XmlPrettyPrinter) pp : null;\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  PrettyPrinter\n  PrettyPrinter _cfgPrettyPrinter\u003e \u003d r1\n  $z0 \u003d XmlPrettyPrinter\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d XmlPrettyPrinter) r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d null\n}",
      "B3 {\n  XmlPrettyPrinter _xmlPrettyPrinter\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "overrideFormatFeatures",
    "signature": "com.fasterxml.jackson.core.JsonGenerator overrideFormatFeatures(int,int)",
    "visibility": "public",
    "body": "{\r\n    int oldF \u003d _formatFeatures;\r\n    int newF \u003d (_formatFeatures \u0026 ~mask) | (values \u0026 mask);\r\n    if (oldF !\u003d newF) {\r\n        _formatFeatures \u003d newF;\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d i7) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  i4 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i0 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $i3 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $i9 \u003d (int) -1\n  $i2 \u003d i1 ^ $i9\n  $i6 \u003d $i3 \u0026 $i2\n  $i5 \u003d i4 \u0026 i1\n  i7 \u003d $i6 | $i5\n  if (i0 \u003d\u003d i7) goto B1 else B2\n}",
      "B1 {\n  ToXmlGenerator: int _formatFeatures\u003e \u003d i7\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  ToXmlGenerator$Feature\n  $i0 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator configure(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  ToXmlGenerator$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "setNextNameIfMissing",
    "signature": "boolean setNextNameIfMissing(javax.xml.namespace.QName)",
    "visibility": "public",
    "body": "{\r\n    if (_nextName \u003d\u003d null) {\r\n        _nextName \u003d name;\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  QName\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  QName _nextName\u003e \u003d r2\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "startWrappedValue",
    "signature": "void startWrappedValue(javax.xml.namespace.QName,javax.xml.namespace.QName)",
    "visibility": "public",
    "body": "{\r\n    if (wrapperName !\u003d null) {\r\n        try {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeStartElement(_xmlWriter, wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\r\n            } else {\r\n                _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\r\n            }\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, this);\r\n        }\r\n    }\r\n    this.setNextName(wrappedName);\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B6",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  QName\n  QName\n  if (r0 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $r3 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d r0.getNamespaceURI()\n  $r9 \u003d r0.getLocalPart()\n  $r7.writeStartElement($r8, $r10, $r9)\n  goto B4\n}",
      "B3 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r6 \u003d r0.getNamespaceURI()\n  $r5 \u003d r0.getLocalPart()\n  $r4.writeStartElement($r6, $r5)\n}",
      "B4 {\n  goto B6\n}",
      "B5 {\n  $r11 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r11, r1)\n}",
      "B6 {\n  r1.setNextName(r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#setNextName(...1)",
        "body": "{\r\n    _nextName \u003d name;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "finishWrappedValue",
    "signature": "void finishWrappedValue(javax.xml.namespace.QName,javax.xml.namespace.QName)",
    "visibility": "public",
    "body": "{\r\n    // First: wrapper to close?\r\n    if (wrapperName !\u003d null) {\r\n        try {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeEndElement(_xmlWriter, _writeContext.getEntryCount());\r\n            } else {\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, this);\r\n        }\r\n    }\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B6",
      "B1 : If($r2 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  QName\n  QName\n  if (r0 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r6 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getEntryCount()\n  $r5.writeEndElement($r6, $i0)\n  goto B4\n}",
      "B3 {\n  $r3 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3.writeEndElement()\n}",
      "B4 {\n  goto B6\n}",
      "B5 {\n  $r7 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r7, r1)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRepeatedFieldName",
    "signature": "void writeRepeatedFieldName()",
    "visibility": "public",
    "body": "{\r\n    if (_writeContext.writeFieldName(_nextName.getLocalPart()) \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r1 \u003d QName _nextName\u003e\n  $r3 \u003d $r1.getLocalPart()\n  $i0 \u003d $r2.writeFieldName($r3)\n  if ($i0 !\u003d 4) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_writeContext.writeFieldName(name) \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    String ns;\r\n    // 30-Jan-2024, tatu: Surprise!\r\n    if (Feature.AUTO_DETECT_XSI_TYPE.enabledIn(_formatFeatures) \u0026\u0026 \"xsi:type\".equals(name)) {\r\n        setNextName(new QName(XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"type\", \"xsi\"));\r\n        setNextIsAttribute(true);\r\n    } else {\r\n        // Should this ever get called?\r\n        ns \u003d (_nextName \u003d\u003d null) ? \"\" : _nextName.getNamespaceURI();\r\n        _nameToEncode.namespace \u003d ns;\r\n        _nameToEncode.localPart \u003d name;\r\n        _nameProcessor.encodeName(_nameToEncode);\r\n        setNextName(new QName(_nameToEncode.namespace, _nameToEncode.localPart));\r\n    }\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B0 : If($i0 !\u003d 4) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($r4 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r2.writeFieldName(r1)\n  if ($i0 !\u003d 4) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B2 {\n  $r3 \u003d ToXmlGenerator$Feature AUTO_DETECT_XSI_TYPE\u003e\n  $i1 \u003d ToXmlGenerator: int _formatFeatures\u003e\n  $z0 \u003d $r3.enabledIn($i1)\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r15 \u003d \"xsi:type\"\n  $z1 \u003d $r15.equals(r1)\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r16 \u003d QName\n  new QName(\"http://www.w3.org/2001/XMLSchema-instance\", \"type\", \"xsi\")\n  r0.setNextName($r16)\n  r0.setNextIsAttribute(1)\n  goto B9\n}",
      "B5 {\n  $r4 \u003d QName _nextName\u003e\n  if ($r4 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r17 \u003d \"\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d QName _nextName\u003e\n  $r17 \u003d $r5.getNamespaceURI()\n}",
      "B8 {\n  $r6 \u003d XmlNameProcessor$XmlName _nameToEncode\u003e\n  String namespace\u003e \u003d $r17\n  $r7 \u003d XmlNameProcessor$XmlName _nameToEncode\u003e\n  String localPart\u003e \u003d r1\n  $r9 \u003d XmlNameProcessor _nameProcessor\u003e\n  $r8 \u003d XmlNameProcessor$XmlName _nameToEncode\u003e\n  $r9.encodeName($r8)\n  $r10 \u003d QName\n  $r11 \u003d XmlNameProcessor$XmlName _nameToEncode\u003e\n  $r14 \u003d String namespace\u003e\n  $r12 \u003d XmlNameProcessor$XmlName _nameToEncode\u003e\n  $r13 \u003d String localPart\u003e\n  new QName($r14, $r13)\n  r0.setNextName($r10)\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#setNextName(...1)",
        "body": "{\r\n    _nextName \u003d name;\r\n}"
      },
      {
        "name": "ToXmlGenerator#setNextIsAttribute(...1)",
        "body": "{\r\n    _nextIsAttribute \u003d isAttribute;\r\n}"
      },
      {
        "name": "ToXmlGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        // nothing to do here; no-operation\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r0._verifyValueWrite(\"start an array\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildArrayContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r6.writeStartArray(r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#streamWriteConstraints(...0)",
        "body": "{\r\n    return _streamWriteConstraints;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeEndArray",
    "signature": "void writeEndArray()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        // nothing to do here; no-operation\r\n    }\r\n    _writeContext \u003d _writeContext.getParent();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inArray()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d JsonWriteContext _writeContext\u003e\n  $r8 \u003d $r7.typeDesc()\n  $r9 \u003d dynInvoke makeConcatWithConstants($r8)\n  r0._reportError($r9)\n}",
      "B2 {\n  $r2 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r5 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r5.getEntryCount()\n  $r6.writeEndArray(r0, $i0)\n}",
      "B4 {\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $r4 \u003d $r3.getParent()\n  JsonWriteContext _writeContext\u003e \u003d $r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an object\");\r\n    _writeContext \u003d _writeContext.createChildObjectContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartObject(this);\r\n    } else {\r\n        _handleStartObject();\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r0._verifyValueWrite(\"start an object\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildObjectContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r6.writeStartObject(r0)\n  goto B3\n}",
      "B2 {\n  r0._handleStartObject()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#_handleStartObject(...0)",
        "body": "{\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    // Need to keep track of names to make Lists work correctly\r\n    _elementNameStack.addLast(_nextName);\r\n    try {\r\n        _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#streamWriteConstraints(...0)",
        "body": "{\r\n    return _streamWriteConstraints;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    _writeContext \u003d _writeContext.getParent();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // as per [Issue#45], need to suppress indentation if only attributes written:\r\n        int count \u003d _nextIsAttribute ? 0 : _writeContext.getEntryCount();\r\n        _cfgPrettyPrinter.writeEndObject(this, count);\r\n    } else {\r\n        _handleEndObject();\r\n    }\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r4 \u003d\u003d null) → B3 | else → B7",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inObject()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d JsonWriteContext _writeContext\u003e\n  $r8 \u003d $r7.typeDesc()\n  $r9 \u003d dynInvoke makeConcatWithConstants($r8)\n  r0._reportError($r9)\n}",
      "B2 {\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d $r2.getParent()\n  JsonWriteContext _writeContext\u003e \u003d $r3\n  $r4 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r4 \u003d\u003d null) goto B3 else B7\n}",
      "B3 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $i0 \u003d 0\n  goto B6\n}",
      "B5 {\n  $r5 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r5.getEntryCount()\n}",
      "B6 {\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r6.writeEndObject(r0, $i0)\n  goto B8\n}",
      "B7 {\n  r0._handleEndObject()\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_handleEndObject(...0)",
        "body": "{\r\n    // We may want to repeat same element, so:\r\n    if (_elementNameStack.isEmpty()) {\r\n        throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\r\n    }\r\n    _nextName \u003d _elementNameStack.removeLast();\r\n    try {\r\n        // note: since attributes don\u0027t nest, can only have one attribute active, so:\r\n        _nextIsAttribute \u003d false;\r\n        _xmlWriter.writeEndElement();\r\n        // [databind-xml#172]: possibly also need indentation\r\n        if (_elementNameStack.isEmpty() \u0026\u0026 (_xmlPrettyPrinter !\u003d null)) {\r\n            // ... but only if it is likely to succeed:\r\n            if (!_stax2Emulation) {\r\n                _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "_handleStartObject",
    "signature": "void _handleStartObject()",
    "visibility": "public",
    "body": "{\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    // Need to keep track of names to make Lists work correctly\r\n    _elementNameStack.addLast(_nextName);\r\n    try {\r\n        _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $r3 \u003d LinkedList _elementNameStack\u003e\n  $r2 \u003d QName _nextName\u003e\n  $r3.addLast($r2)\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4 \u003d QName _nextName\u003e\n  $r8 \u003d $r4.getNamespaceURI()\n  $r6 \u003d QName _nextName\u003e\n  $r7 \u003d $r6.getLocalPart()\n  $r5.writeStartElement($r8, $r7)\n  goto B4\n}",
      "B3 {\n  $r9 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r9, r0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "_handleEndObject",
    "signature": "void _handleEndObject()",
    "visibility": "public",
    "body": "{\r\n    // We may want to repeat same element, so:\r\n    if (_elementNameStack.isEmpty()) {\r\n        throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\r\n    }\r\n    _nextName \u003d _elementNameStack.removeLast();\r\n    try {\r\n        // note: since attributes don\u0027t nest, can only have one attribute active, so:\r\n        _nextIsAttribute \u003d false;\r\n        _xmlWriter.writeEndElement();\r\n        // [databind-xml#172]: possibly also need indentation\r\n        if (_elementNameStack.isEmpty() \u0026\u0026 (_xmlPrettyPrinter !\u003d null)) {\r\n            // ... but only if it is likely to succeed:\r\n            if (!_stax2Emulation) {\r\n                _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B6",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B6",
      "B4 : If($z2 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r1 \u003d LinkedList _elementNameStack\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d JsonGenerationException\n  new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", r0)\n  throw $r10\n}",
      "B2 {\n  $r2 \u003d LinkedList _elementNameStack\u003e\n  $r3 \u003d $r2.removeLast()\n  $r4 \u003d QName) $r3\n  QName _nextName\u003e \u003d $r4\n  ToXmlGenerator: boolean _nextIsAttribute\u003e \u003d 0\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5.writeEndElement()\n  $r6 \u003d LinkedList _elementNameStack\u003e\n  $z1 \u003d $r6.isEmpty()\n  if ($z1 \u003d\u003d false) goto B3 else B6\n}",
      "B3 {\n  $r7 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r7 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  $z2 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r9 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writePrologLinefeed($r8)\n}",
      "B6 {\n  goto B8\n}",
      "B7 {\n  $r11 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r11, r0)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeString",
    "signature": "void writeString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (text \u003d\u003d null) {\r\n        // [dataformat-xml#413]\r\n        writeNull();\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write String value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // must write attribute name and value with one call\r\n            _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // [dataformat-xml#56] Should figure out how to prevent indentation for end element\r\n            //   but for now, let\u0027s just make sure structure is correct\r\n            //if (_xmlPrettyPrinter !\u003d null) { ... }\r\n            if (_nextIsCData) {\r\n                _xmlWriter.writeCData(text);\r\n            } else {\r\n                _xmlWriter.writeCharacters(text);\r\n            }\r\n        } else if (_xmlPrettyPrinter !\u003d null) {\r\n            _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), text, _nextIsCData);\r\n        } else {\r\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n            if (_nextIsCData) {\r\n                _xmlWriter.writeCData(text);\r\n            } else {\r\n                _xmlWriter.writeCharacters(text);\r\n            }\r\n            _xmlWriter.writeEndElement();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 19,
    "edges": 24,
    "cc": 7,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B10",
      "B7 : If($z4 \u003d\u003d false) → B8 | else → B9",
      "B10 : If($r3 \u003d\u003d null) → B11 | else → B12",
      "B12 : If($z2 \u003d\u003d false) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.writeNull()\n  return\n}",
      "B2 {\n  r1._verifyValueWrite(\"write String value\")\n  $r2 \u003d QName _nextName\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r1.handleMissingName()\n}",
      "B4 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r21 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r20 \u003d QName _nextName\u003e\n  $r24 \u003d $r20.getNamespaceURI()\n  $r22 \u003d QName _nextName\u003e\n  $r23 \u003d $r22.getLocalPart()\n  $r21.writeAttribute($r24, $r23, r0)\n  goto B16\n}",
      "B6 {\n  $z1 \u003d r1.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  $z4 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  if ($z4 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r19 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r19.writeCData(r0)\n  goto B16\n}",
      "B9 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r18.writeCharacters(r0)\n  goto B16\n}",
      "B10 {\n  $r3 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r3 \u003d\u003d null) goto B11 else B12\n}",
      "B11 {\n  $r13 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r14 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r12 \u003d QName _nextName\u003e\n  $r17 \u003d $r12.getNamespaceURI()\n  $r15 \u003d QName _nextName\u003e\n  $r16 \u003d $r15.getLocalPart()\n  $z3 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  $r13.writeLeafElement($r14, $r17, $r16, r0, $z3)\n  goto B16\n}",
      "B12 {\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4 \u003d QName _nextName\u003e\n  $r8 \u003d $r4.getNamespaceURI()\n  $r6 \u003d QName _nextName\u003e\n  $r7 \u003d $r6.getLocalPart()\n  $r5.writeStartElement($r8, $r7)\n  $z2 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  if ($z2 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $r11 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11.writeCData(r0)\n  goto B15\n}",
      "B14 {\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeCharacters(r0)\n}",
      "B15 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeEndElement()\n}",
      "B16 {\n  goto B18\n}",
      "B17 {\n  $r25 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r25, r1)\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B16",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B16",
      "B9 --\u003e B16",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNull(...0)",
        "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeString",
    "signature": "void writeString(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"write String value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            if (_nextIsCData) {\r\n                _xmlWriter.writeCData(text, offset, len);\r\n            } else {\r\n                _xmlWriter.writeCharacters(text, offset, len);\r\n            }\r\n        } else if (_xmlPrettyPrinter !\u003d null) {\r\n            _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), text, offset, len, _nextIsCData);\r\n        } else {\r\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n            if (_nextIsCData) {\r\n                _xmlWriter.writeCData(text, offset, len);\r\n            } else {\r\n                _xmlWriter.writeCharacters(text, offset, len);\r\n            }\r\n            _xmlWriter.writeEndElement();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 17,
    "edges": 22,
    "cc": 7,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B8",
      "B5 : If($z4 \u003d\u003d false) → B6 | else → B7",
      "B8 : If($r2 \u003d\u003d null) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r8 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write String value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r21 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r20 \u003d QName _nextName\u003e\n  $r25 \u003d $r20.getNamespaceURI()\n  $r22 \u003d QName _nextName\u003e\n  $r24 \u003d $r22.getLocalPart()\n  $r23 \u003d String\n  new String(r8, i0, i1)\n  $r21.writeAttribute($r25, $r24, $r23)\n  goto B14\n}",
      "B4 {\n  $z1 \u003d r0.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $z4 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  if ($z4 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r19 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r19.writeCData(r8, i0, i1)\n  goto B14\n}",
      "B7 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r18.writeCharacters(r8, i0, i1)\n  goto B14\n}",
      "B8 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r13 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r14 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r12 \u003d QName _nextName\u003e\n  $r17 \u003d $r12.getNamespaceURI()\n  $r15 \u003d QName _nextName\u003e\n  $r16 \u003d $r15.getLocalPart()\n  $z3 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  $r13.writeLeafElement($r14, $r17, $r16, r8, i0, i1, $z3)\n  goto B14\n}",
      "B10 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $z2 \u003d ToXmlGenerator: boolean _nextIsCData\u003e\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r11 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11.writeCData(r8, i0, i1)\n  goto B13\n}",
      "B12 {\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeCharacters(r8, i0, i1)\n}",
      "B13 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeEndElement()\n}",
      "B14 {\n  goto B16\n}",
      "B15 {\n  $r26 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r26, r0)\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B14",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B14",
      "B7 --\u003e B14",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRawValue\");\r\n    }\r\n    try {\r\n        _verifyValueWrite(\"write raw value\");\r\n        if (_nextName \u003d\u003d null) {\r\n            handleMissingName();\r\n        }\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeRaw(text);\r\n        } else {\r\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n            _xmlWriter.writeRaw(text);\r\n            _xmlWriter.writeEndElement();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRawValue\")\n}",
      "B2 {\n  r0._verifyValueWrite(\"write raw value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.handleMissingName()\n}",
      "B4 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11 \u003d QName _nextName\u003e\n  $r15 \u003d $r11.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r12.writeAttribute($r15, $r14, r7)\n  goto B9\n}",
      "B6 {\n  $z2 \u003d r0.checkNextIsUnwrapped()\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeRaw(r7)\n  goto B9\n}",
      "B8 {\n  $r3 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2 \u003d QName _nextName\u003e\n  $r6 \u003d $r2.getNamespaceURI()\n  $r4 \u003d QName _nextName\u003e\n  $r5 \u003d $r4.getLocalPart()\n  $r3.writeStartElement($r6, $r5)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeRaw(r7)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r16 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r16, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRawValue\");\r\n    }\r\n    try {\r\n        _verifyValueWrite(\"write raw value\");\r\n        if (_nextName \u003d\u003d null) {\r\n            handleMissingName();\r\n        }\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text.substring(offset, offset + len));\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeRaw(text, offset, len);\r\n        } else {\r\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n            _xmlWriter.writeRaw(text, offset, len);\r\n            _xmlWriter.writeEndElement();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRawValue\")\n}",
      "B2 {\n  r0._verifyValueWrite(\"write raw value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.handleMissingName()\n}",
      "B4 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11 \u003d QName _nextName\u003e\n  $r16 \u003d $r11.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r15 \u003d $r13.getLocalPart()\n  $i2 \u003d i0 + i1\n  $r14 \u003d r7.substring(i0, $i2)\n  $r12.writeAttribute($r16, $r15, $r14)\n  goto B9\n}",
      "B6 {\n  $z2 \u003d r0.checkNextIsUnwrapped()\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeRaw(r7, i0, i1)\n  goto B9\n}",
      "B8 {\n  $r3 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2 \u003d QName _nextName\u003e\n  $r6 \u003d $r2.getNamespaceURI()\n  $r4 \u003d QName _nextName\u003e\n  $r5 \u003d $r4.getLocalPart()\n  $r3.writeStartElement($r6, $r5)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeRaw(r7, i0, i1)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r17 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r17, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRawValue\");\r\n    }\r\n    _verifyValueWrite(\"write raw value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeRaw(text, offset, len);\r\n        } else {\r\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n            _xmlWriter.writeRaw(text, offset, len);\r\n            _xmlWriter.writeEndElement();\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r7 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRawValue\")\n}",
      "B2 {\n  r0._verifyValueWrite(\"write raw value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.handleMissingName()\n}",
      "B4 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11 \u003d QName _nextName\u003e\n  $r16 \u003d $r11.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r15 \u003d $r13.getLocalPart()\n  $r14 \u003d String\n  new String(r7, i0, i1)\n  $r12.writeAttribute($r16, $r15, $r14)\n  goto B9\n}",
      "B6 {\n  $z2 \u003d r0.checkNextIsUnwrapped()\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeRaw(r7, i0, i1)\n  goto B9\n}",
      "B8 {\n  $r3 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2 \u003d QName _nextName\u003e\n  $r6 \u003d $r2.getNamespaceURI()\n  $r4 \u003d QName _nextName\u003e\n  $r5 \u003d $r4.getLocalPart()\n  $r3.writeStartElement($r6, $r5)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeRaw(r7, i0, i1)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r17 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r17, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRaw\");\r\n    }\r\n    try {\r\n        _xmlWriter.writeRaw(text);\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRaw\")\n}",
      "B2 {\n  $r2 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2.writeRaw(r1)\n  goto B4\n}",
      "B3 {\n  $r3 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r3, r0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRaw\");\r\n    }\r\n    try {\r\n        _xmlWriter.writeRaw(text, offset, len);\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRaw\")\n}",
      "B2 {\n  $r2 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2.writeRaw(r1, i0, i1)\n  goto B4\n}",
      "B3 {\n  $r3 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r3, r0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#39]\r\n    if (_stax2Emulation) {\r\n        _reportUnimplementedStax2(\"writeRaw\");\r\n    }\r\n    try {\r\n        _xmlWriter.writeRaw(text, offset, len);\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d ToXmlGenerator: boolean _stax2Emulation\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._reportUnimplementedStax2(\"writeRaw\")\n}",
      "B2 {\n  $r2 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2.writeRaw(r1, i0, i1)\n  goto B4\n}",
      "B3 {\n  $r3 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r3, r0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_reportUnimplementedStax2(...1)",
        "body": "{\r\n    throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \" + _originalXmlWriter.getClass().getName() + \") does not implement Stax2 API natively and is missing method \u0027\" + missingMethod + \"\u0027: this breaks functionality such as indentation that relies on it. \" + \"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\", this);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeBinary",
    "signature": "void writeBinary(com.fasterxml.jackson.core.Base64Variant,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (data \u003d\u003d null) {\r\n        writeNull();\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write Binary value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    final org.codehaus.stax2.typed.Base64Variant stax2base64v \u003d StaxUtil.toStax2Base64Variant(b64variant);\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // Stax2 API only has \u0027full buffer\u0027 write method:\r\n            byte[] fullBuffer \u003d toFullBuffer(data, offset, len);\r\n            _xmlWriter.writeBinaryAttribute(stax2base64v, \"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            _xmlWriter.writeBinary(stax2base64v, data, offset, len);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), stax2base64v, data, offset, len);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeBinary(stax2base64v, data, offset, len);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 14,
    "edges": 17,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($r4 \u003d\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  Base64Variant\n  r0 :\u003d @parameter1: byte[]\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.writeNull()\n  return\n}",
      "B2 {\n  r1._verifyValueWrite(\"write Binary value\")\n  $r2 \u003d QName _nextName\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r1.handleMissingName()\n}",
      "B4 {\n  $r24 \u003d StaxUtil.toStax2Base64Variant(r3)\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r26 \u003d r1.toFullBuffer(r0, i0, i1)\n  $r20 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r19 \u003d QName _nextName\u003e\n  $r23 \u003d $r19.getNamespaceURI()\n  $r21 \u003d QName _nextName\u003e\n  $r22 \u003d $r21.getLocalPart()\n  $r20.writeBinaryAttribute($r24, \"\", $r23, $r22, r26)\n  goto B11\n}",
      "B6 {\n  $z1 \u003d r1.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r18.writeBinary($r24, r0, i0, i1)\n  goto B11\n}",
      "B8 {\n  $r4 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r4 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r13 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r14 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r12 \u003d QName _nextName\u003e\n  $r17 \u003d $r12.getNamespaceURI()\n  $r15 \u003d QName _nextName\u003e\n  $r16 \u003d $r15.getLocalPart()\n  $r13.writeLeafElement($r14, $r17, $r16, $r24, r0, i0, i1)\n  goto B11\n}",
      "B10 {\n  $r6 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5 \u003d QName _nextName\u003e\n  $r9 \u003d $r5.getNamespaceURI()\n  $r7 \u003d QName _nextName\u003e\n  $r8 \u003d $r7.getLocalPart()\n  $r6.writeStartElement($r9, $r8)\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeBinary($r24, r0, i0, i1)\n  $r11 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11.writeEndElement()\n}",
      "B11 {\n  goto B13\n}",
      "B12 {\n  $r25 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r25, r1)\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#toFullBuffer(...3)",
        "body": "{\r\n    // might already be ok:\r\n    if (offset \u003d\u003d 0 \u0026\u0026 len \u003d\u003d data.length) {\r\n        return data;\r\n    }\r\n    byte[] result \u003d new byte[len];\r\n    if (len \u003e 0) {\r\n        System.arraycopy(data, offset, result, 0, len);\r\n    }\r\n    return result;\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNull(...0)",
        "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeBinary",
    "signature": "int writeBinary(com.fasterxml.jackson.core.Base64Variant,java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    if (data \u003d\u003d null) {\r\n        writeNull();\r\n        return 0;\r\n    }\r\n    _verifyValueWrite(\"write Binary value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    final org.codehaus.stax2.typed.Base64Variant stax2base64v \u003d StaxUtil.toStax2Base64Variant(b64variant);\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // Stax2 API only has \u0027full buffer\u0027 write method:\r\n            byte[] fullBuffer \u003d toFullBuffer(data, dataLength);\r\n            _xmlWriter.writeBinaryAttribute(stax2base64v, \"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            writeStreamAsBinary(stax2base64v, data, dataLength);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), stax2base64v, toFullBuffer(data, dataLength), 0, dataLength);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                writeStreamAsBinary(stax2base64v, data, dataLength);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n    return dataLength;\r\n}",
    "nodes": 14,
    "edges": 17,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($r4 \u003d\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  Base64Variant\n  InputStream\n  i0 :\u003d @parameter2: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.writeNull()\n  return\n}",
      "B2 {\n  r1._verifyValueWrite(\"write Binary value\")\n  $r2 \u003d QName _nextName\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r1.handleMissingName()\n}",
      "B4 {\n  $r23 \u003d StaxUtil.toStax2Base64Variant(r3)\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r25 \u003d r1.toFullBuffer(r0, i0)\n  $r19 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r18 \u003d QName _nextName\u003e\n  $r22 \u003d $r18.getNamespaceURI()\n  $r20 \u003d QName _nextName\u003e\n  $r21 \u003d $r20.getLocalPart()\n  $r19.writeBinaryAttribute($r23, \"\", $r22, $r21, r25)\n  goto B11\n}",
      "B6 {\n  $z1 \u003d r1.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  r1.writeStreamAsBinary($r23, r0, i0)\n  goto B11\n}",
      "B8 {\n  $r4 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r4 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r12 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r13 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11 \u003d QName _nextName\u003e\n  $r17 \u003d $r11.getNamespaceURI()\n  $r14 \u003d QName _nextName\u003e\n  $r16 \u003d $r14.getLocalPart()\n  $r15 \u003d r1.toFullBuffer(r0, i0)\n  $r12.writeLeafElement($r13, $r17, $r16, $r23, $r15, 0, i0)\n  goto B11\n}",
      "B10 {\n  $r6 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5 \u003d QName _nextName\u003e\n  $r9 \u003d $r5.getNamespaceURI()\n  $r7 \u003d QName _nextName\u003e\n  $r8 \u003d $r7.getLocalPart()\n  $r6.writeStartElement($r9, $r8)\n  r1.writeStreamAsBinary($r23, r0, i0)\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeEndElement()\n}",
      "B11 {\n  goto B13\n}",
      "B12 {\n  $r24 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r24, r1)\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#toFullBuffer(...2)",
        "body": "{\r\n    byte[] result \u003d new byte[len];\r\n    int offset \u003d 0;\r\n    for (; offset \u003c len; ) {\r\n        int count \u003d data.read(result, offset, len - offset);\r\n        if (count \u003c 0) {\r\n            _reportError(\"Too few bytes available: missing \" + (len - offset) + \" bytes (out of \" + len + \")\");\r\n        }\r\n        offset +\u003d count;\r\n    }\r\n    return result;\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNull(...0)",
        "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeStreamAsBinary(...3)",
        "body": "{\r\n    // base64 encodes up to 3 bytes into a 4 bytes string\r\n    byte[] tmp \u003d new byte[3];\r\n    int offset \u003d 0;\r\n    int read;\r\n    while ((read \u003d data.read(tmp, offset, Math.min(3 - offset, len))) !\u003d -1) {\r\n        offset +\u003d read;\r\n        len -\u003d read;\r\n        if (offset \u003d\u003d 3) {\r\n            offset \u003d 0;\r\n            _xmlWriter.writeBinary(stax2base64v, tmp, 0, 3);\r\n        }\r\n        if (len \u003d\u003d 0) {\r\n            break;\r\n        }\r\n    }\r\n    // we still have \u003c 3 bytes in the buffer\r\n    if (offset \u003e 0) {\r\n        _xmlWriter.writeBinary(stax2base64v, tmp, 0, offset);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeBoolean",
    "signature": "void writeBoolean(boolean)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"write boolean value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            _xmlWriter.writeBoolean(value);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeBoolean(value);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($r2 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  z2 :\u003d @parameter0: boolean\n  r0._verifyValueWrite(\"write boolean value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17 \u003d QName _nextName\u003e\n  $r21 \u003d $r17.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r18.writeBooleanAttribute(null, $r21, $r20, z2)\n  goto B9\n}",
      "B4 {\n  $z1 \u003d r0.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16.writeBoolean(z2)\n  goto B9\n}",
      "B6 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d QName _nextName\u003e\n  $r15 \u003d $r10.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r11.writeLeafElement($r12, $r15, $r14, z2)\n  goto B9\n}",
      "B8 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeBoolean(z2)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r22 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r22, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNull",
    "signature": "void writeNull()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 17,
    "edges": 23,
    "cc": 8,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($r3 \u003d\u003d null) → B7 | else → B11",
      "B7 : If(z3 \u003d\u003d false) → B8 | else → B10",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B10",
      "B11 : If(z3 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  r0._verifyValueWrite(\"write null value\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  goto B14\n}",
      "B4 {\n  $z1 \u003d r0.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  goto B14\n}",
      "B6 {\n  $r2 \u003d ToXmlGenerator$Feature WRITE_NULLS_AS_XSI_NIL\u003e\n  z3 \u003d r0.isEnabled($r2)\n  $r3 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r3 \u003d\u003d null) goto B7 else B11\n}",
      "B7 {\n  if (z3 \u003d\u003d false) goto B8 else B10\n}",
      "B8 {\n  $r22 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $z2 \u003d DefaultXmlPrettyPrinter\n  if ($z2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r23 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r29 \u003d DefaultXmlPrettyPrinter) $r23\n  $r25 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r24 \u003d QName _nextName\u003e\n  $r28 \u003d $r24.getNamespaceURI()\n  $r26 \u003d QName _nextName\u003e\n  $r27 \u003d $r26.getLocalPart()\n  $r29.writeLeafXsiNilElement($r25, $r28, $r27)\n  goto B14\n}",
      "B10 {\n  $r17 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16 \u003d QName _nextName\u003e\n  $r21 \u003d $r16.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r17.writeLeafNullElement($r18, $r21, $r20)\n  goto B14\n}",
      "B11 {\n  if (z3 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9 \u003d QName _nextName\u003e\n  $r13 \u003d $r9.getNamespaceURI()\n  $r11 \u003d QName _nextName\u003e\n  $r12 \u003d $r11.getLocalPart()\n  $r10.writeStartElement($r13, $r12)\n  $r14 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r14.writeAttribute(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\", \"nil\", \"true\")\n  $r15 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r15.writeEndElement()\n  goto B14\n}",
      "B13 {\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4 \u003d QName _nextName\u003e\n  $r8 \u003d $r4.getNamespaceURI()\n  $r6 \u003d QName _nextName\u003e\n  $r7 \u003d $r6.getLocalPart()\n  $r5.writeEmptyElement($r8, $r7)\n}",
      "B14 {\n  goto B16\n}",
      "B15 {\n  $r30 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r30, r0)\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B14",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B14",
      "B6 --\u003e B7",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            _xmlWriter.writeInt(i);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeInt(i);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($r2 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  i0 :\u003d @parameter0: int\n  r0._verifyValueWrite(\"write number\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17 \u003d QName _nextName\u003e\n  $r21 \u003d $r17.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r18.writeIntAttribute(null, $r21, $r20, i0)\n  goto B9\n}",
      "B4 {\n  $z1 \u003d r0.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16.writeInt(i0)\n  goto B9\n}",
      "B6 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d QName _nextName\u003e\n  $r15 \u003d $r10.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r11.writeLeafElement($r12, $r15, $r14, i0)\n  goto B9\n}",
      "B8 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeInt(i0)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r22 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r22, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(long)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeLong(l);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeLong(l);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($r2 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  l0 :\u003d @parameter0: long\n  r0._verifyValueWrite(\"write number\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.handleMissingName()\n}",
      "B2 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17 \u003d QName _nextName\u003e\n  $r21 \u003d $r17.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r18.writeLongAttribute(null, $r21, $r20, l0)\n  goto B9\n}",
      "B4 {\n  $z1 \u003d r0.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16.writeLong(l0)\n  goto B9\n}",
      "B6 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d QName _nextName\u003e\n  $r15 \u003d $r10.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r11.writeLeafElement($r12, $r15, $r14, l0)\n  goto B9\n}",
      "B8 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeLong(l0)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r22 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r22, r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(double)",
    "visibility": "public",
    "body": "{\r\n    if (Double.isInfinite(d) \u0026\u0026 isEnabled(Feature.WRITE_XML_SCHEMA_CONFORMING_FLOATS)) {\r\n        writeNumber(d \u003e 0d ? \"INF\" : \"-INF\");\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeDouble(d);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeDouble(d);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 18,
    "edges": 23,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B6",
      "B1 : If($z3 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($i1 \u003c\u003d 0) → B3 | else → B4",
      "B6 : If($r1 !\u003d null) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($r2 \u003d\u003d null) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  d0 :\u003d @parameter0: double\n  $z0 \u003d Double.isInfinite(d0)\n  if ($z0 \u003d\u003d false) goto B1 else B6\n}",
      "B1 {\n  $r22 \u003d ToXmlGenerator$Feature WRITE_XML_SCHEMA_CONFORMING_FLOATS\u003e\n  $z3 \u003d r0.isEnabled($r22)\n  if ($z3 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $b0 \u003d 0\n  $i1 \u003d (int) $b0\n  if ($i1 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r24 \u003d \"INF\"\n  goto B5\n}",
      "B4 {\n  $r24 \u003d \"-INF\"\n}",
      "B5 {\n  r0.writeNumber($r24)\n  return\n}",
      "B6 {\n  r0._verifyValueWrite(\"write number\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  r0.handleMissingName()\n}",
      "B8 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17 \u003d QName _nextName\u003e\n  $r21 \u003d $r17.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r18.writeDoubleAttribute(null, $r21, $r20, d0)\n  goto B15\n}",
      "B10 {\n  $z2 \u003d r0.checkNextIsUnwrapped()\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16.writeDouble(d0)\n  goto B15\n}",
      "B12 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $r11 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d QName _nextName\u003e\n  $r15 \u003d $r10.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r11.writeLeafElement($r12, $r15, $r14, d0)\n  goto B15\n}",
      "B14 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeDouble(d0)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B15 {\n  goto B17\n}",
      "B16 {\n  $r23 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r23, r0)\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNumber(...1)",
        "body": "{\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            _xmlWriter.writeInt(i);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeInt(i);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(float)",
    "visibility": "public",
    "body": "{\r\n    if (Float.isInfinite(f) \u0026\u0026 isEnabled(Feature.WRITE_XML_SCHEMA_CONFORMING_FLOATS)) {\r\n        writeNumber(f \u003e 0f ? \"INF\" : \"-INF\");\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeFloat(f);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeFloat(f);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 18,
    "edges": 23,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B6",
      "B1 : If($z3 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($i1 \u003c\u003d 0) → B3 | else → B4",
      "B6 : If($r1 !\u003d null) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($r2 \u003d\u003d null) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  f0 :\u003d @parameter0: float\n  $z0 \u003d Float.isInfinite(f0)\n  if ($z0 \u003d\u003d false) goto B1 else B6\n}",
      "B1 {\n  $r22 \u003d ToXmlGenerator$Feature WRITE_XML_SCHEMA_CONFORMING_FLOATS\u003e\n  $z3 \u003d r0.isEnabled($r22)\n  if ($z3 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $b0 \u003d 0F\n  $i1 \u003d (int) $b0\n  if ($i1 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r24 \u003d \"INF\"\n  goto B5\n}",
      "B4 {\n  $r24 \u003d \"-INF\"\n}",
      "B5 {\n  r0.writeNumber($r24)\n  return\n}",
      "B6 {\n  r0._verifyValueWrite(\"write number\")\n  $r1 \u003d QName _nextName\u003e\n  if ($r1 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  r0.handleMissingName()\n}",
      "B8 {\n  $z1 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r18 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17 \u003d QName _nextName\u003e\n  $r21 \u003d $r17.getNamespaceURI()\n  $r19 \u003d QName _nextName\u003e\n  $r20 \u003d $r19.getLocalPart()\n  $r18.writeFloatAttribute(null, $r21, $r20, f0)\n  goto B15\n}",
      "B10 {\n  $z2 \u003d r0.checkNextIsUnwrapped()\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r16.writeFloat(f0)\n  goto B15\n}",
      "B12 {\n  $r2 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $r11 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10 \u003d QName _nextName\u003e\n  $r15 \u003d $r10.getNamespaceURI()\n  $r13 \u003d QName _nextName\u003e\n  $r14 \u003d $r13.getLocalPart()\n  $r11.writeLeafElement($r12, $r15, $r14, f0)\n  goto B15\n}",
      "B14 {\n  $r4 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3 \u003d QName _nextName\u003e\n  $r7 \u003d $r3.getNamespaceURI()\n  $r5 \u003d QName _nextName\u003e\n  $r6 \u003d $r5.getLocalPart()\n  $r4.writeStartElement($r7, $r6)\n  $r8 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r8.writeFloat(f0)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeEndElement()\n}",
      "B15 {\n  goto B17\n}",
      "B16 {\n  $r23 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r23, r0)\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNumber(...1)",
        "body": "{\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // should we consider pretty-printing or not?\r\n            _xmlWriter.writeInt(i);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeInt(i);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigDecimal)",
    "visibility": "public",
    "body": "{\r\n    if (dec \u003d\u003d null) {\r\n        writeNull();\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    boolean usePlain \u003d isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            if (usePlain) {\r\n                _xmlWriter.writeAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec.toPlainString());\r\n            } else {\r\n                _xmlWriter.writeDecimalAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\r\n            }\r\n        } else if (checkNextIsUnwrapped()) {\r\n            if (usePlain) {\r\n                _xmlWriter.writeCharacters(dec.toPlainString());\r\n            } else {\r\n                _xmlWriter.writeDecimal(dec);\r\n            }\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                if (usePlain) {\r\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec.toPlainString(), false);\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\r\n                }\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                if (usePlain) {\r\n                    _xmlWriter.writeCharacters(dec.toPlainString());\r\n                } else {\r\n                    _xmlWriter.writeDecimal(dec);\r\n                }\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 23,
    "edges": 30,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B8",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B12",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11",
      "B12 : If($r4 \u003d\u003d null) → B13 | else → B16",
      "B13 : If($z2 \u003d\u003d false) → B14 | else → B15",
      "B16 : If($z2 \u003d\u003d false) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  BigDecimal\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.writeNull()\n  return\n}",
      "B2 {\n  r1._verifyValueWrite(\"write number\")\n  $r2 \u003d QName _nextName\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r1.handleMissingName()\n}",
      "B4 {\n  $r3 \u003d JsonGenerator$Feature WRITE_BIGDECIMAL_AS_PLAIN\u003e\n  $z2 \u003d r1.isEnabled($r3)\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r36 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r35 \u003d QName _nextName\u003e\n  $r40 \u003d $r35.getNamespaceURI()\n  $r37 \u003d QName _nextName\u003e\n  $r39 \u003d $r37.getLocalPart()\n  $r38 \u003d r0.toPlainString()\n  $r36.writeAttribute(\"\", $r40, $r39, $r38)\n  goto B20\n}",
      "B7 {\n  $r31 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r30 \u003d QName _nextName\u003e\n  $r34 \u003d $r30.getNamespaceURI()\n  $r32 \u003d QName _nextName\u003e\n  $r33 \u003d $r32.getLocalPart()\n  $r31.writeDecimalAttribute(\"\", $r34, $r33, r0)\n  goto B20\n}",
      "B8 {\n  $z1 \u003d r1.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r28 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r29 \u003d r0.toPlainString()\n  $r28.writeCharacters($r29)\n  goto B20\n}",
      "B11 {\n  $r27 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r27.writeDecimal(r0)\n  goto B20\n}",
      "B12 {\n  $r4 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r4 \u003d\u003d null) goto B13 else B16\n}",
      "B13 {\n  if ($z2 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r21 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r22 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r20 \u003d QName _nextName\u003e\n  $r26 \u003d $r20.getNamespaceURI()\n  $r23 \u003d QName _nextName\u003e\n  $r25 \u003d $r23.getLocalPart()\n  $r24 \u003d r0.toPlainString()\n  $r21.writeLeafElement($r22, $r26, $r25, $r24, 0)\n  goto B20\n}",
      "B15 {\n  $r15 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r16 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r14 \u003d QName _nextName\u003e\n  $r19 \u003d $r14.getNamespaceURI()\n  $r17 \u003d QName _nextName\u003e\n  $r18 \u003d $r17.getLocalPart()\n  $r15.writeLeafElement($r16, $r19, $r18, r0)\n  goto B20\n}",
      "B16 {\n  $r6 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5 \u003d QName _nextName\u003e\n  $r9 \u003d $r5.getNamespaceURI()\n  $r7 \u003d QName _nextName\u003e\n  $r8 \u003d $r7.getLocalPart()\n  $r6.writeStartElement($r9, $r8)\n  if ($z2 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r12 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r13 \u003d r0.toPlainString()\n  $r12.writeCharacters($r13)\n  goto B19\n}",
      "B18 {\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeDecimal(r0)\n}",
      "B19 {\n  $r11 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11.writeEndElement()\n}",
      "B20 {\n  goto B22\n}",
      "B21 {\n  $r41 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r41, r1)\n}",
      "B22 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B20",
      "B7 --\u003e B20",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B20",
      "B11 --\u003e B20",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B20",
      "B15 --\u003e B20",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNull(...0)",
        "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigInteger)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        writeNull();\r\n        return;\r\n    }\r\n    _verifyValueWrite(\"write number\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            _xmlWriter.writeIntegerAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\r\n        } else if (checkNextIsUnwrapped()) {\r\n            _xmlWriter.writeInteger(value);\r\n        } else {\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\r\n            } else {\r\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                _xmlWriter.writeInteger(value);\r\n                _xmlWriter.writeEndElement();\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}",
    "nodes": 14,
    "edges": 17,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($r3 \u003d\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  BigInteger\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.writeNull()\n  return\n}",
      "B2 {\n  r1._verifyValueWrite(\"write number\")\n  $r2 \u003d QName _nextName\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r1.handleMissingName()\n}",
      "B4 {\n  $z0 \u003d ToXmlGenerator: boolean _nextIsAttribute\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r19 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r18 \u003d QName _nextName\u003e\n  $r22 \u003d $r18.getNamespaceURI()\n  $r20 \u003d QName _nextName\u003e\n  $r21 \u003d $r20.getLocalPart()\n  $r19.writeIntegerAttribute(\"\", $r22, $r21, r0)\n  goto B11\n}",
      "B6 {\n  $z1 \u003d r1.checkNextIsUnwrapped()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r17 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r17.writeInteger(r0)\n  goto B11\n}",
      "B8 {\n  $r3 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  if ($r3 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r12 \u003d XmlPrettyPrinter _xmlPrettyPrinter\u003e\n  $r13 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r11 \u003d QName _nextName\u003e\n  $r16 \u003d $r11.getNamespaceURI()\n  $r14 \u003d QName _nextName\u003e\n  $r15 \u003d $r14.getLocalPart()\n  $r12.writeLeafElement($r13, $r16, $r15, r0)\n  goto B11\n}",
      "B10 {\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r4 \u003d QName _nextName\u003e\n  $r8 \u003d $r4.getNamespaceURI()\n  $r6 \u003d QName _nextName\u003e\n  $r7 \u003d $r6.getLocalPart()\n  $r5.writeStartElement($r8, $r7)\n  $r9 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r9.writeInteger(r0)\n  $r10 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r10.writeEndElement()\n}",
      "B11 {\n  goto B13\n}",
      "B12 {\n  $r23 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r23, r1)\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeValue();\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_NAME) {\r\n        _reportError(\"Can not \" + typeMsg + \", expecting field name\");\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#handleMissingName(...0)",
        "body": "{\r\n    throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\r\n}"
      },
      {
        "name": "ToXmlGenerator#checkNextIsUnwrapped(...0)",
        "body": "{\r\n    if (_nextIsUnwrapped) {\r\n        _nextIsUnwrapped \u003d false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeNull(...0)",
        "body": "{\r\n    _verifyValueWrite(\"write null value\");\r\n    if (_nextName \u003d\u003d null) {\r\n        handleMissingName();\r\n    }\r\n    try {\r\n        if (_nextIsAttribute) {\r\n            // With attributes, best just leave it out, right? (since there\u0027s no way\r\n            // to use \u0027xsi:nil\u0027)\r\n        } else if (checkNextIsUnwrapped()) {\r\n            // as with above, best left unwritten?\r\n        } else {\r\n            final boolean asXsiNil \u003d isEnabled(Feature.WRITE_NULLS_AS_XSI_NIL);\r\n            if (_xmlPrettyPrinter !\u003d null) {\r\n                // 12-Nov-2020, tatu: Not clean, due to backwards-compat challenges..\r\n                //    but has to do\r\n                if (asXsiNil \u0026\u0026 (_xmlPrettyPrinter instanceof DefaultXmlPrettyPrinter)) {\r\n                    ((DefaultXmlPrettyPrinter) _xmlPrettyPrinter).writeLeafXsiNilElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                } else {\r\n                    _xmlPrettyPrinter.writeLeafNullElement(_xmlWriter, _nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            } else {\r\n                if (asXsiNil) {\r\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                    _xmlWriter.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n                    _xmlWriter.writeEndElement();\r\n                } else {\r\n                    _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\r\n                }\r\n            }\r\n        }\r\n    } catch (XMLStreamException e) {\r\n        StaxUtil.throwAsGenerationException(e, this);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\r\n        try {\r\n            _xmlWriter.flush();\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, this);\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $r1 \u003d JsonGenerator$Feature FLUSH_PASSED_TO_STREAM\u003e\n  $z0 \u003d r0.isEnabled($r1)\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r2.flush()\n  goto B3\n}",
      "B2 {\n  $r3 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r3, r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!isClosed()) {\r\n        // First: let\u0027s see that we still have buffers...\r\n        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\r\n            try {\r\n                while (true) {\r\n                    /* 28-May-2016, tatu: To work around incompatibility introduced by\r\n                         *     `jackson-core` 2.8 where return type of `getOutputContext()`\r\n                         *     changed, let\u0027s do direct access here.\r\n                         */\r\n                    //                    JsonStreamContext ctxt \u003d getOutputContext();\r\n                    JsonStreamContext ctxt \u003d _writeContext;\r\n                    if (ctxt.inArray()) {\r\n                        writeEndArray();\r\n                    } else if (ctxt.inObject()) {\r\n                        writeEndObject();\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (ArrayIndexOutOfBoundsException e) {\r\n                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn\u0027t do array checks, so we get\r\n                     *   hit by this as a collateral problem in some cases. Yuck.\r\n                     */\r\n                throw new JsonGenerationException(e, this);\r\n            }\r\n        }\r\n        try {\r\n            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\r\n                _xmlWriter.closeCompletely();\r\n            } else {\r\n                _xmlWriter.close();\r\n            }\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, this);\r\n        }\r\n        super.close();\r\n    }\r\n}",
    "nodes": 17,
    "edges": 21,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B16",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B9",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z5 \u003d\u003d false) → B5 | else → B7",
      "B9 : If($z2 !\u003d 0) → B10 | else → B11",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ToXmlGenerator\n  $z0 \u003d r0.isClosed()\n  if ($z0 !\u003d 0) goto B1 else B16\n}",
      "B1 {\n  $r1 \u003d JsonGenerator$Feature AUTO_CLOSE_JSON_CONTENT\u003e\n  $z1 \u003d r0.isEnabled($r1)\n  if ($z1 \u003d\u003d false) goto B2 else B9\n}",
      "B2 {\n  $r6 \u003d JsonWriteContext _writeContext\u003e\n  $z4 \u003d $r6.inArray()\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0.writeEndArray()\n  goto B6\n}",
      "B4 {\n  $z5 \u003d $r6.inObject()\n  if ($z5 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  r0.writeEndObject()\n}",
      "B6 {\n  goto B2\n}",
      "B7 {\n  goto B9\n}",
      "B8 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d JsonGenerationException\n  new JsonGenerationException($r8, r0)\n  throw $r9\n}",
      "B9 {\n  $r2 \u003d IOContext _ioContext\u003e\n  $z2 \u003d $r2.isResourceManaged()\n  if ($z2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $r4 \u003d JsonGenerator$Feature AUTO_CLOSE_TARGET\u003e\n  $z3 \u003d r0.isEnabled($r4)\n  if ($z3 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r3 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r3.closeCompletely()\n  goto B13\n}",
      "B12 {\n  $r5 \u003d XMLStreamWriter2 _xmlWriter\u003e\n  $r5.close()\n}",
      "B13 {\n  goto B15\n}",
      "B14 {\n  $r7 :\u003d @caughtexception\n  StaxUtil.throwAsGenerationException($r7, r0)\n}",
      "B15 {\n  r0.close()\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B16",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ToXmlGenerator#isEnabled(...1)",
        "body": "{\r\n    return (_formatFeatures \u0026 f.getMask()) !\u003d 0;\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeEndArray(...0)",
        "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        // nothing to do here; no-operation\r\n    }\r\n    _writeContext \u003d _writeContext.getParent();\r\n}"
      },
      {
        "name": "ToXmlGenerator#writeEndObject(...0)",
        "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    _writeContext \u003d _writeContext.getParent();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // as per [Issue#45], need to suppress indentation if only attributes written:\r\n        int count \u003d _nextIsAttribute ? 0 : _writeContext.getEntryCount();\r\n        _cfgPrettyPrinter.writeEndObject(this, count);\r\n    } else {\r\n        _handleEndObject();\r\n    }\r\n}"
      },
      {
        "name": "ToXmlGenerator#isClosed(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.UnwrappingXmlBeanSerializer",
    "methodName": "serialize",
    "signature": "void serialize(java.lang.Object,com.fasterxml.jackson.core.JsonGenerator,com.fasterxml.jackson.databind.SerializerProvider)",
    "visibility": "public",
    "body": "{\r\n    if (_objectIdWriter !\u003d null) {\r\n        _serializeWithObjectId(bean, jgen, provider, false);\r\n        return;\r\n    }\r\n    if (_propertyFilterId !\u003d null) {\r\n        serializeFieldsFiltered(bean, jgen, provider);\r\n    } else {\r\n        serializeFields(bean, jgen, provider);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UnwrappingXmlBeanSerializer\n  Object\n  JsonGenerator\n  SerializerProvider\n  $r1 \u003d ObjectIdWriter _objectIdWriter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._serializeWithObjectId(r3, r4, r5, 0)\n  return\n}",
      "B2 {\n  $r2 \u003d Object _propertyFilterId\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.serializeFieldsFiltered(r3, r4, r5)\n  goto B5\n}",
      "B4 {\n  r0.serializeFields(r3, r4, r5)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnwrappingXmlBeanSerializer#serializeFields(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UnwrappingXmlBeanSerializer#_serializeWithObjectId(...4)",
        "body": "(source not found)"
      },
      {
        "name": "UnwrappingXmlBeanSerializer#serializeFieldsFiltered(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanPropertyWriter",
    "methodName": "serializeAsField",
    "signature": "void serializeAsField(java.lang.Object,com.fasterxml.jackson.core.JsonGenerator,com.fasterxml.jackson.databind.SerializerProvider)",
    "visibility": "public",
    "body": "{\r\n    Object value \u003d get(bean);\r\n    /* 13-Feb-2014, tatu: As per [#103], default handling does not really\r\n         *   work here. Rather, we need just a wrapping and should NOT call\r\n         *   null handler, as it does not know what to do...\r\n         *   \r\n         *   Question, however, is what should it be serialized as. We have two main\r\n         *   choices; equivalent empty List, and \"nothing\" (missing). Let\u0027s start with\r\n         *   empty List? But producing missing entry is non-trivial...\r\n         */\r\n    if (value \u003d\u003d null) {\r\n        // if (_nullSerializer !\u003d null) { ... }\r\n        // For Empty List, we\u0027d do this:\r\n        /*\r\n            @SuppressWarnings(\"resource\")\r\n            final ToXmlGenerator xmlGen \u003d (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\r\n            if (xmlGen !\u003d null) {\r\n                xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\r\n                xmlGen.finishWrappedValue(_wrapperQName, _wrappedQName);\r\n            }\r\n            */\r\n        // but for missing thing, well, just output nothing\r\n        return;\r\n    }\r\n    // then find serializer to use\r\n    JsonSerializer\u003cObject\u003e ser \u003d _serializer;\r\n    if (ser \u003d\u003d null) {\r\n        Class\u003c?\u003e cls \u003d value.getClass();\r\n        PropertySerializerMap map \u003d _dynamicSerializers;\r\n        ser \u003d map.serializerFor(cls);\r\n        if (ser \u003d\u003d null) {\r\n            ser \u003d _findAndAddDynamic(map, cls, prov);\r\n        }\r\n    }\r\n    // and then see if we must suppress certain values (default, empty)\r\n    if (_suppressableValue !\u003d null) {\r\n        if (MARKER_FOR_EMPTY \u003d\u003d _suppressableValue) {\r\n            if (ser.isEmpty(prov, value)) {\r\n                return;\r\n            }\r\n        } else if (_suppressableValue.equals(value)) {\r\n            return;\r\n        }\r\n    }\r\n    // For non-nulls: simple check for direct cycles\r\n    if (value \u003d\u003d bean) {\r\n        // NOTE: method signature here change 2.3-\u003e2.4\r\n        if (_handleSelfReference(bean, jgen, prov, ser)) {\r\n            return;\r\n        }\r\n    }\r\n    final ToXmlGenerator xmlGen \u003d (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\r\n    // Ok then; addition we want to do is to add wrapper element, and that\u0027s what happens here\r\n    // 19-Aug-2013, tatu: ... except for those nasty \u0027convertValue()\u0027 calls...\r\n    if (xmlGen !\u003d null) {\r\n        xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\r\n    }\r\n    jgen.writeFieldName(_name);\r\n    if (_typeSerializer \u003d\u003d null) {\r\n        ser.serialize(value, jgen, prov);\r\n    } else {\r\n        ser.serializeWithType(value, jgen, prov, _typeSerializer);\r\n    }\r\n    if (xmlGen !\u003d null) {\r\n        xmlGen.finishWrappedValue(_wrapperQName, _wrappedQName);\r\n    }\r\n}",
    "nodes": 25,
    "edges": 33,
    "cc": 10,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(r16 !\u003d null) → B3 | else → B5",
      "B3 : If(r16 !\u003d null) → B4 | else → B5",
      "B5 : If($r18 \u003d\u003d null) → B6 | else → B11",
      "B6 : If($r13 !\u003d $r12) → B7 | else → B9",
      "B7 : If($z3 \u003d\u003d false) → B8 | else → B11",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11",
      "B11 : If(r2 !\u003d r1) → B12 | else → B14",
      "B12 : If($z1 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($z0 \u003d\u003d false) → B15 | else → B16",
      "B17 : If($r19 \u003d\u003d null) → B18 | else → B19",
      "B19 : If($r5 !\u003d null) → B20 | else → B21",
      "B22 : If(r20 \u003d\u003d null) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  XmlBeanPropertyWriter\n  Object\n  JsonGenerator\n  SerializerProvider\n  r2 \u003d r0.get(r1)\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r16 \u003d JsonSerializer _serializer\u003e\n  if (r16 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r17 \u003d r2.getClass()\n  r15 \u003d PropertySerializerMap _dynamicSerializers\u003e\n  r16 \u003d r15.serializerFor(r17)\n  if (r16 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  r16 \u003d r0._findAndAddDynamic(r15, r17, r6)\n}",
      "B5 {\n  $r18 \u003d Object _suppressableValue\u003e\n  if ($r18 \u003d\u003d null) goto B6 else B11\n}",
      "B6 {\n  $r13 \u003d Object MARKER_FOR_EMPTY\u003e\n  $r12 \u003d Object _suppressableValue\u003e\n  if ($r13 !\u003d $r12) goto B7 else B9\n}",
      "B7 {\n  $z3 \u003d r16.isEmpty(r6, r2)\n  if ($z3 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $r14 \u003d Object _suppressableValue\u003e\n  $z2 \u003d $r14.equals(r2)\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  if (r2 !\u003d r1) goto B12 else B14\n}",
      "B12 {\n  $z1 \u003d r0._handleSelfReference(r1, r3, r6, r16)\n  if ($z1 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $z0 \u003d ToXmlGenerator\n  if ($z0 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $r19 \u003d ToXmlGenerator) r3\n  goto B17\n}",
      "B16 {\n  $r19 \u003d null\n}",
      "B17 {\n  r20 \u003d $r19\n  if ($r19 \u003d\u003d null) goto B18 else B19\n}",
      "B18 {\n  $r11 \u003d QName _wrapperQName\u003e\n  $r10 \u003d QName _wrappedQName\u003e\n  $r19.startWrappedValue($r11, $r10)\n}",
      "B19 {\n  $r4 \u003d SerializedString _name\u003e\n  r3.writeFieldName($r4)\n  $r5 \u003d TypeSerializer _typeSerializer\u003e\n  if ($r5 !\u003d null) goto B20 else B21\n}",
      "B20 {\n  r16.serialize(r2, r3, r6)\n  goto B22\n}",
      "B21 {\n  $r7 \u003d TypeSerializer _typeSerializer\u003e\n  r16.serializeWithType(r2, r3, r6, $r7)\n}",
      "B22 {\n  if (r20 \u003d\u003d null) goto B23 else B24\n}",
      "B23 {\n  $r9 \u003d QName _wrapperQName\u003e\n  $r8 \u003d QName _wrappedQName\u003e\n  r20.finishWrappedValue($r9, $r8)\n}",
      "B24 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlBeanPropertyWriter#_handleSelfReference(...4)",
        "body": "(source not found)"
      },
      {
        "name": "XmlBeanPropertyWriter#get(...1)",
        "body": "(source not found)"
      },
      {
        "name": "XmlBeanPropertyWriter#_findAndAddDynamic(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer",
    "methodName": "serialize",
    "signature": "void serialize(java.lang.Object,com.fasterxml.jackson.core.JsonGenerator,com.fasterxml.jackson.databind.SerializerProvider)",
    "visibility": "public",
    "body": "{\r\n    if (_objectIdWriter !\u003d null) {\r\n        _serializeWithObjectId(bean, g, provider, true);\r\n        return;\r\n    }\r\n    g.writeStartObject();\r\n    if (_propertyFilterId !\u003d null) {\r\n        serializeFieldsFiltered(bean, g, provider);\r\n    } else {\r\n        serializeFields(bean, g, provider);\r\n    }\r\n    g.writeEndObject();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  XmlBeanSerializer\n  Object\n  JsonGenerator\n  SerializerProvider\n  $r1 \u003d ObjectIdWriter _objectIdWriter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._serializeWithObjectId(r4, r2, r5, 1)\n  return\n}",
      "B2 {\n  r2.writeStartObject()\n  $r3 \u003d Object _propertyFilterId\u003e\n  if ($r3 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.serializeFieldsFiltered(r4, r2, r5)\n  goto B5\n}",
      "B4 {\n  r0.serializeFields(r4, r2, r5)\n}",
      "B5 {\n  r2.writeEndObject()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlBeanSerializer#serializeFields(...3)",
        "body": "(source not found)"
      },
      {
        "name": "XmlBeanSerializer#_serializeWithObjectId(...4)",
        "body": "(source not found)"
      },
      {
        "name": "XmlBeanSerializer#serializeFieldsFiltered(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier",
    "methodName": "changeProperties",
    "signature": "java.util.List changeProperties(com.fasterxml.jackson.databind.SerializationConfig,com.fasterxml.jackson.databind.BeanDescription,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    final AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\r\n    for (int i \u003d 0, len \u003d beanProperties.size(); i \u003c len; ++i) {\r\n        BeanPropertyWriter bpw \u003d beanProperties.get(i);\r\n        final AnnotatedMember member \u003d bpw.getMember();\r\n        String ns \u003d AnnotationUtil.findNamespaceAnnotation(config, intr, member);\r\n        Boolean isAttribute \u003d AnnotationUtil.findIsAttributeAnnotation(config, intr, member);\r\n        Boolean isText \u003d AnnotationUtil.findIsTextAnnotation(config, intr, member);\r\n        Boolean isCData \u003d AnnotationUtil.findIsCDataAnnotation(config, intr, member);\r\n        bpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO, new XmlInfo(isAttribute, ns, isText, isCData));\r\n        // Actually: if we have a Collection type, easiest place to add wrapping would be here...\r\n        //  or: let\u0027s also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\r\n        //   typed Collection...\r\n        if (!TypeUtil.isIndexedType(bpw.getType())) {\r\n            continue;\r\n        }\r\n        PropertyName wrappedName \u003d PropertyName.construct(bpw.getName(), ns);\r\n        PropertyName wrapperName \u003d bpw.getWrapperName();\r\n        // first things first: no wrapping?\r\n        if (wrapperName \u003d\u003d null || wrapperName \u003d\u003d PropertyName.NO_NAME) {\r\n            continue;\r\n        }\r\n        // no local name? Just double the wrapped name for wrapper\r\n        String localName \u003d wrapperName.getSimpleName();\r\n        if (localName \u003d\u003d null || localName.length() \u003d\u003d 0) {\r\n            wrapperName \u003d wrappedName;\r\n        }\r\n        beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\r\n    }\r\n    return beanProperties;\r\n}",
    "nodes": 13,
    "edges": 18,
    "cc": 7,
    "flowSummary": [
      "B1 : If(i2 \u003e\u003d i0) → B2 | else → B12",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If(r19 \u003d\u003d null) → B5 | else → B11",
      "B5 : If(r19 !\u003d $r15) → B6 | else → B7",
      "B7 : If(r16 \u003d\u003d null) → B8 | else → B9",
      "B8 : If($i1 !\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  XmlBeanSerializerModifier\n  SerializationConfig\n  BeanDescription\n  List\n  r1 \u003d r0.getAnnotationIntrospector()\n  i2 \u003d 0\n  i0 \u003d r2.size()\n}",
      "B1 {\n  if (i2 \u003e\u003d i0) goto B2 else B12\n}",
      "B2 {\n  $r3 \u003d r2.get(i2)\n  r4 \u003d BeanPropertyWriter) $r3\n  r5 \u003d r4.getMember()\n  r6 \u003d AnnotationUtil.findNamespaceAnnotation(r0, r1, r5)\n  r7 \u003d AnnotationUtil.findIsAttributeAnnotation(r0, r1, r5)\n  r8 \u003d AnnotationUtil.findIsTextAnnotation(r0, r1, r5)\n  r9 \u003d AnnotationUtil.findIsCDataAnnotation(r0, r1, r5)\n  $r11 \u003d String KEY_XML_INFO\u003e\n  $r10 \u003d XmlInfo\n  new XmlInfo(r7, r6, r8, r9)\n  r4.setInternalSetting($r11, $r10)\n  $r12 \u003d r4.getType()\n  $z0 \u003d TypeUtil.isIndexedType($r12)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  goto B11\n}",
      "B4 {\n  $r13 \u003d r4.getName()\n  r14 \u003d PropertyName.construct($r13, r6)\n  r19 \u003d r4.getWrapperName()\n  if (r19 \u003d\u003d null) goto B5 else B11\n}",
      "B5 {\n  $r15 \u003d PropertyName NO_NAME\u003e\n  if (r19 !\u003d $r15) goto B6 else B7\n}",
      "B6 {\n  goto B11\n}",
      "B7 {\n  r16 \u003d r19.getSimpleName()\n  if (r16 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d r16.length()\n  if ($i1 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  r19 \u003d r14\n}",
      "B10 {\n  $r20 \u003d XmlBeanPropertyWriter\n  new XmlBeanPropertyWriter(r4, r19, r14)\n  r2.set(i2, $r20)\n}",
      "B11 {\n  i2 \u003d i2 + 1\n  goto B1\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B11",
      "B4 --\u003e B5",
      "B4 --\u003e B11",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B1",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier",
    "methodName": "modifySerializer",
    "signature": "com.fasterxml.jackson.databind.JsonSerializer modifySerializer(com.fasterxml.jackson.databind.SerializationConfig,com.fasterxml.jackson.databind.BeanDescription,com.fasterxml.jackson.databind.JsonSerializer)",
    "visibility": "public",
    "body": "{\r\n    /* First things first: we can only handle real BeanSerializers; question\r\n         * is, what to do if it\u0027s not one: throw exception or bail out?\r\n         * For now let\u0027s do latter.\r\n         */\r\n    if (!(serializer instanceof BeanSerializerBase)) {\r\n        return serializer;\r\n    }\r\n    return new XmlBeanSerializer((BeanSerializerBase) serializer);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlBeanSerializerModifier\n  SerializationConfig\n  BeanDescription\n  JsonSerializer\n  $z0 \u003d BeanSerializerBase\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d XmlBeanSerializer\n  $r2 \u003d BeanSerializerBase) r0\n  new XmlBeanSerializer($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider",
    "methodName": "serializeValue",
    "signature": "void serializeValue(com.fasterxml.jackson.core.JsonGenerator,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _generator \u003d gen;\r\n    if (value \u003d\u003d null) {\r\n        _serializeXmlNull(gen);\r\n        return;\r\n    }\r\n    final Class\u003c?\u003e cls \u003d value.getClass();\r\n    final boolean asArray;\r\n    final ToXmlGenerator xgen \u003d _asXmlGenerator(gen);\r\n    if (xgen \u003d\u003d null) {\r\n        // called by convertValue()\r\n        asArray \u003d false;\r\n    } else {\r\n        // [dataformat-xml#441]: allow ObjectNode unwrapping\r\n        if (_shouldUnwrapObjectNode(xgen, value)) {\r\n            _serializeUnwrappedObjectNode(xgen, value, null);\r\n            return;\r\n        }\r\n        QName rootName \u003d _rootNameFromConfig();\r\n        if (rootName \u003d\u003d null) {\r\n            rootName \u003d _rootNameLookup.findRootName(cls, _config);\r\n        }\r\n        _initWithRootName(xgen, rootName);\r\n        asArray \u003d TypeUtil.isIndexedType(_config.constructType(cls));\r\n        if (asArray) {\r\n            _startRootArray(xgen, rootName);\r\n        }\r\n    }\r\n    // From super-class implementation\r\n    final JsonSerializer\u003cObject\u003e ser \u003d findTypedValueSerializer(cls, true, null);\r\n    try {\r\n        ser.serialize(value, gen, this);\r\n    } catch (Exception e) {\r\n        // but wrap RuntimeExceptions, to get path information\r\n        throw _wrapAsIOE(gen, e);\r\n    }\r\n    // end of super-class implementation\r\n    if (asArray) {\r\n        gen.writeEndObject();\r\n    }\r\n}",
    "nodes": 15,
    "edges": 17,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(r4 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If(r11 !\u003d null) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B12 : If(z2 \u003d\u003d false) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  XmlSerializerProvider\n  JsonGenerator\n  Object\n  JsonGenerator _generator\u003e \u003d r1\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._serializeXmlNull(r1)\n  return\n}",
      "B2 {\n  r3 \u003d r2.getClass()\n  r4 \u003d r0._asXmlGenerator(r1)\n  if (r4 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  z2 \u003d 0\n  goto B10\n}",
      "B4 {\n  $z0 \u003d r0._shouldUnwrapObjectNode(r4, r2)\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r0._serializeUnwrappedObjectNode(r4, r2, null)\n  return\n}",
      "B6 {\n  r11 \u003d r0._rootNameFromConfig()\n  if (r11 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r8 \u003d XmlRootNameLookup _rootNameLookup\u003e\n  $r7 \u003d SerializationConfig _config\u003e\n  r11 \u003d $r8.findRootName(r3, $r7)\n}",
      "B8 {\n  r0._initWithRootName(r4, r11)\n  $r5 \u003d SerializationConfig _config\u003e\n  $r6 \u003d $r5.constructType(r3)\n  $z1 \u003d TypeUtil.isIndexedType($r6)\n  z2 \u003d $z1\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r0._startRootArray(r4, r11)\n}",
      "B10 {\n  $r12 \u003d r0.findTypedValueSerializer(r3, 1, null)\n  $r12.serialize(r2, r1, r0)\n  goto B12\n}",
      "B11 {\n  $r9 :\u003d @caughtexception\n  $r10 \u003d r0._wrapAsIOE(r1, $r9)\n  throw $r10\n}",
      "B12 {\n  if (z2 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  r1.writeEndObject()\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlSerializerProvider#_initWithRootName(...2)",
        "body": "{\r\n    // 28-Nov-2012, tatu: We should only initialize the root name if no name has been\r\n    //   set, as per [dataformat-xml#42], to allow for custom serializers to work.\r\n    if (!xgen.setNextNameIfMissing(rootName)) {\r\n        // however, if we are root, we... insist\r\n        if (xgen.inRoot()) {\r\n            xgen.setNextName(rootName);\r\n        }\r\n    }\r\n    xgen.initGenerator();\r\n    String ns \u003d rootName.getNamespaceURI();\r\n    // [dataformat-xml#26] If we just try writing root element with namespace,\r\n    // we will get an explicit prefix. But we\u0027d rather use the default\r\n    // namespace, so let\u0027s try to force that.\r\n    if (ns !\u003d null \u0026\u0026 ns.length() \u003e 0) {\r\n        try {\r\n            xgen.getStaxWriter().setDefaultNamespace(ns);\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, xgen);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_serializeUnwrappedObjectNode(...3)",
        "body": "{\r\n    ObjectNode root \u003d (ObjectNode) value;\r\n    Map.Entry\u003cString, JsonNode\u003e entry \u003d root.fields().next();\r\n    final JsonNode newRoot \u003d entry.getValue();\r\n    // No namespace associated with JsonNode:\r\n    _initWithRootName(xgen, new QName(entry.getKey()));\r\n    if (ser \u003d\u003d null) {\r\n        ser \u003d findTypedValueSerializer(newRoot.getClass(), true, null);\r\n    }\r\n    // From super-class implementation\r\n    try {\r\n        ser.serialize(newRoot, xgen, this);\r\n    } catch (Exception e) {\r\n        // but others do need to be, to get path etc\r\n        throw _wrapAsIOE(xgen, e);\r\n    }\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_wrapAsIOE(...2)",
        "body": "{\r\n    if (e instanceof IOException) {\r\n        return (IOException) e;\r\n    }\r\n    String msg \u003d e.getMessage();\r\n    if (msg \u003d\u003d null) {\r\n        msg \u003d \"[no message for \" + e.getClass().getName() + \"]\";\r\n    }\r\n    return new JsonMappingException(g, msg, e);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#findTypedValueSerializer(...3)",
        "body": "(source not found)"
      },
      {
        "name": "XmlSerializerProvider#_asXmlGenerator(...1)",
        "body": "{\r\n    if (!(gen instanceof ToXmlGenerator)) {\r\n        // [dataformat-xml#71]: We sometimes get TokenBuffer, which is fine\r\n        if (gen instanceof TokenBuffer) {\r\n            return null;\r\n        }\r\n        // but verify\r\n        throw JsonMappingException.from(gen, \"XmlMapper does not work with generators of type other than `ToXmlGenerator`; got: `\" + gen.getClass().getName() + \"`\");\r\n    }\r\n    return (ToXmlGenerator) gen;\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_rootNameFromConfig(...0)",
        "body": "{\r\n    PropertyName name \u003d _config.getFullRootName();\r\n    if (name \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    String ns \u003d name.getNamespace();\r\n    if (ns \u003d\u003d null || ns.isEmpty()) {\r\n        return new QName(name.getSimpleName());\r\n    }\r\n    return new QName(ns, name.getSimpleName());\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_serializeXmlNull(...1)",
        "body": "{\r\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\r\n    //    configured root name...\r\n    QName rootName \u003d _rootNameFromConfig();\r\n    if (rootName \u003d\u003d null) {\r\n        rootName \u003d XmlRootNameLookup.ROOT_NAME_FOR_NULL;\r\n    }\r\n    if (gen instanceof ToXmlGenerator) {\r\n        _initWithRootName((ToXmlGenerator) gen, rootName);\r\n    }\r\n    super.serializeValue(gen, null);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_startRootArray(...2)",
        "body": "{\r\n    xgen.writeStartObject();\r\n    // Could repeat root name, but what\u0027s the point? How to customize?\r\n    xgen.writeFieldName(\"item\");\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_shouldUnwrapObjectNode(...2)",
        "body": "{\r\n    return xgen.isEnabled(ToXmlGenerator.Feature.UNWRAP_ROOT_OBJECT_NODE) \u0026\u0026 (value instanceof ObjectNode) \u0026\u0026 (((ObjectNode) value).size() \u003d\u003d 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider",
    "methodName": "serializeValue",
    "signature": "void serializeValue(com.fasterxml.jackson.core.JsonGenerator,java.lang.Object,com.fasterxml.jackson.databind.JavaType,com.fasterxml.jackson.databind.JsonSerializer)",
    "visibility": "public",
    "body": "{\r\n    _generator \u003d gen;\r\n    if (value \u003d\u003d null) {\r\n        _serializeXmlNull(gen);\r\n        return;\r\n    }\r\n    // Let\u0027s ensure types are compatible at this point\r\n    if ((rootType !\u003d null) \u0026\u0026 !rootType.getRawClass().isAssignableFrom(value.getClass())) {\r\n        _reportIncompatibleRootType(value, rootType);\r\n    }\r\n    final boolean asArray;\r\n    final ToXmlGenerator xgen \u003d _asXmlGenerator(gen);\r\n    if (xgen \u003d\u003d null) {\r\n        // called by convertValue()\r\n        asArray \u003d false;\r\n    } else {\r\n        // [dataformat-xml#441]: allow ObjectNode unwrapping\r\n        if (_shouldUnwrapObjectNode(xgen, value)) {\r\n            _serializeUnwrappedObjectNode(xgen, value, ser);\r\n            return;\r\n        }\r\n        QName rootName \u003d _rootNameFromConfig();\r\n        if (rootName \u003d\u003d null) {\r\n            rootName \u003d (rootType \u003d\u003d null) ? _rootNameLookup.findRootName(value.getClass(), _config) : _rootNameLookup.findRootName(rootType, _config);\r\n        }\r\n        _initWithRootName(xgen, rootName);\r\n        asArray \u003d (rootType \u003d\u003d null) ? TypeUtil.isIndexedType(_config.constructType(value.getClass())) : TypeUtil.isIndexedType(rootType);\r\n        if (asArray) {\r\n            _startRootArray(xgen, rootName);\r\n        }\r\n    }\r\n    if (ser \u003d\u003d null) {\r\n        ser \u003d findTypedValueSerializer(rootType, true, null);\r\n    }\r\n    // From super-class implementation\r\n    try {\r\n        ser.serialize(value, gen, this);\r\n    } catch (Exception e) {\r\n        // but others do need to be, to get path etc\r\n        throw _wrapAsIOE(gen, e);\r\n    }\r\n    // end of super-class implementation\r\n    if (asArray) {\r\n        gen.writeEndObject();\r\n    }\r\n}",
    "nodes": 26,
    "edges": 33,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B5 : If($r17 !\u003d null) → B6 | else → B7",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9",
      "B9 : If(r18 !\u003d null) → B10 | else → B14",
      "B10 : If(r3 !\u003d null) → B11 | else → B12",
      "B14 : If(r3 !\u003d null) → B15 | else → B16",
      "B17 : If($z3 \u003d\u003d false) → B18 | else → B19",
      "B19 : If(r16 !\u003d null) → B20 | else → B21",
      "B23 : If(z2 \u003d\u003d false) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  XmlSerializerProvider\n  JsonGenerator\n  Object\n  JavaType\n  JsonSerializer\n  JsonGenerator _generator\u003e \u003d r1\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._serializeXmlNull(r1)\n  return\n}",
      "B2 {\n  if (r3 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r13 \u003d r3.getRawClass()\n  $r12 \u003d r2.getClass()\n  $z1 \u003d $r13.isAssignableFrom($r12)\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0._reportIncompatibleRootType(r2, r3)\n}",
      "B5 {\n  $r17 \u003d r0._asXmlGenerator(r1)\n  if ($r17 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  z2 \u003d 0\n  goto B19\n}",
      "B7 {\n  $z0 \u003d r0._shouldUnwrapObjectNode($r17, r2)\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  r0._serializeUnwrappedObjectNode($r17, r2, r16)\n  return\n}",
      "B9 {\n  r18 \u003d r0._rootNameFromConfig()\n  if (r18 !\u003d null) goto B10 else B14\n}",
      "B10 {\n  if (r3 !\u003d null) goto B11 else B12\n}",
      "B11 {\n  $r9 \u003d XmlRootNameLookup _rootNameLookup\u003e\n  $r11 \u003d r2.getClass()\n  $r10 \u003d SerializationConfig _config\u003e\n  $r19 \u003d $r9.findRootName($r11, $r10)\n  goto B13\n}",
      "B12 {\n  $r8 \u003d XmlRootNameLookup _rootNameLookup\u003e\n  $r7 \u003d SerializationConfig _config\u003e\n  $r19 \u003d $r8.findRootName(r3, $r7)\n}",
      "B13 {\n  r18 \u003d $r19\n}",
      "B14 {\n  r0._initWithRootName($r17, r18)\n  if (r3 !\u003d null) goto B15 else B16\n}",
      "B15 {\n  $r4 \u003d SerializationConfig _config\u003e\n  $r5 \u003d r2.getClass()\n  $r6 \u003d $r4.constructType($r5)\n  $z3 \u003d TypeUtil.isIndexedType($r6)\n  goto B17\n}",
      "B16 {\n  $z3 \u003d TypeUtil.isIndexedType(r3)\n}",
      "B17 {\n  z2 \u003d $z3\n  if ($z3 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  r0._startRootArray($r17, r18)\n}",
      "B19 {\n  if (r16 !\u003d null) goto B20 else B21\n}",
      "B20 {\n  r16 \u003d r0.findTypedValueSerializer(r3, 1, null)\n}",
      "B21 {\n  r16.serialize(r2, r1, r0)\n  goto B23\n}",
      "B22 {\n  $r14 :\u003d @caughtexception\n  $r15 \u003d r0._wrapAsIOE(r1, $r14)\n  throw $r15\n}",
      "B23 {\n  if (z2 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  r1.writeEndObject()\n}",
      "B25 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B19",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlSerializerProvider#_reportIncompatibleRootType(...2)",
        "body": "(source not found)"
      },
      {
        "name": "XmlSerializerProvider#_initWithRootName(...2)",
        "body": "{\r\n    // 28-Nov-2012, tatu: We should only initialize the root name if no name has been\r\n    //   set, as per [dataformat-xml#42], to allow for custom serializers to work.\r\n    if (!xgen.setNextNameIfMissing(rootName)) {\r\n        // however, if we are root, we... insist\r\n        if (xgen.inRoot()) {\r\n            xgen.setNextName(rootName);\r\n        }\r\n    }\r\n    xgen.initGenerator();\r\n    String ns \u003d rootName.getNamespaceURI();\r\n    // [dataformat-xml#26] If we just try writing root element with namespace,\r\n    // we will get an explicit prefix. But we\u0027d rather use the default\r\n    // namespace, so let\u0027s try to force that.\r\n    if (ns !\u003d null \u0026\u0026 ns.length() \u003e 0) {\r\n        try {\r\n            xgen.getStaxWriter().setDefaultNamespace(ns);\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, xgen);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_serializeUnwrappedObjectNode(...3)",
        "body": "{\r\n    ObjectNode root \u003d (ObjectNode) value;\r\n    Map.Entry\u003cString, JsonNode\u003e entry \u003d root.fields().next();\r\n    final JsonNode newRoot \u003d entry.getValue();\r\n    // No namespace associated with JsonNode:\r\n    _initWithRootName(xgen, new QName(entry.getKey()));\r\n    if (ser \u003d\u003d null) {\r\n        ser \u003d findTypedValueSerializer(newRoot.getClass(), true, null);\r\n    }\r\n    // From super-class implementation\r\n    try {\r\n        ser.serialize(newRoot, xgen, this);\r\n    } catch (Exception e) {\r\n        // but others do need to be, to get path etc\r\n        throw _wrapAsIOE(xgen, e);\r\n    }\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_wrapAsIOE(...2)",
        "body": "{\r\n    if (e instanceof IOException) {\r\n        return (IOException) e;\r\n    }\r\n    String msg \u003d e.getMessage();\r\n    if (msg \u003d\u003d null) {\r\n        msg \u003d \"[no message for \" + e.getClass().getName() + \"]\";\r\n    }\r\n    return new JsonMappingException(g, msg, e);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#findTypedValueSerializer(...3)",
        "body": "(source not found)"
      },
      {
        "name": "XmlSerializerProvider#_asXmlGenerator(...1)",
        "body": "{\r\n    if (!(gen instanceof ToXmlGenerator)) {\r\n        // [dataformat-xml#71]: We sometimes get TokenBuffer, which is fine\r\n        if (gen instanceof TokenBuffer) {\r\n            return null;\r\n        }\r\n        // but verify\r\n        throw JsonMappingException.from(gen, \"XmlMapper does not work with generators of type other than `ToXmlGenerator`; got: `\" + gen.getClass().getName() + \"`\");\r\n    }\r\n    return (ToXmlGenerator) gen;\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_rootNameFromConfig(...0)",
        "body": "{\r\n    PropertyName name \u003d _config.getFullRootName();\r\n    if (name \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    String ns \u003d name.getNamespace();\r\n    if (ns \u003d\u003d null || ns.isEmpty()) {\r\n        return new QName(name.getSimpleName());\r\n    }\r\n    return new QName(ns, name.getSimpleName());\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_serializeXmlNull(...1)",
        "body": "{\r\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\r\n    //    configured root name...\r\n    QName rootName \u003d _rootNameFromConfig();\r\n    if (rootName \u003d\u003d null) {\r\n        rootName \u003d XmlRootNameLookup.ROOT_NAME_FOR_NULL;\r\n    }\r\n    if (gen instanceof ToXmlGenerator) {\r\n        _initWithRootName((ToXmlGenerator) gen, rootName);\r\n    }\r\n    super.serializeValue(gen, null);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_startRootArray(...2)",
        "body": "{\r\n    xgen.writeStartObject();\r\n    // Could repeat root name, but what\u0027s the point? How to customize?\r\n    xgen.writeFieldName(\"item\");\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_shouldUnwrapObjectNode(...2)",
        "body": "{\r\n    return xgen.isEnabled(ToXmlGenerator.Feature.UNWRAP_ROOT_OBJECT_NODE) \u0026\u0026 (value instanceof ObjectNode) \u0026\u0026 (((ObjectNode) value).size() \u003d\u003d 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider",
    "methodName": "serializePolymorphic",
    "signature": "void serializePolymorphic(com.fasterxml.jackson.core.JsonGenerator,java.lang.Object,com.fasterxml.jackson.databind.JavaType,com.fasterxml.jackson.databind.JsonSerializer,com.fasterxml.jackson.databind.jsontype.TypeSerializer)",
    "visibility": "public",
    "body": "{\r\n    _generator \u003d gen;\r\n    if (value \u003d\u003d null) {\r\n        _serializeXmlNull(gen);\r\n        return;\r\n    }\r\n    // Let\u0027s ensure types are compatible at this point\r\n    if ((rootType !\u003d null) \u0026\u0026 !rootType.getRawClass().isAssignableFrom(value.getClass())) {\r\n        _reportIncompatibleRootType(value, rootType);\r\n    }\r\n    final boolean asArray;\r\n    final ToXmlGenerator xgen \u003d _asXmlGenerator(gen);\r\n    if (xgen \u003d\u003d null) {\r\n        // called by convertValue()\r\n        asArray \u003d false;\r\n    } else {\r\n        QName rootName \u003d _rootNameFromConfig();\r\n        if (rootName \u003d\u003d null) {\r\n            rootName \u003d (rootType \u003d\u003d null) ? _rootNameLookup.findRootName(value.getClass(), _config) : _rootNameLookup.findRootName(rootType, _config);\r\n        }\r\n        _initWithRootName(xgen, rootName);\r\n        asArray \u003d (rootType \u003d\u003d null) ? TypeUtil.isIndexedType(_config.constructType(value.getClass())) : TypeUtil.isIndexedType(rootType);\r\n        if (asArray) {\r\n            _startRootArray(xgen, rootName);\r\n        }\r\n    }\r\n    // 21-May-2020: See comments in `jackson-databind/DefaultSerializerProvider`\r\n    if (valueSer \u003d\u003d null) {\r\n        if ((rootType !\u003d null) \u0026\u0026 rootType.isContainerType()) {\r\n            valueSer \u003d findValueSerializer(rootType, null);\r\n        } else {\r\n            valueSer \u003d findValueSerializer(value.getClass(), null);\r\n        }\r\n    }\r\n    // From super-class implementation\r\n    try {\r\n        valueSer.serializeWithType(value, gen, this, typeSer);\r\n    } catch (Exception e) {\r\n        // but others do need to be, to get path etc\r\n        throw _wrapAsIOE(gen, e);\r\n    }\r\n    // end of super-class implementation\r\n    if (asArray) {\r\n        gen.writeEndObject();\r\n    }\r\n}",
    "nodes": 27,
    "edges": 36,
    "cc": 11,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B5 : If($r19 !\u003d null) → B6 | else → B7",
      "B7 : If(r20 !\u003d null) → B8 | else → B12",
      "B8 : If(r3 !\u003d null) → B9 | else → B10",
      "B12 : If(r3 !\u003d null) → B13 | else → B14",
      "B15 : If($z3 \u003d\u003d false) → B16 | else → B17",
      "B17 : If(r18 !\u003d null) → B18 | else → B22",
      "B18 : If(r3 \u003d\u003d null) → B19 | else → B21",
      "B19 : If($z0 \u003d\u003d false) → B20 | else → B21",
      "B24 : If(z2 \u003d\u003d false) → B25 | else → B26"
    ],
    "blockList": [
      "B0 {\n  XmlSerializerProvider\n  JsonGenerator\n  Object\n  JavaType\n  JsonSerializer\n  TypeSerializer\n  JsonGenerator _generator\u003e \u003d r1\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._serializeXmlNull(r1)\n  return\n}",
      "B2 {\n  if (r3 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r15 \u003d r3.getRawClass()\n  $r14 \u003d r2.getClass()\n  $z1 \u003d $r15.isAssignableFrom($r14)\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0._reportIncompatibleRootType(r2, r3)\n}",
      "B5 {\n  $r19 \u003d r0._asXmlGenerator(r1)\n  if ($r19 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  z2 \u003d 0\n  goto B17\n}",
      "B7 {\n  r20 \u003d r0._rootNameFromConfig()\n  if (r20 !\u003d null) goto B8 else B12\n}",
      "B8 {\n  if (r3 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r11 \u003d XmlRootNameLookup _rootNameLookup\u003e\n  $r13 \u003d r2.getClass()\n  $r12 \u003d SerializationConfig _config\u003e\n  $r21 \u003d $r11.findRootName($r13, $r12)\n  goto B11\n}",
      "B10 {\n  $r10 \u003d XmlRootNameLookup _rootNameLookup\u003e\n  $r9 \u003d SerializationConfig _config\u003e\n  $r21 \u003d $r10.findRootName(r3, $r9)\n}",
      "B11 {\n  r20 \u003d $r21\n}",
      "B12 {\n  r0._initWithRootName($r19, r20)\n  if (r3 !\u003d null) goto B13 else B14\n}",
      "B13 {\n  $r6 \u003d SerializationConfig _config\u003e\n  $r7 \u003d r2.getClass()\n  $r8 \u003d $r6.constructType($r7)\n  $z3 \u003d TypeUtil.isIndexedType($r8)\n  goto B15\n}",
      "B14 {\n  $z3 \u003d TypeUtil.isIndexedType(r3)\n}",
      "B15 {\n  z2 \u003d $z3\n  if ($z3 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  r0._startRootArray($r19, r20)\n}",
      "B17 {\n  if (r18 !\u003d null) goto B18 else B22\n}",
      "B18 {\n  if (r3 \u003d\u003d null) goto B19 else B21\n}",
      "B19 {\n  $z0 \u003d r3.isContainerType()\n  if ($z0 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  r18 \u003d r0.findValueSerializer(r3, null)\n  goto B22\n}",
      "B21 {\n  $r5 \u003d r2.getClass()\n  r18 \u003d r0.findValueSerializer($r5, null)\n}",
      "B22 {\n  r18.serializeWithType(r2, r1, r0, r4)\n  goto B24\n}",
      "B23 {\n  $r16 :\u003d @caughtexception\n  $r17 \u003d r0._wrapAsIOE(r1, $r16)\n  throw $r17\n}",
      "B24 {\n  if (z2 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  r1.writeEndObject()\n}",
      "B26 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B17",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B22",
      "B18 --\u003e B19",
      "B18 --\u003e B21",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B24",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlSerializerProvider#_reportIncompatibleRootType(...2)",
        "body": "(source not found)"
      },
      {
        "name": "XmlSerializerProvider#_initWithRootName(...2)",
        "body": "{\r\n    // 28-Nov-2012, tatu: We should only initialize the root name if no name has been\r\n    //   set, as per [dataformat-xml#42], to allow for custom serializers to work.\r\n    if (!xgen.setNextNameIfMissing(rootName)) {\r\n        // however, if we are root, we... insist\r\n        if (xgen.inRoot()) {\r\n            xgen.setNextName(rootName);\r\n        }\r\n    }\r\n    xgen.initGenerator();\r\n    String ns \u003d rootName.getNamespaceURI();\r\n    // [dataformat-xml#26] If we just try writing root element with namespace,\r\n    // we will get an explicit prefix. But we\u0027d rather use the default\r\n    // namespace, so let\u0027s try to force that.\r\n    if (ns !\u003d null \u0026\u0026 ns.length() \u003e 0) {\r\n        try {\r\n            xgen.getStaxWriter().setDefaultNamespace(ns);\r\n        } catch (XMLStreamException e) {\r\n            StaxUtil.throwAsGenerationException(e, xgen);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_wrapAsIOE(...2)",
        "body": "{\r\n    if (e instanceof IOException) {\r\n        return (IOException) e;\r\n    }\r\n    String msg \u003d e.getMessage();\r\n    if (msg \u003d\u003d null) {\r\n        msg \u003d \"[no message for \" + e.getClass().getName() + \"]\";\r\n    }\r\n    return new JsonMappingException(g, msg, e);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#findValueSerializer(...2)",
        "body": "(source not found)"
      },
      {
        "name": "XmlSerializerProvider#_asXmlGenerator(...1)",
        "body": "{\r\n    if (!(gen instanceof ToXmlGenerator)) {\r\n        // [dataformat-xml#71]: We sometimes get TokenBuffer, which is fine\r\n        if (gen instanceof TokenBuffer) {\r\n            return null;\r\n        }\r\n        // but verify\r\n        throw JsonMappingException.from(gen, \"XmlMapper does not work with generators of type other than `ToXmlGenerator`; got: `\" + gen.getClass().getName() + \"`\");\r\n    }\r\n    return (ToXmlGenerator) gen;\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_rootNameFromConfig(...0)",
        "body": "{\r\n    PropertyName name \u003d _config.getFullRootName();\r\n    if (name \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    String ns \u003d name.getNamespace();\r\n    if (ns \u003d\u003d null || ns.isEmpty()) {\r\n        return new QName(name.getSimpleName());\r\n    }\r\n    return new QName(ns, name.getSimpleName());\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_serializeXmlNull(...1)",
        "body": "{\r\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\r\n    //    configured root name...\r\n    QName rootName \u003d _rootNameFromConfig();\r\n    if (rootName \u003d\u003d null) {\r\n        rootName \u003d XmlRootNameLookup.ROOT_NAME_FOR_NULL;\r\n    }\r\n    if (gen instanceof ToXmlGenerator) {\r\n        _initWithRootName((ToXmlGenerator) gen, rootName);\r\n    }\r\n    super.serializeValue(gen, null);\r\n}"
      },
      {
        "name": "XmlSerializerProvider#_startRootArray(...2)",
        "body": "{\r\n    xgen.writeStartObject();\r\n    // Could repeat root name, but what\u0027s the point? How to customize?\r\n    xgen.writeFieldName(\"item\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil",
    "methodName": "findNamespaceAnnotation",
    "signature": "java.lang.String findNamespaceAnnotation(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.AnnotationIntrospector,com.fasterxml.jackson.databind.introspect.AnnotatedMember)",
    "visibility": "public",
    "body": "{\r\n    for (AnnotationIntrospector intr : ai.allIntrospectors()) {\r\n        if (intr instanceof AnnotationIntrospector.XmlExtensions) {\r\n            String ns \u003d ((AnnotationIntrospector.XmlExtensions) intr).findNamespace(config, prop);\r\n            if (ns !\u003d null) {\r\n                return ns;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(r8 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MapperConfig\n  AnnotationIntrospector\n  AnnotatedMember\n  $r1 \u003d r0.allIntrospectors()\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d AnnotationIntrospector) $r3\n  $z1 \u003d AnnotationIntrospector$XmlExtensions\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r7 \u003d AnnotationIntrospector$XmlExtensions) r4\n  r8 \u003d $r7.findNamespace(r5, r6)\n  if (r8 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil",
    "methodName": "findIsAttributeAnnotation",
    "signature": "java.lang.Boolean findIsAttributeAnnotation(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.AnnotationIntrospector,com.fasterxml.jackson.databind.introspect.AnnotatedMember)",
    "visibility": "public",
    "body": "{\r\n    for (AnnotationIntrospector intr : ai.allIntrospectors()) {\r\n        if (intr instanceof AnnotationIntrospector.XmlExtensions) {\r\n            Boolean b \u003d ((AnnotationIntrospector.XmlExtensions) intr).isOutputAsAttribute(config, prop);\r\n            if (b !\u003d null) {\r\n                return b;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(r8 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MapperConfig\n  AnnotationIntrospector\n  AnnotatedMember\n  $r1 \u003d r0.allIntrospectors()\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d AnnotationIntrospector) $r3\n  $z1 \u003d AnnotationIntrospector$XmlExtensions\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r7 \u003d AnnotationIntrospector$XmlExtensions) r4\n  r8 \u003d $r7.isOutputAsAttribute(r5, r6)\n  if (r8 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil",
    "methodName": "findIsTextAnnotation",
    "signature": "java.lang.Boolean findIsTextAnnotation(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.AnnotationIntrospector,com.fasterxml.jackson.databind.introspect.AnnotatedMember)",
    "visibility": "public",
    "body": "{\r\n    for (AnnotationIntrospector intr : ai.allIntrospectors()) {\r\n        if (intr instanceof AnnotationIntrospector.XmlExtensions) {\r\n            Boolean b \u003d ((AnnotationIntrospector.XmlExtensions) intr).isOutputAsText(config, prop);\r\n            if (b !\u003d null) {\r\n                return b;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(r8 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MapperConfig\n  AnnotationIntrospector\n  AnnotatedMember\n  $r1 \u003d r0.allIntrospectors()\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d AnnotationIntrospector) $r3\n  $z1 \u003d AnnotationIntrospector$XmlExtensions\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r7 \u003d AnnotationIntrospector$XmlExtensions) r4\n  r8 \u003d $r7.isOutputAsText(r5, r6)\n  if (r8 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil",
    "methodName": "findIsCDataAnnotation",
    "signature": "java.lang.Boolean findIsCDataAnnotation(com.fasterxml.jackson.databind.cfg.MapperConfig,com.fasterxml.jackson.databind.AnnotationIntrospector,com.fasterxml.jackson.databind.introspect.AnnotatedMember)",
    "visibility": "public",
    "body": "{\r\n    for (AnnotationIntrospector intr : ai.allIntrospectors()) {\r\n        if (intr instanceof AnnotationIntrospector.XmlExtensions) {\r\n            Boolean b \u003d ((AnnotationIntrospector.XmlExtensions) intr).isOutputAsCData(config, prop);\r\n            if (b !\u003d null) {\r\n                return b;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(r8 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MapperConfig\n  AnnotationIntrospector\n  AnnotatedMember\n  $r1 \u003d r0.allIntrospectors()\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d AnnotationIntrospector) $r3\n  $z1 \u003d AnnotationIntrospector$XmlExtensions\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r7 \u003d AnnotationIntrospector$XmlExtensions) r4\n  r8 \u003d $r7.isOutputAsCData(r5, r6)\n  if (r8 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.CaseInsensitiveNameSet",
    "methodName": "construct",
    "signature": "com.fasterxml.jackson.dataformat.xml.util.CaseInsensitiveNameSet construct(java.util.Set)",
    "visibility": "public",
    "body": "{\r\n    Set\u003cString\u003e namesToMatch \u003d new HashSet\u003cString\u003e(names0);\r\n    for (String name : names0) {\r\n        namesToMatch.add(name.toLowerCase());\r\n    }\r\n    return new CaseInsensitiveNameSet(namesToMatch);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Set\n  $r0 \u003d HashSet\n  new HashSet(r1)\n  r2 \u003d r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r2.next()\n  r5 \u003d String) $r4\n  $r6 \u003d r5.toLowerCase()\n  $r0.add($r6)\n  goto B1\n}",
      "B3 {\n  $r3 \u003d CaseInsensitiveNameSet\n  new CaseInsensitiveNameSet($r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.CaseInsensitiveNameSet",
    "methodName": "contains",
    "signature": "boolean contains(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    final String key \u003d (String) key0;\r\n    if (_namesToMatch.contains(key)) {\r\n        return true;\r\n    }\r\n    final String lc \u003d key.toLowerCase();\r\n    return (lc !\u003d key) \u0026\u0026 _namesToMatch.contains(lc);\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(r4 \u003d\u003d r1) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CaseInsensitiveNameSet\n  Object\n  r1 \u003d String) r0\n  $r3 \u003d Set _namesToMatch\u003e\n  $z0 \u003d $r3.contains(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r1.toLowerCase()\n  if (r4 \u003d\u003d r1) goto B3 else B5\n}",
      "B3 {\n  $r5 \u003d Set _namesToMatch\u003e\n  $z1 \u003d $r5.contains(r4)\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z2 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z2 \u003d 0\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "indentArraysWith",
    "signature": "void indentArraysWith(com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  DefaultXmlPrettyPrinter$Indenter\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DefaultXmlPrettyPrinter$NopIndenter\n  $r2 \u003d $r3\n  new DefaultXmlPrettyPrinter$NopIndenter()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  DefaultXmlPrettyPrinter$Indenter _arrayIndenter\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "indentObjectsWith",
    "signature": "void indentObjectsWith(com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  DefaultXmlPrettyPrinter$Indenter\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DefaultXmlPrettyPrinter$NopIndenter\n  $r2 \u003d $r3\n  new DefaultXmlPrettyPrinter$NopIndenter()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "withCustomNewLine",
    "signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter withCustomNewLine(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _newLine \u003d newLine !\u003d null ? newLine : SYSTEM_DEFAULT_NEW_LINE;\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  String\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d String SYSTEM_DEFAULT_NEW_LINE\u003e\n}",
      "B3 {\n  String _newLine\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        if (_nesting \u003e 0) {\r\n            _objectIndenter.writeIndentation(gen, _nesting);\r\n        }\r\n        ++_nesting;\r\n    }\r\n    _justHadStartElement \u003d true;\r\n    ((ToXmlGenerator) gen)._handleStartObject();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($i0 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  JsonGenerator\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  if ($i0 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i3 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r3.writeIndentation(r2, $i3)\n}",
      "B3 {\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $i2 \u003d $i1 + 1\n  DefaultXmlPrettyPrinter: int _nesting\u003e \u003d $i2\n}",
      "B4 {\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 1\n  $r4 \u003d ToXmlGenerator) r2\n  $r4._handleStartObject()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject(com.fasterxml.jackson.core.JsonGenerator,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        --_nesting;\r\n    }\r\n    // for empty elements, no need for linefeeds etc:\r\n    if (_justHadStartElement) {\r\n        _justHadStartElement \u003d false;\r\n    } else {\r\n        _objectIndenter.writeIndentation(gen, _nesting);\r\n    }\r\n    ((ToXmlGenerator) gen)._handleEndObject();\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  JsonGenerator\n  i3 :\u003d @parameter1: int\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $i2 \u003d $i1 - 1\n  DefaultXmlPrettyPrinter: int _nesting\u003e \u003d $i2\n}",
      "B2 {\n  $z1 \u003d DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r3 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r3.writeIndentation(r2, $i0)\n}",
      "B5 {\n  $r4 \u003d ToXmlGenerator) r2\n  $r4._handleEndObject()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeStartElement",
    "signature": "void writeStartElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        if (_justHadStartElement) {\r\n            _justHadStartElement \u003d false;\r\n        }\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n        ++_nesting;\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    _justHadStartElement \u003d true;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n}",
      "B3 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $i2 \u003d $i1 + 1\n  DefaultXmlPrettyPrinter: int _nesting\u003e \u003d $i2\n}",
      "B4 {\n  r2.writeStartElement(r3, r4)\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeEndElement",
    "signature": "void writeEndElement(org.codehaus.stax2.XMLStreamWriter2,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        --_nesting;\r\n    }\r\n    // for empty elements, no need for linefeeds etc:\r\n    if (_justHadStartElement) {\r\n        _justHadStartElement \u003d false;\r\n    } else {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeEndElement();\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  i3 :\u003d @parameter1: int\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $i2 \u003d $i1 - 1\n  DefaultXmlPrettyPrinter: int _nesting\u003e \u003d $i2\n}",
      "B2 {\n  $z1 \u003d DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r3 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r3.writeIndentation(r2, $i0)\n}",
      "B5 {\n  r2.writeEndElement()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    if (isCData) {\r\n        sw.writeCData(text);\r\n    } else {\r\n        sw.writeCharacters(text);\r\n    }\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  String\n  z1 :\u003d @parameter4: boolean\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r6.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  if (z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r2.writeCData(r5)\n  goto B5\n}",
      "B4 {\n  r2.writeCharacters(r5)\n}",
      "B5 {\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,char[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    if (isCData) {\r\n        sw.writeCData(buffer, offset, len);\r\n    } else {\r\n        sw.writeCharacters(buffer, offset, len);\r\n    }\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  r5 :\u003d @parameter3: char[]\n  i0 :\u003d @parameter4: int\n  i1 :\u003d @parameter5: int\n  z1 :\u003d @parameter6: boolean\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i2 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r6.writeIndentation(r2, $i2)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  if (z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r2.writeCData(r5, i0, i1)\n  goto B5\n}",
      "B4 {\n  r2.writeCharacters(r5, i0, i1)\n}",
      "B5 {\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeBoolean(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  z1 :\u003d @parameter3: boolean\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeBoolean(z1)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeInt(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  i0 :\u003d @parameter3: int\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i1)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeInt(i0)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,long)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeLong(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  l0 :\u003d @parameter3: long\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i1 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i1)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeLong(l0)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,double)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeDouble(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  d0 :\u003d @parameter3: double\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeDouble(d0)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,float)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeFloat(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  f0 :\u003d @parameter3: float\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeFloat(f0)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,java.math.BigInteger)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeInteger(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  BigInteger\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r6.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeInteger(r5)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,java.math.BigDecimal)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeDecimal(value);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  BigDecimal\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r6.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeDecimal(r5)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafElement",
    "signature": "void writeLeafElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String,org.codehaus.stax2.typed.Base64Variant,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeStartElement(nsURI, localName);\r\n    sw.writeBinary(base64variant, data, offset, len);\r\n    sw.writeEndElement();\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  Base64Variant\n  r6 :\u003d @parameter4: byte[]\n  i0 :\u003d @parameter5: int\n  i1 :\u003d @parameter6: int\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i2 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r7.writeIndentation(r2, $i2)\n}",
      "B2 {\n  r2.writeStartElement(r3, r4)\n  r2.writeBinary(r5, r6, i0, i1)\n  r2.writeEndElement()\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafNullElement",
    "signature": "void writeLeafNullElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeEmptyElement(nsURI, localName);\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeEmptyElement(r3, r4)\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter",
    "methodName": "writeLeafXsiNilElement",
    "signature": "void writeLeafXsiNilElement(org.codehaus.stax2.XMLStreamWriter2,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        _objectIndenter.writeIndentation(sw, _nesting);\r\n    }\r\n    sw.writeEmptyElement(nsURI, localName);\r\n    sw.writeAttribute(\"xsi\", XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI, \"nil\", \"true\");\r\n    _justHadStartElement \u003d false;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultXmlPrettyPrinter\n  XMLStreamWriter2\n  String\n  String\n  $r1 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d DefaultXmlPrettyPrinter$Indenter _objectIndenter\u003e\n  $i0 \u003d DefaultXmlPrettyPrinter: int _nesting\u003e\n  $r5.writeIndentation(r2, $i0)\n}",
      "B2 {\n  r2.writeEmptyElement(r3, r4)\n  r2.writeAttribute(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\", \"nil\", \"true\")\n  DefaultXmlPrettyPrinter: boolean _justHadStartElement\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.Stax2JacksonReaderAdapter",
    "methodName": "wrapIfNecessary",
    "signature": "org.codehaus.stax2.XMLStreamReader2 wrapIfNecessary(javax.xml.stream.XMLStreamReader)",
    "visibility": "public",
    "body": "{\r\n    if (sr instanceof XMLStreamReader2) {\r\n        return (XMLStreamReader2) sr;\r\n    }\r\n    return new Stax2JacksonReaderAdapter(sr);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XMLStreamReader\n  $z0 \u003d XMLStreamReader2\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d XMLStreamReader2) r0\n  return\n}",
      "B2 {\n  $r1 \u003d Stax2JacksonReaderAdapter\n  new Stax2JacksonReaderAdapter(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.StaxUtil",
    "methodName": "sanitizeXmlTypeName",
    "signature": "java.lang.String sanitizeXmlTypeName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // [dataformat-xml#451]: with DEDUCTION, at least, won\u0027t have property name\r\n    //   (but probably sensible to check for it anyway)\r\n    if (name \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb;\r\n    int changes \u003d 0;\r\n    // First things first: remove array types\u0027 trailing[]...\r\n    if (name.endsWith(\"[]\")) {\r\n        do {\r\n            name \u003d name.substring(0, name.length() - 2);\r\n            ++changes;\r\n        } while (name.endsWith(\"[]\"));\r\n        sb \u003d new StringBuilder(name);\r\n        // do trivial pluralization attempt\r\n        if (name.endsWith(\"s\")) {\r\n            sb.append(\"es\");\r\n        } else {\r\n            sb.append(\u0027s\u0027);\r\n        }\r\n    } else {\r\n        sb \u003d new StringBuilder(name);\r\n    }\r\n    for (int i \u003d 0, len \u003d name.length(); i \u003c len; ++i) {\r\n        char c \u003d name.charAt(i);\r\n        if (c \u003e 127)\r\n            continue;\r\n        if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027z\u0027)\r\n            continue;\r\n        if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027Z\u0027)\r\n            continue;\r\n        if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027)\r\n            continue;\r\n        if (c \u003d\u003d \u0027_\u0027 || c \u003d\u003d \u0027.\u0027 || c \u003d\u003d \u0027-\u0027)\r\n            continue;\r\n        // Ok, need to replace\r\n        ++changes;\r\n        if (c \u003d\u003d \u0027$\u0027) {\r\n            sb.setCharAt(i, \u0027.\u0027);\r\n        } else {\r\n            sb.setCharAt(i, \u0027_\u0027);\r\n        }\r\n    }\r\n    if (changes \u003d\u003d 0) {\r\n        return name;\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 32,
    "edges": 46,
    "cc": 16,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B7",
      "B3 : If($z1 !\u003d 0) → B4 | else → B3",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B9 : If(i4 \u003e\u003d $i5) → B10 | else → B29",
      "B10 : If($i6 \u003c\u003d 127) → B11 | else → B12",
      "B12 : If($i7 \u003c 97) → B13 | else → B15",
      "B13 : If($i8 \u003e 122) → B14 | else → B15",
      "B15 : If($i9 \u003c 65) → B16 | else → B18",
      "B16 : If($i10 \u003e 90) → B17 | else → B18",
      "B18 : If($i11 \u003c 48) → B19 | else → B21",
      "B19 : If($i12 \u003e 57) → B20 | else → B21",
      "B21 : If($i13 \u003d\u003d 95) → B22 | else → B28",
      "B22 : If($i14 \u003d\u003d 46) → B23 | else → B28",
      "B23 : If($i15 !\u003d 45) → B24 | else → B25",
      "B25 : If($i16 !\u003d 36) → B26 | else → B27",
      "B29 : If(i3 !\u003d 0) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i3 \u003d 0\n  $z0 \u003d r4.endsWith(\"\")\n  if ($z0 \u003d\u003d false) goto B3 else B7\n}",
      "B3 {\n  $i1 \u003d r4.length()\n  $i2 \u003d $i1 - 2\n  $r2 \u003d r4.substring(0, $i2)\n  r4 \u003d $r2\n  i3 \u003d i3 + 1\n  $z1 \u003d $r2.endsWith(\"\")\n  if ($z1 !\u003d 0) goto B4 else B3\n}",
      "B4 {\n  $r6 \u003d StringBuilder\n  new StringBuilder($r2)\n  r5 \u003d $r6\n  $z2 \u003d $r2.endsWith(\"s\")\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r6.append(\"es\")\n  goto B8\n}",
      "B6 {\n  $r6.append(115)\n  goto B8\n}",
      "B7 {\n  $r7 \u003d StringBuilder\n  new StringBuilder(r4)\n  r5 \u003d $r7\n}",
      "B8 {\n  i4 \u003d 0\n  $i5 \u003d r4.length()\n}",
      "B9 {\n  if (i4 \u003e\u003d $i5) goto B10 else B29\n}",
      "B10 {\n  c0 \u003d r4.charAt(i4)\n  $i6 \u003d (int) c0\n  if ($i6 \u003c\u003d 127) goto B11 else B12\n}",
      "B11 {\n  goto B28\n}",
      "B12 {\n  $i7 \u003d (int) c0\n  if ($i7 \u003c 97) goto B13 else B15\n}",
      "B13 {\n  $i8 \u003d (int) c0\n  if ($i8 \u003e 122) goto B14 else B15\n}",
      "B14 {\n  goto B28\n}",
      "B15 {\n  $i9 \u003d (int) c0\n  if ($i9 \u003c 65) goto B16 else B18\n}",
      "B16 {\n  $i10 \u003d (int) c0\n  if ($i10 \u003e 90) goto B17 else B18\n}",
      "B17 {\n  goto B28\n}",
      "B18 {\n  $i11 \u003d (int) c0\n  if ($i11 \u003c 48) goto B19 else B21\n}",
      "B19 {\n  $i12 \u003d (int) c0\n  if ($i12 \u003e 57) goto B20 else B21\n}",
      "B20 {\n  goto B28\n}",
      "B21 {\n  $i13 \u003d (int) c0\n  if ($i13 \u003d\u003d 95) goto B22 else B28\n}",
      "B22 {\n  $i14 \u003d (int) c0\n  if ($i14 \u003d\u003d 46) goto B23 else B28\n}",
      "B23 {\n  $i15 \u003d (int) c0\n  if ($i15 !\u003d 45) goto B24 else B25\n}",
      "B24 {\n  goto B28\n}",
      "B25 {\n  i3 \u003d i3 + 1\n  $i16 \u003d (int) c0\n  if ($i16 !\u003d 36) goto B26 else B27\n}",
      "B26 {\n  r5.setCharAt(i4, 46)\n  goto B28\n}",
      "B27 {\n  r5.setCharAt(i4, 95)\n}",
      "B28 {\n  i4 \u003d i4 + 1\n  goto B9\n}",
      "B29 {\n  if (i3 !\u003d 0) goto B30 else B31\n}",
      "B30 {\n  return\n}",
      "B31 {\n  $r1 \u003d r5.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B3",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B29",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B28",
      "B12 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B28",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B28",
      "B18 --\u003e B19",
      "B18 --\u003e B21",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B28",
      "B21 --\u003e B22",
      "B21 --\u003e B28",
      "B22 --\u003e B23",
      "B22 --\u003e B28",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B9",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil",
    "methodName": "isIndexedType",
    "signature": "boolean isIndexedType(com.fasterxml.jackson.databind.JavaType)",
    "visibility": "public",
    "body": "{\r\n    Class\u003c?\u003e cls \u003d type.getRawClass();\r\n    // 25-Mar-2024, tatu [dataformat-xml#646]: Need to support Iterable too\r\n    if (type.isContainerType() || type.isIterationType() || cls \u003d\u003d Iterable.class) {\r\n        // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\r\n        // (actually, ditto for char[]; thought to be a String)\r\n        if (cls \u003d\u003d byte[].class || cls \u003d\u003d char[].class) {\r\n            return false;\r\n        }\r\n        // Also, should not add wrapping for Maps\r\n        // [dataformat-xml#220]: nor map-like (Scala Map) types\r\n        if (type.isMapLikeType()) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z2 !\u003d 0) → B2 | else → B3",
      "B2 : If(r1 !\u003d class \"Ljava/lang/Iterable;\") → B3 | else → B9",
      "B3 : If(r1 \u003d\u003d class \"[B\") → B4 | else → B5",
      "B4 : If(r1 !\u003d class \"[C\") → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  JavaType\n  r1 \u003d r0.getRawClass()\n  $z0 \u003d r0.isContainerType()\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z2 \u003d r0.isIterationType()\n  if ($z2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  if (r1 !\u003d class \"Ljava/lang/Iterable;\") goto B3 else B9\n}",
      "B3 {\n  if (r1 \u003d\u003d class \"[B\") goto B4 else B5\n}",
      "B4 {\n  if (r1 !\u003d class \"[C\") goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $z1 \u003d r0.isMapLikeType()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup",
    "methodName": "findRootName",
    "signature": "javax.xml.namespace.QName findRootName(java.lang.Class,com.fasterxml.jackson.databind.cfg.MapperConfig)",
    "visibility": "public",
    "body": "{\r\n    ClassKey key \u003d new ClassKey(rootType);\r\n    QName name \u003d _rootNames.get(key);\r\n    if (name !\u003d null) {\r\n        return name;\r\n    }\r\n    name \u003d _findRootName(config, rootType);\r\n    _rootNames.put(key, name);\r\n    return name;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r7 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlRootNameLookup\n  Class\n  MapperConfig\n  $r0 \u003d ClassKey\n  new ClassKey(r1)\n  $r3 \u003d LRUMap _rootNames\u003e\n  $r4 \u003d $r3.get($r0)\n  r7 \u003d QName) $r4\n  if (r7 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r8 \u003d r2._findRootName(r5, r1)\n  $r6 \u003d LRUMap _rootNames\u003e\n  $r6.put($r0, r8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlRootNameLookup#_findRootName(...2)",
        "body": "{\r\n    BeanDescription beanDesc \u003d config.introspectClassAnnotations(rootType);\r\n    AnnotationIntrospector intr \u003d config.getAnnotationIntrospector();\r\n    AnnotatedClass ac \u003d beanDesc.getClassInfo();\r\n    String localName \u003d null;\r\n    String ns \u003d null;\r\n    PropertyName root \u003d intr.findRootName(ac);\r\n    if (root !\u003d null) {\r\n        localName \u003d root.getSimpleName();\r\n        ns \u003d root.getNamespace();\r\n    }\r\n    // No answer so far? Let\u0027s just default to using simple class name\r\n    if (localName \u003d\u003d null || localName.length() \u003d\u003d 0) {\r\n        // Should we strip out enclosing class tho? For now, nope:\r\n        // one caveat: array simple names end with \"[]\"; also, \"$\" needs replacing\r\n        localName \u003d StaxUtil.sanitizeXmlTypeName(rootType.getSimpleName());\r\n        return _qname(ns, localName);\r\n    }\r\n    // Otherwise let\u0027s see if there\u0027s namespace, too (if we are missing it)\r\n    if (ns \u003d\u003d null || ns.isEmpty()) {\r\n        ns \u003d _findNamespace(config, intr, ac);\r\n    }\r\n    return _qname(ns, localName);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory configure(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  FromXmlParser$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  FromXmlParser$Feature\n  $i0 \u003d XmlFactory: int _xmlParserFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory configure(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  ToXmlGenerator$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  ToXmlGenerator$Feature\n  $i0 \u003d XmlFactory: int _xmlGeneratorFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.core.JsonParser createParser(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    Reader r \u003d new StringReader(content);\r\n    IOContext ctxt \u003d _createContext(_createContentReference(r), true);\r\n    if (_inputDecorator !\u003d null) {\r\n        r \u003d _inputDecorator.decorate(ctxt, r);\r\n    }\r\n    return _createParser(r, ctxt);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  String\n  $r0 \u003d StringReader\n  new StringReader(r1)\n  r8 \u003d $r0\n  $r3 \u003d r2._createContentReference($r0)\n  r4 \u003d r2._createContext($r3, 1)\n  $r5 \u003d InputDecorator _inputDecorator\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d InputDecorator _inputDecorator\u003e\n  r8 \u003d $r7.decorate(r4, $r0)\n}",
      "B2 {\n  $r6 \u003d r2._createParser(r8, r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlFactory#_createContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "XmlFactory#_createParser(...2)",
        "body": "{\r\n    XMLStreamReader sr;\r\n    try {\r\n        sr \u003d _xmlInputFactory.createXMLStreamReader(in);\r\n    } catch (XMLStreamException e) {\r\n        return StaxUtil.throwAsParseException(e, null);\r\n    }\r\n    sr \u003d _initializeXmlReader(sr);\r\n    FromXmlParser xp \u003d new FromXmlParser(ctxt, _parserFeatures, _xmlParserFeatures, _objectCodec, sr, _nameProcessor);\r\n    if (_cfgNameForTextElement !\u003d null) {\r\n        xp.setXMLTextElementName(_cfgNameForTextElement);\r\n    }\r\n    return xp;\r\n}"
      },
      {
        "name": "XmlFactory#_createContentReference(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser createParser(javax.xml.stream.XMLStreamReader)",
    "visibility": "public",
    "body": "{\r\n    // note: should NOT move parser if already pointing to START_ELEMENT\r\n    if (sr.getEventType() !\u003d XMLStreamConstants.START_ELEMENT) {\r\n        sr \u003d _initializeXmlReader(sr);\r\n    }\r\n    // false -\u003e not managed\r\n    FromXmlParser xp \u003d new FromXmlParser(_createContext(_createContentReference(sr), false), _parserFeatures, _xmlParserFeatures, _objectCodec, sr, _nameProcessor);\r\n    if (_cfgNameForTextElement !\u003d null) {\r\n        xp.setXMLTextElementName(_cfgNameForTextElement);\r\n    }\r\n    return xp;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 1) → B1 | else → B2",
      "B2 : If($r6 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  XmlFactory\n  XMLStreamReader\n  $i0 \u003d r8.getEventType()\n  if ($i0 \u003d\u003d 1) goto B1 else B2\n}",
      "B1 {\n  r8 \u003d r1._initializeXmlReader(r8)\n}",
      "B2 {\n  $r0 \u003d FromXmlParser\n  $r2 \u003d r1._createContentReference(r8)\n  $r5 \u003d r1._createContext($r2, 0)\n  $i2 \u003d XmlFactory: int _parserFeatures\u003e\n  $i1 \u003d XmlFactory: int _xmlParserFeatures\u003e\n  $r4 \u003d ObjectCodec _objectCodec\u003e\n  $r3 \u003d XmlNameProcessor _nameProcessor\u003e\n  new FromXmlParser($r5, $i2, $i1, $r4, r8, $r3)\n  $r6 \u003d String _cfgNameForTextElement\u003e\n  if ($r6 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d String _cfgNameForTextElement\u003e\n  $r0.setXMLTextElementName($r7)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlFactory#_initializeXmlReader(...1)",
        "body": "{\r\n    try {\r\n        // for now, nothing to do... except let\u0027s find the root element\r\n        while (sr.next() !\u003d XMLStreamConstants.START_ELEMENT) {\r\n            ;\r\n        }\r\n        // [dataformat-xml#350]: Xerces-backed impl throws non-XMLStreamException so:\r\n    } catch (Exception e) {\r\n        throw new JsonParseException(null, e.getMessage(), e);\r\n    }\r\n    return sr;\r\n}"
      },
      {
        "name": "XmlFactory#_createContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "XmlFactory#_createContentReference(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactory",
    "methodName": "hasXMLFormat",
    "signature": "com.fasterxml.jackson.core.format.MatchStrength hasXMLFormat(com.fasterxml.jackson.core.format.InputAccessor)",
    "visibility": "public",
    "body": "{\r\n    /* Basically we just need to find \"\u003c!\", \"\u003c?\" or \"\u003cNAME\"... but ideally\r\n         * we would actually see the XML declaration\r\n         */\r\n    if (!acc.hasMoreBytes()) {\r\n        return MatchStrength.INCONCLUSIVE;\r\n    }\r\n    byte b \u003d acc.nextByte();\r\n    // Very first thing, a UTF-8 BOM? (later improvements: other BOM\u0027s, heuristics)\r\n    if (b \u003d\u003d UTF8_BOM_1) {\r\n        // yes, looks like UTF-8 BOM\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d UTF8_BOM_2) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d UTF8_BOM_3) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        b \u003d acc.nextByte();\r\n    }\r\n    // otherwise: XML declaration?\r\n    boolean maybeXmlDecl \u003d (b \u003d\u003d BYTE_LT);\r\n    if (!maybeXmlDecl) {\r\n        int ch \u003d skipSpace(acc, b);\r\n        if (ch \u003c 0) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        b \u003d (byte) ch;\r\n        // If we did not get an LT, shouldn\u0027t be valid XML (minus encoding issues etc)\r\n        if (b !\u003d BYTE_LT) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n    }\r\n    if (!acc.hasMoreBytes()) {\r\n        return MatchStrength.INCONCLUSIVE;\r\n    }\r\n    b \u003d acc.nextByte();\r\n    // Couple of choices here\r\n    if (b \u003d\u003d BYTE_QMARK) {\r\n        // \u003c?\r\n        b \u003d acc.nextByte();\r\n        if (b \u003d\u003d BYTE_x) {\r\n            if (maybeXmlDecl) {\r\n                if (acc.hasMoreBytes() \u0026\u0026 acc.nextByte() \u003d\u003d BYTE_m) {\r\n                    if (acc.hasMoreBytes() \u0026\u0026 acc.nextByte() \u003d\u003d BYTE_l) {\r\n                        return MatchStrength.FULL_MATCH;\r\n                    }\r\n                }\r\n            }\r\n            // but even with just partial match, we ought to be fine\r\n            return MatchStrength.SOLID_MATCH;\r\n        }\r\n        // Ok to start with some other char too; just not xml declaration\r\n        if (validXmlNameStartChar(acc, b)) {\r\n            return MatchStrength.SOLID_MATCH;\r\n        }\r\n    } else if (b \u003d\u003d BYTE_EXCL) {\r\n        /* must be \u003c!-- comment --\u003e or \u003c!DOCTYPE ...\u003e, since\r\n             * \u003c![CDATA[ ]]\u003e can NOT come outside of root\r\n             */\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        b \u003d acc.nextByte();\r\n        if (b \u003d\u003d BYTE_HYPHEN) {\r\n            if (!acc.hasMoreBytes()) {\r\n                return MatchStrength.INCONCLUSIVE;\r\n            }\r\n            if (acc.nextByte() \u003d\u003d BYTE_HYPHEN) {\r\n                return MatchStrength.SOLID_MATCH;\r\n            }\r\n        } else if (b \u003d\u003d BYTE_D) {\r\n            return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\r\n        }\r\n    } else {\r\n        // maybe root element? Just needs to match first char.\r\n        if (validXmlNameStartChar(acc, b)) {\r\n            return MatchStrength.SOLID_MATCH;\r\n        }\r\n    }\r\n    return MatchStrength.NO_MATCH;\r\n}",
    "nodes": 48,
    "edges": 57,
    "cc": 11,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i11 !\u003d $i13) → B3 | else → B14",
      "B3 : If($z9 !\u003d 0) → B4 | else → B5",
      "B5 : If($i14 \u003d\u003d $i16) → B6 | else → B7",
      "B7 : If($z10 !\u003d 0) → B8 | else → B9",
      "B9 : If($i17 \u003d\u003d $i19) → B10 | else → B11",
      "B11 : If($z11 !\u003d 0) → B12 | else → B13",
      "B14 : If($i20 !\u003d 60) → B15 | else → B16",
      "B17 : If($z14 !\u003d 0) → B18 | else → B22",
      "B18 : If(i3 \u003e\u003d 0) → B19 | else → B20",
      "B20 : If($i21 \u003d\u003d 60) → B21 | else → B22",
      "B22 : If($z2 !\u003d 0) → B23 | else → B24",
      "B24 : If($i22 !\u003d 63) → B25 | else → B35",
      "B25 : If($i23 !\u003d 120) → B26 | else → B33",
      "B26 : If(z1 \u003d\u003d false) → B27 | else → B32",
      "B27 : If($z7 \u003d\u003d false) → B28 | else → B32",
      "B28 : If($i24 !\u003d 109) → B29 | else → B32",
      "B29 : If($z8 \u003d\u003d false) → B30 | else → B32",
      "B30 : If($i25 !\u003d 108) → B31 | else → B32",
      "B33 : If($z6 \u003d\u003d false) → B34 | else → B47",
      "B35 : If($i26 !\u003d 33) → B36 | else → B45",
      "B36 : If($z4 !\u003d 0) → B37 | else → B38",
      "B38 : If($i27 !\u003d 45) → B39 | else → B43",
      "B39 : If($z5 !\u003d 0) → B40 | else → B41",
      "B41 : If($i28 !\u003d 45) → B42 | else → B47",
      "B43 : If($i29 !\u003d 68) → B44 | else → B47",
      "B45 : If($z3 \u003d\u003d false) → B46 | else → B47"
    ],
    "blockList": [
      "B0 {\n  InputAccessor\n  $z0 \u003d r0.hasMoreBytes()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r17 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B2 {\n  b6 \u003d r0.nextByte()\n  $i11 \u003d (int) b6\n  $i13 \u003d (int) -17\n  if ($i11 !\u003d $i13) goto B3 else B14\n}",
      "B3 {\n  $z9 \u003d r0.hasMoreBytes()\n  if ($z9 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r16 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B5 {\n  $b4 \u003d r0.nextByte()\n  $i14 \u003d (int) $b4\n  $i16 \u003d (int) -69\n  if ($i14 \u003d\u003d $i16) goto B6 else B7\n}",
      "B6 {\n  $r15 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B7 {\n  $z10 \u003d r0.hasMoreBytes()\n  if ($z10 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $r14 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B9 {\n  $b5 \u003d r0.nextByte()\n  $i17 \u003d (int) $b5\n  $i19 \u003d (int) -65\n  if ($i17 \u003d\u003d $i19) goto B10 else B11\n}",
      "B10 {\n  $r13 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B11 {\n  $z11 \u003d r0.hasMoreBytes()\n  if ($z11 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r12 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B13 {\n  b6 \u003d r0.nextByte()\n}",
      "B14 {\n  $i20 \u003d (int) b6\n  if ($i20 !\u003d 60) goto B15 else B16\n}",
      "B15 {\n  $z14 \u003d 1\n  $z13 \u003d 1\n  goto B17\n}",
      "B16 {\n  $z14 \u003d 0\n  $z13 \u003d 0\n}",
      "B17 {\n  z1 \u003d $z13\n  if ($z14 !\u003d 0) goto B18 else B22\n}",
      "B18 {\n  i3 \u003d XmlFactory.skipSpace(r0, b6)\n  if (i3 \u003e\u003d 0) goto B19 else B20\n}",
      "B19 {\n  $r11 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B20 {\n  b7 \u003d (byte) i3\n  $i21 \u003d (int) b7\n  if ($i21 \u003d\u003d 60) goto B21 else B22\n}",
      "B21 {\n  $r10 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B22 {\n  $z2 \u003d r0.hasMoreBytes()\n  if ($z2 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  $r9 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B24 {\n  b8 \u003d r0.nextByte()\n  $i22 \u003d (int) b8\n  if ($i22 !\u003d 63) goto B25 else B35\n}",
      "B25 {\n  b9 \u003d r0.nextByte()\n  $i23 \u003d (int) b9\n  if ($i23 !\u003d 120) goto B26 else B33\n}",
      "B26 {\n  if (z1 \u003d\u003d false) goto B27 else B32\n}",
      "B27 {\n  $z7 \u003d r0.hasMoreBytes()\n  if ($z7 \u003d\u003d false) goto B28 else B32\n}",
      "B28 {\n  $b1 \u003d r0.nextByte()\n  $i24 \u003d (int) $b1\n  if ($i24 !\u003d 109) goto B29 else B32\n}",
      "B29 {\n  $z8 \u003d r0.hasMoreBytes()\n  if ($z8 \u003d\u003d false) goto B30 else B32\n}",
      "B30 {\n  $b2 \u003d r0.nextByte()\n  $i25 \u003d (int) $b2\n  if ($i25 !\u003d 108) goto B31 else B32\n}",
      "B31 {\n  $r8 \u003d MatchStrength FULL_MATCH\u003e\n  return\n}",
      "B32 {\n  $r18 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B33 {\n  $z6 \u003d XmlFactory.validXmlNameStartChar(r0, b9)\n  if ($z6 \u003d\u003d false) goto B34 else B47\n}",
      "B34 {\n  $r7 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B35 {\n  $i26 \u003d (int) b8\n  if ($i26 !\u003d 33) goto B36 else B45\n}",
      "B36 {\n  $z4 \u003d r0.hasMoreBytes()\n  if ($z4 !\u003d 0) goto B37 else B38\n}",
      "B37 {\n  $r6 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B38 {\n  b10 \u003d r0.nextByte()\n  $i27 \u003d (int) b10\n  if ($i27 !\u003d 45) goto B39 else B43\n}",
      "B39 {\n  $z5 \u003d r0.hasMoreBytes()\n  if ($z5 !\u003d 0) goto B40 else B41\n}",
      "B40 {\n  $r5 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B41 {\n  $b0 \u003d r0.nextByte()\n  $i28 \u003d (int) $b0\n  if ($i28 !\u003d 45) goto B42 else B47\n}",
      "B42 {\n  $r4 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B43 {\n  $i29 \u003d (int) b10\n  if ($i29 !\u003d 68) goto B44 else B47\n}",
      "B44 {\n  $r2 \u003d MatchStrength SOLID_MATCH\u003e\n  $r3 \u003d XmlFactory.tryMatch(r0, \"OCTYPE\", $r2)\n  return\n}",
      "B45 {\n  $z3 \u003d XmlFactory.validXmlNameStartChar(r0, b8)\n  if ($z3 \u003d\u003d false) goto B46 else B47\n}",
      "B46 {\n  $r1 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B47 {\n  $r19 \u003d MatchStrength NO_MATCH\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B14",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B22",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e B25",
      "B24 --\u003e B35",
      "B25 --\u003e B26",
      "B25 --\u003e B33",
      "B26 --\u003e B27",
      "B26 --\u003e B32",
      "B27 --\u003e B28",
      "B27 --\u003e B32",
      "B28 --\u003e B29",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B32",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e [EXIT]",
      "B33 --\u003e B34",
      "B33 --\u003e B47",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e B36",
      "B35 --\u003e B45",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e B39",
      "B38 --\u003e B43",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e [EXIT]",
      "B41 --\u003e B42",
      "B41 --\u003e B47",
      "B42 --\u003e [EXIT]",
      "B43 --\u003e B44",
      "B43 --\u003e B47",
      "B44 --\u003e [EXIT]",
      "B45 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e [EXIT]",
      "B47 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlFactory#validXmlNameStartChar(...2)",
        "body": "{\r\n    /* Can make it actual real XML check in future; for now we do just crude\r\n         * check for ASCII range\r\n         */\r\n    int ch \u003d (int) b \u0026 0xFF;\r\n    if (ch \u003e\u003d \u0027A\u0027) {\r\n        // in theory, colon could be; in practice it should never be valid (wrt namespace)\r\n        // This is where we\u0027d check for multi-byte UTF-8 chars (or whatever encoding is in use)...\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "XmlFactory#tryMatch(...3)",
        "body": "{\r\n    for (int i \u003d 0, len \u003d matchStr.length(); i \u003c len; ++i) {\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d matchStr.charAt(i)) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n    }\r\n    return fullMatchStrength;\r\n}"
      },
      {
        "name": "XmlFactory#skipSpace(...2)",
        "body": "{\r\n    while (true) {\r\n        int ch \u003d (int) b \u0026 0xFF;\r\n        if (!(ch \u003d\u003d \u0027 \u0027 || ch \u003d\u003d \u0027\\r\u0027 || ch \u003d\u003d \u0027\\n\u0027 || ch \u003d\u003d \u0027\\t\u0027)) {\r\n            return ch;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return -1;\r\n        }\r\n        b \u003d acc.nextByte();\r\n        ch \u003d (int) b \u0026 0xFF;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "xmlInputFactory",
    "signature": "javax.xml.stream.XMLInputFactory xmlInputFactory()",
    "visibility": "public",
    "body": "{\r\n    if (_xmlInputFactory \u003d\u003d null) {\r\n        return defaultInputFactory();\r\n    }\r\n    return _xmlInputFactory;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  $r1 \u003d XMLInputFactory _xmlInputFactory\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.defaultInputFactory()\n  return\n}",
      "B2 {\n  $r2 \u003d XMLInputFactory _xmlInputFactory\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlFactoryBuilder#defaultInputFactory(...0)",
        "body": "{\r\n    XMLInputFactory xmlIn \u003d StaxUtil.defaultInputFactory(_classLoaderForStax);\r\n    // as per [dataformat-xml#190], disable external entity expansion by default\r\n    xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\r\n    // and ditto wrt [dataformat-xml#211], SUPPORT_DTD\r\n    xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\r\n    return xmlIn;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "xmlOutputFactory",
    "signature": "javax.xml.stream.XMLOutputFactory xmlOutputFactory()",
    "visibility": "public",
    "body": "{\r\n    if (_xmlOutputFactory \u003d\u003d null) {\r\n        return defaultOutputFactory();\r\n    }\r\n    return _xmlOutputFactory;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  $r1 \u003d XMLOutputFactory _xmlOutputFactory\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.defaultOutputFactory()\n  return\n}",
      "B2 {\n  $r2 \u003d XMLOutputFactory _xmlOutputFactory\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlFactoryBuilder#defaultOutputFactory(...0)",
        "body": "{\r\n    XMLOutputFactory xmlOut \u003d StaxUtil.defaultOutputFactory(_classLoaderForStax);\r\n    // [dataformat-xml#326]: Better ensure namespaces get built properly:\r\n    xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\r\n    return xmlOut;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "enable",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder enable(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature,com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  FromXmlParser$Feature\n  FromXmlParser$Feature[]\n  $i0 \u003d XmlFactoryBuilder: int _formatParserFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 | $i1\n  XmlFactoryBuilder: int _formatParserFeatures\u003e \u003d $i2\n  i3 \u003d lengthof r2\n  i7 \u003d 0\n}",
      "B1 {\n  if (i7 \u003e\u003d i3) goto B2 else B3\n}",
      "B2 {\n  r5 \u003d r2[i7]\n  $i4 \u003d XmlFactoryBuilder: int _formatParserFeatures\u003e\n  $i5 \u003d r5.getMask()\n  $i6 \u003d $i4 | $i5\n  XmlFactoryBuilder: int _formatParserFeatures\u003e \u003d $i6\n  i7 \u003d i7 + 1\n  goto B1\n}",
      "B3 {\n  $r3 \u003d r0._this()\n  $r4 \u003d XmlFactoryBuilder) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "disable",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder disable(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature,com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d i4) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  FromXmlParser$Feature\n  FromXmlParser$Feature[]\n  $i0 \u003d XmlFactoryBuilder: int _formatParserFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i11 \u003d (int) -1\n  $i2 \u003d $i1 ^ $i11\n  $i3 \u003d $i0 \u0026 $i2\n  XmlFactoryBuilder: int _formatParserFeatures\u003e \u003d $i3\n  i4 \u003d lengthof r2\n  i9 \u003d 0\n}",
      "B1 {\n  if (i9 \u003e\u003d i4) goto B2 else B3\n}",
      "B2 {\n  r5 \u003d r2[i9]\n  $i5 \u003d XmlFactoryBuilder: int _formatParserFeatures\u003e\n  $i6 \u003d r5.getMask()\n  $i13 \u003d (int) -1\n  $i7 \u003d $i6 ^ $i13\n  $i8 \u003d $i5 \u0026 $i7\n  XmlFactoryBuilder: int _formatParserFeatures\u003e \u003d $i8\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B3 {\n  $r3 \u003d r0._this()\n  $r4 \u003d XmlFactoryBuilder) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder configure(com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  FromXmlParser$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "enable",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder enable(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature,com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  ToXmlGenerator$Feature\n  ToXmlGenerator$Feature[]\n  $i0 \u003d XmlFactoryBuilder: int _formatGeneratorFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 | $i1\n  XmlFactoryBuilder: int _formatGeneratorFeatures\u003e \u003d $i2\n  i3 \u003d lengthof r2\n  i7 \u003d 0\n}",
      "B1 {\n  if (i7 \u003e\u003d i3) goto B2 else B3\n}",
      "B2 {\n  r5 \u003d r2[i7]\n  $i4 \u003d XmlFactoryBuilder: int _formatGeneratorFeatures\u003e\n  $i5 \u003d r5.getMask()\n  $i6 \u003d $i4 | $i5\n  XmlFactoryBuilder: int _formatGeneratorFeatures\u003e \u003d $i6\n  i7 \u003d i7 + 1\n  goto B1\n}",
      "B3 {\n  $r3 \u003d r0._this()\n  $r4 \u003d XmlFactoryBuilder) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "disable",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder disable(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature,com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d i4) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  ToXmlGenerator$Feature\n  ToXmlGenerator$Feature[]\n  $i0 \u003d XmlFactoryBuilder: int _formatGeneratorFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i11 \u003d (int) -1\n  $i2 \u003d $i1 ^ $i11\n  $i3 \u003d $i0 \u0026 $i2\n  XmlFactoryBuilder: int _formatGeneratorFeatures\u003e \u003d $i3\n  i4 \u003d lengthof r2\n  i9 \u003d 0\n}",
      "B1 {\n  if (i9 \u003e\u003d i4) goto B2 else B3\n}",
      "B2 {\n  r5 \u003d r2[i9]\n  $i5 \u003d XmlFactoryBuilder: int _formatGeneratorFeatures\u003e\n  $i6 \u003d r5.getMask()\n  $i13 \u003d (int) -1\n  $i7 \u003d $i6 ^ $i13\n  $i8 \u003d $i5 \u0026 $i7\n  XmlFactoryBuilder: int _formatGeneratorFeatures\u003e \u003d $i8\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B3 {\n  $r3 \u003d r0._this()\n  $r4 \u003d XmlFactoryBuilder) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlFactoryBuilder configure(com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XmlFactoryBuilder\n  ToXmlGenerator$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.dataformat.xml.XmlMapper",
    "methodName": "setDefaultUseWrapper",
    "signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper setDefaultUseWrapper(boolean)",
    "visibility": "public",
    "body": "{\r\n    // ser and deser configs should usually have the same introspector, so:\r\n    AnnotationIntrospector ai0 \u003d getDeserializationConfig().getAnnotationIntrospector();\r\n    for (AnnotationIntrospector ai : ai0.allIntrospectors()) {\r\n        if (ai instanceof JacksonXmlAnnotationIntrospector) {\r\n            ((JacksonXmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\r\n        }\r\n    }\r\n    return this;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  XmlMapper\n  z2 :\u003d @parameter0: boolean\n  $r1 \u003d r0.getDeserializationConfig()\n  r2 \u003d $r1.getAnnotationIntrospector()\n  $r3 \u003d r2.allIntrospectors()\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r5 \u003d r4.next()\n  r6 \u003d AnnotationIntrospector) $r5\n  $z1 \u003d JacksonXmlAnnotationIntrospector\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d JacksonXmlAnnotationIntrospector) r6\n  $r7.setDefaultUseWrapper(z2)\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XmlMapper#getDeserializationConfig(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "MethodAnalysisToJson",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 72,
    "edges": 101,
    "cc": 31,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B67",
      "B3 : If($z16 \u003d\u003d false) → B4 | else → B66",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B8 : If(i1 \u003d\u003d false) → B9 | else → B3",
      "B9 : If(i2 !\u003d 0) → B10 | else → B11",
      "B11 : If(i4 \u003e 0) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i13 \u003c\u003d 0) → B16 | else → B17",
      "B19 : If($z17 \u003d\u003d false) → B20 | else → B28",
      "B20 : If($i10 \u003e\u003d 2) → B21 | else → B22",
      "B22 : If($z13 \u003d\u003d false) → B23 | else → B24",
      "B24 : If($z14 !\u003d 0) → B25 | else → B26",
      "B25 : If($z15 \u003d\u003d false) → B26 | else → B19",
      "B28 : If(r140 \u003d\u003d null) → B29 | else → B32",
      "B29 : If($z11 \u003d\u003d false) → B30 | else → B32",
      "B30 : If($z12 \u003d\u003d false) → B31 | else → B32",
      "B32 : If($z18 \u003d\u003d false) → B33 | else → B36",
      "B33 : If(i11 \u003e\u003d i12) → B34 | else → B36",
      "B36 : If(r140 \u003d\u003d null) → B37 | else → B39",
      "B37 : If($z10 \u003d\u003d false) → B38 | else → B39",
      "B40 : If($z19 \u003d\u003d false) → B41 | else → B56",
      "B41 : If($z6 \u003d\u003d false) → B42 | else → B43",
      "B44 : If($z7 \u003d\u003d false) → B45 | else → B46",
      "B47 : If($z8 !\u003d 0) → B48 | else → B49",
      "B49 : If($z9 \u003d\u003d false) → B50 | else → B51",
      "B52 : If($r74 \u003d\u003d null) → B53 | else → B54",
      "B57 : If($z3 \u003d\u003d false) → B58 | else → B65",
      "B58 : If(r151 \u003d\u003d null) → B59 | else → B60",
      "B60 : If($z4 \u003d\u003d false) → B61 | else → B64",
      "B61 : If(r59 \u003d\u003d null) → B62 | else → B64",
      "B62 : If($z5 \u003d\u003d false) → B63 | else → B64"
    ],
    "blockList": [
      "B0 {\n  String[]\n  G.reset()\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r1 \u003d Options.v()\n  $r1.set_allow_phantom_refs(1)\n  $r3 \u003d Options.v()\n  $r2 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-dataformat-xml-jackson-dataformat-xml-2.19.1\\\\target\\\\classes\")\n  $r3.set_process_dir($r2)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r9 \u003d Options.v()\n  $r6 \u003d String pathSeparator\u003e\n  $r5 \u003d CharSequence)[2]\n  $r5[0] \u003d 1\\\\target\\\\classes\"\n  $r7 \u003d System.getProperty(\"java.class.path\")\n  $r5[1] \u003d $r7\n  $r8 \u003d String.join($r6, $r5)\n  $r9.set_soot_classpath($r8)\n  $r10 \u003d Scene.v()\n  $r10.loadNecessaryClasses()\n  $r11 \u003d HashMap\n  new HashMap()\n  $r13 \u003d Path SOURCE_ROOT\u003e\n  $r12 \u003d FileVisitOption)[0]\n  $r15 \u003d Files.walk($r13, $r12)\n  $r14 \u003d MethodAnalysisToJson$lambda_main_2__1.bootstrap$()\n  $r17 \u003d $r15.filter($r14)\n  $r16 \u003d MethodAnalysisToJson$lambda_main_3__2.bootstrap$($r11)\n  $r17.forEach($r16)\n  $r18 \u003d ArrayList\n  new ArrayList()\n  $r19 \u003d HashMap\n  new HashMap()\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  r119 \u003d $r20.iterator()\n}",
      "B1 {\n  $z0 \u003d r119.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B67\n}",
      "B2 {\n  $r28 \u003d r119.next()\n  r120 \u003d SootClass) $r28\n  $r29 \u003d ArrayList\n  $r30 \u003d r120.getMethods()\n  new ArrayList($r30)\n  r121 \u003d $r29.iterator()\n}",
      "B3 {\n  $z16 \u003d r121.hasNext()\n  if ($z16 \u003d\u003d false) goto B4 else B66\n}",
      "B4 {\n  $r31 \u003d r121.next()\n  r122 \u003d SootMethod) $r31\n  $z1 \u003d MethodAnalysisToJson.isEligible(r120, r122)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r32 \u003d r122.retrieveActiveBody()\n  goto B8\n}",
      "B7 {\n  $r117 :\u003d @caughtexception\n  goto B3\n}",
      "B8 {\n  $r33 \u003d BriefBlockGraph\n  new BriefBlockGraph(r32)\n  i1 \u003d $r33.size()\n  $r34 \u003d $r33.getBlocks()\n  $r36 \u003d $r34.stream()\n  $r35 \u003d MethodAnalysisToJson$lambda_main_4__3.bootstrap$($r33)\n  $r37 \u003d $r36.mapToInt($r35)\n  i2 \u003d $r37.sum()\n  $i3 \u003d i2 - i1\n  i4 \u003d $i3 + 2\n  if (i1 \u003d\u003d false) goto B9 else B3\n}",
      "B9 {\n  if (i2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  goto B3\n}",
      "B11 {\n  if (i4 \u003e 0) goto B12 else B13\n}",
      "B12 {\n  goto B3\n}",
      "B13 {\n  i11 \u003d 2147483647\n  i12 \u003d -2147483648\n  $r38 \u003d r32.getUnits()\n  r123 \u003d $r38.iterator()\n}",
      "B14 {\n  $z2 \u003d r123.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r113 \u003d r123.next()\n  r124 \u003d Unit) $r113\n  i13 \u003d r124.getJavaSourceStartLineNumber()\n  if (i13 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i11 \u003d Math.min(i11, i13)\n  i12 \u003d Math.max(i12, i13)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  $r39 \u003d ArrayList\n  new ArrayList()\n  r125 \u003d $r33.iterator()\n}",
      "B19 {\n  $z17 \u003d r125.hasNext()\n  if ($z17 \u003d\u003d false) goto B20 else B28\n}",
      "B20 {\n  $r105 \u003d r125.next()\n  r126 \u003d Block) $r105\n  r127 \u003d $r33.getSuccsOf(r126)\n  $i10 \u003d r127.size()\n  if ($i10 \u003e\u003d 2) goto B21 else B22\n}",
      "B21 {\n  goto B19\n}",
      "B22 {\n  r128 \u003d r126.getTail()\n  $z13 \u003d IfStmt\n  if ($z13 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r111 \u003d IfStmt) r128\n  $r112 \u003d $r111.getCondition()\n  r129 \u003d $r112.toString()\n  goto B27\n}",
      "B24 {\n  $z14 \u003d LookupSwitchStmt\n  if ($z14 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  $z15 \u003d TableSwitchStmt\n  if ($z15 \u003d\u003d false) goto B26 else B19\n}",
      "B26 {\n  $r106 \u003d r128.getUseBoxes()\n  $r107 \u003d $r106.get(0)\n  $r108 \u003d ValueBox) $r107\n  $r109 \u003d $r108.getValue()\n  $r110 \u003d String.valueOf($r109)\n  r129 \u003d dynInvoke makeConcatWithConstants($r110)\n}",
      "B27 {\n  $r130 \u003d Object)[4]\n  $i14 \u003d r126.getIndexInMethod()\n  $r131 \u003d Integer.valueOf($i14)\n  $r130[0] \u003d $r131\n  $r130[1] \u003d r129\n  $r132 \u003d r127.get(0)\n  $r133 \u003d Block) $r132\n  $i15 \u003d $r133.getIndexInMethod()\n  $r134 \u003d Integer.valueOf($i15)\n  $r130[2] \u003d $r134\n  $r135 \u003d r127.get(1)\n  $r136 \u003d Block) $r135\n  $i16 \u003d $r136.getIndexInMethod()\n  $r137 \u003d Integer.valueOf($i16)\n  $r130[3] \u003d $r137\n  $r138 \u003d String.format(\"B%d : If(%s) \\u2192 B%d | else \\u2192 B%d\", $r130)\n  $r39.add($r138)\n  goto B19\n}",
      "B28 {\n  r139 \u003d r120.getName()\n  $r40 \u003d MethodAnalysisToJson$lambda_main_5__4.bootstrap$()\n  $r41 \u003d $r19.computeIfAbsent(r139, $r40)\n  r140 \u003d CompilationUnit) $r41\n  r141 \u003d \"(source not found)\"\n  r142 \u003d r122.getSubSignature()\n  MethodAnalysisToJson.toSimpleSig(r142)\n  if (r140 \u003d\u003d null) goto B29 else B32\n}",
      "B29 {\n  $r92 \u003d r120.getShortName()\n  r143 \u003d r140.getClassByName($r92)\n  $z11 \u003d r143.isPresent()\n  if ($z11 \u003d\u003d false) goto B30 else B32\n}",
      "B30 {\n  $r93 \u003d r143.get()\n  $r94 \u003d ClassOrInterfaceDeclaration) $r93\n  $r95 \u003d $r94.getMethods()\n  $r97 \u003d $r95.stream()\n  $r96 \u003d MethodAnalysisToJson$lambda_main_6__7.bootstrap$(r122)\n  $r98 \u003d $r97.filter($r96)\n  r144 \u003d $r98.findFirst()\n  $z12 \u003d r144.isPresent()\n  if ($z12 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  $r99 \u003d r144.get()\n  $r100 \u003d MethodDeclaration) $r99\n  $r102 \u003d $r100.getBody()\n  $r101 \u003d MethodAnalysisToJson$toString__8.bootstrap$()\n  $r103 \u003d $r102.map($r101)\n  $r104 \u003d $r103.orElse(\"(no body)\")\n  r141 \u003d String) $r104\n}",
      "B32 {\n  $r145 \u003d \"(source not found)\"\n  $z18 \u003d $r145.equals(r141)\n  if ($z18 \u003d\u003d false) goto B33 else B36\n}",
      "B33 {\n  if (i11 \u003e\u003d i12) goto B34 else B36\n}",
      "B34 {\n  $r87 \u003d Path SOURCE_ROOT\u003e\n  $r88 \u003d r139.replace(46, 47)\n  $r89 \u003d dynInvoke makeConcatWithConstants($r88)\n  r146 \u003d $r87.resolve($r89)\n  r147 \u003d Files.readAllLines(r146)\n  $r91 \u003d System.lineSeparator()\n  $i9 \u003d i11 - 1\n  $i7 \u003d r147.size()\n  $i8 \u003d Math.min(i12, $i7)\n  $r90 \u003d r147.subList($i9, $i8)\n  r141 \u003d String.join($r91, $r90)\n  goto B36\n}",
      "B35 {\n  $r116 :\u003d @caughtexception\n}",
      "B36 {\n  $r148 \u003d MethodAnalysisToJson.buildPrettyCFG(r32)\n  $r149 \u003d HashSet\n  new HashSet()\n  $r150 \u003d HashSet\n  new HashSet()\n  r151 \u003d null\n  if (r140 \u003d\u003d null) goto B37 else B39\n}",
      "B37 {\n  $r77 \u003d r120.getShortName()\n  r152 \u003d r140.getClassByName($r77)\n  $z10 \u003d r152.isPresent()\n  if ($z10 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r78 \u003d r152.get()\n  r151 \u003d ClassOrInterfaceDeclaration) $r78\n  $r79 \u003d r152.get()\n  $r80 \u003d ClassOrInterfaceDeclaration) $r79\n  $r81 \u003d $r80.getMethods()\n  $r83 \u003d $r81.stream()\n  $r82 \u003d MethodAnalysisToJson$lambda_main_7__5.bootstrap$(r122)\n  $r84 \u003d $r83.filter($r82)\n  $r86 \u003d $r84.findFirst()\n  $r85 \u003d MethodAnalysisToJson$lambda_main_8__6.bootstrap$(r120, $r149, $r150)\n  $r86.ifPresent($r85)\n}",
      "B39 {\n  $r153 \u003d new MethodInfo\n  new MethodInfo()\n  $r154 \u003d $r149.iterator()\n}",
      "B40 {\n  $z19 \u003d $r154.hasNext()\n  if ($z19 \u003d\u003d false) goto B41 else B56\n}",
      "B41 {\n  $r66 \u003d $r154.next()\n  r155 \u003d String) $r66\n  $z6 \u003d r155.contains(\".\")\n  if ($z6 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $i5 \u003d r155.lastIndexOf(46)\n  $i6 \u003d $i5 + 1\n  $r156 \u003d r155.substring($i6)\n  goto B44\n}",
      "B43 {\n  $r156 \u003d r155\n}",
      "B44 {\n  r157 \u003d $r156\n  $z7 \u003d r155.contains(\".\")\n  if ($z7 \u003d\u003d false) goto B45 else B46\n}",
      "B45 {\n  $r158 \u003d r155\n  goto B47\n}",
      "B46 {\n  $r67 \u003d r120.getPackageName()\n  $r158 \u003d dynInvoke makeConcatWithConstants($r67, $r156)\n}",
      "B47 {\n  r159 \u003d $r158\n  $r68 \u003d Path SOURCE_ROOT\u003e\n  $r69 \u003d $r158.replace(46, 47)\n  $r70 \u003d dynInvoke makeConcatWithConstants($r69)\n  $r76 \u003d $r68.resolve($r70)\n  r160 \u003d $r76\n  $r71 \u003d LinkOption)[0]\n  $z8 \u003d Files.exists($r76, $r71)\n  if ($z8 !\u003d 0) goto B48 else B49\n}",
      "B48 {\n  $r75 \u003d $r11.get(r157)\n  r160 \u003d Path) $r75\n}",
      "B49 {\n  $r72 \u003d new DependencyInfo\n  new DependencyInfo()\n  $z9 \u003d r159.contains(\".\")\n  if ($z9 \u003d\u003d false) goto B50 else B51\n}",
      "B50 {\n  $r161 \u003d r159\n  goto B52\n}",
      "B51 {\n  $r161 \u003d r157\n}",
      "B52 {\n  String name\u003e \u003d $r161\n  $r74 \u003d MethodAnalysisToJson.loadCU(r160, $r19)\n  if ($r74 \u003d\u003d null) goto B53 else B54\n}",
      "B53 {\n  $r162 \u003d $r74.toString()\n  goto B55\n}",
      "B54 {\n  $r162 \u003d \"(source not found)\"\n}",
      "B55 {\n  String body\u003e \u003d $r162\n  $r73 \u003d List depClasses\u003e\n  $r73.add($r72)\n  goto B40\n}",
      "B56 {\n  r163 \u003d $r150.iterator()\n}",
      "B57 {\n  $z3 \u003d r163.hasNext()\n  if ($z3 \u003d\u003d false) goto B58 else B65\n}",
      "B58 {\n  $r49 \u003d r163.next()\n  r164 \u003d List) $r49\n  $r50 \u003d r164.get(0)\n  r165 \u003d String) $r50\n  $r51 \u003d r164.get(1)\n  $r52 \u003d String) $r51\n  i17 \u003d Integer.parseInt($r52)\n  $r53 \u003d new DependencyInfo\n  new DependencyInfo()\n  $r54 \u003d r120.getShortName()\n  $r55 \u003d dynInvoke makeConcatWithConstants($r54, r165, i17)\n  String name\u003e \u003d $r55\n  r166 \u003d \"(source not found)\"\n  if (r151 \u003d\u003d null) goto B59 else B60\n}",
      "B59 {\n  $r65 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc(r151, r165, $r65)\n}",
      "B60 {\n  $r56 \u003d \"(source not found)\"\n  $z4 \u003d $r56.equals(r166)\n  if ($z4 \u003d\u003d false) goto B61 else B64\n}",
      "B61 {\n  $r57 \u003d r120.getShortName()\n  $r58 \u003d $r11.get($r57)\n  r167 \u003d Path) $r58\n  r59 \u003d MethodAnalysisToJson.loadCU(r167, $r19)\n  if (r59 \u003d\u003d null) goto B62 else B64\n}",
      "B62 {\n  $r60 \u003d r120.getShortName()\n  r61 \u003d r59.getClassByName($r60)\n  $z5 \u003d r61.isPresent()\n  if ($z5 \u003d\u003d false) goto B63 else B64\n}",
      "B63 {\n  $r62 \u003d r61.get()\n  $r64 \u003d ClassOrInterfaceDeclaration) $r62\n  $r63 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc($r64, r165, $r63)\n}",
      "B64 {\n  String body\u003e \u003d r166\n  $r168 \u003d List depMethods\u003e\n  $r168.add($r53)\n  goto B57\n}",
      "B65 {\n  String clazz\u003e \u003d r139\n  $r42 \u003d r122.getName()\n  String methodName\u003e \u003d $r42\n  $r43 \u003d r122.getSubSignature()\n  String signature\u003e \u003d $r43\n  $r44 \u003d MethodAnalysisToJson.vis(r122)\n  String visibility\u003e \u003d $r44\n  String body\u003e \u003d r141\n  \u003cMethodInfo: int nodes\u003e \u003d i1\n  \u003cMethodInfo: int edges\u003e \u003d i2\n  \u003cMethodInfo: int cc\u003e \u003d i4\n  List flowSummary\u003e \u003d $r39\n  $r45 \u003d $r148.get(\"blocks\")\n  $r46 \u003d List) $r45\n  List blockList\u003e \u003d $r46\n  $r47 \u003d $r148.get(\"edges\")\n  $r48 \u003d List) $r47\n  List blockEdges\u003e \u003d $r48\n  $r18.add($r153)\n  goto B3\n}",
      "B66 {\n  goto B1\n}",
      "B67 {\n  $r23 \u003d GsonBuilder\n  new GsonBuilder()\n  $r24 \u003d $r23.setPrettyPrinting()\n  r169 \u003d $r24.create()\n  $r25 \u003d FileWriter\n  new FileWriter(\"C:/Users/00000/Desktop/my/jdataformat_all_methods.json\")\n  r169.toJson($r18, $r25)\n  $r25.close()\n  goto B71\n}",
      "B68 {\n  $r115 :\u003d @caughtexception\n  $r25.close()\n  goto B70\n}",
      "B69 {\n  $r114 :\u003d @caughtexception\n  $r115.addSuppressed($r114)\n}",
      "B70 {\n  throw $r115\n}",
      "B71 {\n  $r26 \u003d PrintStream out\u003e\n  $i0 \u003d $r18.size()\n  $r27 \u003d dynInvoke makeConcatWithConstants($i0)\n  $r26.println($r27)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B67",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B66",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B8",
      "B7 --\u003e B3",
      "B8 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B3",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B19",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B27",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B19",
      "B26 --\u003e B27",
      "B27 --\u003e B19",
      "B28 --\u003e B29",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B32",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B36",
      "B33 --\u003e B34",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B36 --\u003e B39",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B40 --\u003e B41",
      "B40 --\u003e B56",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B55",
      "B54 --\u003e B55",
      "B55 --\u003e B40",
      "B56 --\u003e B57",
      "B57 --\u003e B58",
      "B57 --\u003e B65",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B64",
      "B61 --\u003e B62",
      "B61 --\u003e B64",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B57",
      "B65 --\u003e B3",
      "B66 --\u003e B1",
      "B67 --\u003e B71",
      "B68 --\u003e B70",
      "B69 --\u003e B70",
      "B70 --\u003e [EXIT]",
      "B71 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "SootCFGAnalysis",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    //        String targetDir \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\benchmark\\\\commons-collections4-4.5.0-M1-src\\\\commons-collections4-4.5.0-M1-src\\\\target\\\\classes\"; // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    //        String outputCsv \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\cfg_analysis_result.tsv\"; // 결과 저장할 CSV 파일 경로\r\n    // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    String targetDir \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-dataformat-xml-jackson-dataformat-xml-2.19.1\\\\target\\\\classes\";\r\n    // 결과 저장할 CSV 파일 경로\r\n    String outputCsv \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jdataformat.csv\";\r\n    if (System.getProperty(\"sun.boot.class.path\") \u003d\u003d null)\r\n        System.setProperty(\"sun.boot.class.path\", \"\");\r\n    if (System.getProperty(\"java.ext.dirs\") \u003d\u003d null)\r\n        System.setProperty(\"java.ext.dirs\", \"\");\r\n    // (1) 기본 Soot 설정\r\n    Options.v().set_prepend_classpath(true);\r\n    Options.v().set_process_dir(Collections.singletonList(targetDir));\r\n    Options.v().set_whole_program(true);\r\n    // 출력 없음\r\n    Options.v().set_output_format(Options.output_format_none);\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_allow_phantom_refs(true);\r\n    Options.v().set_keep_line_number(true);\r\n    // phantom 클래스에 바디 생성 안 함\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_process_dir(// 내 클래스만\r\n    Collections.singletonList(\"target/classes\"));\r\n    Options.v().set_src_prec(Options.src_prec_class);\r\n    Options.v().setPhaseOption(\"jb\", \"use-original-names:true\");\r\n    Scene.v().loadNecessaryClasses();\r\n    // (★) 이미 본 메서드 서명을 기억할 Set\r\n    Set\u003cString\u003e seen \u003d new HashSet\u003c\u003e();\r\n    // (2) 애플리케이션 클래스들 순회\r\n    try (CSVWriter writer \u003d new CSVWriter(new FileWriter(outputCsv))) {\r\n        // CSV 헤더 작성\r\n        writer.writeNext(new String[] { \"Class\", \"Method\", \"MethodSig\", \"Nodes\", \"Edges\", \"McCabe_CC\", \"StartLine\", \"EndLine\", \"LineCount\" });\r\n        List\u003cSootClass\u003e classes \u003d new ArrayList\u003c\u003e(Scene.v().getApplicationClasses());\r\n        for (SootClass cls : classes) {\r\n            for (SootMethod method : cls.getMethods()) {\r\n                if (!method.isConcrete())\r\n                    continue;\r\n                try {\r\n                    Body body \u003d method.retrieveActiveBody();\r\n                    // 기본 블록 단위\r\n                    BlockGraph cfg \u003d new BriefBlockGraph(body);\r\n                    int nodeCount \u003d cfg.size();\r\n                    int edgeCount \u003d 0;\r\n                    for (Block b : cfg) edgeCount +\u003d cfg.getSuccsOf(b).size();\r\n                    int cc \u003d edgeCount - nodeCount + 2;\r\n                    int startLine \u003d Integer.MAX_VALUE;\r\n                    int endLine \u003d Integer.MIN_VALUE;\r\n                    for (Unit unit : body.getUnits()) {\r\n                        int line \u003d unit.getJavaSourceStartLineNumber();\r\n                        if (line \u003e 0) {\r\n                            startLine \u003d Math.min(startLine, line);\r\n                            endLine \u003d Math.max(endLine, line);\r\n                        }\r\n                    }\r\n                    int lineCount \u003d (startLine \u003c\u003d endLine) ? (endLine - startLine + 1) : 0;\r\n                    if (!isTopLevelPublic(cls) || !isRealMethod(method))\r\n                        continue;\r\n                    if (nodeCount \u003d\u003d 0 || edgeCount \u003d\u003d 0)\r\n                        continue;\r\n                    if (cc \u003c\u003d 0)\r\n                        continue;\r\n                    String methodSig \u003d method.getSubSignature();\r\n                    String uniqueKey \u003d method.getSignature();\r\n                    // (★) 이미 기록된 서명이라면 건너뛰기\r\n                    if (!seen.add(uniqueKey))\r\n                        continue;\r\n                    // 결과를 CSV로 저장\r\n                    String[] row \u003d { cls.getName(), method.getName(), uniqueKey, String.valueOf(nodeCount), String.valueOf(edgeCount), String.valueOf(cc), String.valueOf(startLine), String.valueOf(endLine), String.valueOf(lineCount) };\r\n                    writer.writeNext(row);\r\n                } catch (Exception e) {\r\n                    System.out.printf(\"[⚠️ 오류] %s.%s: %s\\n\", cls.getName(), method.getName(), e.getMessage());\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"✅ 분석 완료: \" + outputCsv + \"에 저장됨\");\r\n    } catch (IOException e) {\r\n        System.err.println(\"❌ CSV 저장 중 오류: \" + e.getMessage());\r\n    }\r\n}",
    "nodes": 42,
    "edges": 55,
    "cc": 15,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B5 : If($z6 \u003d\u003d false) → B6 | else → B35",
      "B7 : If($z7 \u003d\u003d false) → B8 | else → B34",
      "B8 : If($z0 !\u003d 0) → B9 | else → B10",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i8 \u003c\u003d 0) → B16 | else → B17",
      "B18 : If(i6 \u003e i7) → B19 | else → B20",
      "B21 : If($z3 \u003d\u003d false) → B22 | else → B23",
      "B22 : If($z4 !\u003d 0) → B23 | else → B24",
      "B24 : If(i0 \u003d\u003d false) → B25 | else → B26",
      "B25 : If(i4 !\u003d 0) → B26 | else → B27",
      "B27 : If(i5 \u003e 0) → B28 | else → B29",
      "B29 : If($z5 !\u003d 0) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $r0 \u003d System.getProperty(\"sun.boot.class.path\")\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  System.setProperty(\"sun.boot.class.path\", \"\")\n}",
      "B2 {\n  $r1 \u003d System.getProperty(\"java.ext.dirs\")\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  System.setProperty(\"java.ext.dirs\", \"\")\n}",
      "B4 {\n  $r2 \u003d Options.v()\n  $r2.set_prepend_classpath(1)\n  $r4 \u003d Options.v()\n  $r3 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-dataformat-xml-jackson-dataformat-xml-2.19.1\\\\target\\\\classes\")\n  $r4.set_process_dir($r3)\n  $r5 \u003d Options.v()\n  $r5.set_whole_program(1)\n  $r6 \u003d Options.v()\n  $r6.set_output_format(12)\n  $r7 \u003d Options.v()\n  $r7.set_no_bodies_for_excluded(1)\n  $r8 \u003d Options.v()\n  $r8.set_allow_phantom_refs(1)\n  $r9 \u003d Options.v()\n  $r9.set_keep_line_number(1)\n  $r10 \u003d Options.v()\n  $r10.set_no_bodies_for_excluded(1)\n  $r12 \u003d Options.v()\n  $r11 \u003d Collections.singletonList(\"target/classes\")\n  $r12.set_process_dir($r11)\n  $r13 \u003d Options.v()\n  $r13.set_src_prec(1)\n  $r14 \u003d Options.v()\n  $r14.setPhaseOption(\"jb\", \"use-original-names:true\")\n  $r15 \u003d Scene.v()\n  $r15.loadNecessaryClasses()\n  $r16 \u003d HashSet\n  new HashSet()\n  $r17 \u003d CSVWriter\n  $r18 \u003d FileWriter\n  new FileWriter(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jdataformat.csv\")\n  new CSVWriter($r18)\n  $r19 \u003d String)[9]\n  $r19[0] \u003d \"Class\"\n  $r19[1] \u003d \"Method\"\n  $r19[2] \u003d \"MethodSig\"\n  $r19[3] \u003d \"Nodes\"\n  $r19[4] \u003d \"Edges\"\n  $r19[5] \u003d \"McCabe_CC\"\n  $r19[6] \u003d \"StartLine\"\n  $r19[7] \u003d \"EndLine\"\n  $r19[8] \u003d \"LineCount\"\n  $r17.writeNext($r19)\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  $r45 \u003d $r20.iterator()\n}",
      "B5 {\n  $z6 \u003d $r45.hasNext()\n  if ($z6 \u003d\u003d false) goto B6 else B35\n}",
      "B6 {\n  $r25 \u003d $r45.next()\n  r26 \u003d SootClass) $r25\n  $r27 \u003d r26.getMethods()\n  r28 \u003d $r27.iterator()\n}",
      "B7 {\n  $z7 \u003d r28.hasNext()\n  if ($z7 \u003d\u003d false) goto B8 else B34\n}",
      "B8 {\n  $r29 \u003d r28.next()\n  r30 \u003d SootMethod) $r29\n  $z0 \u003d r30.isConcrete()\n  if ($z0 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  goto B7\n}",
      "B10 {\n  r59 \u003d r30.retrieveActiveBody()\n  $r31 \u003d BriefBlockGraph\n  new BriefBlockGraph(r59)\n  i0 \u003d $r31.size()\n  i4 \u003d 0\n  r60 \u003d $r31.iterator()\n}",
      "B11 {\n  $z1 \u003d r60.hasNext()\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r43 \u003d r60.next()\n  r61 \u003d Block) $r43\n  $r44 \u003d $r31.getSuccsOf(r61)\n  $i3 \u003d $r44.size()\n  i4 \u003d i4 + $i3\n  goto B11\n}",
      "B13 {\n  $i1 \u003d i4 - i0\n  i5 \u003d $i1 + 2\n  i6 \u003d 2147483647\n  i7 \u003d -2147483648\n  $r32 \u003d r59.getUnits()\n  r62 \u003d $r32.iterator()\n}",
      "B14 {\n  $z2 \u003d r62.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r42 \u003d r62.next()\n  r63 \u003d Unit) $r42\n  i8 \u003d r63.getJavaSourceStartLineNumber()\n  if (i8 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i6 \u003d Math.min(i6, i8)\n  i7 \u003d Math.max(i7, i8)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  if (i6 \u003e i7) goto B19 else B20\n}",
      "B19 {\n  $i2 \u003d i7 - i6\n  $i9 \u003d $i2 + 1\n  goto B21\n}",
      "B20 {\n  $i9 \u003d 0\n}",
      "B21 {\n  $z3 \u003d SootCFGAnalysis.isTopLevelPublic(r26)\n  if ($z3 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $z4 \u003d SootCFGAnalysis.isRealMethod(r30)\n  if ($z4 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  goto B7\n}",
      "B24 {\n  if (i0 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  if (i4 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B7\n}",
      "B27 {\n  if (i5 \u003e 0) goto B28 else B29\n}",
      "B28 {\n  goto B7\n}",
      "B29 {\n  r30.getSubSignature()\n  r64 \u003d r30.getSignature()\n  $z5 \u003d $r16.add(r64)\n  if ($z5 !\u003d 0) goto B30 else B31\n}",
      "B30 {\n  goto B7\n}",
      "B31 {\n  $r33 \u003d String)[9]\n  $r34 \u003d r26.getName()\n  $r33[0] \u003d $r34\n  $r35 \u003d r30.getName()\n  $r33[1] \u003d $r35\n  $r33[2] \u003d r64\n  $r36 \u003d String.valueOf(i0)\n  $r33[3] \u003d $r36\n  $r37 \u003d String.valueOf(i4)\n  $r33[4] \u003d $r37\n  $r38 \u003d String.valueOf(i5)\n  $r33[5] \u003d $r38\n  $r39 \u003d String.valueOf(i6)\n  $r33[6] \u003d $r39\n  $r40 \u003d String.valueOf(i7)\n  $r33[7] \u003d $r40\n  $r41 \u003d String.valueOf($i9)\n  $r33[8] \u003d $r41\n  $r17.writeNext($r33)\n  goto B33\n}",
      "B32 {\n  $r52 :\u003d @caughtexception\n  $r54 \u003d PrintStream out\u003e\n  $r53 \u003d Object)[3]\n  $r55 \u003d r26.getName()\n  $r53[0] \u003d $r55\n  $r56 \u003d r30.getName()\n  $r53[1] \u003d $r56\n  $r57 \u003d $r52.getMessage()\n  $r53[2] \u003d $r57\n  $r54.printf(\"\\u26a0\\ufe0f \\uc624\\ub958 %s.%s: %s\\n\", $r53)\n}",
      "B33 {\n  goto B7\n}",
      "B34 {\n  goto B5\n}",
      "B35 {\n  $r23 \u003d PrintStream out\u003e\n  $r24 \u003d dynInvoke makeConcatWithConstants(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jdataformat.csv\")\n  $r23.println($r24)\n  $r17.close()\n  goto B39\n}",
      "B36 {\n  $r51 :\u003d @caughtexception\n  $r17.close()\n  goto B38\n}",
      "B37 {\n  $r50 :\u003d @caughtexception\n  $r51.addSuppressed($r50)\n}",
      "B38 {\n  throw $r51\n}",
      "B39 {\n  goto B41\n}",
      "B40 {\n  $r46 :\u003d @caughtexception\n  $r47 \u003d PrintStream err\u003e\n  $r48 \u003d $r46.getMessage()\n  $r49 \u003d dynInvoke makeConcatWithConstants($r48)\n  $r47.println($r49)\n}",
      "B41 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B35",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B34",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B7",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B7",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B7",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B7",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B7",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B7",
      "B34 --\u003e B5",
      "B35 --\u003e B39",
      "B36 --\u003e B38",
      "B37 --\u003e B38",
      "B38 --\u003e [EXIT]",
      "B39 --\u003e B41",
      "B40 --\u003e B41",
      "B41 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SootCFGAnalysis#isTopLevelPublic(...1)",
        "body": "{\r\n    return c.isPublic() \u0026\u0026 !c.getName().contains(\"$\") \u0026\u0026 !c.isInterface() \u0026\u0026 !c.isAbstract();\r\n}"
      },
      {
        "name": "SootCFGAnalysis#isRealMethod(...1)",
        "body": "{\r\n    // (1) 바디 없는 메서드는 제외\r\n    if (!m.isConcrete())\r\n        return false;\r\n    // (2) 생성자/클래스 초기화자 제외\r\n    if (m.isConstructor() || m.isStaticInitializer())\r\n        return false;\r\n    // (3) 컴파일러 생성 메서드 제외 (synthetic, bridge)\r\n    final int ACC_BRIDGE \u003d 0x0040;\r\n    final int ACC_SYNTHETIC \u003d 0x1000;\r\n    int mod \u003d m.getModifiers();\r\n    // (4) public 이 아닌 메서드 제외\r\n    if (!Modifier.isPublic(mod))\r\n        return false;\r\n    return (mod \u0026 ACC_BRIDGE) \u003d\u003d 0 \u0026\u0026 (mod \u0026 ACC_SYNTHETIC) \u003d\u003d 0;\r\n}"
      }
    ]
  }
]