[
  {
    "clazz": "MethodAnalysisToJson",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 72,
    "edges": 101,
    "cc": 31,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B67",
      "B3 : If($z16 \u003d\u003d false) → B4 | else → B66",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B8 : If(i1 \u003d\u003d false) → B9 | else → B3",
      "B9 : If(i2 !\u003d 0) → B10 | else → B11",
      "B11 : If(i4 \u003e 0) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i13 \u003c\u003d 0) → B16 | else → B17",
      "B19 : If($z17 \u003d\u003d false) → B20 | else → B28",
      "B20 : If($i10 \u003e\u003d 2) → B21 | else → B22",
      "B22 : If($z13 \u003d\u003d false) → B23 | else → B24",
      "B24 : If($z14 !\u003d 0) → B25 | else → B26",
      "B25 : If($z15 \u003d\u003d false) → B26 | else → B19",
      "B28 : If(r140 \u003d\u003d null) → B29 | else → B32",
      "B29 : If($z11 \u003d\u003d false) → B30 | else → B32",
      "B30 : If($z12 \u003d\u003d false) → B31 | else → B32",
      "B32 : If($z18 \u003d\u003d false) → B33 | else → B36",
      "B33 : If(i11 \u003e\u003d i12) → B34 | else → B36",
      "B36 : If(r140 \u003d\u003d null) → B37 | else → B39",
      "B37 : If($z10 \u003d\u003d false) → B38 | else → B39",
      "B40 : If($z19 \u003d\u003d false) → B41 | else → B56",
      "B41 : If($z6 \u003d\u003d false) → B42 | else → B43",
      "B44 : If($z7 \u003d\u003d false) → B45 | else → B46",
      "B47 : If($z8 !\u003d 0) → B48 | else → B49",
      "B49 : If($z9 \u003d\u003d false) → B50 | else → B51",
      "B52 : If($r74 \u003d\u003d null) → B53 | else → B54",
      "B57 : If($z3 \u003d\u003d false) → B58 | else → B65",
      "B58 : If(r151 \u003d\u003d null) → B59 | else → B60",
      "B60 : If($z4 \u003d\u003d false) → B61 | else → B64",
      "B61 : If(r59 \u003d\u003d null) → B62 | else → B64",
      "B62 : If($z5 \u003d\u003d false) → B63 | else → B64"
    ],
    "blockList": [
      "B0 {\n  String[]\n  G.reset()\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r1 \u003d Options.v()\n  $r1.set_allow_phantom_refs(1)\n  $r3 \u003d Options.v()\n  $r2 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\joda-time-2.14.0\\\\target\\\\classes\")\n  $r3.set_process_dir($r2)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r9 \u003d Options.v()\n  $r6 \u003d String pathSeparator\u003e\n  $r5 \u003d CharSequence)[2]\n  $r5[0] \u003d 0\\\\target\\\\classes\"\n  $r7 \u003d System.getProperty(\"java.class.path\")\n  $r5[1] \u003d $r7\n  $r8 \u003d String.join($r6, $r5)\n  $r9.set_soot_classpath($r8)\n  $r10 \u003d Scene.v()\n  $r10.loadNecessaryClasses()\n  $r11 \u003d HashMap\n  new HashMap()\n  $r13 \u003d Path SOURCE_ROOT\u003e\n  $r12 \u003d FileVisitOption)[0]\n  $r15 \u003d Files.walk($r13, $r12)\n  $r14 \u003d MethodAnalysisToJson$lambda_main_2__1.bootstrap$()\n  $r17 \u003d $r15.filter($r14)\n  $r16 \u003d MethodAnalysisToJson$lambda_main_3__2.bootstrap$($r11)\n  $r17.forEach($r16)\n  $r18 \u003d ArrayList\n  new ArrayList()\n  $r19 \u003d HashMap\n  new HashMap()\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  r119 \u003d $r20.iterator()\n}",
      "B1 {\n  $z0 \u003d r119.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B67\n}",
      "B2 {\n  $r28 \u003d r119.next()\n  r120 \u003d SootClass) $r28\n  $r29 \u003d ArrayList\n  $r30 \u003d r120.getMethods()\n  new ArrayList($r30)\n  r121 \u003d $r29.iterator()\n}",
      "B3 {\n  $z16 \u003d r121.hasNext()\n  if ($z16 \u003d\u003d false) goto B4 else B66\n}",
      "B4 {\n  $r31 \u003d r121.next()\n  r122 \u003d SootMethod) $r31\n  $z1 \u003d MethodAnalysisToJson.isEligible(r120, r122)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r32 \u003d r122.retrieveActiveBody()\n  goto B8\n}",
      "B7 {\n  $r117 :\u003d @caughtexception\n  goto B3\n}",
      "B8 {\n  $r33 \u003d BriefBlockGraph\n  new BriefBlockGraph(r32)\n  i1 \u003d $r33.size()\n  $r34 \u003d $r33.getBlocks()\n  $r36 \u003d $r34.stream()\n  $r35 \u003d MethodAnalysisToJson$lambda_main_4__3.bootstrap$($r33)\n  $r37 \u003d $r36.mapToInt($r35)\n  i2 \u003d $r37.sum()\n  $i3 \u003d i2 - i1\n  i4 \u003d $i3 + 2\n  if (i1 \u003d\u003d false) goto B9 else B3\n}",
      "B9 {\n  if (i2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  goto B3\n}",
      "B11 {\n  if (i4 \u003e 0) goto B12 else B13\n}",
      "B12 {\n  goto B3\n}",
      "B13 {\n  i11 \u003d 2147483647\n  i12 \u003d -2147483648\n  $r38 \u003d r32.getUnits()\n  r123 \u003d $r38.iterator()\n}",
      "B14 {\n  $z2 \u003d r123.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r113 \u003d r123.next()\n  r124 \u003d Unit) $r113\n  i13 \u003d r124.getJavaSourceStartLineNumber()\n  if (i13 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i11 \u003d Math.min(i11, i13)\n  i12 \u003d Math.max(i12, i13)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  $r39 \u003d ArrayList\n  new ArrayList()\n  r125 \u003d $r33.iterator()\n}",
      "B19 {\n  $z17 \u003d r125.hasNext()\n  if ($z17 \u003d\u003d false) goto B20 else B28\n}",
      "B20 {\n  $r105 \u003d r125.next()\n  r126 \u003d Block) $r105\n  r127 \u003d $r33.getSuccsOf(r126)\n  $i10 \u003d r127.size()\n  if ($i10 \u003e\u003d 2) goto B21 else B22\n}",
      "B21 {\n  goto B19\n}",
      "B22 {\n  r128 \u003d r126.getTail()\n  $z13 \u003d IfStmt\n  if ($z13 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r111 \u003d IfStmt) r128\n  $r112 \u003d $r111.getCondition()\n  r129 \u003d $r112.toString()\n  goto B27\n}",
      "B24 {\n  $z14 \u003d LookupSwitchStmt\n  if ($z14 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  $z15 \u003d TableSwitchStmt\n  if ($z15 \u003d\u003d false) goto B26 else B19\n}",
      "B26 {\n  $r106 \u003d r128.getUseBoxes()\n  $r107 \u003d $r106.get(0)\n  $r108 \u003d ValueBox) $r107\n  $r109 \u003d $r108.getValue()\n  $r110 \u003d String.valueOf($r109)\n  r129 \u003d dynInvoke makeConcatWithConstants($r110)\n}",
      "B27 {\n  $r130 \u003d Object)[4]\n  $i14 \u003d r126.getIndexInMethod()\n  $r131 \u003d Integer.valueOf($i14)\n  $r130[0] \u003d $r131\n  $r130[1] \u003d r129\n  $r132 \u003d r127.get(0)\n  $r133 \u003d Block) $r132\n  $i15 \u003d $r133.getIndexInMethod()\n  $r134 \u003d Integer.valueOf($i15)\n  $r130[2] \u003d $r134\n  $r135 \u003d r127.get(1)\n  $r136 \u003d Block) $r135\n  $i16 \u003d $r136.getIndexInMethod()\n  $r137 \u003d Integer.valueOf($i16)\n  $r130[3] \u003d $r137\n  $r138 \u003d String.format(\"B%d : If(%s) \\u2192 B%d | else \\u2192 B%d\", $r130)\n  $r39.add($r138)\n  goto B19\n}",
      "B28 {\n  r139 \u003d r120.getName()\n  $r40 \u003d MethodAnalysisToJson$lambda_main_5__4.bootstrap$()\n  $r41 \u003d $r19.computeIfAbsent(r139, $r40)\n  r140 \u003d CompilationUnit) $r41\n  r141 \u003d \"(source not found)\"\n  r142 \u003d r122.getSubSignature()\n  MethodAnalysisToJson.toSimpleSig(r142)\n  if (r140 \u003d\u003d null) goto B29 else B32\n}",
      "B29 {\n  $r92 \u003d r120.getShortName()\n  r143 \u003d r140.getClassByName($r92)\n  $z11 \u003d r143.isPresent()\n  if ($z11 \u003d\u003d false) goto B30 else B32\n}",
      "B30 {\n  $r93 \u003d r143.get()\n  $r94 \u003d ClassOrInterfaceDeclaration) $r93\n  $r95 \u003d $r94.getMethods()\n  $r97 \u003d $r95.stream()\n  $r96 \u003d MethodAnalysisToJson$lambda_main_6__7.bootstrap$(r122)\n  $r98 \u003d $r97.filter($r96)\n  r144 \u003d $r98.findFirst()\n  $z12 \u003d r144.isPresent()\n  if ($z12 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  $r99 \u003d r144.get()\n  $r100 \u003d MethodDeclaration) $r99\n  $r102 \u003d $r100.getBody()\n  $r101 \u003d MethodAnalysisToJson$toString__8.bootstrap$()\n  $r103 \u003d $r102.map($r101)\n  $r104 \u003d $r103.orElse(\"(no body)\")\n  r141 \u003d String) $r104\n}",
      "B32 {\n  $r145 \u003d \"(source not found)\"\n  $z18 \u003d $r145.equals(r141)\n  if ($z18 \u003d\u003d false) goto B33 else B36\n}",
      "B33 {\n  if (i11 \u003e\u003d i12) goto B34 else B36\n}",
      "B34 {\n  $r87 \u003d Path SOURCE_ROOT\u003e\n  $r88 \u003d r139.replace(46, 47)\n  $r89 \u003d dynInvoke makeConcatWithConstants($r88)\n  r146 \u003d $r87.resolve($r89)\n  r147 \u003d Files.readAllLines(r146)\n  $r91 \u003d System.lineSeparator()\n  $i9 \u003d i11 - 1\n  $i7 \u003d r147.size()\n  $i8 \u003d Math.min(i12, $i7)\n  $r90 \u003d r147.subList($i9, $i8)\n  r141 \u003d String.join($r91, $r90)\n  goto B36\n}",
      "B35 {\n  $r116 :\u003d @caughtexception\n}",
      "B36 {\n  $r148 \u003d MethodAnalysisToJson.buildPrettyCFG(r32)\n  $r149 \u003d HashSet\n  new HashSet()\n  $r150 \u003d HashSet\n  new HashSet()\n  r151 \u003d null\n  if (r140 \u003d\u003d null) goto B37 else B39\n}",
      "B37 {\n  $r77 \u003d r120.getShortName()\n  r152 \u003d r140.getClassByName($r77)\n  $z10 \u003d r152.isPresent()\n  if ($z10 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r78 \u003d r152.get()\n  r151 \u003d ClassOrInterfaceDeclaration) $r78\n  $r79 \u003d r152.get()\n  $r80 \u003d ClassOrInterfaceDeclaration) $r79\n  $r81 \u003d $r80.getMethods()\n  $r83 \u003d $r81.stream()\n  $r82 \u003d MethodAnalysisToJson$lambda_main_7__5.bootstrap$(r122)\n  $r84 \u003d $r83.filter($r82)\n  $r86 \u003d $r84.findFirst()\n  $r85 \u003d MethodAnalysisToJson$lambda_main_8__6.bootstrap$(r120, $r149, $r150)\n  $r86.ifPresent($r85)\n}",
      "B39 {\n  $r153 \u003d new MethodInfo\n  new MethodInfo()\n  $r154 \u003d $r149.iterator()\n}",
      "B40 {\n  $z19 \u003d $r154.hasNext()\n  if ($z19 \u003d\u003d false) goto B41 else B56\n}",
      "B41 {\n  $r66 \u003d $r154.next()\n  r155 \u003d String) $r66\n  $z6 \u003d r155.contains(\".\")\n  if ($z6 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $i5 \u003d r155.lastIndexOf(46)\n  $i6 \u003d $i5 + 1\n  $r156 \u003d r155.substring($i6)\n  goto B44\n}",
      "B43 {\n  $r156 \u003d r155\n}",
      "B44 {\n  r157 \u003d $r156\n  $z7 \u003d r155.contains(\".\")\n  if ($z7 \u003d\u003d false) goto B45 else B46\n}",
      "B45 {\n  $r158 \u003d r155\n  goto B47\n}",
      "B46 {\n  $r67 \u003d r120.getPackageName()\n  $r158 \u003d dynInvoke makeConcatWithConstants($r67, $r156)\n}",
      "B47 {\n  r159 \u003d $r158\n  $r68 \u003d Path SOURCE_ROOT\u003e\n  $r69 \u003d $r158.replace(46, 47)\n  $r70 \u003d dynInvoke makeConcatWithConstants($r69)\n  $r76 \u003d $r68.resolve($r70)\n  r160 \u003d $r76\n  $r71 \u003d LinkOption)[0]\n  $z8 \u003d Files.exists($r76, $r71)\n  if ($z8 !\u003d 0) goto B48 else B49\n}",
      "B48 {\n  $r75 \u003d $r11.get(r157)\n  r160 \u003d Path) $r75\n}",
      "B49 {\n  $r72 \u003d new DependencyInfo\n  new DependencyInfo()\n  $z9 \u003d r159.contains(\".\")\n  if ($z9 \u003d\u003d false) goto B50 else B51\n}",
      "B50 {\n  $r161 \u003d r159\n  goto B52\n}",
      "B51 {\n  $r161 \u003d r157\n}",
      "B52 {\n  String name\u003e \u003d $r161\n  $r74 \u003d MethodAnalysisToJson.loadCU(r160, $r19)\n  if ($r74 \u003d\u003d null) goto B53 else B54\n}",
      "B53 {\n  $r162 \u003d $r74.toString()\n  goto B55\n}",
      "B54 {\n  $r162 \u003d \"(source not found)\"\n}",
      "B55 {\n  String body\u003e \u003d $r162\n  $r73 \u003d List depClasses\u003e\n  $r73.add($r72)\n  goto B40\n}",
      "B56 {\n  r163 \u003d $r150.iterator()\n}",
      "B57 {\n  $z3 \u003d r163.hasNext()\n  if ($z3 \u003d\u003d false) goto B58 else B65\n}",
      "B58 {\n  $r49 \u003d r163.next()\n  r164 \u003d List) $r49\n  $r50 \u003d r164.get(0)\n  r165 \u003d String) $r50\n  $r51 \u003d r164.get(1)\n  $r52 \u003d String) $r51\n  i17 \u003d Integer.parseInt($r52)\n  $r53 \u003d new DependencyInfo\n  new DependencyInfo()\n  $r54 \u003d r120.getShortName()\n  $r55 \u003d dynInvoke makeConcatWithConstants($r54, r165, i17)\n  String name\u003e \u003d $r55\n  r166 \u003d \"(source not found)\"\n  if (r151 \u003d\u003d null) goto B59 else B60\n}",
      "B59 {\n  $r65 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc(r151, r165, $r65)\n}",
      "B60 {\n  $r56 \u003d \"(source not found)\"\n  $z4 \u003d $r56.equals(r166)\n  if ($z4 \u003d\u003d false) goto B61 else B64\n}",
      "B61 {\n  $r57 \u003d r120.getShortName()\n  $r58 \u003d $r11.get($r57)\n  r167 \u003d Path) $r58\n  r59 \u003d MethodAnalysisToJson.loadCU(r167, $r19)\n  if (r59 \u003d\u003d null) goto B62 else B64\n}",
      "B62 {\n  $r60 \u003d r120.getShortName()\n  r61 \u003d r59.getClassByName($r60)\n  $z5 \u003d r61.isPresent()\n  if ($z5 \u003d\u003d false) goto B63 else B64\n}",
      "B63 {\n  $r62 \u003d r61.get()\n  $r64 \u003d ClassOrInterfaceDeclaration) $r62\n  $r63 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc($r64, r165, $r63)\n}",
      "B64 {\n  String body\u003e \u003d r166\n  $r168 \u003d List depMethods\u003e\n  $r168.add($r53)\n  goto B57\n}",
      "B65 {\n  String clazz\u003e \u003d r139\n  $r42 \u003d r122.getName()\n  String methodName\u003e \u003d $r42\n  $r43 \u003d r122.getSubSignature()\n  String signature\u003e \u003d $r43\n  $r44 \u003d MethodAnalysisToJson.vis(r122)\n  String visibility\u003e \u003d $r44\n  String body\u003e \u003d r141\n  \u003cMethodInfo: int nodes\u003e \u003d i1\n  \u003cMethodInfo: int edges\u003e \u003d i2\n  \u003cMethodInfo: int cc\u003e \u003d i4\n  List flowSummary\u003e \u003d $r39\n  $r45 \u003d $r148.get(\"blocks\")\n  $r46 \u003d List) $r45\n  List blockList\u003e \u003d $r46\n  $r47 \u003d $r148.get(\"edges\")\n  $r48 \u003d List) $r47\n  List blockEdges\u003e \u003d $r48\n  $r18.add($r153)\n  goto B3\n}",
      "B66 {\n  goto B1\n}",
      "B67 {\n  $r23 \u003d GsonBuilder\n  new GsonBuilder()\n  $r24 \u003d $r23.setPrettyPrinting()\n  r169 \u003d $r24.create()\n  $r25 \u003d FileWriter\n  new FileWriter(\"C:/Users/00000/Desktop/my/time_all_methods.json\")\n  r169.toJson($r18, $r25)\n  $r25.close()\n  goto B71\n}",
      "B68 {\n  $r115 :\u003d @caughtexception\n  $r25.close()\n  goto B70\n}",
      "B69 {\n  $r114 :\u003d @caughtexception\n  $r115.addSuppressed($r114)\n}",
      "B70 {\n  throw $r115\n}",
      "B71 {\n  $r26 \u003d PrintStream out\u003e\n  $i0 \u003d $r18.size()\n  $r27 \u003d dynInvoke makeConcatWithConstants($i0)\n  $r26.println($r27)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B67",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B66",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B8",
      "B7 --\u003e B3",
      "B8 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B3",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B19",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B27",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B19",
      "B26 --\u003e B27",
      "B27 --\u003e B19",
      "B28 --\u003e B29",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B32",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B36",
      "B33 --\u003e B34",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B36 --\u003e B39",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B40 --\u003e B41",
      "B40 --\u003e B56",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B55",
      "B54 --\u003e B55",
      "B55 --\u003e B40",
      "B56 --\u003e B57",
      "B57 --\u003e B58",
      "B57 --\u003e B65",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B64",
      "B61 --\u003e B62",
      "B61 --\u003e B64",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B57",
      "B65 --\u003e B3",
      "B66 --\u003e B1",
      "B67 --\u003e B71",
      "B68 --\u003e B70",
      "B69 --\u003e B70",
      "B70 --\u003e [EXIT]",
      "B71 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.BuddhistChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.BuddhistChronology getInstance(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    BuddhistChronology chrono \u003d cCache.get(zone);\r\n    if (chrono \u003d\u003d null) {\r\n        // First create without a lower limit.\r\n        chrono \u003d new BuddhistChronology(GJChronology.getInstance(zone, null), null);\r\n        // Impose lower limit and make another BuddhistChronology.\r\n        DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n        chrono \u003d new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\r\n        BuddhistChronology oldChrono \u003d cCache.putIfAbsent(zone, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r11 !\u003d null) → B1 | else → B2",
      "B2 : If($r10 !\u003d null) → B3 | else → B5",
      "B3 : If(r9 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r11 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r11 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r11)\n  $r10 \u003d BuddhistChronology) $r1\n  r12 \u003d $r10\n  if ($r10 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r2 \u003d BuddhistChronology\n  $r3 \u003d GJChronology.getInstance(r11, null)\n  new BuddhistChronology($r3, null)\n  $r4 \u003d DateTime\n  new DateTime(1, 1, 1, 0, 0, 0, 0, $r2)\n  $r5 \u003d BuddhistChronology\n  $r6 \u003d LimitChronology.getInstance($r2, $r4, null)\n  new BuddhistChronology($r6, \"\")\n  r12 \u003d $r5\n  $r7 \u003d ConcurrentHashMap cCache\u003e\n  $r8 \u003d $r7.putIfAbsent(r11, $r5)\n  r9 \u003d BuddhistChronology) $r8\n  if (r9 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r12 \u003d r9\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.BuddhistChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  BuddhistChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d BuddhistChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BuddhistChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "BuddhistChronology#getInstance(...1)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    BuddhistChronology chrono \u003d cCache.get(zone);\r\n    if (chrono \u003d\u003d null) {\r\n        // First create without a lower limit.\r\n        chrono \u003d new BuddhistChronology(GJChronology.getInstance(zone, null), null);\r\n        // Impose lower limit and make another BuddhistChronology.\r\n        DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n        chrono \u003d new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\r\n        BuddhistChronology oldChrono \u003d cCache.putIfAbsent(zone, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.BuddhistChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof BuddhistChronology) {\r\n        BuddhistChronology chrono \u003d (BuddhistChronology) obj;\r\n        return getZone().equals(chrono.getZone());\r\n    }\r\n    return false;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  BuddhistChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d BuddhistChronology\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r2 \u003d BuddhistChronology) r1\n  $r4 \u003d r0.getZone()\n  $r3 \u003d r2.getZone()\n  $z1 \u003d $r4.equals($r3)\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BuddhistChronology#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.BuddhistChronology",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    String str \u003d \"BuddhistChronology\";\r\n    DateTimeZone zone \u003d getZone();\r\n    if (zone !\u003d null) {\r\n        str \u003d str + \u0027[\u0027 + zone.getID() + \u0027]\u0027;\r\n    }\r\n    return str;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BuddhistChronology\n  r3 \u003d \"BuddhistChronology\"\n  r1 \u003d r0.getZone()\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1.getID()\n  r3 \u003d dynInvoke makeConcatWithConstants(\"BuddhistChronology\", $r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BuddhistChronology#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.CopticChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.CopticChronology getInstance(org.joda.time.DateTimeZone,int)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    CopticChronology chrono;\r\n    CopticChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new CopticChronology[7];\r\n        CopticChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    // First create without a lower limit.\r\n                    chrono \u003d new CopticChronology(null, null, minDaysInFirstWeek);\r\n                    // Impose lower limit and make another CopticChronology.\r\n                    DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono \u003d new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 16,
    "edges": 19,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r17 !\u003d null) → B1 | else → B2",
      "B2 : If($r12 !\u003d null) → B3 | else → B5",
      "B3 : If(r19 \u003d\u003d null) → B4 | else → B5",
      "B7 : If($r20 !\u003d null) → B8 | else → B15",
      "B8 : If(r21 !\u003d null) → B9 | else → B13",
      "B9 : If(r17 !\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  i0 :\u003d @parameter1: int\n  if (r17 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r17 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r17)\n  $r12 \u003d CopticChronology[]) $r1\n  r18 \u003d $r12\n  if ($r12 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r18 \u003d CopticChronology)[7]\n  $r10 \u003d ConcurrentHashMap cCache\u003e\n  $r11 \u003d $r10.putIfAbsent(r17, r18)\n  r19 \u003d CopticChronology[]) $r11\n  if (r19 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r18 \u003d r19\n}",
      "B5 {\n  $i3 \u003d i0 - 1\n  $r20 \u003d r18[$i3]\n  r21 \u003d $r20\n  goto B7\n}",
      "B6 {\n  $r14 :\u003d @caughtexception\n  $r15 \u003d IllegalArgumentException\n  $r16 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r16)\n  throw $r15\n}",
      "B7 {\n  if ($r20 !\u003d null) goto B8 else B15\n}",
      "B8 {\n  r22 \u003d r18\n  entermonitor r18\n  $i1 \u003d i0 - 1\n  r21 \u003d r18[$i1]\n  if (r21 !\u003d null) goto B9 else B13\n}",
      "B9 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r17 !\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r6 \u003d CopticChronology\n  new CopticChronology(null, null, i0)\n  $r7 \u003d DateTime\n  new DateTime(1, 1, 1, 0, 0, 0, 0, $r6)\n  $r8 \u003d CopticChronology\n  $r9 \u003d LimitChronology.getInstance($r6, $r7, null)\n  new CopticChronology($r9, null, i0)\n  r21 \u003d $r8\n  goto B12\n}",
      "B11 {\n  $r3 \u003d DateTimeZone UTC\u003e\n  r23 \u003d CopticChronology.getInstance($r3, i0)\n  $r4 \u003d CopticChronology\n  $r5 \u003d ZonedChronology.getInstance(r23, r17)\n  new CopticChronology($r5, null, i0)\n  r21 \u003d $r4\n}",
      "B12 {\n  $i2 \u003d i0 - 1\n  r18[$i2] \u003d r21\n}",
      "B13 {\n  exitmonitor r22\n  goto B15\n}",
      "B14 {\n  $r13 :\u003d @caughtexception\n  exitmonitor r22\n  throw $r13\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B15",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CopticChronology#getInstance(...2)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    CopticChronology chrono;\r\n    CopticChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new CopticChronology[7];\r\n        CopticChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    // First create without a lower limit.\r\n                    chrono \u003d new CopticChronology(null, null, minDaysInFirstWeek);\r\n                    // Impose lower limit and make another CopticChronology.\r\n                    DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono \u003d new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.CopticChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CopticChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d CopticChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CopticChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CopticChronology#getInstance(...1)",
        "body": "{\r\n    return getInstance(zone, 4);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.EthiopicChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.EthiopicChronology getInstance(org.joda.time.DateTimeZone,int)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    EthiopicChronology chrono;\r\n    EthiopicChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new EthiopicChronology[7];\r\n        EthiopicChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    // First create without a lower limit.\r\n                    chrono \u003d new EthiopicChronology(null, null, minDaysInFirstWeek);\r\n                    // Impose lower limit and make another EthiopicChronology.\r\n                    DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono \u003d new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 16,
    "edges": 19,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r17 !\u003d null) → B1 | else → B2",
      "B2 : If($r12 !\u003d null) → B3 | else → B5",
      "B3 : If(r19 \u003d\u003d null) → B4 | else → B5",
      "B7 : If($r20 !\u003d null) → B8 | else → B15",
      "B8 : If(r21 !\u003d null) → B9 | else → B13",
      "B9 : If(r17 !\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  i0 :\u003d @parameter1: int\n  if (r17 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r17 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r17)\n  $r12 \u003d EthiopicChronology[]) $r1\n  r18 \u003d $r12\n  if ($r12 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r18 \u003d EthiopicChronology)[7]\n  $r10 \u003d ConcurrentHashMap cCache\u003e\n  $r11 \u003d $r10.putIfAbsent(r17, r18)\n  r19 \u003d EthiopicChronology[]) $r11\n  if (r19 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r18 \u003d r19\n}",
      "B5 {\n  $i3 \u003d i0 - 1\n  $r20 \u003d r18[$i3]\n  r21 \u003d $r20\n  goto B7\n}",
      "B6 {\n  $r14 :\u003d @caughtexception\n  $r15 \u003d IllegalArgumentException\n  $r16 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r16)\n  throw $r15\n}",
      "B7 {\n  if ($r20 !\u003d null) goto B8 else B15\n}",
      "B8 {\n  r22 \u003d r18\n  entermonitor r18\n  $i1 \u003d i0 - 1\n  r21 \u003d r18[$i1]\n  if (r21 !\u003d null) goto B9 else B13\n}",
      "B9 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r17 !\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r6 \u003d EthiopicChronology\n  new EthiopicChronology(null, null, i0)\n  $r7 \u003d DateTime\n  new DateTime(1, 1, 1, 0, 0, 0, 0, $r6)\n  $r8 \u003d EthiopicChronology\n  $r9 \u003d LimitChronology.getInstance($r6, $r7, null)\n  new EthiopicChronology($r9, null, i0)\n  r21 \u003d $r8\n  goto B12\n}",
      "B11 {\n  $r3 \u003d DateTimeZone UTC\u003e\n  r23 \u003d EthiopicChronology.getInstance($r3, i0)\n  $r4 \u003d EthiopicChronology\n  $r5 \u003d ZonedChronology.getInstance(r23, r17)\n  new EthiopicChronology($r5, null, i0)\n  r21 \u003d $r4\n}",
      "B12 {\n  $i2 \u003d i0 - 1\n  r18[$i2] \u003d r21\n}",
      "B13 {\n  exitmonitor r22\n  goto B15\n}",
      "B14 {\n  $r13 :\u003d @caughtexception\n  exitmonitor r22\n  throw $r13\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B15",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "EthiopicChronology#getInstance(...2)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    EthiopicChronology chrono;\r\n    EthiopicChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new EthiopicChronology[7];\r\n        EthiopicChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    // First create without a lower limit.\r\n                    chrono \u003d new EthiopicChronology(null, null, minDaysInFirstWeek);\r\n                    // Impose lower limit and make another EthiopicChronology.\r\n                    DateTime lowerLimit \u003d new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\r\n                    chrono \u003d new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.EthiopicChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  EthiopicChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d EthiopicChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "EthiopicChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "EthiopicChronology#getInstance(...1)",
        "body": "{\r\n    return getInstance(zone, 4);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.GJChronology getInstance(org.joda.time.DateTimeZone,org.joda.time.ReadableInstant,int)",
    "visibility": "public",
    "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover \u003d\u003d null) {\r\n        cutoverInstant \u003d DEFAULT_CUTOVER;\r\n    } else {\r\n        cutoverInstant \u003d gregorianCutover.toInstant();\r\n        LocalDate cutoverDate \u003d new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\r\n        if (cutoverDate.getYear() \u003c\u003d 0) {\r\n            throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\r\n        }\r\n    }\r\n    GJCacheKey cacheKey \u003d new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);\r\n    GJChronology chrono \u003d cCache.get(cacheKey);\r\n    if (chrono \u003d\u003d null) {\r\n        if (zone \u003d\u003d DateTimeZone.UTC) {\r\n            chrono \u003d new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant);\r\n        } else {\r\n            chrono \u003d getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\r\n            chrono \u003d new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);\r\n        }\r\n        GJChronology oldChrono \u003d cCache.putIfAbsent(cacheKey, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($i1 \u003e 0) → B3 | else → B4",
      "B4 : If($r20 !\u003d null) → B5 | else → B10",
      "B5 : If(r22 !\u003d $r6) → B6 | else → B7",
      "B8 : If($r18 \u003d\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  ReadableInstant\n  i2 :\u003d @parameter2: int\n  r22 \u003d DateTimeUtils.getZone(r21)\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r23 \u003d Instant DEFAULT_CUTOVER\u003e\n  goto B4\n}",
      "B2 {\n  r23 \u003d r0.toInstant()\n  $r1 \u003d LocalDate\n  $l0 \u003d r23.getMillis()\n  $r2 \u003d GregorianChronology.getInstance(r22)\n  new LocalDate($l0, $r2)\n  $i1 \u003d $r1.getYear()\n  if ($i1 \u003e 0) goto B3 else B4\n}",
      "B3 {\n  $r19 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\")\n  throw $r19\n}",
      "B4 {\n  $r3 \u003d GJCacheKey\n  new GJCacheKey(r22, r23, i2)\n  $r4 \u003d ConcurrentHashMap cCache\u003e\n  $r5 \u003d $r4.get($r3)\n  $r20 \u003d GJChronology) $r5\n  r24 \u003d $r20\n  if ($r20 !\u003d null) goto B5 else B10\n}",
      "B5 {\n  $r6 \u003d DateTimeZone UTC\u003e\n  if (r22 !\u003d $r6) goto B6 else B7\n}",
      "B6 {\n  $r15 \u003d GJChronology\n  $r17 \u003d JulianChronology.getInstance(r22, i2)\n  $r16 \u003d GregorianChronology.getInstance(r22, i2)\n  new GJChronology($r17, $r16, r23)\n  r24 \u003d $r15\n  goto B8\n}",
      "B7 {\n  $r7 \u003d DateTimeZone UTC\u003e\n  r25 \u003d GJChronology.getInstance($r7, r23, i2)\n  $r8 \u003d GJChronology\n  $r12 \u003d ZonedChronology.getInstance(r25, r22)\n  $r11 \u003d JulianChronology iJulianChronology\u003e\n  $r10 \u003d GregorianChronology iGregorianChronology\u003e\n  $r9 \u003d Instant iCutoverInstant\u003e\n  new GJChronology($r12, $r11, $r10, $r9)\n  r24 \u003d $r8\n}",
      "B8 {\n  $r13 \u003d ConcurrentHashMap cCache\u003e\n  $r14 \u003d $r13.putIfAbsent($r3, r24)\n  $r18 \u003d GJChronology) $r14\n  if ($r18 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  r24 \u003d $r18\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getInstance(...3)",
        "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover \u003d\u003d null) {\r\n        cutoverInstant \u003d DEFAULT_CUTOVER;\r\n    } else {\r\n        cutoverInstant \u003d gregorianCutover.toInstant();\r\n        LocalDate cutoverDate \u003d new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\r\n        if (cutoverDate.getYear() \u003c\u003d 0) {\r\n            throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\r\n        }\r\n    }\r\n    GJCacheKey cacheKey \u003d new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);\r\n    GJChronology chrono \u003d cCache.get(cacheKey);\r\n    if (chrono \u003d\u003d null) {\r\n        if (zone \u003d\u003d DateTimeZone.UTC) {\r\n            chrono \u003d new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant);\r\n        } else {\r\n            chrono \u003d getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\r\n            chrono \u003d new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);\r\n        }\r\n        GJChronology oldChrono \u003d cCache.putIfAbsent(cacheKey, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.GJChronology getInstance(org.joda.time.DateTimeZone,long,int)",
    "visibility": "public",
    "body": "{\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover \u003d\u003d DEFAULT_CUTOVER.getMillis()) {\r\n        cutoverInstant \u003d null;\r\n    } else {\r\n        cutoverInstant \u003d new Instant(gregorianCutover);\r\n    }\r\n    return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  l0 :\u003d @parameter1: long\n  i3 :\u003d @parameter2: int\n  $r0 \u003d Instant DEFAULT_CUTOVER\u003e\n  $l1 \u003d $r0.getMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r4 \u003d null\n  goto B3\n}",
      "B2 {\n  $r1 \u003d Instant\n  new Instant(l0)\n  r4 \u003d $r1\n}",
      "B3 {\n  $r3 \u003d GJChronology.getInstance(r2, r4, i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getInstance(...3)",
        "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover \u003d\u003d null) {\r\n        cutoverInstant \u003d DEFAULT_CUTOVER;\r\n    } else {\r\n        cutoverInstant \u003d gregorianCutover.toInstant();\r\n        LocalDate cutoverDate \u003d new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\r\n        if (cutoverDate.getYear() \u003c\u003d 0) {\r\n            throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\r\n        }\r\n    }\r\n    GJCacheKey cacheKey \u003d new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);\r\n    GJChronology chrono \u003d cCache.get(cacheKey);\r\n    if (chrono \u003d\u003d null) {\r\n        if (zone \u003d\u003d DateTimeZone.UTC) {\r\n            chrono \u003d new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant);\r\n        } else {\r\n            chrono \u003d getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\r\n            chrono \u003d new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);\r\n        }\r\n        GJChronology oldChrono \u003d cCache.putIfAbsent(cacheKey, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "getZone",
    "signature": "org.joda.time.DateTimeZone getZone()",
    "visibility": "public",
    "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getZone();\r\n    }\r\n    return DateTimeZone.UTC;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  $r1 \u003d r0.getBase()\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d $r1.getZone()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2",
      "B2 : If(r4 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  DateTimeZone\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r4 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r4 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d Instant iCutoverInstant\u003e\n  $i0 \u003d r0.getMinimumDaysInFirstWeek()\n  $r3 \u003d GJChronology.getInstance(r4, $r2, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getInstance(...3)",
        "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    Instant cutoverInstant;\r\n    if (gregorianCutover \u003d\u003d null) {\r\n        cutoverInstant \u003d DEFAULT_CUTOVER;\r\n    } else {\r\n        cutoverInstant \u003d gregorianCutover.toInstant();\r\n        LocalDate cutoverDate \u003d new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\r\n        if (cutoverDate.getYear() \u003c\u003d 0) {\r\n            throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\r\n        }\r\n    }\r\n    GJCacheKey cacheKey \u003d new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);\r\n    GJChronology chrono \u003d cCache.get(cacheKey);\r\n    if (chrono \u003d\u003d null) {\r\n        if (zone \u003d\u003d DateTimeZone.UTC) {\r\n            chrono \u003d new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant);\r\n        } else {\r\n            chrono \u003d getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\r\n            chrono \u003d new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant);\r\n        }\r\n        GJChronology oldChrono \u003d cCache.putIfAbsent(cacheKey, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      },
      {
        "name": "GJChronology#getMinimumDaysInFirstWeek(...0)",
        "body": "{\r\n    return iGregorianChronology.getMinimumDaysInFirstWeek();\r\n}"
      },
      {
        "name": "GJChronology#getZone(...0)",
        "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getZone();\r\n    }\r\n    return DateTimeZone.UTC;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "getDateTimeMillis",
    "signature": "long getDateTimeMillis(int,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\r\n    }\r\n    // Assume date is Gregorian.\r\n    long instant \u003d iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\r\n    if (instant \u003c iCutoverMillis) {\r\n        // Maybe it\u0027s Julian.\r\n        instant \u003d iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\r\n        if (instant \u003e\u003d iCutoverMillis) {\r\n            // Okay, it\u0027s in the illegal cutover gap.\r\n            throw new IllegalArgumentException(\"Specified date does not exist\");\r\n        }\r\n    }\r\n    return instant;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i10 \u003e\u003d 0) → B3 | else → B5",
      "B3 : If($i11 \u003c 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  i3 :\u003d @parameter3: int\n  $r1 \u003d r0.getBase()\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l8 \u003d $r1.getDateTimeMillis(i0, i1, i2, i3)\n  return\n}",
      "B2 {\n  $r2 \u003d GregorianChronology iGregorianChronology\u003e\n  l9 \u003d $r2.getDateTimeMillis(i0, i1, i2, i3)\n  $l4 \u003d GJChronology: long iCutoverMillis\u003e\n  $b5 \u003d l9 cmp $l4\n  $i10 \u003d (int) $b5\n  if ($i10 \u003e\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $r3 \u003d JulianChronology iJulianChronology\u003e\n  l9 \u003d $r3.getDateTimeMillis(i0, i1, i2, i3)\n  $l6 \u003d GJChronology: long iCutoverMillis\u003e\n  $b7 \u003d l9 cmp $l6\n  $i11 \u003d (int) $b7\n  if ($i11 \u003c 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Specified date does not exist\")\n  throw $r5\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "getDateTimeMillis",
    "signature": "long getDateTimeMillis(int,int,int,int,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    }\r\n    // Assume date is Gregorian.\r\n    long instant;\r\n    try {\r\n        instant \u003d iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    } catch (IllegalFieldValueException ex) {\r\n        if (monthOfYear !\u003d 2 || dayOfMonth !\u003d 29) {\r\n            throw ex;\r\n        }\r\n        instant \u003d iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n        if (instant \u003e\u003d iCutoverMillis) {\r\n            throw ex;\r\n        }\r\n    }\r\n    if (instant \u003c iCutoverMillis) {\r\n        // Maybe it\u0027s Julian.\r\n        instant \u003d iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n        if (instant \u003e\u003d iCutoverMillis) {\r\n            // Okay, it\u0027s in the illegal cutover gap.\r\n            throw new IllegalArgumentException(\"Specified date does not exist\");\r\n        }\r\n    }\r\n    return instant;\r\n}",
    "nodes": 12,
    "edges": 13,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(i1 !\u003d 2) → B4 | else → B5",
      "B4 : If(i2 \u003d\u003d 29) → B5 | else → B6",
      "B6 : If($i15 \u003c 0) → B7 | else → B8",
      "B8 : If($i16 \u003e\u003d 0) → B9 | else → B11",
      "B9 : If($i17 \u003c 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  i3 :\u003d @parameter3: int\n  i4 :\u003d @parameter4: int\n  i5 :\u003d @parameter5: int\n  i6 :\u003d @parameter6: int\n  $r1 \u003d r0.getBase()\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l11 \u003d $r1.getDateTimeMillis(i0, i1, i2, i3, i4, i5, i6)\n  return\n}",
      "B2 {\n  $r2 \u003d GregorianChronology iGregorianChronology\u003e\n  l14 \u003d $r2.getDateTimeMillis(i0, i1, i2, i3, i4, i5, i6)\n  goto B8\n}",
      "B3 {\n  $r5 :\u003d @caughtexception\n  if (i1 !\u003d 2) goto B4 else B5\n}",
      "B4 {\n  if (i2 \u003d\u003d 29) goto B5 else B6\n}",
      "B5 {\n  throw $r5\n}",
      "B6 {\n  $r6 \u003d GregorianChronology iGregorianChronology\u003e\n  l14 \u003d $r6.getDateTimeMillis(i0, i1, 28, i3, i4, i5, i6)\n  $l12 \u003d GJChronology: long iCutoverMillis\u003e\n  $b13 \u003d l14 cmp $l12\n  $i15 \u003d (int) $b13\n  if ($i15 \u003c 0) goto B7 else B8\n}",
      "B7 {\n  throw $r5\n}",
      "B8 {\n  $l7 \u003d GJChronology: long iCutoverMillis\u003e\n  $b8 \u003d l14 cmp $l7\n  $i16 \u003d (int) $b8\n  if ($i16 \u003e\u003d 0) goto B9 else B11\n}",
      "B9 {\n  $r3 \u003d JulianChronology iJulianChronology\u003e\n  l14 \u003d $r3.getDateTimeMillis(i0, i1, i2, i3, i4, i5, i6)\n  $l9 \u003d GJChronology: long iCutoverMillis\u003e\n  $b10 \u003d l14 cmp $l9\n  $i17 \u003d (int) $b10\n  if ($i17 \u003c 0) goto B10 else B11\n}",
      "B10 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Specified date does not exist\")\n  throw $r7\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof GJChronology) {\r\n        GJChronology chrono \u003d (GJChronology) obj;\r\n        return iCutoverMillis \u003d\u003d chrono.iCutoverMillis \u0026\u0026 getMinimumDaysInFirstWeek() \u003d\u003d chrono.getMinimumDaysInFirstWeek() \u0026\u0026 getZone().equals(chrono.getZone());\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B9",
      "B3 : If($b2 !\u003d 0) → B4 | else → B7",
      "B4 : If($i4 !\u003d $i3) → B5 | else → B7",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d GJChronology\n  if ($z0 \u003d\u003d false) goto B3 else B9\n}",
      "B3 {\n  r2 \u003d GJChronology) r1\n  $l1 \u003d GJChronology: long iCutoverMillis\u003e\n  $l0 \u003d GJChronology: long iCutoverMillis\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B4 else B7\n}",
      "B4 {\n  $i4 \u003d r0.getMinimumDaysInFirstWeek()\n  $i3 \u003d r2.getMinimumDaysInFirstWeek()\n  if ($i4 !\u003d $i3) goto B5 else B7\n}",
      "B5 {\n  $r4 \u003d r0.getZone()\n  $r3 \u003d r2.getZone()\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z2 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z2 \u003d 0\n}",
      "B8 {\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getMinimumDaysInFirstWeek(...0)",
        "body": "{\r\n    return iGregorianChronology.getMinimumDaysInFirstWeek();\r\n}"
      },
      {
        "name": "GJChronology#getZone(...0)",
        "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getZone();\r\n    }\r\n    return DateTimeZone.UTC;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GJChronology",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    StringBuffer sb \u003d new StringBuffer(60);\r\n    sb.append(\"GJChronology\");\r\n    sb.append(\u0027[\u0027);\r\n    sb.append(getZone().getID());\r\n    if (iCutoverMillis !\u003d DEFAULT_CUTOVER.getMillis()) {\r\n        sb.append(\",cutover\u003d\");\r\n        DateTimeFormatter printer;\r\n        if (withUTC().dayOfYear().remainder(iCutoverMillis) \u003d\u003d 0) {\r\n            printer \u003d ISODateTimeFormat.date();\r\n        } else {\r\n            printer \u003d ISODateTimeFormat.dateTime();\r\n        }\r\n        printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\r\n    }\r\n    if (getMinimumDaysInFirstWeek() !\u003d 4) {\r\n        sb.append(\",mdfw\u003d\");\r\n        sb.append(getMinimumDaysInFirstWeek());\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    return sb.toString();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($b2 \u003d\u003d false) → B1 | else → B5",
      "B1 : If($b6 !\u003d 0) → B2 | else → B3",
      "B5 : If($i8 \u003d\u003d 4) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  GJChronology\n  $r0 \u003d StringBuffer\n  new StringBuffer(60)\n  $r0.append(\"GJChronology\")\n  $r0.append(91)\n  $r2 \u003d r1.getZone()\n  $r3 \u003d $r2.getID()\n  $r0.append($r3)\n  $l0 \u003d GJChronology: long iCutoverMillis\u003e\n  $r4 \u003d Instant DEFAULT_CUTOVER\u003e\n  $l1 \u003d $r4.getMillis()\n  $b2 \u003d $l0 cmp $l1\n  if ($b2 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  $r0.append(\",cutover\u003d\")\n  $r6 \u003d r1.withUTC()\n  $r7 \u003d $r6.dayOfYear()\n  $l4 \u003d GJChronology: long iCutoverMillis\u003e\n  $l5 \u003d $r7.remainder($l4)\n  $b6 \u003d $l5 cmp 0L\n  if ($b6 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r10 \u003d ISODateTimeFormat.date()\n  goto B4\n}",
      "B3 {\n  r10 \u003d ISODateTimeFormat.dateTime()\n}",
      "B4 {\n  $r8 \u003d r1.withUTC()\n  $r9 \u003d r10.withChronology($r8)\n  $l7 \u003d GJChronology: long iCutoverMillis\u003e\n  $r9.printTo($r0, $l7)\n}",
      "B5 {\n  $i8 \u003d r1.getMinimumDaysInFirstWeek()\n  if ($i8 \u003d\u003d 4) goto B6 else B7\n}",
      "B6 {\n  $r0.append(\",mdfw\u003d\")\n  $i3 \u003d r1.getMinimumDaysInFirstWeek()\n  $r0.append($i3)\n}",
      "B7 {\n  $r0.append(93)\n  $r5 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GJChronology#getMinimumDaysInFirstWeek(...0)",
        "body": "{\r\n    return iGregorianChronology.getMinimumDaysInFirstWeek();\r\n}"
      },
      {
        "name": "GJChronology#getZone(...0)",
        "body": "{\r\n    Chronology base;\r\n    if ((base \u003d getBase()) !\u003d null) {\r\n        return base.getZone();\r\n    }\r\n    return DateTimeZone.UTC;\r\n}"
      },
      {
        "name": "GJChronology#withUTC(...0)",
        "body": "{\r\n    return withZone(DateTimeZone.UTC);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GregorianChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.GregorianChronology getInstance(org.joda.time.DateTimeZone,int)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    GregorianChronology chrono;\r\n    GregorianChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new GregorianChronology[7];\r\n        GregorianChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    chrono \u003d new GregorianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 16,
    "edges": 19,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r14 !\u003d null) → B1 | else → B2",
      "B2 : If($r9 !\u003d null) → B3 | else → B5",
      "B3 : If(r16 \u003d\u003d null) → B4 | else → B5",
      "B7 : If($r17 !\u003d null) → B8 | else → B15",
      "B8 : If(r18 !\u003d null) → B9 | else → B13",
      "B9 : If(r14 !\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  i0 :\u003d @parameter1: int\n  if (r14 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r14)\n  $r9 \u003d GregorianChronology[]) $r1\n  r15 \u003d $r9\n  if ($r9 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r15 \u003d GregorianChronology)[7]\n  $r7 \u003d ConcurrentHashMap cCache\u003e\n  $r8 \u003d $r7.putIfAbsent(r14, r15)\n  r16 \u003d GregorianChronology[]) $r8\n  if (r16 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r15 \u003d r16\n}",
      "B5 {\n  $i3 \u003d i0 - 1\n  $r17 \u003d r15[$i3]\n  r18 \u003d $r17\n  goto B7\n}",
      "B6 {\n  $r11 :\u003d @caughtexception\n  $r12 \u003d IllegalArgumentException\n  $r13 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r13)\n  throw $r12\n}",
      "B7 {\n  if ($r17 !\u003d null) goto B8 else B15\n}",
      "B8 {\n  r19 \u003d r15\n  entermonitor r15\n  $i1 \u003d i0 - 1\n  r18 \u003d r15[$i1]\n  if (r18 !\u003d null) goto B9 else B13\n}",
      "B9 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r14 !\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r6 \u003d GregorianChronology\n  new GregorianChronology(null, null, i0)\n  r18 \u003d $r6\n  goto B12\n}",
      "B11 {\n  $r3 \u003d DateTimeZone UTC\u003e\n  r20 \u003d GregorianChronology.getInstance($r3, i0)\n  $r4 \u003d GregorianChronology\n  $r5 \u003d ZonedChronology.getInstance(r20, r14)\n  new GregorianChronology($r5, null, i0)\n  r18 \u003d $r4\n}",
      "B12 {\n  $i2 \u003d i0 - 1\n  r15[$i2] \u003d r18\n}",
      "B13 {\n  exitmonitor r19\n  goto B15\n}",
      "B14 {\n  $r10 :\u003d @caughtexception\n  exitmonitor r19\n  throw $r10\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B15",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GregorianChronology#getInstance(...2)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    GregorianChronology chrono;\r\n    GregorianChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new GregorianChronology[7];\r\n        GregorianChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    chrono \u003d new GregorianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.GregorianChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  GregorianChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d GregorianChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GregorianChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "GregorianChronology#getInstance(...1)",
        "body": "{\r\n    return getInstance(zone, 4);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.IslamicChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.IslamicChronology getInstance(org.joda.time.DateTimeZone,org.joda.time.chrono.IslamicChronology$LeapYearPatternType)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r15 !\u003d null) → B1 | else → B2",
      "B2 : If($r13 !\u003d null) → B3 | else → B5",
      "B3 : If(r17 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($r18 !\u003d null) → B6 | else → B13",
      "B6 : If(r19 !\u003d null) → B7 | else → B11",
      "B7 : If(r15 !\u003d $r3) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  IslamicChronology$LeapYearPatternType\n  if (r15 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r15 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r15)\n  $r13 \u003d IslamicChronology[]) $r1\n  r16 \u003d $r13\n  if ($r13 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r16 \u003d IslamicChronology)[4]\n  $r11 \u003d ConcurrentHashMap cCache\u003e\n  $r12 \u003d $r11.putIfAbsent(r15, r16)\n  r17 \u003d IslamicChronology[]) $r12\n  if (r17 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r16 \u003d r17\n}",
      "B5 {\n  $b2 \u003d IslamicChronology$LeapYearPatternType: byte index\u003e\n  $i3 \u003d (int) $b2\n  $r18 \u003d r16[$i3]\n  r19 \u003d $r18\n  if ($r18 !\u003d null) goto B6 else B13\n}",
      "B6 {\n  r20 \u003d r16\n  entermonitor r16\n  $b0 \u003d IslamicChronology$LeapYearPatternType: byte index\u003e\n  $i4 \u003d (int) $b0\n  r19 \u003d r16[$i4]\n  if (r19 !\u003d null) goto B7 else B11\n}",
      "B7 {\n  $r3 \u003d DateTimeZone UTC\u003e\n  if (r15 !\u003d $r3) goto B8 else B9\n}",
      "B8 {\n  $r22 \u003d IslamicChronology\n  new IslamicChronology(null, null, r2)\n  $r23 \u003d DateTime\n  new DateTime(1, 1, 1, 0, 0, 0, 0, $r22)\n  $r24 \u003d IslamicChronology\n  $r10 \u003d LimitChronology.getInstance($r22, $r23, null)\n  new IslamicChronology($r10, null, r2)\n  r19 \u003d $r24\n  goto B10\n}",
      "B9 {\n  $r4 \u003d DateTimeZone UTC\u003e\n  r21 \u003d IslamicChronology.getInstance($r4, r2)\n  $r25 \u003d IslamicChronology\n  $r6 \u003d ZonedChronology.getInstance(r21, r15)\n  new IslamicChronology($r6, null, r2)\n  r19 \u003d $r25\n}",
      "B10 {\n  $b1 \u003d IslamicChronology$LeapYearPatternType: byte index\u003e\n  $i5 \u003d (int) $b1\n  r16[$i5] \u003d r19\n}",
      "B11 {\n  exitmonitor r20\n  goto B13\n}",
      "B12 {\n  $r14 :\u003d @caughtexception\n  exitmonitor r20\n  throw $r14\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B7",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.IslamicChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  IslamicChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d IslamicChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IslamicChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "IslamicChronology#getInstance(...1)",
        "body": "{\r\n    return getInstance(zone, LEAP_YEAR_16_BASED);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.IslamicChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof IslamicChronology) {\r\n        IslamicChronology chrono \u003d (IslamicChronology) obj;\r\n        return getLeapYearPatternType().index \u003d\u003d chrono.getLeapYearPatternType().index \u0026\u0026 super.equals(obj);\r\n    }\r\n    return false;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($i2 !\u003d $i3) → B4 | else → B6",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  IslamicChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d IslamicChronology\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d IslamicChronology) r1\n  $r3 \u003d r0.getLeapYearPatternType()\n  $b0 \u003d IslamicChronology$LeapYearPatternType: byte index\u003e\n  $r4 \u003d r2.getLeapYearPatternType()\n  $b1 \u003d IslamicChronology$LeapYearPatternType: byte index\u003e\n  $i2 \u003d (int) $b0\n  $i3 \u003d (int) $b1\n  if ($i2 !\u003d $i3) goto B4 else B6\n}",
      "B4 {\n  $z1 \u003d r0.equals(r1)\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $z2 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z2 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IslamicChronology#getLeapYearPatternType(...0)",
        "body": "{\r\n    return iLeapYears;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.ISOChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.ISOChronology getInstance(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    ISOChronology chrono \u003d cCache.get(zone);\r\n    if (chrono \u003d\u003d null) {\r\n        chrono \u003d new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\r\n        ISOChronology oldChrono \u003d cCache.putIfAbsent(zone, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r9 !\u003d null) → B1 | else → B2",
      "B2 : If($r8 !\u003d null) → B3 | else → B5",
      "B3 : If(r7 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r9 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r9 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r9)\n  $r8 \u003d ISOChronology) $r1\n  r10 \u003d $r8\n  if ($r8 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r2 \u003d ISOChronology\n  $r3 \u003d ISOChronology INSTANCE_UTC\u003e\n  $r4 \u003d ZonedChronology.getInstance($r3, r9)\n  new ISOChronology($r4)\n  r10 \u003d $r2\n  $r5 \u003d ConcurrentHashMap cCache\u003e\n  $r6 \u003d $r5.putIfAbsent(r9, $r2)\n  r7 \u003d ISOChronology) $r6\n  if (r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r10 \u003d r7\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.ISOChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ISOChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d ISOChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISOChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ISOChronology#getInstance(...1)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    ISOChronology chrono \u003d cCache.get(zone);\r\n    if (chrono \u003d\u003d null) {\r\n        chrono \u003d new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\r\n        ISOChronology oldChrono \u003d cCache.putIfAbsent(zone, chrono);\r\n        if (oldChrono !\u003d null) {\r\n            chrono \u003d oldChrono;\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.ISOChronology",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    String str \u003d \"ISOChronology\";\r\n    DateTimeZone zone \u003d getZone();\r\n    if (zone !\u003d null) {\r\n        str \u003d str + \u0027[\u0027 + zone.getID() + \u0027]\u0027;\r\n    }\r\n    return str;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ISOChronology\n  r3 \u003d \"ISOChronology\"\n  r1 \u003d r0.getZone()\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1.getID()\n  r3 \u003d dynInvoke makeConcatWithConstants(\"ISOChronology\", $r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISOChronology#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.ISOChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ISOChronology) {\r\n        ISOChronology chrono \u003d (ISOChronology) obj;\r\n        return getZone().equals(chrono.getZone());\r\n    }\r\n    return false;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ISOChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d ISOChronology\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r2 \u003d ISOChronology) r1\n  $r4 \u003d r0.getZone()\n  $r3 \u003d r2.getZone()\n  $z1 \u003d $r4.equals($r3)\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISOChronology#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.JulianChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.JulianChronology getInstance(org.joda.time.DateTimeZone,int)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    JulianChronology chrono;\r\n    JulianChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new JulianChronology[7];\r\n        JulianChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    chrono \u003d new JulianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 16,
    "edges": 19,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r14 !\u003d null) → B1 | else → B2",
      "B2 : If($r9 !\u003d null) → B3 | else → B5",
      "B3 : If(r16 \u003d\u003d null) → B4 | else → B5",
      "B7 : If($r17 !\u003d null) → B8 | else → B15",
      "B8 : If(r18 !\u003d null) → B9 | else → B13",
      "B9 : If(r14 !\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  i0 :\u003d @parameter1: int\n  if (r14 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d ConcurrentHashMap cCache\u003e\n  $r1 \u003d $r0.get(r14)\n  $r9 \u003d JulianChronology[]) $r1\n  r15 \u003d $r9\n  if ($r9 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  r15 \u003d JulianChronology)[7]\n  $r7 \u003d ConcurrentHashMap cCache\u003e\n  $r8 \u003d $r7.putIfAbsent(r14, r15)\n  r16 \u003d JulianChronology[]) $r8\n  if (r16 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r15 \u003d r16\n}",
      "B5 {\n  $i3 \u003d i0 - 1\n  $r17 \u003d r15[$i3]\n  r18 \u003d $r17\n  goto B7\n}",
      "B6 {\n  $r11 :\u003d @caughtexception\n  $r12 \u003d IllegalArgumentException\n  $r13 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r13)\n  throw $r12\n}",
      "B7 {\n  if ($r17 !\u003d null) goto B8 else B15\n}",
      "B8 {\n  r19 \u003d r15\n  entermonitor r15\n  $i1 \u003d i0 - 1\n  r18 \u003d r15[$i1]\n  if (r18 !\u003d null) goto B9 else B13\n}",
      "B9 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r14 !\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r6 \u003d JulianChronology\n  new JulianChronology(null, null, i0)\n  r18 \u003d $r6\n  goto B12\n}",
      "B11 {\n  $r3 \u003d DateTimeZone UTC\u003e\n  r20 \u003d JulianChronology.getInstance($r3, i0)\n  $r4 \u003d JulianChronology\n  $r5 \u003d ZonedChronology.getInstance(r20, r14)\n  new JulianChronology($r5, null, i0)\n  r18 \u003d $r4\n}",
      "B12 {\n  $i2 \u003d i0 - 1\n  r15[$i2] \u003d r18\n}",
      "B13 {\n  exitmonitor r19\n  goto B15\n}",
      "B14 {\n  $r10 :\u003d @caughtexception\n  exitmonitor r19\n  throw $r10\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B15",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JulianChronology#getInstance(...2)",
        "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    JulianChronology chrono;\r\n    JulianChronology[] chronos \u003d cCache.get(zone);\r\n    if (chronos \u003d\u003d null) {\r\n        chronos \u003d new JulianChronology[7];\r\n        JulianChronology[] oldChronos \u003d cCache.putIfAbsent(zone, chronos);\r\n        if (oldChronos !\u003d null) {\r\n            chronos \u003d oldChronos;\r\n        }\r\n    }\r\n    try {\r\n        chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        synchronized (chronos) {\r\n            chrono \u003d chronos[minDaysInFirstWeek - 1];\r\n            if (chrono \u003d\u003d null) {\r\n                if (zone \u003d\u003d DateTimeZone.UTC) {\r\n                    chrono \u003d new JulianChronology(null, null, minDaysInFirstWeek);\r\n                } else {\r\n                    chrono \u003d getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\r\n                    chrono \u003d new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\r\n                }\r\n                chronos[minDaysInFirstWeek - 1] \u003d chrono;\r\n            }\r\n        }\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.JulianChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return getInstance(zone);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d $r1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JulianChronology\n  DateTimeZone\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r3 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d JulianChronology.getInstance(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JulianChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "JulianChronology#getInstance(...1)",
        "body": "{\r\n    return getInstance(zone, 4);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LenientChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.LenientChronology getInstance(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    return new LenientChronology(base);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must supply a chronology\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LenientChronology\n  new LenientChronology(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.LenientChronology",
    "methodName": "withUTC",
    "signature": "org.joda.time.Chronology withUTC()",
    "visibility": "public",
    "body": "{\r\n    if (iWithUTC \u003d\u003d null) {\r\n        if (getZone() \u003d\u003d DateTimeZone.UTC) {\r\n            iWithUTC \u003d this;\r\n        } else {\r\n            iWithUTC \u003d LenientChronology.getInstance(getBase().withUTC());\r\n        }\r\n    }\r\n    return iWithUTC;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B4",
      "B1 : If($r3 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  LenientChronology\n  $r1 \u003d Chronology iWithUTC\u003e\n  if ($r1 !\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d r0.getZone()\n  $r2 \u003d DateTimeZone UTC\u003e\n  if ($r3 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  Chronology iWithUTC\u003e \u003d r0\n  goto B4\n}",
      "B3 {\n  $r4 \u003d r0.getBase()\n  $r5 \u003d $r4.withUTC()\n  $r6 \u003d LenientChronology.getInstance($r5)\n  Chronology iWithUTC\u003e \u003d $r6\n}",
      "B4 {\n  $r7 \u003d Chronology iWithUTC\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LenientChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "LenientChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LenientChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d DateTimeZone.UTC) {\r\n        return withUTC();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return LenientChronology.getInstance(getBase().withZone(zone));\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B2",
      "B2 : If(r7 !\u003d $r0) → B3 | else → B4",
      "B4 : If(r7 !\u003d $r2) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LenientChronology\n  DateTimeZone\n  if (r7 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r7 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d DateTimeZone UTC\u003e\n  if (r7 !\u003d $r0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r1.withUTC()\n  return\n}",
      "B4 {\n  $r2 \u003d r1.getZone()\n  if (r7 !\u003d $r2) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r3 \u003d r1.getBase()\n  $r4 \u003d $r3.withZone(r7)\n  $r5 \u003d LenientChronology.getInstance($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LenientChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "LenientChronology#getBase(...0)",
        "body": "(source not found)"
      },
      {
        "name": "LenientChronology#withUTC(...0)",
        "body": "{\r\n    if (iWithUTC \u003d\u003d null) {\r\n        if (getZone() \u003d\u003d DateTimeZone.UTC) {\r\n            iWithUTC \u003d this;\r\n        } else {\r\n            iWithUTC \u003d LenientChronology.getInstance(getBase().withUTC());\r\n        }\r\n    }\r\n    return iWithUTC;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LenientChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LenientChronology \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    LenientChronology chrono \u003d (LenientChronology) obj;\r\n    return getBase().equals(chrono.getBase());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LenientChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LenientChronology\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d LenientChronology) r1\n  $r4 \u003d r0.getBase()\n  $r3 \u003d r2.getBase()\n  $z1 \u003d $r4.equals($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LenientChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LimitChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.LimitChronology getInstance(org.joda.time.Chronology,org.joda.time.ReadableDateTime,org.joda.time.ReadableDateTime)",
    "visibility": "public",
    "body": "{\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    lowerLimit \u003d lowerLimit \u003d\u003d null ? null : lowerLimit.toDateTime();\r\n    upperLimit \u003d upperLimit \u003d\u003d null ? null : upperLimit.toDateTime();\r\n    if (lowerLimit !\u003d null \u0026\u0026 upperLimit !\u003d null \u0026\u0026 !lowerLimit.isBefore(upperLimit)) {\r\n        throw new IllegalArgumentException(\"The lower limit must be come before than the upper limit\");\r\n    }\r\n    return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit);\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d null) → B3 | else → B4",
      "B5 : If(r4 !\u003d null) → B6 | else → B7",
      "B8 : If(r6 \u003d\u003d null) → B9 | else → B12",
      "B9 : If($r7 \u003d\u003d null) → B10 | else → B12",
      "B10 : If($z0 !\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  ReadableDateTime\n  ReadableDateTime\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must supply a chronology\")\n  throw $r2\n}",
      "B2 {\n  if (r3 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d null\n  goto B5\n}",
      "B4 {\n  $r5 \u003d r3.toDateTime()\n}",
      "B5 {\n  r6 \u003d $r5\n  if (r4 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d null\n  goto B8\n}",
      "B7 {\n  $r7 \u003d r4.toDateTime()\n}",
      "B8 {\n  r8 \u003d $r7\n  if (r6 \u003d\u003d null) goto B9 else B12\n}",
      "B9 {\n  if ($r7 \u003d\u003d null) goto B10 else B12\n}",
      "B10 {\n  $z0 \u003d r6.isBefore($r7)\n  if ($z0 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The lower limit must be come before than the upper limit\")\n  throw $r1\n}",
      "B12 {\n  $r9 \u003d LimitChronology\n  $r10 \u003d DateTime) r6\n  $r11 \u003d DateTime) r8\n  new LimitChronology(r0, $r10, $r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.LimitChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    if (zone \u003d\u003d DateTimeZone.UTC \u0026\u0026 iWithUTC !\u003d null) {\r\n        return iWithUTC;\r\n    }\r\n    DateTime lowerLimit \u003d iLowerLimit;\r\n    if (lowerLimit !\u003d null) {\r\n        MutableDateTime mdt \u003d lowerLimit.toMutableDateTime();\r\n        mdt.setZoneRetainFields(zone);\r\n        lowerLimit \u003d mdt.toDateTime();\r\n    }\r\n    DateTime upperLimit \u003d iUpperLimit;\r\n    if (upperLimit !\u003d null) {\r\n        MutableDateTime mdt \u003d upperLimit.toMutableDateTime();\r\n        mdt.setZoneRetainFields(zone);\r\n        upperLimit \u003d mdt.toDateTime();\r\n    }\r\n    LimitChronology chrono \u003d getInstance(getBase().withZone(zone), lowerLimit, upperLimit);\r\n    if (zone \u003d\u003d DateTimeZone.UTC) {\r\n        iWithUTC \u003d chrono;\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r11 !\u003d null) → B1 | else → B2",
      "B2 : If(r11 !\u003d $r1) → B3 | else → B4",
      "B4 : If(r11 !\u003d $r2) → B5 | else → B7",
      "B5 : If($r8 \u003d\u003d null) → B6 | else → B7",
      "B7 : If($r9 \u003d\u003d null) → B8 | else → B9",
      "B9 : If($r7 \u003d\u003d null) → B10 | else → B11",
      "B11 : If(r11 !\u003d $r5) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  LimitChronology\n  DateTimeZone\n  if (r11 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r11 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getZone()\n  if (r11 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r11 !\u003d $r2) goto B5 else B7\n}",
      "B5 {\n  $r8 \u003d LimitChronology iWithUTC\u003e\n  if ($r8 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d LimitChronology iWithUTC\u003e\n  return\n}",
      "B7 {\n  $r9 \u003d DateTime iLowerLimit\u003e\n  r12 \u003d $r9\n  if ($r9 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  r13 \u003d $r9.toMutableDateTime()\n  r13.setZoneRetainFields(r11)\n  r12 \u003d r13.toDateTime()\n}",
      "B9 {\n  $r7 \u003d DateTime iUpperLimit\u003e\n  r14 \u003d $r7\n  if ($r7 \u003d\u003d null) goto B10 else B11\n}",
      "B10 {\n  r15 \u003d $r7.toMutableDateTime()\n  r15.setZoneRetainFields(r11)\n  r14 \u003d r15.toDateTime()\n}",
      "B11 {\n  $r3 \u003d r0.getBase()\n  $r4 \u003d $r3.withZone(r11)\n  $r6 \u003d LimitChronology.getInstance($r4, r12, r14)\n  $r5 \u003d DateTimeZone UTC\u003e\n  if (r11 !\u003d $r5) goto B12 else B13\n}",
      "B12 {\n  LimitChronology iWithUTC\u003e \u003d $r6\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LimitChronology#getInstance(...3)",
        "body": "{\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    lowerLimit \u003d lowerLimit \u003d\u003d null ? null : lowerLimit.toDateTime();\r\n    upperLimit \u003d upperLimit \u003d\u003d null ? null : upperLimit.toDateTime();\r\n    if (lowerLimit !\u003d null \u0026\u0026 upperLimit !\u003d null \u0026\u0026 !lowerLimit.isBefore(upperLimit)) {\r\n        throw new IllegalArgumentException(\"The lower limit must be come before than the upper limit\");\r\n    }\r\n    return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit);\r\n}"
      },
      {
        "name": "LimitChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "LimitChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LimitChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LimitChronology \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    LimitChronology chrono \u003d (LimitChronology) obj;\r\n    return getBase().equals(chrono.getBase()) \u0026\u0026 FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) \u0026\u0026 FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B8",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z3 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  LimitChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LimitChronology\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d LimitChronology) r1\n  $r4 \u003d r0.getBase()\n  $r3 \u003d r2.getBase()\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $r6 \u003d r0.getLowerLimit()\n  $r5 \u003d r2.getLowerLimit()\n  $z2 \u003d FieldUtils.equals($r6, $r5)\n  if ($z2 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d r0.getUpperLimit()\n  $r7 \u003d r2.getUpperLimit()\n  $z3 \u003d FieldUtils.equals($r8, $r7)\n  if ($z3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z4 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z4 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LimitChronology#getLowerLimit(...0)",
        "body": "{\r\n    return iLowerLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getUpperLimit(...0)",
        "body": "{\r\n    return iUpperLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LimitChronology",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    int hash \u003d 317351877;\r\n    hash +\u003d (getLowerLimit() !\u003d null ? getLowerLimit().hashCode() : 0);\r\n    hash +\u003d (getUpperLimit() !\u003d null ? getUpperLimit().hashCode() : 0);\r\n    hash +\u003d getBase().hashCode() * 7;\r\n    return hash;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LimitChronology\n  $r1 \u003d r0.getLowerLimit()\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0.getLowerLimit()\n  $i5 \u003d $r5.hashCode()\n  goto B3\n}",
      "B2 {\n  $i5 \u003d 0\n}",
      "B3 {\n  $i4 \u003d 317351877 + $i5\n  $r2 \u003d r0.getUpperLimit()\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d r0.getUpperLimit()\n  $i6 \u003d $r4.hashCode()\n  goto B6\n}",
      "B5 {\n  $i6 \u003d 0\n}",
      "B6 {\n  $i2 \u003d $i4 + $i6\n  $r3 \u003d r0.getBase()\n  $i0 \u003d $r3.hashCode()\n  $i1 \u003d $i0 * 7\n  $i3 \u003d $i2 + $i1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LimitChronology#getLowerLimit(...0)",
        "body": "{\r\n    return iLowerLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getUpperLimit(...0)",
        "body": "{\r\n    return iUpperLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.LimitChronology",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    return \"LimitChronology[\" + getBase().toString() + \", \" + (getLowerLimit() \u003d\u003d null ? \"NoLimit\" : getLowerLimit().toString()) + \", \" + (getUpperLimit() \u003d\u003d null ? \"NoLimit\" : getUpperLimit().toString()) + \u0027]\u0027;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 !\u003d null) → B1 | else → B2",
      "B3 : If($r4 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LimitChronology\n  $r1 \u003d r0.getBase()\n  $r6 \u003d $r1.toString()\n  $r2 \u003d r0.getLowerLimit()\n  if ($r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d \"NoLimit\"\n  goto B3\n}",
      "B2 {\n  $r3 \u003d r0.getLowerLimit()\n  $r7 \u003d $r3.toString()\n}",
      "B3 {\n  $r4 \u003d r0.getUpperLimit()\n  if ($r4 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d \"NoLimit\"\n  goto B6\n}",
      "B5 {\n  $r5 \u003d r0.getUpperLimit()\n  $r8 \u003d $r5.toString()\n}",
      "B6 {\n  $r9 \u003d dynInvoke makeConcatWithConstants($r6, $r7, $r8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LimitChronology#getLowerLimit(...0)",
        "body": "{\r\n    return iLowerLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getUpperLimit(...0)",
        "body": "{\r\n    return iUpperLimit;\r\n}"
      },
      {
        "name": "LimitChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.StrictChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.StrictChronology getInstance(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    return new StrictChronology(base);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must supply a chronology\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d StrictChronology\n  new StrictChronology(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.StrictChronology",
    "methodName": "withUTC",
    "signature": "org.joda.time.Chronology withUTC()",
    "visibility": "public",
    "body": "{\r\n    if (iWithUTC \u003d\u003d null) {\r\n        if (getZone() \u003d\u003d DateTimeZone.UTC) {\r\n            iWithUTC \u003d this;\r\n        } else {\r\n            iWithUTC \u003d StrictChronology.getInstance(getBase().withUTC());\r\n        }\r\n    }\r\n    return iWithUTC;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B4",
      "B1 : If($r3 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  StrictChronology\n  $r1 \u003d Chronology iWithUTC\u003e\n  if ($r1 !\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d r0.getZone()\n  $r2 \u003d DateTimeZone UTC\u003e\n  if ($r3 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  Chronology iWithUTC\u003e \u003d r0\n  goto B4\n}",
      "B3 {\n  $r4 \u003d r0.getBase()\n  $r5 \u003d $r4.withUTC()\n  $r6 \u003d StrictChronology.getInstance($r5)\n  Chronology iWithUTC\u003e \u003d $r6\n}",
      "B4 {\n  $r7 \u003d Chronology iWithUTC\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StrictChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "StrictChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.StrictChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d DateTimeZone.UTC) {\r\n        return withUTC();\r\n    }\r\n    if (zone \u003d\u003d getZone()) {\r\n        return this;\r\n    }\r\n    return StrictChronology.getInstance(getBase().withZone(zone));\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B2",
      "B2 : If(r7 !\u003d $r0) → B3 | else → B4",
      "B4 : If(r7 !\u003d $r2) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  StrictChronology\n  DateTimeZone\n  if (r7 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r7 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r0 \u003d DateTimeZone UTC\u003e\n  if (r7 !\u003d $r0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r1.withUTC()\n  return\n}",
      "B4 {\n  $r2 \u003d r1.getZone()\n  if (r7 !\u003d $r2) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r3 \u003d r1.getBase()\n  $r4 \u003d $r3.withZone(r7)\n  $r5 \u003d StrictChronology.getInstance($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StrictChronology#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "StrictChronology#getBase(...0)",
        "body": "(source not found)"
      },
      {
        "name": "StrictChronology#withUTC(...0)",
        "body": "{\r\n    if (iWithUTC \u003d\u003d null) {\r\n        if (getZone() \u003d\u003d DateTimeZone.UTC) {\r\n            iWithUTC \u003d this;\r\n        } else {\r\n            iWithUTC \u003d StrictChronology.getInstance(getBase().withUTC());\r\n        }\r\n    }\r\n    return iWithUTC;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.StrictChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof StrictChronology \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    StrictChronology chrono \u003d (StrictChronology) obj;\r\n    return getBase().equals(chrono.getBase());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  StrictChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d StrictChronology\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d StrictChronology) r1\n  $r4 \u003d r0.getBase()\n  $r3 \u003d r2.getBase()\n  $z1 \u003d $r4.equals($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StrictChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.ZonedChronology",
    "methodName": "getInstance",
    "signature": "org.joda.time.chrono.ZonedChronology getInstance(org.joda.time.Chronology,org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must supply a chronology\");\r\n    }\r\n    base \u003d base.withUTC();\r\n    if (base \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"UTC chronology must not be null\");\r\n    }\r\n    if (zone \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"DateTimeZone must not be null\");\r\n    }\r\n    return new ZonedChronology(base, zone);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If(r6 !\u003d null) → B3 | else → B4",
      "B4 : If(r0 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  DateTimeZone\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must supply a chronology\")\n  throw $r4\n}",
      "B2 {\n  r6 \u003d r5.withUTC()\n  if (r6 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"UTC chronology must not be null\")\n  throw $r3\n}",
      "B4 {\n  if (r0 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"DateTimeZone must not be null\")\n  throw $r2\n}",
      "B6 {\n  $r1 \u003d ZonedChronology\n  new ZonedChronology(r6, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.chrono.ZonedChronology",
    "methodName": "withZone",
    "signature": "org.joda.time.Chronology withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        zone \u003d DateTimeZone.getDefault();\r\n    }\r\n    if (zone \u003d\u003d getParam()) {\r\n        return this;\r\n    }\r\n    if (zone \u003d\u003d DateTimeZone.UTC) {\r\n        return getBase();\r\n    }\r\n    return new ZonedChronology(getBase(), zone);\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B2",
      "B2 : If(r6 !\u003d $r1) → B3 | else → B4",
      "B4 : If(r6 !\u003d $r2) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ZonedChronology\n  DateTimeZone\n  if (r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r6 \u003d DateTimeZone.getDefault()\n}",
      "B2 {\n  $r1 \u003d r0.getParam()\n  if (r6 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  if (r6 !\u003d $r2) goto B5 else B6\n}",
      "B5 {\n  $r5 \u003d r0.getBase()\n  return\n}",
      "B6 {\n  $r3 \u003d ZonedChronology\n  $r4 \u003d r0.getBase()\n  new ZonedChronology($r4, r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZonedChronology#getParam(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZonedChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.chrono.ZonedChronology",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof ZonedChronology \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    ZonedChronology chrono \u003d (ZonedChronology) obj;\r\n    return getBase().equals(chrono.getBase()) \u0026\u0026 getZone().equals(chrono.getZone());\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B7",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ZonedChronology\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d ZonedChronology\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d ZonedChronology) r1\n  $r4 \u003d r0.getBase()\n  $r3 \u003d r2.getBase()\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  $r6 \u003d r0.getZone()\n  $r5 \u003d r2.getZone()\n  $z2 \u003d $r6.equals($r5)\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z3 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z3 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZonedChronology#getZone(...0)",
        "body": "{\r\n    return (DateTimeZone) getParam();\r\n}"
      },
      {
        "name": "ZonedChronology#getBase(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "getInstantConverter",
    "signature": "org.joda.time.convert.InstantConverter getInstantConverter(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    InstantConverter converter \u003d (InstantConverter) iInstantConverters.select(object \u003d\u003d null ? null : object.getClass());\r\n    if (converter !\u003d null) {\r\n        return converter;\r\n    }\r\n    throw new IllegalArgumentException(\"No instant converter found for type: \" + (object \u003d\u003d null ? \"null\" : object.getClass().getName()));\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  Object\n  $r2 \u003d ConverterSet iInstantConverters\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d r1.getClass()\n}",
      "B3 {\n  $r3 \u003d $r2.select($r8)\n  $r7 \u003d InstantConverter) $r3\n  if ($r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r4 \u003d IllegalArgumentException\n  if (r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d \"null\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d r1.getClass()\n  $r9 \u003d $r5.getName()\n}",
      "B8 {\n  $r6 \u003d dynInvoke makeConcatWithConstants($r9)\n  new IllegalArgumentException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "addInstantConverter",
    "signature": "org.joda.time.convert.InstantConverter addInstantConverter(org.joda.time.convert.InstantConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterInstantConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    InstantConverter[] removed \u003d new InstantConverter[1];\r\n    iInstantConverters \u003d iInstantConverters.add(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  InstantConverter\n  r0.checkAlterInstantConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d InstantConverter)[1]\n  $r3 \u003d ConverterSet iInstantConverters\u003e\n  $r4 \u003d $r3.add(r1, r2)\n  ConverterSet iInstantConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterInstantConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "removeInstantConverter",
    "signature": "org.joda.time.convert.InstantConverter removeInstantConverter(org.joda.time.convert.InstantConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterInstantConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    InstantConverter[] removed \u003d new InstantConverter[1];\r\n    iInstantConverters \u003d iInstantConverters.remove(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  InstantConverter\n  r0.checkAlterInstantConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d InstantConverter)[1]\n  $r3 \u003d ConverterSet iInstantConverters\u003e\n  $r4 \u003d $r3.remove(r1, r2)\n  ConverterSet iInstantConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterInstantConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "getPartialConverter",
    "signature": "org.joda.time.convert.PartialConverter getPartialConverter(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    PartialConverter converter \u003d (PartialConverter) iPartialConverters.select(object \u003d\u003d null ? null : object.getClass());\r\n    if (converter !\u003d null) {\r\n        return converter;\r\n    }\r\n    throw new IllegalArgumentException(\"No partial converter found for type: \" + (object \u003d\u003d null ? \"null\" : object.getClass().getName()));\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  Object\n  $r2 \u003d ConverterSet iPartialConverters\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d r1.getClass()\n}",
      "B3 {\n  $r3 \u003d $r2.select($r8)\n  $r7 \u003d PartialConverter) $r3\n  if ($r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r4 \u003d IllegalArgumentException\n  if (r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d \"null\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d r1.getClass()\n  $r9 \u003d $r5.getName()\n}",
      "B8 {\n  $r6 \u003d dynInvoke makeConcatWithConstants($r9)\n  new IllegalArgumentException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "addPartialConverter",
    "signature": "org.joda.time.convert.PartialConverter addPartialConverter(org.joda.time.convert.PartialConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterPartialConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    PartialConverter[] removed \u003d new PartialConverter[1];\r\n    iPartialConverters \u003d iPartialConverters.add(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  PartialConverter\n  r0.checkAlterPartialConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d PartialConverter)[1]\n  $r3 \u003d ConverterSet iPartialConverters\u003e\n  $r4 \u003d $r3.add(r1, r2)\n  ConverterSet iPartialConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterPartialConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "removePartialConverter",
    "signature": "org.joda.time.convert.PartialConverter removePartialConverter(org.joda.time.convert.PartialConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterPartialConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    PartialConverter[] removed \u003d new PartialConverter[1];\r\n    iPartialConverters \u003d iPartialConverters.remove(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  PartialConverter\n  r0.checkAlterPartialConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d PartialConverter)[1]\n  $r3 \u003d ConverterSet iPartialConverters\u003e\n  $r4 \u003d $r3.remove(r1, r2)\n  ConverterSet iPartialConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterPartialConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "getDurationConverter",
    "signature": "org.joda.time.convert.DurationConverter getDurationConverter(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    DurationConverter converter \u003d (DurationConverter) iDurationConverters.select(object \u003d\u003d null ? null : object.getClass());\r\n    if (converter !\u003d null) {\r\n        return converter;\r\n    }\r\n    throw new IllegalArgumentException(\"No duration converter found for type: \" + (object \u003d\u003d null ? \"null\" : object.getClass().getName()));\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  Object\n  $r2 \u003d ConverterSet iDurationConverters\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d r1.getClass()\n}",
      "B3 {\n  $r3 \u003d $r2.select($r8)\n  $r7 \u003d DurationConverter) $r3\n  if ($r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r4 \u003d IllegalArgumentException\n  if (r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d \"null\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d r1.getClass()\n  $r9 \u003d $r5.getName()\n}",
      "B8 {\n  $r6 \u003d dynInvoke makeConcatWithConstants($r9)\n  new IllegalArgumentException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "addDurationConverter",
    "signature": "org.joda.time.convert.DurationConverter addDurationConverter(org.joda.time.convert.DurationConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterDurationConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    DurationConverter[] removed \u003d new DurationConverter[1];\r\n    iDurationConverters \u003d iDurationConverters.add(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  DurationConverter\n  r0.checkAlterDurationConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d DurationConverter)[1]\n  $r3 \u003d ConverterSet iDurationConverters\u003e\n  $r4 \u003d $r3.add(r1, r2)\n  ConverterSet iDurationConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterDurationConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "removeDurationConverter",
    "signature": "org.joda.time.convert.DurationConverter removeDurationConverter(org.joda.time.convert.DurationConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterDurationConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    DurationConverter[] removed \u003d new DurationConverter[1];\r\n    iDurationConverters \u003d iDurationConverters.remove(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  DurationConverter\n  r0.checkAlterDurationConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d DurationConverter)[1]\n  $r3 \u003d ConverterSet iDurationConverters\u003e\n  $r4 \u003d $r3.remove(r1, r2)\n  ConverterSet iDurationConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterDurationConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "getPeriodConverter",
    "signature": "org.joda.time.convert.PeriodConverter getPeriodConverter(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    PeriodConverter converter \u003d (PeriodConverter) iPeriodConverters.select(object \u003d\u003d null ? null : object.getClass());\r\n    if (converter !\u003d null) {\r\n        return converter;\r\n    }\r\n    throw new IllegalArgumentException(\"No period converter found for type: \" + (object \u003d\u003d null ? \"null\" : object.getClass().getName()));\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  Object\n  $r2 \u003d ConverterSet iPeriodConverters\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d r1.getClass()\n}",
      "B3 {\n  $r3 \u003d $r2.select($r8)\n  $r7 \u003d PeriodConverter) $r3\n  if ($r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r4 \u003d IllegalArgumentException\n  if (r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d \"null\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d r1.getClass()\n  $r9 \u003d $r5.getName()\n}",
      "B8 {\n  $r6 \u003d dynInvoke makeConcatWithConstants($r9)\n  new IllegalArgumentException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "addPeriodConverter",
    "signature": "org.joda.time.convert.PeriodConverter addPeriodConverter(org.joda.time.convert.PeriodConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterPeriodConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    PeriodConverter[] removed \u003d new PeriodConverter[1];\r\n    iPeriodConverters \u003d iPeriodConverters.add(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  PeriodConverter\n  r0.checkAlterPeriodConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d PeriodConverter)[1]\n  $r3 \u003d ConverterSet iPeriodConverters\u003e\n  $r4 \u003d $r3.add(r1, r2)\n  ConverterSet iPeriodConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterPeriodConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "removePeriodConverter",
    "signature": "org.joda.time.convert.PeriodConverter removePeriodConverter(org.joda.time.convert.PeriodConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterPeriodConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    PeriodConverter[] removed \u003d new PeriodConverter[1];\r\n    iPeriodConverters \u003d iPeriodConverters.remove(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  PeriodConverter\n  r0.checkAlterPeriodConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d PeriodConverter)[1]\n  $r3 \u003d ConverterSet iPeriodConverters\u003e\n  $r4 \u003d $r3.remove(r1, r2)\n  ConverterSet iPeriodConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterPeriodConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "getIntervalConverter",
    "signature": "org.joda.time.convert.IntervalConverter getIntervalConverter(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    IntervalConverter converter \u003d (IntervalConverter) iIntervalConverters.select(object \u003d\u003d null ? null : object.getClass());\r\n    if (converter !\u003d null) {\r\n        return converter;\r\n    }\r\n    throw new IllegalArgumentException(\"No interval converter found for type: \" + (object \u003d\u003d null ? \"null\" : object.getClass().getName()));\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r7 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  Object\n  $r2 \u003d ConverterSet iIntervalConverters\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d r1.getClass()\n}",
      "B3 {\n  $r3 \u003d $r2.select($r8)\n  $r7 \u003d IntervalConverter) $r3\n  if ($r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r4 \u003d IllegalArgumentException\n  if (r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d \"null\"\n  goto B8\n}",
      "B7 {\n  $r5 \u003d r1.getClass()\n  $r9 \u003d $r5.getName()\n}",
      "B8 {\n  $r6 \u003d dynInvoke makeConcatWithConstants($r9)\n  new IllegalArgumentException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "addIntervalConverter",
    "signature": "org.joda.time.convert.IntervalConverter addIntervalConverter(org.joda.time.convert.IntervalConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterIntervalConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    IntervalConverter[] removed \u003d new IntervalConverter[1];\r\n    iIntervalConverters \u003d iIntervalConverters.add(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  IntervalConverter\n  r0.checkAlterIntervalConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d IntervalConverter)[1]\n  $r3 \u003d ConverterSet iIntervalConverters\u003e\n  $r4 \u003d $r3.add(r1, r2)\n  ConverterSet iIntervalConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterIntervalConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.convert.ConverterManager",
    "methodName": "removeIntervalConverter",
    "signature": "org.joda.time.convert.IntervalConverter removeIntervalConverter(org.joda.time.convert.IntervalConverter)",
    "visibility": "public",
    "body": "{\r\n    checkAlterIntervalConverters();\r\n    if (converter \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    IntervalConverter[] removed \u003d new IntervalConverter[1];\r\n    iIntervalConverters \u003d iIntervalConverters.remove(converter, removed);\r\n    return removed[0];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConverterManager\n  IntervalConverter\n  r0.checkAlterIntervalConverters()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d IntervalConverter)[1]\n  $r3 \u003d ConverterSet iIntervalConverters\u003e\n  $r4 \u003d $r3.remove(r1, r2)\n  ConverterSet iIntervalConverters\u003e \u003d $r4\n  $r5 \u003d r2[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConverterManager#checkAlterIntervalConverters(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "now",
    "signature": "org.joda.time.DateMidnight now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new DateMidnight(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d DateMidnight\n  new DateMidnight(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "now",
    "signature": "org.joda.time.DateMidnight now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new DateMidnight(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d DateMidnight\n  new DateMidnight(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withMillis",
    "signature": "org.joda.time.DateMidnight withMillis(long)",
    "visibility": "public",
    "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  l2 :\u003d @parameter0: long\n  r1 \u003d r0.getChronology()\n  l3 \u003d r0.checkInstant(l2, r1)\n  $l0 \u003d r0.getMillis()\n  $b1 \u003d l3 cmp $l0\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d DateMidnight\n  new DateMidnight(l3, r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#checkInstant(...2)",
        "body": "{\r\n    return chronology.dayOfMonth().roundFloor(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withChronology",
    "signature": "org.joda.time.DateMidnight withChronology(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    return (newChronology \u003d\u003d getChronology() ? this : new DateMidnight(getMillis(), newChronology));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  Chronology\n  $r2 \u003d r1.getChronology()\n  if (r0 !\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r3 \u003d DateMidnight\n  $l0 \u003d r1.getMillis()\n  new DateMidnight($l0, r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withZoneRetainFields",
    "signature": "org.joda.time.DateMidnight withZoneRetainFields(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    newZone \u003d DateTimeUtils.getZone(newZone);\r\n    DateTimeZone originalZone \u003d DateTimeUtils.getZone(getZone());\r\n    if (newZone \u003d\u003d originalZone) {\r\n        return this;\r\n    }\r\n    long millis \u003d originalZone.getMillisKeepLocal(newZone, getMillis());\r\n    return new DateMidnight(millis, getChronology().withZone(newZone));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r7 !\u003d r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  DateTimeZone\n  r7 \u003d DateTimeUtils.getZone(r6)\n  $r1 \u003d r0.getZone()\n  r2 \u003d DateTimeUtils.getZone($r1)\n  if (r7 !\u003d r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  l1 \u003d r2.getMillisKeepLocal(r7, $l0)\n  $r3 \u003d DateMidnight\n  $r4 \u003d r0.getChronology()\n  $r5 \u003d $r4.withZone(r7)\n  new DateMidnight(l1, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withFields",
    "signature": "org.joda.time.DateMidnight withFields(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withMillis(getChronology().set(partial, getMillis()));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getMillis()\n  $l1 \u003d $r2.set(r0, $l0)\n  $r3 \u003d r1.withMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withField",
    "signature": "org.joda.time.DateMidnight withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).set(getMillis(), value);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r3.set($l1, i0)\n  $r4 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.DateMidnight withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).add(getMillis(), amount);\r\n    return withMillis(instant);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  if (i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r3.add($l1, i0)\n  $r4 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.DateMidnight withDurationAdded(long,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 \u003d\u003d false) → B1 | else → B2",
      "B1 : If(i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  l0 :\u003d @parameter0: long\n  i2 :\u003d @parameter1: int\n  $b1 \u003d l0 cmp 0L\n  if ($b1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  if (i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d r0.getChronology()\n  $l3 \u003d r0.getMillis()\n  l4 \u003d $r1.add($l3, l0, i2)\n  $r2 \u003d r0.withMillis(l4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.DateMidnight withDurationAdded(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $l1 \u003d r0.getMillis()\n  $r2 \u003d r1.withDurationAdded($l1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.DateMidnight withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(period, getMillis(), scalar);\r\n    return withMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r2.add(r0, $l1, i0)\n  $r3 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "plusYears",
    "signature": "org.joda.time.DateMidnight plusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().add(getMillis(), years);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "plusMonths",
    "signature": "org.joda.time.DateMidnight plusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().add(getMillis(), months);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "plusWeeks",
    "signature": "org.joda.time.DateMidnight plusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().add(getMillis(), weeks);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "plusDays",
    "signature": "org.joda.time.DateMidnight plusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().add(getMillis(), days);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "minusYears",
    "signature": "org.joda.time.DateMidnight minusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().subtract(getMillis(), years);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "minusMonths",
    "signature": "org.joda.time.DateMidnight minusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().subtract(getMillis(), months);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "minusWeeks",
    "signature": "org.joda.time.DateMidnight minusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().subtract(getMillis(), weeks);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "minusDays",
    "signature": "org.joda.time.DateMidnight minusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().subtract(getMillis(), days);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateMidnight#withMillis(...1)",
        "body": "{\r\n    Chronology chrono \u003d getChronology();\r\n    newMillis \u003d checkInstant(newMillis, chrono);\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateMidnight(newMillis, chrono));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateMidnight",
    "methodName": "property",
    "signature": "org.joda.time.DateMidnight$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field \u003d type.getField(getChronology());\r\n    if (field.isSupported() \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + type + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateMidnight\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  r3 \u003d r0.getField($r2)\n  $z0 \u003d r3.isSupported()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r4 \u003d DateMidnight$Property\n  new DateMidnight$Property(r1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateMidnight#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "now",
    "signature": "org.joda.time.DateTime now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new DateTime(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d DateTime\n  new DateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "now",
    "signature": "org.joda.time.DateTime now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new DateTime(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d DateTime\n  new DateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "toDateTimeISO",
    "signature": "org.joda.time.DateTime toDateTimeISO()",
    "visibility": "public",
    "body": "{\r\n    if (getChronology() \u003d\u003d ISOChronology.getInstance()) {\r\n        return this;\r\n    }\r\n    return super.toDateTimeISO();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  $r2 \u003d r0.getChronology()\n  $r1 \u003d ISOChronology.getInstance()\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d r0.toDateTimeISO()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "toDateTime",
    "signature": "org.joda.time.DateTime toDateTime(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    if (getZone() \u003d\u003d zone) {\r\n        return this;\r\n    }\r\n    return super.toDateTime(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d r4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  DateTimeZone\n  r4 \u003d DateTimeUtils.getZone(r3)\n  $r1 \u003d r0.getZone()\n  if ($r1 !\u003d r4) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r0.toDateTime(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "toDateTime",
    "signature": "org.joda.time.DateTime toDateTime(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    chronology \u003d DateTimeUtils.getChronology(chronology);\r\n    if (getChronology() \u003d\u003d chronology) {\r\n        return this;\r\n    }\r\n    return super.toDateTime(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d r4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  Chronology\n  r4 \u003d DateTimeUtils.getChronology(r3)\n  $r1 \u003d r0.getChronology()\n  if ($r1 !\u003d r4) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r0.toDateTime(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withMillis",
    "signature": "org.joda.time.DateTime withMillis(long)",
    "visibility": "public",
    "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  l0 :\u003d @parameter0: long\n  $l1 \u003d r0.getMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d DateTime\n  $r1 \u003d r0.getChronology()\n  new DateTime(l0, $r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withChronology",
    "signature": "org.joda.time.DateTime withChronology(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    return (newChronology \u003d\u003d getChronology() ? this : new DateTime(getMillis(), newChronology));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  Chronology\n  r3 \u003d DateTimeUtils.getChronology(r2)\n  $r1 \u003d r0.getChronology()\n  if (r3 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r4 \u003d DateTime\n  $l0 \u003d r0.getMillis()\n  new DateTime($l0, r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withZoneRetainFields",
    "signature": "org.joda.time.DateTime withZoneRetainFields(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    newZone \u003d DateTimeUtils.getZone(newZone);\r\n    DateTimeZone originalZone \u003d DateTimeUtils.getZone(getZone());\r\n    if (newZone \u003d\u003d originalZone) {\r\n        return this;\r\n    }\r\n    long millis \u003d originalZone.getMillisKeepLocal(newZone, getMillis());\r\n    return new DateTime(millis, getChronology().withZone(newZone));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r7 !\u003d r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  DateTimeZone\n  r7 \u003d DateTimeUtils.getZone(r6)\n  $r1 \u003d r0.getZone()\n  r2 \u003d DateTimeUtils.getZone($r1)\n  if (r7 !\u003d r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  l1 \u003d r2.getMillisKeepLocal(r7, $l0)\n  $r3 \u003d DateTime\n  $r4 \u003d r0.getChronology()\n  $r5 \u003d $r4.withZone(r7)\n  new DateTime(l1, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getZone(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withFields",
    "signature": "org.joda.time.DateTime withFields(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withMillis(getChronology().set(partial, getMillis()));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getMillis()\n  $l1 \u003d $r2.set(r0, $l0)\n  $r3 \u003d r1.withMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withField",
    "signature": "org.joda.time.DateTime withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).set(getMillis(), value);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r3.set($l1, i0)\n  $r4 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.DateTime withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).add(getMillis(), amount);\r\n    return withMillis(instant);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  if (i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r3.add($l1, i0)\n  $r4 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.DateTime withDurationAdded(long,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 \u003d\u003d false) → B1 | else → B2",
      "B1 : If(i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  l0 :\u003d @parameter0: long\n  i2 :\u003d @parameter1: int\n  $b1 \u003d l0 cmp 0L\n  if ($b1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  if (i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d r0.getChronology()\n  $l3 \u003d r0.getMillis()\n  l4 \u003d $r1.add($l3, l0, i2)\n  $r2 \u003d r0.withMillis(l4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.DateTime withDurationAdded(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $l1 \u003d r0.getMillis()\n  $r2 \u003d r1.withDurationAdded($l1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.DateTime withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(period, getMillis(), scalar);\r\n    return withMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $l1 \u003d r1.getMillis()\n  l2 \u003d $r2.add(r0, $l1, i0)\n  $r3 \u003d r1.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusYears",
    "signature": "org.joda.time.DateTime plusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().add(getMillis(), years);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusMonths",
    "signature": "org.joda.time.DateTime plusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().add(getMillis(), months);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusWeeks",
    "signature": "org.joda.time.DateTime plusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().add(getMillis(), weeks);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusDays",
    "signature": "org.joda.time.DateTime plusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().add(getMillis(), days);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusHours",
    "signature": "org.joda.time.DateTime plusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().add(getMillis(), hours);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusMinutes",
    "signature": "org.joda.time.DateTime plusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().add(getMillis(), minutes);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusSeconds",
    "signature": "org.joda.time.DateTime plusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().add(getMillis(), seconds);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "plusMillis",
    "signature": "org.joda.time.DateTime plusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().add(getMillis(), millis);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusYears",
    "signature": "org.joda.time.DateTime minusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().subtract(getMillis(), years);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusMonths",
    "signature": "org.joda.time.DateTime minusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().subtract(getMillis(), months);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusWeeks",
    "signature": "org.joda.time.DateTime minusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().subtract(getMillis(), weeks);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusDays",
    "signature": "org.joda.time.DateTime minusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().subtract(getMillis(), days);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusHours",
    "signature": "org.joda.time.DateTime minusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().subtract(getMillis(), hours);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusMinutes",
    "signature": "org.joda.time.DateTime minusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().subtract(getMillis(), minutes);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusSeconds",
    "signature": "org.joda.time.DateTime minusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().subtract(getMillis(), seconds);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "minusMillis",
    "signature": "org.joda.time.DateTime minusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().subtract(getMillis(), millis);\r\n    return withMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "DateTime#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getMillis() ? this : new DateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTime",
    "methodName": "property",
    "signature": "org.joda.time.DateTime$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field \u003d type.getField(getChronology());\r\n    if (field.isSupported() \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + type + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  r3 \u003d r0.getField($r2)\n  $z0 \u003d r3.isSupported()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r4 \u003d DateTime$Property\n  new DateTime$Property(r1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTimeComparator",
    "methodName": "getInstance",
    "signature": "org.joda.time.DateTimeComparator getInstance(org.joda.time.DateTimeFieldType,org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (lowerLimit \u003d\u003d null \u0026\u0026 upperLimit \u003d\u003d null) {\r\n        return ALL_INSTANCE;\r\n    }\r\n    if (lowerLimit \u003d\u003d DateTimeFieldType.dayOfYear() \u0026\u0026 upperLimit \u003d\u003d null) {\r\n        return DATE_INSTANCE;\r\n    }\r\n    if (lowerLimit \u003d\u003d null \u0026\u0026 upperLimit \u003d\u003d DateTimeFieldType.dayOfYear()) {\r\n        return TIME_INSTANCE;\r\n    }\r\n    return new DateTimeComparator(lowerLimit, upperLimit);\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B3",
      "B1 : If(r3 !\u003d null) → B2 | else → B3",
      "B3 : If(r0 !\u003d $r1) → B4 | else → B6",
      "B4 : If(r3 !\u003d null) → B5 | else → B6",
      "B6 : If(r0 !\u003d null) → B7 | else → B9",
      "B7 : If(r3 !\u003d $r4) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFieldType\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  if (r3 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d DateTimeComparator ALL_INSTANCE\u003e\n  return\n}",
      "B3 {\n  $r1 \u003d DateTimeFieldType.dayOfYear()\n  if (r0 !\u003d $r1) goto B4 else B6\n}",
      "B4 {\n  if (r3 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d DateTimeComparator DATE_INSTANCE\u003e\n  return\n}",
      "B6 {\n  if (r0 !\u003d null) goto B7 else B9\n}",
      "B7 {\n  $r4 \u003d DateTimeFieldType.dayOfYear()\n  if (r3 !\u003d $r4) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d DateTimeComparator TIME_INSTANCE\u003e\n  return\n}",
      "B9 {\n  $r2 \u003d DateTimeComparator\n  new DateTimeComparator(r0, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeComparator",
    "methodName": "compare",
    "signature": "int compare(java.lang.Object,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    InstantConverter conv \u003d ConverterManager.getInstance().getInstantConverter(lhsObj);\r\n    Chronology lhsChrono \u003d conv.getChronology(lhsObj, (Chronology) null);\r\n    long lhsMillis \u003d conv.getInstantMillis(lhsObj, lhsChrono);\r\n    // handle null\u003d\u003dnull and other cases where objects are the same\r\n    // but only do this after checking the input is valid\r\n    if (lhsObj \u003d\u003d rhsObj) {\r\n        return 0;\r\n    }\r\n    conv \u003d ConverterManager.getInstance().getInstantConverter(rhsObj);\r\n    Chronology rhsChrono \u003d conv.getChronology(rhsObj, (Chronology) null);\r\n    long rhsMillis \u003d conv.getInstantMillis(rhsObj, rhsChrono);\r\n    if (iLowerLimit !\u003d null) {\r\n        lhsMillis \u003d iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\r\n        rhsMillis \u003d iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\r\n    }\r\n    if (iUpperLimit !\u003d null) {\r\n        lhsMillis \u003d iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\r\n        rhsMillis \u003d iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\r\n    }\r\n    if (lhsMillis \u003c rhsMillis) {\r\n        return -1;\r\n    } else if (lhsMillis \u003e rhsMillis) {\r\n        return 1;\r\n    } else {\r\n        return 0;\r\n    }\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r3) → B1 | else → B2",
      "B2 : If($r7 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r8 \u003d\u003d null) → B5 | else → B6",
      "B6 : If($i4 \u003e\u003d 0) → B7 | else → B8",
      "B8 : If($i7 \u003c\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  DateTimeComparator\n  Object\n  Object\n  $r1 \u003d ConverterManager.getInstance()\n  r17 \u003d $r1.getInstantConverter(r0)\n  r2 \u003d r17.getChronology(r0, null)\n  l2 \u003d r17.getInstantMillis(r0, r2)\n  if (r0 !\u003d r3) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r4 \u003d ConverterManager.getInstance()\n  r18 \u003d $r4.getInstantConverter(r3)\n  r5 \u003d r18.getChronology(r3, null)\n  l3 \u003d r18.getInstantMillis(r3, r5)\n  $r7 \u003d DateTimeFieldType iLowerLimit\u003e\n  if ($r7 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r13 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r14 \u003d $r13.getField(r2)\n  l2 \u003d $r14.roundFloor(l2)\n  $r15 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r16 \u003d $r15.getField(r5)\n  l3 \u003d $r16.roundFloor(l3)\n}",
      "B4 {\n  $r8 \u003d DateTimeFieldType iUpperLimit\u003e\n  if ($r8 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r9 \u003d DateTimeFieldType iUpperLimit\u003e\n  $r10 \u003d $r9.getField(r2)\n  l2 \u003d $r10.remainder(l2)\n  $r11 \u003d DateTimeFieldType iUpperLimit\u003e\n  $r12 \u003d $r11.getField(r5)\n  l3 \u003d $r12.remainder(l3)\n}",
      "B6 {\n  $b0 \u003d l2 cmp l3\n  $i4 \u003d (int) $b0\n  if ($i4 \u003e\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $i6 \u003d (int) -1\n  return\n}",
      "B8 {\n  $b1 \u003d l2 cmp l3\n  $i7 \u003d (int) $b1\n  if ($i7 \u003c\u003d 0) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeComparator",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (object instanceof DateTimeComparator) {\r\n        DateTimeComparator other \u003d (DateTimeComparator) object;\r\n        return (iLowerLimit \u003d\u003d other.getLowerLimit() || (iLowerLimit !\u003d null \u0026\u0026 iLowerLimit.equals(other.getLowerLimit()))) \u0026\u0026 (iUpperLimit \u003d\u003d other.getUpperLimit() || (iUpperLimit !\u003d null \u0026\u0026 iUpperLimit.equals(other.getUpperLimit())));\r\n    }\r\n    return false;\r\n}",
    "nodes": 11,
    "edges": 16,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B10",
      "B1 : If($r3 \u003d\u003d $r4) → B2 | else → B4",
      "B2 : If($r10 \u003d\u003d null) → B3 | else → B8",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($r5 \u003d\u003d $r6) → B5 | else → B7",
      "B5 : If($r7 \u003d\u003d null) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  DateTimeComparator\n  Object\n  $z0 \u003d DateTimeComparator\n  if ($z0 \u003d\u003d false) goto B1 else B10\n}",
      "B1 {\n  r1 \u003d DateTimeComparator) r0\n  $r3 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r4 \u003d r1.getLowerLimit()\n  if ($r3 \u003d\u003d $r4) goto B2 else B4\n}",
      "B2 {\n  $r10 \u003d DateTimeFieldType iLowerLimit\u003e\n  if ($r10 \u003d\u003d null) goto B3 else B8\n}",
      "B3 {\n  $r11 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r12 \u003d r1.getLowerLimit()\n  $z2 \u003d $r11.equals($r12)\n  if ($z2 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $r5 \u003d DateTimeFieldType iUpperLimit\u003e\n  $r6 \u003d r1.getUpperLimit()\n  if ($r5 \u003d\u003d $r6) goto B5 else B7\n}",
      "B5 {\n  $r7 \u003d DateTimeFieldType iUpperLimit\u003e\n  if ($r7 \u003d\u003d null) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d DateTimeFieldType iUpperLimit\u003e\n  $r9 \u003d r1.getUpperLimit()\n  $z1 \u003d $r8.equals($r9)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z3 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z3 \u003d 0\n}",
      "B9 {\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeComparator",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    return (iLowerLimit \u003d\u003d null ? 0 : iLowerLimit.hashCode()) + (123 * (iUpperLimit \u003d\u003d null ? 0 : iUpperLimit.hashCode()));\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B3 : If($r3 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  DateTimeComparator\n  $r1 \u003d DateTimeFieldType iLowerLimit\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d DateTimeFieldType iLowerLimit\u003e\n  $i0 \u003d $r2.hashCode()\n}",
      "B3 {\n  $r3 \u003d DateTimeFieldType iUpperLimit\u003e\n  if ($r3 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $i1 \u003d 0\n  goto B6\n}",
      "B5 {\n  $r4 \u003d DateTimeFieldType iUpperLimit\u003e\n  $i1 \u003d $r4.hashCode()\n}",
      "B6 {\n  $i2 \u003d 123 * $i1\n  $i3 \u003d $i0 + $i2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeComparator",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    if (iLowerLimit \u003d\u003d iUpperLimit) {\r\n        return \"DateTimeComparator[\" + (iLowerLimit \u003d\u003d null ? \"\" : iLowerLimit.getName()) + \"]\";\r\n    } else {\r\n        return \"DateTimeComparator[\" + (iLowerLimit \u003d\u003d null ? \"\" : iLowerLimit.getName()) + \"-\" + (iUpperLimit \u003d\u003d null ? \"\" : iUpperLimit.getName()) + \"]\";\r\n    }\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B5",
      "B1 : If($r7 !\u003d null) → B2 | else → B3",
      "B5 : If($r3 !\u003d null) → B6 | else → B7",
      "B8 : If($r5 !\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  DateTimeComparator\n  $r2 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r1 \u003d DateTimeFieldType iUpperLimit\u003e\n  if ($r2 !\u003d $r1) goto B1 else B5\n}",
      "B1 {\n  $r7 \u003d DateTimeFieldType iLowerLimit\u003e\n  if ($r7 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r10 \u003d \"\"\n  goto B4\n}",
      "B3 {\n  $r8 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r10 \u003d $r8.getName()\n}",
      "B4 {\n  $r9 \u003d dynInvoke makeConcatWithConstants($r10)\n  return\n}",
      "B5 {\n  $r3 \u003d DateTimeFieldType iLowerLimit\u003e\n  if ($r3 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r11 \u003d \"\"\n  goto B8\n}",
      "B7 {\n  $r4 \u003d DateTimeFieldType iLowerLimit\u003e\n  $r11 \u003d $r4.getName()\n}",
      "B8 {\n  $r5 \u003d DateTimeFieldType iUpperLimit\u003e\n  if ($r5 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r12 \u003d \"\"\n  goto B11\n}",
      "B10 {\n  $r6 \u003d DateTimeFieldType iUpperLimit\u003e\n  $r12 \u003d $r6.getName()\n}",
      "B11 {\n  $r13 \u003d dynInvoke makeConcatWithConstants($r11, $r12)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "setCurrentMillisOffset",
    "signature": "void setCurrentMillisOffset(long)",
    "visibility": "public",
    "body": "{\r\n    checkPermission();\r\n    if (offsetMillis \u003d\u003d 0) {\r\n        cMillisProvider \u003d SYSTEM_MILLIS_PROVIDER;\r\n    } else {\r\n        cMillisProvider \u003d new OffsetMillisProvider(offsetMillis);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  DateTimeUtils.checkPermission()\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d DateTimeUtils$MillisProvider SYSTEM_MILLIS_PROVIDER\u003e\n  DateTimeUtils$MillisProvider cMillisProvider\u003e \u003d $r1\n  goto B3\n}",
      "B2 {\n  $r0 \u003d DateTimeUtils$OffsetMillisProvider\n  new DateTimeUtils$OffsetMillisProvider(l0)\n  DateTimeUtils$MillisProvider cMillisProvider\u003e \u003d $r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeUtils#checkPermission(...0)",
        "body": "{\r\n    SecurityManager sm \u003d System.getSecurityManager();\r\n    if (sm !\u003d null) {\r\n        sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "setCurrentMillisProvider",
    "signature": "void setCurrentMillisProvider(org.joda.time.DateTimeUtils$MillisProvider)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeUtils$MillisProvider\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The MillisProvider must not be null\")\n  throw $r1\n}",
      "B2 {\n  DateTimeUtils.checkPermission()\n  DateTimeUtils$MillisProvider cMillisProvider\u003e \u003d r0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getInstantMillis",
    "signature": "long getInstantMillis(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    if (instant \u003d\u003d null) {\r\n        return DateTimeUtils.currentTimeMillis();\r\n    }\r\n    return instant.getMillis();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInstant\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l1 \u003d DateTimeUtils.currentTimeMillis()\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getInstantChronology",
    "signature": "org.joda.time.Chronology getInstantChronology(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    if (instant \u003d\u003d null) {\r\n        return ISOChronology.getInstance();\r\n    }\r\n    Chronology chrono \u003d instant.getChronology();\r\n    if (chrono \u003d\u003d null) {\r\n        return ISOChronology.getInstance();\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ReadableInstant\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ISOChronology.getInstance()\n  return\n}",
      "B2 {\n  r1 \u003d r0.getChronology()\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d ISOChronology.getInstance()\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getIntervalChronology",
    "signature": "org.joda.time.Chronology getIntervalChronology(org.joda.time.ReadableInstant,org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    Chronology chrono \u003d null;\r\n    if (start !\u003d null) {\r\n        chrono \u003d start.getChronology();\r\n    } else if (end !\u003d null) {\r\n        chrono \u003d end.getChronology();\r\n    }\r\n    if (chrono \u003d\u003d null) {\r\n        chrono \u003d ISOChronology.getInstance();\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(r2 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ReadableInstant\n  ReadableInstant\n  r2 \u003d null\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r2 \u003d r0.getChronology()\n  goto B4\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  r2 \u003d r1.getChronology()\n}",
      "B4 {\n  if (r2 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  r2 \u003d ISOChronology.getInstance()\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getIntervalChronology",
    "signature": "org.joda.time.Chronology getIntervalChronology(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return ISOChronology.getInstance();\r\n    }\r\n    Chronology chrono \u003d interval.getChronology();\r\n    if (chrono \u003d\u003d null) {\r\n        return ISOChronology.getInstance();\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ISOChronology.getInstance()\n  return\n}",
      "B2 {\n  r1 \u003d r0.getChronology()\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d ISOChronology.getInstance()\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getReadableInterval",
    "signature": "org.joda.time.ReadableInterval getReadableInterval(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        long now \u003d DateTimeUtils.currentTimeMillis();\r\n        interval \u003d new Interval(now, now);\r\n    }\r\n    return interval;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  l0 \u003d DateTimeUtils.currentTimeMillis()\n  $r0 \u003d Interval\n  new Interval(l0, l0)\n  r1 \u003d $r0\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getChronology",
    "signature": "org.joda.time.Chronology getChronology(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chrono \u003d\u003d null) {\r\n        return ISOChronology.getInstance();\r\n    }\r\n    return chrono;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d ISOChronology.getInstance()\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getZone",
    "signature": "org.joda.time.DateTimeZone getZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        return DateTimeZone.getDefault();\r\n    }\r\n    return zone;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d DateTimeZone.getDefault()\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getPeriodType",
    "signature": "org.joda.time.PeriodType getPeriodType(org.joda.time.PeriodType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return PeriodType.standard();\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d PeriodType.standard()\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getDurationMillis",
    "signature": "long getDurationMillis(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    if (duration \u003d\u003d null) {\r\n        return 0L;\r\n    }\r\n    return duration.getMillis();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableDuration\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "isContiguous",
    "signature": "boolean isContiguous(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Partial must not be null\");\r\n    }\r\n    DurationFieldType lastType \u003d null;\r\n    for (int i \u003d 0; i \u003c partial.size(); i++) {\r\n        DateTimeField loopField \u003d partial.getField(i);\r\n        if (i \u003e 0) {\r\n            if (loopField.getRangeDurationField() \u003d\u003d null || loopField.getRangeDurationField().getType() !\u003d lastType) {\r\n                return false;\r\n            }\r\n        }\r\n        lastType \u003d loopField.getDurationField().getType();\r\n    }\r\n    return true;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B3 : If(i1 \u003e\u003d $i0) → B4 | else → B9",
      "B4 : If(i1 \u003c\u003d 0) → B5 | else → B8",
      "B5 : If($r3 \u003d\u003d null) → B6 | else → B7",
      "B6 : If($r5 \u003d\u003d r7) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Partial must not be null\")\n  throw $r6\n}",
      "B2 {\n  r7 \u003d null\n  i1 \u003d 0\n}",
      "B3 {\n  $i0 \u003d r0.size()\n  if (i1 \u003e\u003d $i0) goto B4 else B9\n}",
      "B4 {\n  r1 \u003d r0.getField(i1)\n  if (i1 \u003c\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $r3 \u003d r1.getRangeDurationField()\n  if ($r3 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getRangeDurationField()\n  $r5 \u003d $r4.getType()\n  if ($r5 \u003d\u003d r7) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r2 \u003d r1.getDurationField()\n  r7 \u003d $r2.getType()\n  i1 \u003d i1 + 1\n  goto B3\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B3",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.DateTimeUtils",
    "methodName": "getDefaultTimeZoneNames",
    "signature": "java.util.Map getDefaultTimeZoneNames()",
    "visibility": "public",
    "body": "{\r\n    Map\u003cString, DateTimeZone\u003e names \u003d cZoneNames.get();\r\n    if (names \u003d\u003d null) {\r\n        names \u003d buildDefaultTimeZoneNames();\r\n        if (!cZoneNames.compareAndSet(null, names)) {\r\n            names \u003d cZoneNames.get();\r\n        }\r\n    }\r\n    return names;\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B3",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d AtomicReference cZoneNames\u003e\n  $r1 \u003d $r0.get()\n  r5 \u003d Map) $r1\n  if (r5 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  r5 \u003d DateTimeUtils.buildDefaultTimeZoneNames()\n  $r2 \u003d AtomicReference cZoneNames\u003e\n  $z0 \u003d $r2.compareAndSet(null, r5)\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d AtomicReference cZoneNames\u003e\n  $r4 \u003d $r3.get()\n  r5 \u003d Map) $r4\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeUtils#buildDefaultTimeZoneNames(...0)",
        "body": "{\r\n    // names from RFC-822 / JDK\r\n    // this is all very US-centric and dubious, but perhaps it will help some\r\n    Map\u003cString, DateTimeZone\u003e map \u003d new LinkedHashMap\u003cString, DateTimeZone\u003e();\r\n    map.put(\"UT\", DateTimeZone.UTC);\r\n    map.put(\"UTC\", DateTimeZone.UTC);\r\n    map.put(\"GMT\", DateTimeZone.UTC);\r\n    put(map, \"EST\", \"America/New_York\");\r\n    put(map, \"EDT\", \"America/New_York\");\r\n    put(map, \"CST\", \"America/Chicago\");\r\n    put(map, \"CDT\", \"America/Chicago\");\r\n    put(map, \"MST\", \"America/Denver\");\r\n    put(map, \"MDT\", \"America/Denver\");\r\n    put(map, \"PST\", \"America/Los_Angeles\");\r\n    put(map, \"PDT\", \"America/Los_Angeles\");\r\n    return Collections.unmodifiableMap(map);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "days",
    "signature": "org.joda.time.Days days(int)",
    "visibility": "public",
    "body": "{\r\n    switch(days) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Days(days);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 11,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B10 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Days; }\n}",
      "B1 {\n  $r8 \u003d Days ZERO\u003e\n  return\n}",
      "B2 {\n  $r7 \u003d Days ONE\u003e\n  return\n}",
      "B3 {\n  $r6 \u003d Days TWO\u003e\n  return\n}",
      "B4 {\n  $r5 \u003d Days THREE\u003e\n  return\n}",
      "B5 {\n  $r4 \u003d Days FOUR\u003e\n  return\n}",
      "B6 {\n  $r3 \u003d Days FIVE\u003e\n  return\n}",
      "B7 {\n  $r2 \u003d Days SIX\u003e\n  return\n}",
      "B8 {\n  $r1 \u003d Days SEVEN\u003e\n  return\n}",
      "B9 {\n  $r0 \u003d Days MAX_VALUE\u003e\n  return\n}",
      "B10 {\n  $r9 \u003d Days MIN_VALUE\u003e\n  return\n}",
      "B11 {\n  $r10 \u003d Days\n  new Days(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B10",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B0 --\u003e B7",
      "B0 --\u003e B8",
      "B0 --\u003e B9",
      "B0 --\u003e B11",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "daysBetween",
    "signature": "org.joda.time.Days daysBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalDate \u0026\u0026 end instanceof LocalDate) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int days \u003d chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Days.days(days);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Days.days(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalDate\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.days()\n  $r5 \u003d LocalDate) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalDate) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Days.days(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Days ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Days.days($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "daysIn",
    "signature": "org.joda.time.Days daysIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Days.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\r\n    return Days.days(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Days ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.days()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Days.days(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "parseDays",
    "signature": "org.joda.time.Days parseDays(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Days.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Days.days(p.getDays());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Days ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getDays()\n  $r3 \u003d Days.days($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "plus",
    "signature": "org.joda.time.Days plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Days.days(FieldUtils.safeAdd(getValue(), days));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Days\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Days.days($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "plus",
    "signature": "org.joda.time.Days plus(org.joda.time.Days)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(days.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Days\n  Days\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#plus(...1)",
        "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Days.days(FieldUtils.safeAdd(getValue(), days));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "minus",
    "signature": "org.joda.time.Days minus(org.joda.time.Days)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(days.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Days\n  Days\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(days));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Days dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Days.days(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Days\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Days.days($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Days)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Days\n  Days\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Days",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Days)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Days\n  Days\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Days#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "standardDays",
    "signature": "org.joda.time.Duration standardDays(long)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Duration ZERO\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d FieldUtils.safeMultiply(l0, 86400000)\n  new Duration($l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "standardHours",
    "signature": "org.joda.time.Duration standardHours(long)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Duration ZERO\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d FieldUtils.safeMultiply(l0, 3600000)\n  new Duration($l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "standardMinutes",
    "signature": "org.joda.time.Duration standardMinutes(long)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Duration ZERO\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d Duration\n  $i4 \u003d (int) 60000\n  $l2 \u003d FieldUtils.safeMultiply(l0, $i4)\n  new Duration($l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "standardSeconds",
    "signature": "org.joda.time.Duration standardSeconds(long)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Duration ZERO\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d FieldUtils.safeMultiply(l0, 1000)\n  new Duration($l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "millis",
    "signature": "org.joda.time.Duration millis(long)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return ZERO;\r\n    }\r\n    return new Duration(millis);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Duration ZERO\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  new Duration(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "withMillis",
    "signature": "org.joda.time.Duration withMillis(long)",
    "visibility": "public",
    "body": "{\r\n    if (duration \u003d\u003d getMillis()) {\r\n        return this;\r\n    }\r\n    return new Duration(duration);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  l0 :\u003d @parameter0: long\n  $l1 \u003d r0.getMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d Duration\n  new Duration(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.Duration withDurationAdded(long,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long add \u003d FieldUtils.safeMultiply(durationToAdd, scalar);\r\n    long duration \u003d FieldUtils.safeAdd(getMillis(), add);\r\n    return new Duration(duration);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 \u003d\u003d false) → B1 | else → B2",
      "B1 : If(i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Duration\n  l0 :\u003d @parameter0: long\n  i2 :\u003d @parameter1: int\n  $b1 \u003d l0 cmp 0L\n  if ($b1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  if (i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  l3 \u003d FieldUtils.safeMultiply(l0, i2)\n  $l4 \u003d r0.getMillis()\n  l5 \u003d FieldUtils.safeAdd($l4, l3)\n  $r1 \u003d Duration\n  new Duration(l5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.Duration withDurationAdded(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Duration\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $l1 \u003d r0.getMillis()\n  $r2 \u003d r1.withDurationAdded($l1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long add \u003d FieldUtils.safeMultiply(durationToAdd, scalar);\r\n    long duration \u003d FieldUtils.safeAdd(getMillis(), add);\r\n    return new Duration(duration);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "plus",
    "signature": "org.joda.time.Duration plus(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    if (amount \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(amount.getMillis(), 1);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  ReadableDuration\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  $r2 \u003d r1.withDurationAdded($l0, 1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long add \u003d FieldUtils.safeMultiply(durationToAdd, scalar);\r\n    long duration \u003d FieldUtils.safeAdd(getMillis(), add);\r\n    return new Duration(duration);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "minus",
    "signature": "org.joda.time.Duration minus(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    if (amount \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(amount.getMillis(), -1);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  ReadableDuration\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  $i2 \u003d (int) -1\n  $r2 \u003d r1.withDurationAdded($l0, $i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long add \u003d FieldUtils.safeMultiply(durationToAdd, scalar);\r\n    long duration \u003d FieldUtils.safeAdd(getMillis(), add);\r\n    return new Duration(duration);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "multipliedBy",
    "signature": "org.joda.time.Duration multipliedBy(long)",
    "visibility": "public",
    "body": "{\r\n    if (multiplicand \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 1L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d r1.getMillis()\n  $l3 \u003d FieldUtils.safeMultiply($l2, l0)\n  new Duration($l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Duration dividedBy(long)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return new Duration(FieldUtils.safeDivide(getMillis(), divisor));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 1L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d r1.getMillis()\n  $l3 \u003d FieldUtils.safeDivide($l2, l0)\n  new Duration($l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Duration dividedBy(long,java.math.RoundingMode)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return new Duration(FieldUtils.safeDivide(getMillis(), divisor, roundingMode));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  l0 :\u003d @parameter0: long\n  RoundingMode\n  $b1 \u003d l0 cmp 1L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r0 \u003d Duration\n  $l2 \u003d r1.getMillis()\n  $l3 \u003d FieldUtils.safeDivide($l2, l0, r2)\n  new Duration($l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "negated",
    "signature": "org.joda.time.Duration negated()",
    "visibility": "public",
    "body": "{\r\n    if (getMillis() \u003d\u003d Long.MIN_VALUE) {\r\n        throw new ArithmeticException(\"Negation of this duration would overflow\");\r\n    }\r\n    return new Duration(-getMillis());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  $l0 \u003d r0.getMillis()\n  $b1 \u003d $l0 cmp -9223372036854775808L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ArithmeticException\n  new ArithmeticException(\"Negation of this duration would overflow\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d Duration\n  $l2 \u003d r0.getMillis()\n  $l3 \u003d neg $l2\n  new Duration($l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Duration",
    "methodName": "abs",
    "signature": "org.joda.time.Duration abs()",
    "visibility": "public",
    "body": "{\r\n    if (getMillis() \u003c 0) {\r\n        return negated();\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Duration\n  $l0 \u003d r0.getMillis()\n  $b1 \u003d $l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.negated()\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Duration#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Duration#negated(...0)",
        "body": "{\r\n    if (getMillis() \u003d\u003d Long.MIN_VALUE) {\r\n        throw new ArithmeticException(\"Negation of this duration would overflow\");\r\n    }\r\n    return new Duration(-getMillis());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.DelegatedDateTimeField",
    "methodName": "getRangeDurationField",
    "signature": "org.joda.time.DurationField getRangeDurationField()",
    "visibility": "public",
    "body": "{\r\n    if (iRangeDurationField !\u003d null) {\r\n        return iRangeDurationField;\r\n    }\r\n    return iField.getRangeDurationField();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DelegatedDateTimeField\n  $r1 \u003d DurationField iRangeDurationField\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DurationField iRangeDurationField\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeField iField\u003e\n  $r3 \u003d $r2.getRangeDurationField()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.DelegatedDurationField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (obj instanceof DelegatedDurationField) {\r\n        return iField.equals(((DelegatedDurationField) obj).iField);\r\n    }\r\n    return false;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DelegatedDurationField\n  Object\n  $z0 \u003d DelegatedDurationField\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DurationField iField\u003e\n  $r2 \u003d DelegatedDurationField) r0\n  $r3 \u003d DurationField iField\u003e\n  $z1 \u003d $r4.equals($r3)\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.DelegatedDurationField",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    return (iType \u003d\u003d null) ? iField.toString() : (\"DurationField[\" + iType + \u0027]\u0027);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DelegatedDurationField\n  $r1 \u003d DurationFieldType iType\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DurationField iField\u003e\n  $r5 \u003d $r4.toString()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d DurationFieldType iType\u003e\n  $r3 \u003d String.valueOf($r2)\n  $r5 \u003d dynInvoke makeConcatWithConstants($r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.DividedDateTimeField",
    "methodName": "getRangeDurationField",
    "signature": "org.joda.time.DurationField getRangeDurationField()",
    "visibility": "public",
    "body": "{\r\n    if (iRangeDurationField !\u003d null) {\r\n        return iRangeDurationField;\r\n    }\r\n    return super.getRangeDurationField();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DividedDateTimeField\n  $r1 \u003d DurationField iRangeDurationField\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DurationField iRangeDurationField\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getRangeDurationField()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.DividedDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    int value \u003d getWrappedField().get(instant);\r\n    if (value \u003e\u003d 0) {\r\n        return value / iDivisor;\r\n    } else {\r\n        return ((value + 1) / iDivisor) - 1;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DividedDateTimeField\n  l0 :\u003d @parameter0: long\n  $r1 \u003d r0.getWrappedField()\n  i1 \u003d $r1.get(l0)\n  if (i1 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $i6 \u003d DividedDateTimeField: int iDivisor\u003e\n  $i7 \u003d i1 / $i6\n  return\n}",
      "B2 {\n  $i3 \u003d i1 + 1\n  $i2 \u003d DividedDateTimeField: int iDivisor\u003e\n  $i4 \u003d $i3 / $i2\n  $i5 \u003d $i4 - 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DividedDateTimeField#getWrappedField(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeNegate",
    "signature": "int safeNegate(int)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d Integer.MIN_VALUE) {\r\n        throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\r\n    }\r\n    return -value;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d -2147483648) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d -2147483648) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d ArithmeticException\n  new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\")\n  throw $r0\n}",
      "B2 {\n  $i1 \u003d neg i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeAdd",
    "signature": "int safeAdd(int,int)",
    "visibility": "public",
    "body": "{\r\n    int sum \u003d val1 + val2;\r\n    // If there is a sign change, but the two values have the same sign...\r\n    if ((val1 ^ sum) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003e\u003d 0) {\r\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\r\n    }\r\n    return sum;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i3 \u003e\u003d 0) → B1 | else → B3",
      "B1 : If($i4 \u003c 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i2 \u003d i0 + i1\n  $i3 \u003d i0 ^ i2\n  if ($i3 \u003e\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i4 \u003d i0 ^ i1\n  if ($i4 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(i0, i1)\n  new ArithmeticException($r1)\n  throw $r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeAdd",
    "signature": "long safeAdd(long,long)",
    "visibility": "public",
    "body": "{\r\n    long sum \u003d val1 + val2;\r\n    // If there is a sign change, but the two values have the same sign...\r\n    if ((val1 ^ sum) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003e\u003d 0) {\r\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\r\n    }\r\n    return sum;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i7 \u003e\u003d 0) → B1 | else → B3",
      "B1 : If($i8 \u003c 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  l1 :\u003d @parameter1: long\n  l2 \u003d l0 + l1\n  $l3 \u003d l0 ^ l2\n  $b4 \u003d $l3 cmp 0L\n  $i7 \u003d (int) $b4\n  if ($i7 \u003e\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $l5 \u003d l0 ^ l1\n  $b6 \u003d $l5 cmp 0L\n  $i8 \u003d (int) $b6\n  if ($i8 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l0, l1)\n  new ArithmeticException($r1)\n  throw $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeSubtract",
    "signature": "long safeSubtract(long,long)",
    "visibility": "public",
    "body": "{\r\n    long diff \u003d val1 - val2;\r\n    // If there is a sign change, but the two values have different signs...\r\n    if ((val1 ^ diff) \u003c 0 \u0026\u0026 (val1 ^ val2) \u003c 0) {\r\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\r\n    }\r\n    return diff;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i7 \u003e\u003d 0) → B1 | else → B3",
      "B1 : If($i8 \u003e\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  l1 :\u003d @parameter1: long\n  l2 \u003d l0 - l1\n  $l3 \u003d l0 ^ l2\n  $b4 \u003d $l3 cmp 0L\n  $i7 \u003d (int) $b4\n  if ($i7 \u003e\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $l5 \u003d l0 ^ l1\n  $b6 \u003d $l5 cmp 0L\n  $i8 \u003d (int) $b6\n  if ($i8 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l0, l1)\n  new ArithmeticException($r1)\n  throw $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeMultiply",
    "signature": "int safeMultiply(int,int)",
    "visibility": "public",
    "body": "{\r\n    long total \u003d (long) val1 * (long) val2;\r\n    if (total \u003c Integer.MIN_VALUE || total \u003e Integer.MAX_VALUE) {\r\n        throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\r\n    }\r\n    return (int) total;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i8 \u003c 0) → B1 | else → B2",
      "B1 : If($i9 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  $l3 \u003d (long) i0\n  $l2 \u003d (long) i1\n  l4 \u003d $l3 * $l2\n  $b5 \u003d l4 cmp -2147483648L\n  $i8 \u003d (int) $b5\n  if ($i8 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $b6 \u003d l4 cmp 2147483647L\n  $i9 \u003d (int) $b6\n  if ($i9 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(i0, i1)\n  new ArithmeticException($r1)\n  throw $r2\n}",
      "B3 {\n  $i7 \u003d (int) l4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeMultiply",
    "signature": "long safeMultiply(long,int)",
    "visibility": "public",
    "body": "{\r\n    switch(val2) {\r\n        case -1:\r\n            if (val1 \u003d\u003d Long.MIN_VALUE) {\r\n                throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n            }\r\n            return -val1;\r\n        case 0:\r\n            return 0L;\r\n        case 1:\r\n            return val1;\r\n    }\r\n    long total \u003d val1 * val2;\r\n    if (total / val2 !\u003d val1) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n    }\r\n    return total;\r\n}",
    "nodes": 9,
    "edges": 8,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B4",
      "B1 : If($b2 !\u003d 0) → B2 | else → B3",
      "B6 : If($b8 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  l1 :\u003d @parameter0: long\n  i0 :\u003d @parameter1: int\n  tableswitch(i0) {     case -1: goto $b2 \u003d l1 cmp -9223372036854775808L;     case 0: goto return 0L;     case 1: goto return l1;     default: goto $l4 \u003d (long) i0; }\n}",
      "B1 {\n  $b2 \u003d l1 cmp -9223372036854775808L\n  if ($b2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l1, i0)\n  new ArithmeticException($r1)\n  throw $r0\n}",
      "B3 {\n  $l3 \u003d neg l1\n  return\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $l4 \u003d (long) i0\n  l5 \u003d l1 * $l4\n  $l6 \u003d (long) i0\n  $l7 \u003d l5 / $l6\n  $b8 \u003d $l7 cmp l1\n  if ($b8 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r2 \u003d ArithmeticException\n  $r3 \u003d dynInvoke makeConcatWithConstants(l1, i0)\n  new ArithmeticException($r3)\n  throw $r2\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeMultiply",
    "signature": "long safeMultiply(long,long)",
    "visibility": "public",
    "body": "{\r\n    if (val2 \u003d\u003d 1) {\r\n        return val1;\r\n    }\r\n    if (val1 \u003d\u003d 1) {\r\n        return val2;\r\n    }\r\n    if (val1 \u003d\u003d 0 || val2 \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    long total \u003d val1 * val2;\r\n    if (total / val2 !\u003d val1 || val1 \u003d\u003d Long.MIN_VALUE \u0026\u0026 val2 \u003d\u003d -1 || val2 \u003d\u003d Long.MIN_VALUE \u0026\u0026 val1 \u003d\u003d -1) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n    }\r\n    return total;\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2",
      "B2 : If($b3 !\u003d 0) → B3 | else → B4",
      "B4 : If($b4 \u003d\u003d false) → B5 | else → B6",
      "B5 : If($b5 !\u003d 0) → B6 | else → B7",
      "B7 : If($b8 !\u003d 0) → B8 | else → B12",
      "B8 : If($b9 !\u003d 0) → B9 | else → B10",
      "B9 : If($b12 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($b10 !\u003d 0) → B11 | else → B13",
      "B11 : If($b11 !\u003d 0) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  l2 :\u003d @parameter0: long\n  l0 :\u003d @parameter1: long\n  $b1 \u003d l0 cmp 1L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $b3 \u003d l2 cmp 1L\n  if ($b3 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $b4 \u003d l2 cmp 0L\n  if ($b4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $b5 \u003d l0 cmp 0L\n  if ($b5 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  l6 \u003d l2 * l0\n  $l7 \u003d l6 / l0\n  $b8 \u003d $l7 cmp l2\n  if ($b8 !\u003d 0) goto B8 else B12\n}",
      "B8 {\n  $b9 \u003d l2 cmp -9223372036854775808L\n  if ($b9 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $b12 \u003d l0 cmp -1L\n  if ($b12 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $b10 \u003d l0 cmp -9223372036854775808L\n  if ($b10 !\u003d 0) goto B11 else B13\n}",
      "B11 {\n  $b11 \u003d l2 cmp -1L\n  if ($b11 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r0 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l2, l0)\n  new ArithmeticException($r1)\n  throw $r0\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeDivide",
    "signature": "long safeDivide(long,long)",
    "visibility": "public",
    "body": "{\r\n    if (dividend \u003d\u003d Long.MIN_VALUE \u0026\u0026 divisor \u003d\u003d -1L) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\r\n    }\r\n    return dividend / divisor;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B3",
      "B1 : If($b4 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  l2 :\u003d @parameter1: long\n  $b1 \u003d l0 cmp -9223372036854775808L\n  if ($b1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $b4 \u003d l2 cmp -1L\n  if ($b4 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l0, l2)\n  new ArithmeticException($r1)\n  throw $r0\n}",
      "B3 {\n  $l3 \u003d l0 / l2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeDivide",
    "signature": "long safeDivide(long,long,java.math.RoundingMode)",
    "visibility": "public",
    "body": "{\r\n    if (dividend \u003d\u003d Long.MIN_VALUE \u0026\u0026 divisor \u003d\u003d -1L) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\r\n    }\r\n    BigDecimal dividendBigDecimal \u003d new BigDecimal(dividend);\r\n    BigDecimal divisorBigDecimal \u003d new BigDecimal(divisor);\r\n    return dividendBigDecimal.divide(divisorBigDecimal, roundingMode).longValue();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B3",
      "B1 : If($b4 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  l2 :\u003d @parameter1: long\n  RoundingMode\n  $b1 \u003d l0 cmp -9223372036854775808L\n  if ($b1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $b4 \u003d l2 cmp -1L\n  if ($b4 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d ArithmeticException\n  $r5 \u003d dynInvoke makeConcatWithConstants(l0, l2)\n  new ArithmeticException($r5)\n  throw $r4\n}",
      "B3 {\n  $r0 \u003d BigDecimal\n  new BigDecimal(l0)\n  $r1 \u003d BigDecimal\n  new BigDecimal(l2)\n  $r3 \u003d $r0.divide($r1, r2)\n  $l3 \u003d $r3.longValue()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "safeToInt",
    "signature": "int safeToInt(long)",
    "visibility": "public",
    "body": "{\r\n    if (Integer.MIN_VALUE \u003c\u003d value \u0026\u0026 value \u003c\u003d Integer.MAX_VALUE) {\r\n        return (int) value;\r\n    }\r\n    throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 \u003e 0) → B1 | else → B3",
      "B1 : If($i5 \u003e 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d -2147483648L cmp l0\n  $i4 \u003d (int) $b1\n  if ($i4 \u003e 0) goto B1 else B3\n}",
      "B1 {\n  $b2 \u003d l0 cmp 2147483647L\n  $i5 \u003d (int) $b2\n  if ($i5 \u003e 0) goto B2 else B3\n}",
      "B2 {\n  $i3 \u003d (int) l0\n  return\n}",
      "B3 {\n  $r2 \u003d ArithmeticException\n  $r1 \u003d dynInvoke makeConcatWithConstants(l0)\n  new ArithmeticException($r1)\n  throw $r2\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "verifyValueBounds",
    "signature": "void verifyValueBounds(org.joda.time.DateTimeField,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    if ((value \u003c lowerBound) || (value \u003e upperBound)) {\r\n        throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c i1) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d i2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTimeField\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  i2 :\u003d @parameter3: int\n  if (i0 \u003c i1) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d i2) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IllegalFieldValueException\n  $r5 \u003d r1.getType()\n  $r4 \u003d Integer.valueOf(i0)\n  $r3 \u003d Integer.valueOf(i1)\n  $r2 \u003d Integer.valueOf(i2)\n  new IllegalFieldValueException($r5, $r4, $r3, $r2)\n  throw $r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "verifyValueBounds",
    "signature": "void verifyValueBounds(org.joda.time.DateTimeFieldType,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    if ((value \u003c lowerBound) || (value \u003e upperBound)) {\r\n        throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c i1) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d i2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  i2 :\u003d @parameter3: int\n  if (i0 \u003c i1) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d i2) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IllegalFieldValueException\n  $r4 \u003d Integer.valueOf(i0)\n  $r3 \u003d Integer.valueOf(i1)\n  $r2 \u003d Integer.valueOf(i2)\n  new IllegalFieldValueException(r1, $r4, $r3, $r2)\n  throw $r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "verifyValueBounds",
    "signature": "void verifyValueBounds(java.lang.String,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    if ((value \u003c lowerBound) || (value \u003e upperBound)) {\r\n        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c i1) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d i2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  i2 :\u003d @parameter3: int\n  if (i0 \u003c i1) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d i2) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IllegalFieldValueException\n  $r4 \u003d Integer.valueOf(i0)\n  $r3 \u003d Integer.valueOf(i1)\n  $r2 \u003d Integer.valueOf(i2)\n  new IllegalFieldValueException(r1, $r4, $r3, $r2)\n  throw $r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "getWrappedValue",
    "signature": "int getWrappedValue(int,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (minValue \u003e\u003d maxValue) {\r\n        throw new IllegalArgumentException(\"MIN \u003e MAX\");\r\n    }\r\n    int wrapRange \u003d maxValue - minValue + 1;\r\n    value -\u003d minValue;\r\n    if (value \u003e\u003d 0) {\r\n        return (value % wrapRange) + minValue;\r\n    }\r\n    int remByRange \u003d (-value) % wrapRange;\r\n    if (remByRange \u003d\u003d 0) {\r\n        return 0 + minValue;\r\n    }\r\n    return (wrapRange - remByRange) + minValue;\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c i1) → B1 | else → B2",
      "B2 : If(i12 \u003c 0) → B3 | else → B4",
      "B4 : If(i5 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  i11 :\u003d @parameter0: int\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  if (i0 \u003c i1) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"MIN \u003e MAX\")\n  throw $r0\n}",
      "B2 {\n  $i2 \u003d i1 - i0\n  i3 \u003d $i2 + 1\n  i12 \u003d i11 - i0\n  if (i12 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $i9 \u003d i12 % i3\n  $i10 \u003d $i9 + i0\n  return\n}",
      "B4 {\n  $i4 \u003d neg i12\n  i5 \u003d $i4 % i3\n  if (i5 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i8 \u003d 0 + i0\n  return\n}",
      "B6 {\n  $i6 \u003d i3 - i5\n  $i7 \u003d $i6 + i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.FieldUtils",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (object1 \u003d\u003d object2) {\r\n        return true;\r\n    }\r\n    if (object1 \u003d\u003d null || object2 \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    return object1.equals(object2);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 \u003d\u003d null) → B3 | else → B4",
      "B3 : If(r1 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Object\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  if (r1 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d r0.equals(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.LenientDateTimeField",
    "methodName": "getInstance",
    "signature": "org.joda.time.DateTimeField getInstance(org.joda.time.DateTimeField,org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (field \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (field instanceof StrictDateTimeField) {\r\n        field \u003d ((StrictDateTimeField) field).getWrappedField();\r\n    }\r\n    if (field.isLenient()) {\r\n        return field;\r\n    }\r\n    return new LenientDateTimeField(field, base);\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DateTimeField\n  Chronology\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d StrictDateTimeField\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d StrictDateTimeField) r3\n  r3 \u003d $r2.getWrappedField()\n}",
      "B4 {\n  $z1 \u003d r3.isLenient()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r0 \u003d LenientDateTimeField\n  new LenientDateTimeField(r3, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.MillisDurationField",
    "methodName": "compareTo",
    "signature": "int compareTo(org.joda.time.DurationField)",
    "visibility": "public",
    "body": "{\r\n    long otherMillis \u003d otherField.getUnitMillis();\r\n    long thisMillis \u003d getUnitMillis();\r\n    // cannot do (thisMillis - otherMillis) as can overflow\r\n    if (thisMillis \u003d\u003d otherMillis) {\r\n        return 0;\r\n    }\r\n    if (thisMillis \u003c otherMillis) {\r\n        return -1;\r\n    } else {\r\n        return 1;\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2",
      "B2 : If($i4 \u003e\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  MillisDurationField\n  DurationField\n  l0 \u003d r0.getUnitMillis()\n  l1 \u003d r1.getUnitMillis()\n  $b2 \u003d l1 cmp l0\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $b3 \u003d l1 cmp l0\n  $i4 \u003d (int) $b3\n  if ($i4 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $i6 \u003d (int) -1\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MillisDurationField#getUnitMillis(...0)",
        "body": "{\r\n    return 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.MillisDurationField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (obj instanceof MillisDurationField) {\r\n        return getUnitMillis() \u003d\u003d ((MillisDurationField) obj).getUnitMillis();\r\n    }\r\n    return false;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B5",
      "B1 : If($b2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  MillisDurationField\n  Object\n  $z0 \u003d MillisDurationField\n  if ($z0 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  $l1 \u003d r1.getUnitMillis()\n  $r2 \u003d MillisDurationField) r0\n  $l0 \u003d $r2.getUnitMillis()\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MillisDurationField#getUnitMillis(...0)",
        "body": "{\r\n    return 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.PreciseDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    if (instant \u003e\u003d 0) {\r\n        return (int) ((instant / getUnitMillis()) % iRange);\r\n    } else {\r\n        return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i18 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PreciseDateTimeField\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i18 \u003d (int) $b1\n  if ($i18 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $l12 \u003d r0.getUnitMillis()\n  $l15 \u003d l0 / $l12\n  $i13 \u003d PreciseDateTimeField: int iRange\u003e\n  $l14 \u003d (long) $i13\n  $l16 \u003d $l15 % $l14\n  $i17 \u003d (int) $l16\n  return\n}",
      "B2 {\n  $i2 \u003d PreciseDateTimeField: int iRange\u003e\n  $i10 \u003d $i2 - 1\n  $l4 \u003d l0 + 1L\n  $l3 \u003d r0.getUnitMillis()\n  $l7 \u003d $l4 / $l3\n  $i5 \u003d PreciseDateTimeField: int iRange\u003e\n  $l6 \u003d (long) $i5\n  $l8 \u003d $l7 % $l6\n  $i9 \u003d (int) $l8\n  $i11 \u003d $i10 + $i9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PreciseDateTimeField#getUnitMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.PreciseDurationField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    } else if (obj instanceof PreciseDurationField) {\r\n        PreciseDurationField other \u003d (PreciseDurationField) obj;\r\n        return (getType() \u003d\u003d other.getType()) \u0026\u0026 (iUnitMillis \u003d\u003d other.iUnitMillis);\r\n    }\r\n    return false;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($r4 !\u003d $r3) → B4 | else → B6",
      "B4 : If($b2 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  PreciseDurationField\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d PreciseDurationField\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d PreciseDurationField) r1\n  $r4 \u003d r0.getType()\n  $r3 \u003d r2.getType()\n  if ($r4 !\u003d $r3) goto B4 else B6\n}",
      "B4 {\n  $l1 \u003d PreciseDurationField: long iUnitMillis\u003e\n  $l0 \u003d PreciseDurationField: long iUnitMillis\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z1 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z1 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PreciseDurationField#getType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.RemainderDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    int value \u003d getWrappedField().get(instant);\r\n    if (value \u003e\u003d 0) {\r\n        return value % iDivisor;\r\n    } else {\r\n        return (iDivisor - 1) + ((value + 1) % iDivisor);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  RemainderDateTimeField\n  l0 :\u003d @parameter0: long\n  $r1 \u003d r0.getWrappedField()\n  i1 \u003d $r1.get(l0)\n  if (i1 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $i8 \u003d RemainderDateTimeField: int iDivisor\u003e\n  $i9 \u003d i1 % $i8\n  return\n}",
      "B2 {\n  $i2 \u003d RemainderDateTimeField: int iDivisor\u003e\n  $i6 \u003d $i2 - 1\n  $i4 \u003d i1 + 1\n  $i3 \u003d RemainderDateTimeField: int iDivisor\u003e\n  $i5 \u003d $i4 % $i3\n  $i7 \u003d $i6 + $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "RemainderDateTimeField#getWrappedField(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.ScaledDurationField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    } else if (obj instanceof ScaledDurationField) {\r\n        ScaledDurationField other \u003d (ScaledDurationField) obj;\r\n        return (getWrappedField().equals(other.getWrappedField())) \u0026\u0026 (getType() \u003d\u003d other.getType()) \u0026\u0026 (iScalar \u003d\u003d other.iScalar);\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B9",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B7",
      "B4 : If($r6 !\u003d $r5) → B5 | else → B7",
      "B5 : If($i1 !\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ScaledDurationField\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d ScaledDurationField\n  if ($z0 \u003d\u003d false) goto B3 else B9\n}",
      "B3 {\n  r2 \u003d ScaledDurationField) r1\n  $r4 \u003d r0.getWrappedField()\n  $r3 \u003d r2.getWrappedField()\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  $r6 \u003d r0.getType()\n  $r5 \u003d r2.getType()\n  if ($r6 !\u003d $r5) goto B5 else B7\n}",
      "B5 {\n  $i1 \u003d ScaledDurationField: int iScalar\u003e\n  $i0 \u003d ScaledDurationField: int iScalar\u003e\n  if ($i1 !\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z2 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z2 \u003d 0\n}",
      "B8 {\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ScaledDurationField#getType(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ScaledDurationField#getWrappedField(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.SkipDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    int value \u003d super.get(millis);\r\n    if (value \u003c\u003d iSkip) {\r\n        value--;\r\n    }\r\n    return value;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 \u003e $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SkipDateTimeField\n  l0 :\u003d @parameter0: long\n  i2 \u003d r0.get(l0)\n  $i1 \u003d SkipDateTimeField: int iSkip\u003e\n  if (i2 \u003e $i1) goto B1 else B2\n}",
      "B1 {\n  $i4 \u003d (int) -1\n  i2 \u003d i2 + $i4\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.SkipDateTimeField",
    "methodName": "set",
    "signature": "long set(long,int)",
    "visibility": "public",
    "body": "{\r\n    FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\r\n    if (value \u003c\u003d iSkip) {\r\n        if (value \u003d\u003d iSkip) {\r\n            throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null);\r\n        }\r\n        value++;\r\n    }\r\n    return super.set(millis, value);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i6 \u003e $i2) → B1 | else → B4",
      "B1 : If(i6 !\u003d $i5) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  SkipDateTimeField\n  l3 :\u003d @parameter0: long\n  i6 :\u003d @parameter1: int\n  $i0 \u003d SkipDateTimeField: int iMinValue\u003e\n  $i1 \u003d r0.getMaximumValue()\n  FieldUtils.verifyValueBounds(r0, i6, $i0, $i1)\n  $i2 \u003d SkipDateTimeField: int iSkip\u003e\n  if (i6 \u003e $i2) goto B1 else B4\n}",
      "B1 {\n  $i5 \u003d SkipDateTimeField: int iSkip\u003e\n  if (i6 !\u003d $i5) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalFieldValueException\n  $r3 \u003d DateTimeFieldType.year()\n  $r2 \u003d Integer.valueOf(i6)\n  new IllegalFieldValueException($r3, $r2, null, null)\n  throw $r1\n}",
      "B3 {\n  i6 \u003d i6 + 1\n}",
      "B4 {\n  $l4 \u003d r0.set(l3, i6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SkipDateTimeField#getMaximumValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.SkipUndoDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    int value \u003d super.get(millis);\r\n    if (value \u003c iSkip) {\r\n        value++;\r\n    }\r\n    return value;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 \u003e\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SkipUndoDateTimeField\n  l0 :\u003d @parameter0: long\n  i2 \u003d r0.get(l0)\n  $i1 \u003d SkipUndoDateTimeField: int iSkip\u003e\n  if (i2 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  i2 \u003d i2 + 1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.SkipUndoDateTimeField",
    "methodName": "set",
    "signature": "long set(long,int)",
    "visibility": "public",
    "body": "{\r\n    FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\r\n    if (value \u003c\u003d iSkip) {\r\n        value--;\r\n    }\r\n    return super.set(millis, value);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i5 \u003e $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SkipUndoDateTimeField\n  l3 :\u003d @parameter0: long\n  i5 :\u003d @parameter1: int\n  $i0 \u003d SkipUndoDateTimeField: int iMinValue\u003e\n  $i1 \u003d r0.getMaximumValue()\n  FieldUtils.verifyValueBounds(r0, i5, $i0, $i1)\n  $i2 \u003d SkipUndoDateTimeField: int iSkip\u003e\n  if (i5 \u003e $i2) goto B1 else B2\n}",
      "B1 {\n  $i7 \u003d (int) -1\n  i5 \u003d i5 + $i7\n}",
      "B2 {\n  $l4 \u003d r0.set(l3, i5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SkipUndoDateTimeField#getMaximumValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.StrictDateTimeField",
    "methodName": "getInstance",
    "signature": "org.joda.time.DateTimeField getInstance(org.joda.time.DateTimeField)",
    "visibility": "public",
    "body": "{\r\n    if (field \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (field instanceof LenientDateTimeField) {\r\n        field \u003d ((LenientDateTimeField) field).getWrappedField();\r\n    }\r\n    if (!field.isLenient()) {\r\n        return field;\r\n    }\r\n    return new StrictDateTimeField(field);\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DateTimeField\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LenientDateTimeField\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d LenientDateTimeField) r2\n  r2 \u003d $r1.getWrappedField()\n}",
      "B4 {\n  $z1 \u003d r2.isLenient()\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r0 \u003d StrictDateTimeField\n  new StrictDateTimeField(r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.UnsupportedDateTimeField",
    "methodName": "getInstance",
    "signature": "org.joda.time.field.UnsupportedDateTimeField getInstance(org.joda.time.DateTimeFieldType,org.joda.time.DurationField)",
    "visibility": "public",
    "body": "{\r\n    UnsupportedDateTimeField field;\r\n    if (cCache \u003d\u003d null) {\r\n        cCache \u003d new HashMap\u003cDateTimeFieldType, UnsupportedDateTimeField\u003e(7);\r\n        field \u003d null;\r\n    } else {\r\n        field \u003d cCache.get(type);\r\n        if (field !\u003d null \u0026\u0026 field.getDurationField() !\u003d durationField) {\r\n            field \u003d null;\r\n        }\r\n    }\r\n    if (field \u003d\u003d null) {\r\n        field \u003d new UnsupportedDateTimeField(type, durationField);\r\n        cCache.put(type, field);\r\n    }\r\n    return field;\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r9 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($r7 \u003d\u003d r5) → B4 | else → B5",
      "B5 : If(r9 !\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  DateTimeFieldType\n  DurationField\n  $r0 \u003d HashMap cCache\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d HashMap\n  new HashMap(7)\n  HashMap cCache\u003e \u003d $r8\n  r9 \u003d null\n  goto B5\n}",
      "B2 {\n  $r2 \u003d HashMap cCache\u003e\n  $r3 \u003d $r2.get(r1)\n  r9 \u003d UnsupportedDateTimeField) $r3\n  if (r9 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r7 \u003d r9.getDurationField()\n  if ($r7 \u003d\u003d r5) goto B4 else B5\n}",
      "B4 {\n  r9 \u003d null\n}",
      "B5 {\n  if (r9 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d UnsupportedDateTimeField\n  new UnsupportedDateTimeField(r1, r5)\n  r9 \u003d $r4\n  $r6 \u003d HashMap cCache\u003e\n  $r6.put(r1, $r4)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.UnsupportedDurationField",
    "methodName": "getInstance",
    "signature": "org.joda.time.field.UnsupportedDurationField getInstance(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    UnsupportedDurationField field;\r\n    if (cCache \u003d\u003d null) {\r\n        cCache \u003d new HashMap\u003cDurationFieldType, UnsupportedDurationField\u003e(7);\r\n        field \u003d null;\r\n    } else {\r\n        field \u003d cCache.get(type);\r\n    }\r\n    if (field \u003d\u003d null) {\r\n        field \u003d new UnsupportedDurationField(type);\r\n        cCache.put(type, field);\r\n    }\r\n    return field;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2",
      "B3 : If(r7 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  DurationFieldType\n  $r0 \u003d HashMap cCache\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d HashMap\n  new HashMap(7)\n  HashMap cCache\u003e \u003d $r6\n  r7 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d HashMap cCache\u003e\n  $r3 \u003d $r2.get(r1)\n  r7 \u003d UnsupportedDurationField) $r3\n}",
      "B3 {\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d UnsupportedDurationField\n  new UnsupportedDurationField(r1)\n  r7 \u003d $r4\n  $r5 \u003d HashMap cCache\u003e\n  $r5.put(r1, $r4)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.field.UnsupportedDurationField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    } else if (obj instanceof UnsupportedDurationField) {\r\n        UnsupportedDurationField other \u003d (UnsupportedDurationField) obj;\r\n        if (other.getName() \u003d\u003d null) {\r\n            return (getName() \u003d\u003d null);\r\n        }\r\n        return (other.getName().equals(getName()));\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 10,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B9",
      "B3 : If($r3 !\u003d null) → B4 | else → B8",
      "B4 : If($r6 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UnsupportedDurationField\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d UnsupportedDurationField\n  if ($z0 \u003d\u003d false) goto B3 else B9\n}",
      "B3 {\n  r2 \u003d UnsupportedDurationField) r1\n  $r3 \u003d r2.getName()\n  if ($r3 !\u003d null) goto B4 else B8\n}",
      "B4 {\n  $r6 \u003d r0.getName()\n  if ($r6 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $z2 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z2 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r5 \u003d r2.getName()\n  $r4 \u003d r0.getName()\n  $z1 \u003d $r5.equals($r4)\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnsupportedDurationField#getName(...0)",
        "body": "{\r\n    return iType.getName();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "methodName": "get",
    "signature": "int get(long)",
    "visibility": "public",
    "body": "{\r\n    int value \u003d getWrappedField().get(instant);\r\n    if (value \u003d\u003d 0) {\r\n        value \u003d getMaximumValue();\r\n    }\r\n    return value;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZeroIsMaxDateTimeField\n  l0 :\u003d @parameter0: long\n  $r1 \u003d r0.getWrappedField()\n  i1 \u003d $r1.get(l0)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i1 \u003d r0.getMaximumValue()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZeroIsMaxDateTimeField#getMaximumValue(...0)",
        "body": "{\r\n    return getWrappedField().getMaximumValue() + 1;\r\n}"
      },
      {
        "name": "ZeroIsMaxDateTimeField#getWrappedField(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "methodName": "set",
    "signature": "long set(long,int)",
    "visibility": "public",
    "body": "{\r\n    int max \u003d getMaximumValue();\r\n    FieldUtils.verifyValueBounds(this, value, 1, max);\r\n    if (value \u003d\u003d max) {\r\n        value \u003d 0;\r\n    }\r\n    return getWrappedField().set(instant, value);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i3 !\u003d i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZeroIsMaxDateTimeField\n  l1 :\u003d @parameter0: long\n  i3 :\u003d @parameter1: int\n  i0 \u003d r0.getMaximumValue()\n  FieldUtils.verifyValueBounds(r0, i3, 1, i0)\n  if (i3 !\u003d i0) goto B1 else B2\n}",
      "B1 {\n  i3 \u003d 0\n}",
      "B2 {\n  $r1 \u003d r0.getWrappedField()\n  $l2 \u003d $r1.set(l1, i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZeroIsMaxDateTimeField#getMaximumValue(...0)",
        "body": "{\r\n    return getWrappedField().getMaximumValue() + 1;\r\n}"
      },
      {
        "name": "ZeroIsMaxDateTimeField#getWrappedField(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormat",
    "methodName": "patternForStyle",
    "signature": "java.lang.String patternForStyle(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    DateTimeFormatter formatter \u003d createFormatterForStyle(style);\r\n    if (locale \u003d\u003d null) {\r\n        locale \u003d Locale.getDefault();\r\n    }\r\n    // Not pretty, but it works.\r\n    return ((StyleFormatter) formatter.getPrinter0()).getPattern(locale);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  Locale\n  r1 \u003d DateTimeFormat.createFormatterForStyle(r0)\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r5 \u003d Locale.getDefault()\n}",
      "B2 {\n  $r2 \u003d r1.getPrinter0()\n  $r3 \u003d DateTimeFormat$StyleFormatter) $r2\n  $r4 \u003d $r3.getPattern(r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormat#createFormatterForStyle(...1)",
        "body": "{\r\n    if (style \u003d\u003d null || style.length() !\u003d 2) {\r\n        throw new IllegalArgumentException(\"Invalid style specification: \" + style);\r\n    }\r\n    int dateStyle \u003d selectStyle(style.charAt(0));\r\n    int timeStyle \u003d selectStyle(style.charAt(1));\r\n    if (dateStyle \u003d\u003d NONE \u0026\u0026 timeStyle \u003d\u003d NONE) {\r\n        throw new IllegalArgumentException(\"Style \u0027--\u0027 is invalid\");\r\n    }\r\n    return createFormatterForStyleIndex(dateStyle, timeStyle);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "isPrinter",
    "signature": "boolean isPrinter()",
    "visibility": "public",
    "body": "{\r\n    return (iPrinter !\u003d null);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  $r1 \u003d InternalPrinter iPrinter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "isParser",
    "signature": "boolean isParser()",
    "visibility": "public",
    "body": "{\r\n    return (iParser !\u003d null);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  $r1 \u003d InternalParser iParser\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "withLocale",
    "signature": "org.joda.time.format.DateTimeFormatter withLocale(java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (locale \u003d\u003d getLocale() || (locale !\u003d null \u0026\u0026 locale.equals(getLocale()))) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r0 \u003d\u003d null) → B2 | else → B4",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  Locale\n  $r2 \u003d r1.getLocale()\n  if (r0 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  if (r0 \u003d\u003d null) goto B2 else B4\n}",
      "B2 {\n  $r9 \u003d r1.getLocale()\n  $z1 \u003d r0.equals($r9)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d DateTimeFormatter\n  $r8 \u003d InternalPrinter iPrinter\u003e\n  $r7 \u003d InternalParser iParser\u003e\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  $r6 \u003d Chronology iChrono\u003e\n  $r5 \u003d DateTimeZone iZone\u003e\n  $r4 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeFormatter($r8, $r7, r0, $z0, $r6, $r5, $r4, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#getLocale(...0)",
        "body": "{\r\n    return iLocale;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "withOffsetParsed",
    "signature": "org.joda.time.format.DateTimeFormatter withOffsetParsed()",
    "visibility": "public",
    "body": "{\r\n    if (iOffsetParsed \u003d\u003d true) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  if ($z0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d DateTimeFormatter\n  $r6 \u003d InternalPrinter iPrinter\u003e\n  $r5 \u003d InternalParser iParser\u003e\n  $r4 \u003d Locale iLocale\u003e\n  $r3 \u003d Chronology iChrono\u003e\n  $r2 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeFormatter($r6, $r5, $r4, 1, $r3, null, $r2, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "withChronology",
    "signature": "org.joda.time.format.DateTimeFormatter withChronology(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (iChrono \u003d\u003d chrono) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  Chronology\n  $r2 \u003d Chronology iChrono\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DateTimeFormatter\n  $r8 \u003d InternalPrinter iPrinter\u003e\n  $r7 \u003d InternalParser iParser\u003e\n  $r6 \u003d Locale iLocale\u003e\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  $r5 \u003d DateTimeZone iZone\u003e\n  $r4 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeFormatter($r8, $r7, $r6, $z0, r1, $r5, $r4, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "withZone",
    "signature": "org.joda.time.format.DateTimeFormatter withZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (iZone \u003d\u003d zone) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  DateTimeZone\n  $r2 \u003d DateTimeZone iZone\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DateTimeFormatter\n  $r8 \u003d InternalPrinter iPrinter\u003e\n  $r7 \u003d InternalParser iParser\u003e\n  $r6 \u003d Locale iLocale\u003e\n  $r5 \u003d Chronology iChrono\u003e\n  $r4 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeFormatter($r8, $r7, $r6, 0, $r5, r1, $r4, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "withPivotYear",
    "signature": "org.joda.time.format.DateTimeFormatter withPivotYear(java.lang.Integer)",
    "visibility": "public",
    "body": "{\r\n    long oldVal \u003d iPivotYear \u003d\u003d null ? Long.MIN_VALUE : iPivotYear;\r\n    long newVal \u003d pivotYear \u003d\u003d null ? Long.MIN_VALUE : pivotYear;\r\n    if (oldVal \u003d\u003d newVal) {\r\n        return this;\r\n    }\r\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B3 : If(r3 !\u003d null) → B4 | else → B5",
      "B6 : If($b3 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  Integer\n  $r1 \u003d Integer iPivotYear\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l5 \u003d -9223372036854775808L\n  goto B3\n}",
      "B2 {\n  $r2 \u003d Integer iPivotYear\u003e\n  $i0 \u003d $r2.intValue()\n  $l5 \u003d (long) $i0\n}",
      "B3 {\n  l1 \u003d $l5\n  if (r3 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $l6 \u003d -9223372036854775808L\n  goto B6\n}",
      "B5 {\n  $i2 \u003d r3.intValue()\n  $l6 \u003d (long) $i2\n}",
      "B6 {\n  $b3 \u003d l1 cmp $l6\n  if ($b3 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d DateTimeFormatter\n  $r9 \u003d InternalPrinter iPrinter\u003e\n  $r8 \u003d InternalParser iParser\u003e\n  $r7 \u003d Locale iLocale\u003e\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  $r6 \u003d Chronology iChrono\u003e\n  $r5 \u003d DateTimeZone iZone\u003e\n  $i4 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeFormatter($r9, $r8, $r7, $z0, $r6, $r5, r3, $i4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuffer,org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuffer\n  ReadableInstant\n  r0.printTo(r1, r2)\n  goto B2\n}",
      "B1 {\n  $r3 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuilder,org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuilder\n  ReadableInstant\n  r0.printTo(r1, r2)\n  goto B2\n}",
      "B1 {\n  $r3 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuffer,long)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuffer\n  l0 :\u003d @parameter1: long\n  r0.printTo(r1, l0)\n  goto B2\n}",
      "B1 {\n  $r2 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuilder,long)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuilder\n  l0 :\u003d @parameter1: long\n  r0.printTo(r1, l0)\n  goto B2\n}",
      "B1 {\n  $r2 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuffer,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, partial);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuffer\n  ReadablePartial\n  r0.printTo(r1, r2)\n  goto B2\n}",
      "B1 {\n  $r3 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.StringBuilder,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        printTo((Appendable) buf, partial);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  StringBuilder\n  ReadablePartial\n  r0.printTo(r1, r2)\n  goto B2\n}",
      "B1 {\n  $r3 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "printTo",
    "signature": "void printTo(java.lang.Appendable,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    InternalPrinter printer \u003d requirePrinter();\r\n    if (partial \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The partial must not be null\");\r\n    }\r\n    printer.printTo(appendable, partial, iLocale);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  Appendable\n  ReadablePartial\n  r1 \u003d r0.requirePrinter()\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The partial must not be null\")\n  throw $r5\n}",
      "B2 {\n  $r4 \u003d Locale iLocale\u003e\n  r1.printTo(r3, r2, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#requirePrinter(...0)",
        "body": "{\r\n    InternalPrinter printer \u003d iPrinter;\r\n    if (printer \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Printing not supported\");\r\n    }\r\n    return printer;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "print",
    "signature": "java.lang.String print(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    StringBuilder buf \u003d new StringBuilder(requirePrinter().estimatePrintedLength());\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n    return buf.toString();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  ReadableInstant\n  $r0 \u003d StringBuilder\n  $r2 \u003d r1.requirePrinter()\n  $i0 \u003d $r2.estimatePrintedLength()\n  new StringBuilder($i0)\n  r1.printTo($r0, r3)\n  goto B2\n}",
      "B1 {\n  $r5 :\u003d @caughtexception\n}",
      "B2 {\n  $r4 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      },
      {
        "name": "DateTimeFormatter#requirePrinter(...0)",
        "body": "{\r\n    InternalPrinter printer \u003d iPrinter;\r\n    if (printer \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Printing not supported\");\r\n    }\r\n    return printer;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "print",
    "signature": "java.lang.String print(long)",
    "visibility": "public",
    "body": "{\r\n    StringBuilder buf \u003d new StringBuilder(requirePrinter().estimatePrintedLength());\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n    return buf.toString();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  l1 :\u003d @parameter0: long\n  $r0 \u003d StringBuilder\n  $r2 \u003d r1.requirePrinter()\n  $i0 \u003d $r2.estimatePrintedLength()\n  new StringBuilder($i0)\n  r1.printTo($r0, l1)\n  goto B2\n}",
      "B1 {\n  $r4 :\u003d @caughtexception\n}",
      "B2 {\n  $r3 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      },
      {
        "name": "DateTimeFormatter#requirePrinter(...0)",
        "body": "{\r\n    InternalPrinter printer \u003d iPrinter;\r\n    if (printer \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Printing not supported\");\r\n    }\r\n    return printer;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "print",
    "signature": "java.lang.String print(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    StringBuilder buf \u003d new StringBuilder(requirePrinter().estimatePrintedLength());\r\n    try {\r\n        printTo((Appendable) buf, partial);\r\n    } catch (IOException ex) {\r\n        // StringBuilder does not throw IOException\r\n    }\r\n    return buf.toString();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  ReadablePartial\n  $r0 \u003d StringBuilder\n  $r2 \u003d r1.requirePrinter()\n  $i0 \u003d $r2.estimatePrintedLength()\n  new StringBuilder($i0)\n  r1.printTo($r0, r3)\n  goto B2\n}",
      "B1 {\n  $r5 :\u003d @caughtexception\n}",
      "B2 {\n  $r4 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#printTo(...2)",
        "body": "{\r\n    try {\r\n        printTo((Appendable) buf, instant);\r\n    } catch (IOException ex) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      },
      {
        "name": "DateTimeFormatter#requirePrinter(...0)",
        "body": "{\r\n    InternalPrinter printer \u003d iPrinter;\r\n    if (printer \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Printing not supported\");\r\n    }\r\n    return printer;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "parseInto",
    "signature": "int parseInto(org.joda.time.ReadWritableInstant,java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    InternalParser parser \u003d requireParser();\r\n    if (instant \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Instant must not be null\");\r\n    }\r\n    long instantMillis \u003d instant.getMillis();\r\n    Chronology chrono \u003d instant.getChronology();\r\n    int defaultYear \u003d DateTimeUtils.getChronology(chrono).year().get(instantMillis);\r\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\r\n    chrono \u003d selectChronology(chrono);\r\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear);\r\n    int newPos \u003d parser.parseInto(bucket, text, position);\r\n    instant.setMillis(bucket.computeMillis(false, text));\r\n    if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\r\n        int parsedOffset \u003d bucket.getOffsetInteger();\r\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\r\n        chrono \u003d chrono.withZone(parsedZone);\r\n    } else if (bucket.getZone() !\u003d null) {\r\n        chrono \u003d chrono.withZone(bucket.getZone());\r\n    }\r\n    instant.setChronology(chrono);\r\n    if (iZone !\u003d null) {\r\n        instant.setZone(iZone);\r\n    }\r\n    return newPos;\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($r13 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($r10 \u003d\u003d null) → B6 | else → B7",
      "B7 : If($r19 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  ReadWritableInstant\n  String\n  i5 :\u003d @parameter2: int\n  r1 \u003d r0.requireParser()\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r16 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Instant must not be null\")\n  throw $r16\n}",
      "B2 {\n  l0 \u003d r2.getMillis()\n  r17 \u003d r2.getChronology()\n  $r3 \u003d DateTimeUtils.getChronology(r17)\n  $r4 \u003d $r3.year()\n  i1 \u003d $r4.get(l0)\n  $r5 \u003d r17.getZone()\n  $i2 \u003d $r5.getOffset(l0)\n  $l3 \u003d (long) $i2\n  l4 \u003d l0 + $l3\n  r18 \u003d r0.selectChronology(r17)\n  $r6 \u003d DateTimeParserBucket\n  $r8 \u003d Locale iLocale\u003e\n  $r7 \u003d Integer iPivotYear\u003e\n  new DateTimeParserBucket(l4, r18, $r8, $r7, i1)\n  i6 \u003d r1.parseInto($r6, r9, i5)\n  $l7 \u003d $r6.computeMillis(0, r9)\n  r2.setMillis($l7)\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r13 \u003d $r6.getOffsetInteger()\n  if ($r13 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r14 \u003d $r6.getOffsetInteger()\n  i8 \u003d $r14.intValue()\n  r15 \u003d DateTimeZone.forOffsetMillis(i8)\n  r18 \u003d r18.withZone(r15)\n  goto B7\n}",
      "B5 {\n  $r10 \u003d $r6.getZone()\n  if ($r10 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r12 \u003d $r6.getZone()\n  r18 \u003d r18.withZone($r12)\n}",
      "B7 {\n  r2.setChronology(r18)\n  $r19 \u003d DateTimeZone iZone\u003e\n  if ($r19 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r11 \u003d DateTimeZone iZone\u003e\n  r2.setZone($r11)\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#requireParser(...0)",
        "body": "{\r\n    InternalParser parser \u003d iParser;\r\n    if (parser \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Parsing not supported\");\r\n    }\r\n    return parser;\r\n}"
      },
      {
        "name": "DateTimeFormatter#selectChronology(...1)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    if (iChrono !\u003d null) {\r\n        chrono \u003d iChrono;\r\n    }\r\n    if (iZone !\u003d null) {\r\n        chrono \u003d chrono.withZone(iZone);\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "parseLocalDateTime",
    "signature": "org.joda.time.LocalDateTime parseLocalDateTime(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    InternalParser parser \u003d requireParser();\r\n    // always use UTC, avoiding DST gaps\r\n    Chronology chrono \u003d selectChronology(null).withUTC();\r\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\r\n    int newPos \u003d parser.parseInto(bucket, text, 0);\r\n    if (newPos \u003e\u003d 0) {\r\n        if (newPos \u003e\u003d text.length()) {\r\n            long millis \u003d bucket.computeMillis(true, text);\r\n            if (bucket.getOffsetInteger() !\u003d null) {\r\n                // treat withOffsetParsed() as being true\r\n                int parsedOffset \u003d bucket.getOffsetInteger();\r\n                DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\r\n                chrono \u003d chrono.withZone(parsedZone);\r\n            } else if (bucket.getZone() !\u003d null) {\r\n                chrono \u003d chrono.withZone(bucket.getZone());\r\n            }\r\n            return new LocalDateTime(millis, chrono);\r\n        }\r\n    } else {\r\n        newPos \u003d ~newPos;\r\n    }\r\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i4 \u003c 0) → B1 | else → B7",
      "B1 : If(i4 \u003c $i1) → B2 | else → B8",
      "B2 : If($r9 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r10 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  String\n  r1 \u003d r0.requireParser()\n  $r2 \u003d r0.selectChronology(null)\n  r14 \u003d $r2.withUTC()\n  $r16 \u003d DateTimeParserBucket\n  $r5 \u003d Locale iLocale\u003e\n  $r4 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeParserBucket(0L, r14, $r5, $r4, $i0)\n  i4 \u003d r1.parseInto($r16, r6, 0)\n  if (i4 \u003c 0) goto B1 else B7\n}",
      "B1 {\n  $i1 \u003d r6.length()\n  if (i4 \u003c $i1) goto B2 else B8\n}",
      "B2 {\n  l2 \u003d $r16.computeMillis(1, r6)\n  $r9 \u003d $r16.getOffsetInteger()\n  if ($r9 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d $r16.getOffsetInteger()\n  i3 \u003d $r12.intValue()\n  r13 \u003d DateTimeZone.forOffsetMillis(i3)\n  r14 \u003d r14.withZone(r13)\n  goto B6\n}",
      "B4 {\n  $r10 \u003d $r16.getZone()\n  if ($r10 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r11 \u003d $r16.getZone()\n  r14 \u003d r14.withZone($r11)\n}",
      "B6 {\n  $r17 \u003d LocalDateTime\n  new LocalDateTime(l2, r14)\n  return\n}",
      "B7 {\n  $i6 \u003d (int) -1\n  i4 \u003d i4 ^ $i6\n}",
      "B8 {\n  $r18 \u003d IllegalArgumentException\n  $r8 \u003d FormatUtils.createErrorMessage(r6, i4)\n  new IllegalArgumentException($r8)\n  throw $r18\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#requireParser(...0)",
        "body": "{\r\n    InternalParser parser \u003d iParser;\r\n    if (parser \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Parsing not supported\");\r\n    }\r\n    return parser;\r\n}"
      },
      {
        "name": "DateTimeFormatter#selectChronology(...1)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    if (iChrono !\u003d null) {\r\n        chrono \u003d iChrono;\r\n    }\r\n    if (iZone !\u003d null) {\r\n        chrono \u003d chrono.withZone(iZone);\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "parseDateTime",
    "signature": "org.joda.time.DateTime parseDateTime(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    InternalParser parser \u003d requireParser();\r\n    Chronology chrono \u003d selectChronology(null);\r\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\r\n    int newPos \u003d parser.parseInto(bucket, text, 0);\r\n    if (newPos \u003e\u003d 0) {\r\n        if (newPos \u003e\u003d text.length()) {\r\n            long millis \u003d bucket.computeMillis(true, text);\r\n            if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\r\n                int parsedOffset \u003d bucket.getOffsetInteger();\r\n                DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\r\n                chrono \u003d chrono.withZone(parsedZone);\r\n            } else if (bucket.getZone() !\u003d null) {\r\n                chrono \u003d chrono.withZone(bucket.getZone());\r\n            }\r\n            DateTime dt \u003d new DateTime(millis, chrono);\r\n            if (iZone !\u003d null) {\r\n                dt \u003d dt.withZone(iZone);\r\n            }\r\n            return dt;\r\n        }\r\n    } else {\r\n        newPos \u003d ~newPos;\r\n    }\r\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i3 \u003c 0) → B1 | else → B10",
      "B1 : If(i3 \u003c $i1) → B2 | else → B11",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($r11 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($r8 \u003d\u003d null) → B6 | else → B7",
      "B7 : If($r17 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  String\n  r1 \u003d r0.requireParser()\n  r14 \u003d r0.selectChronology(null)\n  $r18 \u003d DateTimeParserBucket\n  $r4 \u003d Locale iLocale\u003e\n  $r3 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeParserBucket(0L, r14, $r4, $r3, $i0)\n  i3 \u003d r1.parseInto($r18, r5, 0)\n  if (i3 \u003c 0) goto B1 else B10\n}",
      "B1 {\n  $i1 \u003d r5.length()\n  if (i3 \u003c $i1) goto B2 else B11\n}",
      "B2 {\n  l2 \u003d $r18.computeMillis(1, r5)\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r11 \u003d $r18.getOffsetInteger()\n  if ($r11 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r12 \u003d $r18.getOffsetInteger()\n  i4 \u003d $r12.intValue()\n  r13 \u003d DateTimeZone.forOffsetMillis(i4)\n  r14 \u003d r14.withZone(r13)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d $r18.getZone()\n  if ($r8 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d $r18.getZone()\n  r14 \u003d r14.withZone($r10)\n}",
      "B7 {\n  $r19 \u003d DateTime\n  new DateTime(l2, r14)\n  r16 \u003d $r19\n  $r17 \u003d DateTimeZone iZone\u003e\n  if ($r17 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d DateTimeZone iZone\u003e\n  r16 \u003d $r19.withZone($r9)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $i6 \u003d (int) -1\n  i3 \u003d i3 ^ $i6\n}",
      "B11 {\n  $r20 \u003d IllegalArgumentException\n  $r7 \u003d FormatUtils.createErrorMessage(r5, i3)\n  new IllegalArgumentException($r7)\n  throw $r20\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#requireParser(...0)",
        "body": "{\r\n    InternalParser parser \u003d iParser;\r\n    if (parser \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Parsing not supported\");\r\n    }\r\n    return parser;\r\n}"
      },
      {
        "name": "DateTimeFormatter#selectChronology(...1)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    if (iChrono !\u003d null) {\r\n        chrono \u003d iChrono;\r\n    }\r\n    if (iZone !\u003d null) {\r\n        chrono \u003d chrono.withZone(iZone);\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatter",
    "methodName": "parseMutableDateTime",
    "signature": "org.joda.time.MutableDateTime parseMutableDateTime(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    InternalParser parser \u003d requireParser();\r\n    Chronology chrono \u003d selectChronology(null);\r\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\r\n    int newPos \u003d parser.parseInto(bucket, text, 0);\r\n    if (newPos \u003e\u003d 0) {\r\n        if (newPos \u003e\u003d text.length()) {\r\n            long millis \u003d bucket.computeMillis(true, text);\r\n            if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\r\n                int parsedOffset \u003d bucket.getOffsetInteger();\r\n                DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\r\n                chrono \u003d chrono.withZone(parsedZone);\r\n            } else if (bucket.getZone() !\u003d null) {\r\n                chrono \u003d chrono.withZone(bucket.getZone());\r\n            }\r\n            MutableDateTime dt \u003d new MutableDateTime(millis, chrono);\r\n            if (iZone !\u003d null) {\r\n                dt.setZone(iZone);\r\n            }\r\n            return dt;\r\n        }\r\n    } else {\r\n        newPos \u003d ~newPos;\r\n    }\r\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i3 \u003c 0) → B1 | else → B10",
      "B1 : If(i3 \u003c $i1) → B2 | else → B11",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($r11 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($r8 \u003d\u003d null) → B6 | else → B7",
      "B7 : If($r16 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatter\n  String\n  r1 \u003d r0.requireParser()\n  r14 \u003d r0.selectChronology(null)\n  $r17 \u003d DateTimeParserBucket\n  $r4 \u003d Locale iLocale\u003e\n  $r3 \u003d Integer iPivotYear\u003e\n  $i0 \u003d DateTimeFormatter: int iDefaultYear\u003e\n  new DateTimeParserBucket(0L, r14, $r4, $r3, $i0)\n  i3 \u003d r1.parseInto($r17, r5, 0)\n  if (i3 \u003c 0) goto B1 else B10\n}",
      "B1 {\n  $i1 \u003d r5.length()\n  if (i3 \u003c $i1) goto B2 else B11\n}",
      "B2 {\n  l2 \u003d $r17.computeMillis(1, r5)\n  $z0 \u003d DateTimeFormatter: boolean iOffsetParsed\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r11 \u003d $r17.getOffsetInteger()\n  if ($r11 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r12 \u003d $r17.getOffsetInteger()\n  i4 \u003d $r12.intValue()\n  r13 \u003d DateTimeZone.forOffsetMillis(i4)\n  r14 \u003d r14.withZone(r13)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d $r17.getZone()\n  if ($r8 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d $r17.getZone()\n  r14 \u003d r14.withZone($r10)\n}",
      "B7 {\n  $r18 \u003d MutableDateTime\n  new MutableDateTime(l2, r14)\n  $r16 \u003d DateTimeZone iZone\u003e\n  if ($r16 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d DateTimeZone iZone\u003e\n  $r18.setZone($r9)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $i6 \u003d (int) -1\n  i3 \u003d i3 ^ $i6\n}",
      "B11 {\n  $r19 \u003d IllegalArgumentException\n  $r7 \u003d FormatUtils.createErrorMessage(r5, i3)\n  new IllegalArgumentException($r7)\n  throw $r19\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatter#requireParser(...0)",
        "body": "{\r\n    InternalParser parser \u003d iParser;\r\n    if (parser \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Parsing not supported\");\r\n    }\r\n    return parser;\r\n}"
      },
      {
        "name": "DateTimeFormatter#selectChronology(...1)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    if (iChrono !\u003d null) {\r\n        chrono \u003d iChrono;\r\n    }\r\n    if (iZone !\u003d null) {\r\n        chrono \u003d chrono.withZone(iZone);\r\n    }\r\n    return chrono;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "toFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter toFormatter()",
    "visibility": "public",
    "body": "{\r\n    Object f \u003d getFormatter();\r\n    InternalPrinter printer \u003d null;\r\n    if (isPrinter(f)) {\r\n        printer \u003d (InternalPrinter) f;\r\n    }\r\n    InternalParser parser \u003d null;\r\n    if (isParser(f)) {\r\n        parser \u003d (InternalParser) f;\r\n    }\r\n    if (printer !\u003d null || parser !\u003d null) {\r\n        return new DateTimeFormatter(printer, parser);\r\n    }\r\n    throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(r4 !\u003d null) → B5 | else → B6",
      "B5 : If(r5 \u003d\u003d null) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  r1 \u003d r0.getFormatter()\n  r4 \u003d null\n  $z0 \u003d r0.isPrinter(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r4 \u003d InternalPrinter) r1\n}",
      "B2 {\n  r5 \u003d null\n  $z1 \u003d r0.isParser(r1)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r5 \u003d InternalParser) r1\n}",
      "B4 {\n  if (r4 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  if (r5 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r2 \u003d DateTimeFormatter\n  new DateTimeFormatter(r4, r5)\n  return\n}",
      "B7 {\n  $r3 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"Both printing and parsing not supported\")\n  throw $r3\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#isPrinter(...1)",
        "body": "{\r\n    if (f instanceof InternalPrinter) {\r\n        if (f instanceof Composite) {\r\n            return ((Composite) f).isPrinter();\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#getFormatter(...0)",
        "body": "{\r\n    Object f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        if (iElementPairs.size() \u003d\u003d 2) {\r\n            Object printer \u003d iElementPairs.get(0);\r\n            Object parser \u003d iElementPairs.get(1);\r\n            if (printer !\u003d null) {\r\n                if (printer \u003d\u003d parser || parser \u003d\u003d null) {\r\n                    f \u003d printer;\r\n                }\r\n            } else {\r\n                f \u003d parser;\r\n            }\r\n        }\r\n        if (f \u003d\u003d null) {\r\n            f \u003d new Composite(iElementPairs);\r\n        }\r\n        iFormatter \u003d f;\r\n    }\r\n    return f;\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#isParser(...1)",
        "body": "{\r\n    if (f instanceof InternalParser) {\r\n        if (f instanceof Composite) {\r\n            return ((Composite) f).isParser();\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "toPrinter",
    "signature": "org.joda.time.format.DateTimePrinter toPrinter()",
    "visibility": "public",
    "body": "{\r\n    Object f \u003d getFormatter();\r\n    if (isPrinter(f)) {\r\n        InternalPrinter ip \u003d (InternalPrinter) f;\r\n        return InternalPrinterDateTimePrinter.of(ip);\r\n    }\r\n    throw new UnsupportedOperationException(\"Printing is not supported\");\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  r1 \u003d r0.getFormatter()\n  $z0 \u003d r0.isPrinter(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d InternalPrinter) r1\n  $r4 \u003d InternalPrinterDateTimePrinter.of(r3)\n  return\n}",
      "B2 {\n  $r2 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"Printing is not supported\")\n  throw $r2\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#isPrinter(...1)",
        "body": "{\r\n    if (f instanceof InternalPrinter) {\r\n        if (f instanceof Composite) {\r\n            return ((Composite) f).isPrinter();\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#getFormatter(...0)",
        "body": "{\r\n    Object f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        if (iElementPairs.size() \u003d\u003d 2) {\r\n            Object printer \u003d iElementPairs.get(0);\r\n            Object parser \u003d iElementPairs.get(1);\r\n            if (printer !\u003d null) {\r\n                if (printer \u003d\u003d parser || parser \u003d\u003d null) {\r\n                    f \u003d printer;\r\n                }\r\n            } else {\r\n                f \u003d parser;\r\n            }\r\n        }\r\n        if (f \u003d\u003d null) {\r\n            f \u003d new Composite(iElementPairs);\r\n        }\r\n        iFormatter \u003d f;\r\n    }\r\n    return f;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "toParser",
    "signature": "org.joda.time.format.DateTimeParser toParser()",
    "visibility": "public",
    "body": "{\r\n    Object f \u003d getFormatter();\r\n    if (isParser(f)) {\r\n        InternalParser ip \u003d (InternalParser) f;\r\n        return InternalParserDateTimeParser.of(ip);\r\n    }\r\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  r1 \u003d r0.getFormatter()\n  $z0 \u003d r0.isParser(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d InternalParser) r1\n  $r4 \u003d InternalParserDateTimeParser.of(r3)\n  return\n}",
      "B2 {\n  $r2 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"Parsing is not supported\")\n  throw $r2\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#getFormatter(...0)",
        "body": "{\r\n    Object f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        if (iElementPairs.size() \u003d\u003d 2) {\r\n            Object printer \u003d iElementPairs.get(0);\r\n            Object parser \u003d iElementPairs.get(1);\r\n            if (printer !\u003d null) {\r\n                if (printer \u003d\u003d parser || parser \u003d\u003d null) {\r\n                    f \u003d printer;\r\n                }\r\n            } else {\r\n                f \u003d parser;\r\n            }\r\n        }\r\n        if (f \u003d\u003d null) {\r\n            f \u003d new Composite(iElementPairs);\r\n        }\r\n        iFormatter \u003d f;\r\n    }\r\n    return f;\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#isParser(...1)",
        "body": "{\r\n    if (f instanceof InternalParser) {\r\n        if (f instanceof Composite) {\r\n            return ((Composite) f).isParser();\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "append",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder append(org.joda.time.format.DateTimeFormatter)",
    "visibility": "public",
    "body": "{\r\n    if (formatter \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"No formatter supplied\");\r\n    }\r\n    return append0(formatter.getPrinter0(), formatter.getParser0());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFormatter\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No formatter supplied\")\n  throw $r5\n}",
      "B2 {\n  $r3 \u003d r0.getPrinter0()\n  $r2 \u003d r0.getParser0()\n  $r4 \u003d r1.append0($r3, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...2)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    iElementPairs.add(printer);\r\n    iElementPairs.add(parser);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "append",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder append(org.joda.time.format.DateTimePrinter,org.joda.time.format.DateTimeParser[])",
    "visibility": "public",
    "body": "{\r\n    checkPrinter(printer);\r\n    checkParser(parser);\r\n    return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parser));\r\n}",
    "nodes": 14,
    "edges": 15,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If(i0 !\u003d 1) → B5 | else → B8",
      "B5 : If($r12 !\u003d null) → B6 | else → B7",
      "B9 : If(i2 \u003e\u003d $i1) → B10 | else → B13",
      "B10 : If($r10 !\u003d null) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimePrinter\n  DateTimeParser[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r5.checkPrinter(r0)\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r18 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No parsers supplied\")\n  throw $r18\n}",
      "B4 {\n  i0 \u003d lengthof r1\n  if (i0 !\u003d 1) goto B5 else B8\n}",
      "B5 {\n  $r12 \u003d r1[0]\n  if ($r12 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r17 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No parser supplied\")\n  throw $r17\n}",
      "B7 {\n  $r15 \u003d DateTimePrinterInternalPrinter.of(r0)\n  $r13 \u003d r1[0]\n  $r14 \u003d DateTimeParserInternalParser.of($r13)\n  $r16 \u003d r5.append0($r15, $r14)\n  return\n}",
      "B8 {\n  r2 \u003d InternalParser)[i0]\n  i2 \u003d 0\n}",
      "B9 {\n  $i1 \u003d i0 - 1\n  if (i2 \u003e\u003d $i1) goto B10 else B13\n}",
      "B10 {\n  $r9 \u003d r1[i2]\n  $r10 \u003d DateTimeParserInternalParser.of($r9)\n  r2[i2] \u003d $r10\n  if ($r10 !\u003d null) goto B11 else B12\n}",
      "B11 {\n  $r11 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Incomplete parser array\")\n  throw $r11\n}",
      "B12 {\n  i2 \u003d i2 + 1\n  goto B9\n}",
      "B13 {\n  $r3 \u003d r1[i2]\n  $r4 \u003d DateTimeParserInternalParser.of($r3)\n  r2[i2] \u003d $r4\n  $r7 \u003d DateTimePrinterInternalPrinter.of(r0)\n  $r6 \u003d DateTimeFormatterBuilder$MatchingParser\n  new DateTimeFormatterBuilder$MatchingParser(r2)\n  $r8 \u003d r5.append0($r7, $r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B9",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...2)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    iElementPairs.add(printer);\r\n    iElementPairs.add(parser);\r\n    return this;\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#checkParser(...1)",
        "body": "{\r\n    if (parser \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"No parser supplied\");\r\n    }\r\n}"
      },
      {
        "name": "DateTimeFormatterBuilder#checkPrinter(...1)",
        "body": "{\r\n    if (printer \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"No printer supplied\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendLiteral",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendLiteral(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Literal must not be null\");\r\n    }\r\n    switch(text.length()) {\r\n        case 0:\r\n            return this;\r\n        case 1:\r\n            return append0(new CharacterLiteral(text.charAt(0)));\r\n        default:\r\n            return append0(new StringLiteral(text));\r\n    }\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(switch-on $i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Literal must not be null\")\n  throw $r6\n}",
      "B2 {\n  $i0 \u003d r0.length()\n  DateTimeFormatterBuilder$StringLiteral; }\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d DateTimeFormatterBuilder$CharacterLiteral\n  $c1 \u003d r0.charAt(0)\n  new DateTimeFormatterBuilder$CharacterLiteral($c1)\n  $r3 \u003d r1.append0($r2)\n  return\n}",
      "B5 {\n  $r4 \u003d DateTimeFormatterBuilder$StringLiteral\n  new DateTimeFormatterBuilder$StringLiteral(r0)\n  $r5 \u003d r1.append0($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendDecimal",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendDecimal(org.joda.time.DateTimeFieldType,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (maxDigits \u003c minDigits) {\r\n        maxDigits \u003d minDigits;\r\n    }\r\n    if (minDigits \u003c 0 || maxDigits \u003c\u003d 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (minDigits \u003c\u003d 1) {\r\n        return append0(new UnpaddedNumber(fieldType, maxDigits, false));\r\n    } else {\r\n        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\r\n    }\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B4",
      "B4 : If(i0 \u003c 0) → B5 | else → B6",
      "B5 : If(i1 \u003e 0) → B6 | else → B7",
      "B7 : If(i0 \u003e 1) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r7\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B4\n}",
      "B3 {\n  i1 \u003d i0\n}",
      "B4 {\n  if (i0 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  if (i1 \u003e 0) goto B6 else B7\n}",
      "B6 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r1\n}",
      "B7 {\n  if (i0 \u003e 1) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d DateTimeFormatterBuilder$UnpaddedNumber\n  new DateTimeFormatterBuilder$UnpaddedNumber(r0, i1, 0)\n  $r6 \u003d r2.append0($r5)\n  return\n}",
      "B9 {\n  $r3 \u003d DateTimeFormatterBuilder$PaddedNumber\n  new DateTimeFormatterBuilder$PaddedNumber(r0, i1, 0, i0)\n  $r4 \u003d r2.append0($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendFixedDecimal",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendFixedDecimal(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (numDigits \u003c\u003d 0) {\r\n        throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\r\n    }\r\n    return append0(new FixedNumber(fieldType, numDigits, false));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003e 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r6\n}",
      "B2 {\n  if (i0 \u003e 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IllegalArgumentException\n  $r5 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r5)\n  throw $r4\n}",
      "B4 {\n  $r2 \u003d DateTimeFormatterBuilder$FixedNumber\n  new DateTimeFormatterBuilder$FixedNumber(r0, i0, 0)\n  $r3 \u003d r1.append0($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendSignedDecimal",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendSignedDecimal(org.joda.time.DateTimeFieldType,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (maxDigits \u003c minDigits) {\r\n        maxDigits \u003d minDigits;\r\n    }\r\n    if (minDigits \u003c 0 || maxDigits \u003c\u003d 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (minDigits \u003c\u003d 1) {\r\n        return append0(new UnpaddedNumber(fieldType, maxDigits, true));\r\n    } else {\r\n        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\r\n    }\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B4",
      "B4 : If(i0 \u003c 0) → B5 | else → B6",
      "B5 : If(i1 \u003e 0) → B6 | else → B7",
      "B7 : If(i0 \u003e 1) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r7\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B4\n}",
      "B3 {\n  i1 \u003d i0\n}",
      "B4 {\n  if (i0 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  if (i1 \u003e 0) goto B6 else B7\n}",
      "B6 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r1\n}",
      "B7 {\n  if (i0 \u003e 1) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d DateTimeFormatterBuilder$UnpaddedNumber\n  new DateTimeFormatterBuilder$UnpaddedNumber(r0, i1, 1)\n  $r6 \u003d r2.append0($r5)\n  return\n}",
      "B9 {\n  $r3 \u003d DateTimeFormatterBuilder$PaddedNumber\n  new DateTimeFormatterBuilder$PaddedNumber(r0, i1, 1, i0)\n  $r4 \u003d r2.append0($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendFixedSignedDecimal",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendFixedSignedDecimal(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (numDigits \u003c\u003d 0) {\r\n        throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\r\n    }\r\n    return append0(new FixedNumber(fieldType, numDigits, true));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003e 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r6\n}",
      "B2 {\n  if (i0 \u003e 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IllegalArgumentException\n  $r5 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r5)\n  throw $r4\n}",
      "B4 {\n  $r2 \u003d DateTimeFormatterBuilder$FixedNumber\n  new DateTimeFormatterBuilder$FixedNumber(r0, i0, 1)\n  $r3 \u003d r1.append0($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendText",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendText(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    return append0(new TextField(fieldType, false));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d DateTimeFormatterBuilder$TextField\n  new DateTimeFormatterBuilder$TextField(r0, 0)\n  $r3 \u003d r1.append0($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendShortText",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendShortText(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    return append0(new TextField(fieldType, true));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d DateTimeFormatterBuilder$TextField\n  new DateTimeFormatterBuilder$TextField(r0, 1)\n  $r3 \u003d r1.append0($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeFormatterBuilder",
    "methodName": "appendFraction",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder appendFraction(org.joda.time.DateTimeFieldType,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field type must not be null\");\r\n    }\r\n    if (maxDigits \u003c minDigits) {\r\n        maxDigits \u003d minDigits;\r\n    }\r\n    if (minDigits \u003c 0 || maxDigits \u003c\u003d 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return append0(new Fraction(fieldType, minDigits, maxDigits));\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B4",
      "B4 : If(i0 \u003c 0) → B5 | else → B6",
      "B5 : If(i1 \u003e 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  DateTimeFormatterBuilder\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field type must not be null\")\n  throw $r5\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B4\n}",
      "B3 {\n  i1 \u003d i0\n}",
      "B4 {\n  if (i0 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  if (i1 \u003e 0) goto B6 else B7\n}",
      "B6 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r1\n}",
      "B7 {\n  $r3 \u003d DateTimeFormatterBuilder$Fraction\n  new DateTimeFormatterBuilder$Fraction(r0, i0, i1)\n  $r4 \u003d r2.append0($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeFormatterBuilder#append0(...1)",
        "body": "{\r\n    iFormatter \u003d null;\r\n    // Add the element as both a printer and parser.\r\n    iElementPairs.add(element);\r\n    iElementPairs.add(element);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.DateTimeParserBucket",
    "methodName": "getOffset",
    "signature": "int getOffset()",
    "visibility": "public",
    "body": "{\r\n    return (iOffset !\u003d null ? iOffset : 0);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeParserBucket\n  $r1 \u003d Integer iOffset\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Integer iOffset\u003e\n  $i0 \u003d $r2.intValue()\n  goto B3\n}",
      "B2 {\n  $i0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeParserBucket",
    "methodName": "saveState",
    "signature": "java.lang.Object saveState()",
    "visibility": "public",
    "body": "{\r\n    if (iSavedState \u003d\u003d null) {\r\n        iSavedState \u003d new SavedState();\r\n    }\r\n    return iSavedState;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeParserBucket\n  $r1 \u003d Object iSavedState\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DateTimeParserBucket$SavedState\n  new DateTimeParserBucket$SavedState(r0)\n  Object iSavedState\u003e \u003d $r3\n}",
      "B2 {\n  $r2 \u003d Object iSavedState\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeParserBucket",
    "methodName": "restoreState",
    "signature": "boolean restoreState(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (savedState instanceof SavedState) {\r\n        if (((SavedState) savedState).restoreState(this)) {\r\n            iSavedState \u003d savedState;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DateTimeParserBucket\n  Object\n  $z0 \u003d DateTimeParserBucket$SavedState\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d DateTimeParserBucket$SavedState) r0\n  $z1 \u003d $r2.restoreState(r1)\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  Object iSavedState\u003e \u003d r0\n  return\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.DateTimeParserBucket",
    "methodName": "computeMillis",
    "signature": "long computeMillis(boolean,java.lang.CharSequence)",
    "visibility": "public",
    "body": "{\r\n    SavedField[] savedFields \u003d iSavedFields;\r\n    int count \u003d iSavedFieldsCount;\r\n    if (iSavedFieldsShared) {\r\n        // clone so that sort does not affect saved state\r\n        iSavedFields \u003d savedFields \u003d (SavedField[]) iSavedFields.clone();\r\n        iSavedFieldsShared \u003d false;\r\n    }\r\n    sort(savedFields, count);\r\n    if (count \u003e 0) {\r\n        // alter base year for parsing if first field is month or day\r\n        DurationField months \u003d DurationFieldType.months().getField(iChrono);\r\n        DurationField days \u003d DurationFieldType.days().getField(iChrono);\r\n        DurationField first \u003d savedFields[0].iField.getDurationField();\r\n        if (compareReverse(first, months) \u003e\u003d 0 \u0026\u0026 compareReverse(first, days) \u003c\u003d 0) {\r\n            saveField(DateTimeFieldType.year(), iDefaultYear);\r\n            return computeMillis(resetFields, text);\r\n        }\r\n    }\r\n    long millis \u003d iMillis;\r\n    try {\r\n        for (int i \u003d 0; i \u003c count; i++) {\r\n            millis \u003d savedFields[i].set(millis, resetFields);\r\n        }\r\n        if (resetFields) {\r\n            for (int i \u003d 0; i \u003c count; i++) {\r\n                if (!savedFields[i].iField.isLenient()) {\r\n                    millis \u003d savedFields[i].set(millis, i \u003d\u003d (count - 1));\r\n                }\r\n            }\r\n        }\r\n    } catch (IllegalFieldValueException e) {\r\n        if (text !\u003d null) {\r\n            e.prependMessage(\"Cannot parse \\\"\" + text + \u0027\"\u0027);\r\n        }\r\n        throw e;\r\n    }\r\n    if (iOffset !\u003d null) {\r\n        millis -\u003d iOffset;\r\n    } else if (iZone !\u003d null) {\r\n        int offset \u003d iZone.getOffsetFromLocal(millis);\r\n        millis -\u003d offset;\r\n        if (offset !\u003d iZone.getOffset(millis)) {\r\n            String message \u003d \"Illegal instant due to time zone offset transition (\" + iZone + \u0027)\u0027;\r\n            if (text !\u003d null) {\r\n                message \u003d \"Cannot parse \\\"\" + text + \"\\\": \" + message;\r\n            }\r\n            throw new IllegalInstantException(message);\r\n        }\r\n    }\r\n    return millis;\r\n}",
    "nodes": 30,
    "edges": 40,
    "cc": 12,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(i0 \u003c\u003d 0) → B3 | else → B6",
      "B3 : If($i7 \u003c 0) → B4 | else → B6",
      "B4 : If($i8 \u003e 0) → B5 | else → B6",
      "B7 : If(i12 \u003e\u003d i0) → B8 | else → B9",
      "B9 : If(z1 \u003d\u003d false) → B10 | else → B18",
      "B11 : If(i13 \u003e\u003d i0) → B12 | else → B18",
      "B12 : If($z2 !\u003d 0) → B13 | else → B17",
      "B13 : If(i13 !\u003d $i5) → B14 | else → B15",
      "B19 : If(r7 \u003d\u003d null) → B20 | else → B21",
      "B22 : If($r1 \u003d\u003d null) → B23 | else → B24",
      "B24 : If($r2 \u003d\u003d null) → B25 | else → B29",
      "B25 : If(i14 \u003d\u003d $i2) → B26 | else → B29",
      "B26 : If(r7 \u003d\u003d null) → B27 | else → B28"
    ],
    "blockList": [
      "B0 {\n  DateTimeParserBucket\n  z1 :\u003d @parameter0: boolean\n  CharSequence\n  r29 \u003d DateTimeParserBucket$SavedField[] iSavedFields\u003e\n  i0 \u003d DateTimeParserBucket: int iSavedFieldsCount\u003e\n  $z0 \u003d DateTimeParserBucket: boolean iSavedFieldsShared\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r23 \u003d DateTimeParserBucket$SavedField[] iSavedFields\u003e\n  $r24 \u003d $r23.clone()\n  $r25 \u003d DateTimeParserBucket$SavedField[]) $r24\n  r29 \u003d $r25\n  DateTimeParserBucket$SavedField[] iSavedFields\u003e \u003d $r25\n  DateTimeParserBucket: boolean iSavedFieldsShared\u003e \u003d 0\n}",
      "B2 {\n  DateTimeParserBucket.sort(r29, i0)\n  if (i0 \u003c\u003d 0) goto B3 else B6\n}",
      "B3 {\n  $r16 \u003d DurationFieldType.months()\n  $r15 \u003d Chronology iChrono\u003e\n  r30 \u003d $r16.getField($r15)\n  $r18 \u003d DurationFieldType.days()\n  $r17 \u003d Chronology iChrono\u003e\n  r19 \u003d $r18.getField($r17)\n  $r20 \u003d r29[0]\n  $r21 \u003d DateTimeField iField\u003e\n  r31 \u003d $r21.getDurationField()\n  $i7 \u003d DateTimeParserBucket.compareReverse(r31, r30)\n  if ($i7 \u003c 0) goto B4 else B6\n}",
      "B4 {\n  $i8 \u003d DateTimeParserBucket.compareReverse(r31, r19)\n  if ($i8 \u003e 0) goto B5 else B6\n}",
      "B5 {\n  $r22 \u003d DateTimeFieldType.year()\n  $i9 \u003d DateTimeParserBucket: int iDefaultYear\u003e\n  r0.saveField($r22, $i9)\n  $l10 \u003d r0.computeMillis(z1, r7)\n  return\n}",
      "B6 {\n  l11 \u003d DateTimeParserBucket: long iMillis\u003e\n  i12 \u003d 0\n}",
      "B7 {\n  if (i12 \u003e\u003d i0) goto B8 else B9\n}",
      "B8 {\n  $r14 \u003d r29[i12]\n  l11 \u003d $r14.set(l11, z1)\n  i12 \u003d i12 + 1\n  goto B7\n}",
      "B9 {\n  if (z1 \u003d\u003d false) goto B10 else B18\n}",
      "B10 {\n  i13 \u003d 0\n}",
      "B11 {\n  if (i13 \u003e\u003d i0) goto B12 else B18\n}",
      "B12 {\n  $r11 \u003d r29[i13]\n  $r12 \u003d DateTimeField iField\u003e\n  $z2 \u003d $r12.isLenient()\n  if ($z2 !\u003d 0) goto B13 else B17\n}",
      "B13 {\n  $r13 \u003d r29[i13]\n  $l6 \u003d l11\n  $i5 \u003d i0 - 1\n  if (i13 !\u003d $i5) goto B14 else B15\n}",
      "B14 {\n  $z3 \u003d 1\n  goto B16\n}",
      "B15 {\n  $z3 \u003d 0\n}",
      "B16 {\n  l11 \u003d $r13.set($l6, $z3)\n}",
      "B17 {\n  i13 \u003d i13 + 1\n  goto B11\n}",
      "B18 {\n  goto B22\n}",
      "B19 {\n  $r26 :\u003d @caughtexception\n  if (r7 \u003d\u003d null) goto B20 else B21\n}",
      "B20 {\n  $r27 \u003d String.valueOf(r7)\n  $r28 \u003d dynInvoke makeConcatWithConstants($r27)\n  $r26.prependMessage($r28)\n}",
      "B21 {\n  throw $r26\n}",
      "B22 {\n  $r1 \u003d Integer iOffset\u003e\n  if ($r1 \u003d\u003d null) goto B23 else B24\n}",
      "B23 {\n  $r10 \u003d Integer iOffset\u003e\n  $i3 \u003d $r10.intValue()\n  $l4 \u003d (long) $i3\n  l11 \u003d l11 - $l4\n  goto B29\n}",
      "B24 {\n  $r2 \u003d DateTimeZone iZone\u003e\n  if ($r2 \u003d\u003d null) goto B25 else B29\n}",
      "B25 {\n  $r3 \u003d DateTimeZone iZone\u003e\n  i14 \u003d $r3.getOffsetFromLocal(l11)\n  $l1 \u003d (long) i14\n  l11 \u003d l11 - $l1\n  $r4 \u003d DateTimeZone iZone\u003e\n  $i2 \u003d $r4.getOffset(l11)\n  if (i14 \u003d\u003d $i2) goto B26 else B29\n}",
      "B26 {\n  $r5 \u003d DateTimeZone iZone\u003e\n  $r6 \u003d String.valueOf($r5)\n  r32 \u003d dynInvoke makeConcatWithConstants($r6)\n  if (r7 \u003d\u003d null) goto B27 else B28\n}",
      "B27 {\n  $r9 \u003d String.valueOf(r7)\n  r32 \u003d dynInvoke makeConcatWithConstants($r9, r32)\n}",
      "B28 {\n  $r8 \u003d IllegalInstantException\n  new IllegalInstantException(r32)\n  throw $r8\n}",
      "B29 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B9 --\u003e B18",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B18",
      "B12 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B17 --\u003e B11",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B29",
      "B24 --\u003e B25",
      "B24 --\u003e B29",
      "B25 --\u003e B26",
      "B25 --\u003e B29",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeParserBucket#saveField(...2)",
        "body": "{\r\n    obtainSaveField().init(field, value);\r\n}"
      },
      {
        "name": "DateTimeParserBucket#computeMillis(...2)",
        "body": "{\r\n    return computeMillis(resetFields, (CharSequence) text);\r\n}"
      },
      {
        "name": "DateTimeParserBucket#sort(...2)",
        "body": "{\r\n    if (high \u003e 10) {\r\n        Arrays.sort(array, 0, high);\r\n    } else {\r\n        for (int i \u003d 0; i \u003c high; i++) {\r\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\r\n                SavedField t \u003d array[j];\r\n                array[j] \u003d array[j - 1];\r\n                array[j - 1] \u003d t;\r\n            }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "DateTimeParserBucket#compareReverse(...2)",
        "body": "{\r\n    if (a \u003d\u003d null || !a.isSupported()) {\r\n        if (b \u003d\u003d null || !b.isSupported()) {\r\n            return 0;\r\n        }\r\n        return -1;\r\n    }\r\n    if (b \u003d\u003d null || !b.isSupported()) {\r\n        return 1;\r\n    }\r\n    return -a.compareTo(b);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendPaddedInteger",
    "signature": "void appendPaddedInteger(java.lang.StringBuffer,int,int)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        appendPaddedInteger((Appendable) buf, value, size);\r\n    } catch (IOException e) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  StringBuffer\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  FormatUtils.appendPaddedInteger(r0, i0, i1)\n  goto B2\n}",
      "B1 {\n  $r1 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendPaddedInteger(...3)",
        "body": "{\r\n    try {\r\n        appendPaddedInteger((Appendable) buf, value, size);\r\n    } catch (IOException e) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendPaddedInteger",
    "signature": "void appendPaddedInteger(java.lang.Appendable,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003c 0) {\r\n        appenadble.append(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            for (; size \u003e 10; size--) {\r\n                appenadble.append(\u00270\u0027);\r\n            }\r\n            appenadble.append(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        for (; size \u003e 1; size--) {\r\n            appenadble.append(\u00270\u0027);\r\n        }\r\n        appenadble.append((char) (value + \u00270\u0027));\r\n    } else if (value \u003c 100) {\r\n        for (; size \u003e 2; size--) {\r\n            appenadble.append(\u00270\u0027);\r\n        }\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        appenadble.append((char) (d + \u00270\u0027));\r\n        // Append remainder by calculating (value - d * 10).\r\n        appenadble.append((char) (value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027));\r\n    } else {\r\n        int digits;\r\n        if (value \u003c 1000) {\r\n            digits \u003d 3;\r\n        } else if (value \u003c 10000) {\r\n            digits \u003d 4;\r\n        } else {\r\n            digits \u003d (int) (Math.log(value) / LOG_10) + 1;\r\n        }\r\n        for (; size \u003e digits; size--) {\r\n            appenadble.append(\u00270\u0027);\r\n        }\r\n        appenadble.append(Integer.toString(value));\r\n    }\r\n}",
    "nodes": 23,
    "edges": 31,
    "cc": 10,
    "flowSummary": [
      "B0 : If(i13 \u003e\u003d 0) → B1 | else → B6",
      "B1 : If(i13 \u003d\u003d -2147483648) → B2 | else → B3",
      "B3 : If(i14 \u003c\u003d 10) → B4 | else → B5",
      "B6 : If(i13 \u003e\u003d 10) → B7 | else → B10",
      "B7 : If(i14 \u003c\u003d 1) → B8 | else → B9",
      "B10 : If(i13 \u003e\u003d 100) → B11 | else → B14",
      "B11 : If(i14 \u003c\u003d 2) → B12 | else → B13",
      "B14 : If(i13 \u003e\u003d 1000) → B15 | else → B16",
      "B16 : If(i13 \u003e\u003d 10000) → B17 | else → B18",
      "B19 : If(i14 \u003c\u003d i16) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  Appendable\n  i13 :\u003d @parameter1: int\n  i14 :\u003d @parameter2: int\n  if (i13 \u003e\u003d 0) goto B1 else B6\n}",
      "B1 {\n  r0.append(45)\n  if (i13 \u003d\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  i13 \u003d neg i13\n  goto B6\n}",
      "B3 {\n  if (i14 \u003c\u003d 10) goto B4 else B5\n}",
      "B4 {\n  r0.append(48)\n  $i18 \u003d (int) -1\n  i14 \u003d i14 + $i18\n  goto B3\n}",
      "B5 {\n  r0.append(\"2147483648\")\n  return\n}",
      "B6 {\n  if (i13 \u003e\u003d 10) goto B7 else B10\n}",
      "B7 {\n  if (i14 \u003c\u003d 1) goto B8 else B9\n}",
      "B8 {\n  r0.append(48)\n  $i20 \u003d (int) -1\n  i14 \u003d i14 + $i20\n  goto B7\n}",
      "B9 {\n  $i11 \u003d i13 + 48\n  $c12 \u003d (char) $i11\n  r0.append($c12)\n  goto B22\n}",
      "B10 {\n  if (i13 \u003e\u003d 100) goto B11 else B14\n}",
      "B11 {\n  if (i14 \u003c\u003d 2) goto B12 else B13\n}",
      "B12 {\n  r0.append(48)\n  $i22 \u003d (int) -1\n  i14 \u003d i14 + $i22\n  goto B11\n}",
      "B13 {\n  $i1 \u003d i13 + 1\n  $i2 \u003d $i1 * 13421772\n  i15 \u003d $i2 \u003e\u003e 27\n  $i3 \u003d i15 + 48\n  $c4 \u003d (char) $i3\n  r0.append($c4)\n  $i5 \u003d i15 \u003c\u003c 3\n  $i7 \u003d i13 - $i5\n  $i6 \u003d i15 \u003c\u003c 1\n  $i8 \u003d $i7 - $i6\n  $i9 \u003d $i8 + 48\n  $c10 \u003d (char) $i9\n  r0.append($c10)\n  goto B22\n}",
      "B14 {\n  if (i13 \u003e\u003d 1000) goto B15 else B16\n}",
      "B15 {\n  i16 \u003d 3\n  goto B19\n}",
      "B16 {\n  if (i13 \u003e\u003d 10000) goto B17 else B18\n}",
      "B17 {\n  i16 \u003d 4\n  goto B19\n}",
      "B18 {\n  $d0 \u003d (double) i13\n  $d2 \u003d Math.log($d0)\n  $d1 \u003d FormatUtils: double LOG_10\u003e\n  $d3 \u003d $d2 / $d1\n  $i0 \u003d (int) $d3\n  i16 \u003d $i0 + 1\n}",
      "B19 {\n  if (i14 \u003c\u003d i16) goto B20 else B21\n}",
      "B20 {\n  r0.append(48)\n  $i24 \u003d (int) -1\n  i14 \u003d i14 + $i24\n  goto B19\n}",
      "B21 {\n  $r1 \u003d Integer.toString(i13)\n  r0.append($r1)\n}",
      "B22 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B22",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B22",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B19",
      "B21 --\u003e B22",
      "B22 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendPaddedInteger",
    "signature": "void appendPaddedInteger(java.lang.StringBuffer,long,int)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        appendPaddedInteger((Appendable) buf, value, size);\r\n    } catch (IOException e) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  StringBuffer\n  l0 :\u003d @parameter1: long\n  i1 :\u003d @parameter2: int\n  FormatUtils.appendPaddedInteger(r0, l0, i1)\n  goto B2\n}",
      "B1 {\n  $r1 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendPaddedInteger(...3)",
        "body": "{\r\n    try {\r\n        appendPaddedInteger((Appendable) buf, value, size);\r\n    } catch (IOException e) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendPaddedInteger",
    "signature": "void appendPaddedInteger(java.lang.Appendable,long,int)",
    "visibility": "public",
    "body": "{\r\n    int intValue \u003d (int) value;\r\n    if (intValue \u003d\u003d value) {\r\n        appendPaddedInteger(appendable, intValue, size);\r\n    } else if (size \u003c\u003d 19) {\r\n        appendable.append(Long.toString(value));\r\n    } else {\r\n        if (value \u003c 0) {\r\n            appendable.append(\u0027-\u0027);\r\n            if (value !\u003d Long.MIN_VALUE) {\r\n                value \u003d -value;\r\n            } else {\r\n                for (; size \u003e 19; size--) {\r\n                    appendable.append(\u00270\u0027);\r\n                }\r\n                appendable.append(\"9223372036854775808\");\r\n                return;\r\n            }\r\n        }\r\n        int digits \u003d (int) (Math.log(value) / LOG_10) + 1;\r\n        for (; size \u003e digits; size--) {\r\n            appendable.append(\u00270\u0027);\r\n        }\r\n        appendable.append(Long.toString(value));\r\n    }\r\n}",
    "nodes": 15,
    "edges": 19,
    "cc": 6,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2",
      "B2 : If(i8 \u003e 19) → B3 | else → B4",
      "B4 : If($i9 \u003e\u003d 0) → B5 | else → B10",
      "B5 : If($b5 \u003d\u003d false) → B6 | else → B7",
      "B7 : If(i8 \u003c\u003d 19) → B8 | else → B9",
      "B11 : If(i8 \u003c\u003d $i6) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Appendable\n  l7 :\u003d @parameter1: long\n  i8 :\u003d @parameter2: int\n  i0 \u003d (int) l7\n  $l1 \u003d (long) i0\n  $b2 \u003d $l1 cmp l7\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  FormatUtils.appendPaddedInteger(r0, i0, i8)\n  goto B14\n}",
      "B2 {\n  if (i8 \u003e 19) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d Long.toString(l7)\n  r0.append($r2)\n  goto B14\n}",
      "B4 {\n  $b3 \u003d l7 cmp 0L\n  $i9 \u003d (int) $b3\n  if ($i9 \u003e\u003d 0) goto B5 else B10\n}",
      "B5 {\n  r0.append(45)\n  $b5 \u003d l7 cmp -9223372036854775808L\n  if ($b5 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  l7 \u003d neg l7\n  goto B10\n}",
      "B7 {\n  if (i8 \u003c\u003d 19) goto B8 else B9\n}",
      "B8 {\n  r0.append(48)\n  $i11 \u003d (int) -1\n  i8 \u003d i8 + $i11\n  goto B7\n}",
      "B9 {\n  r0.append(\"9223372036854775808\")\n  return\n}",
      "B10 {\n  $d0 \u003d (double) l7\n  $d2 \u003d Math.log($d0)\n  $d1 \u003d FormatUtils: double LOG_10\u003e\n  $d3 \u003d $d2 / $d1\n  $i4 \u003d (int) $d3\n  $i6 \u003d $i4 + 1\n}",
      "B11 {\n  if (i8 \u003c\u003d $i6) goto B12 else B13\n}",
      "B12 {\n  r0.append(48)\n  $i13 \u003d (int) -1\n  i8 \u003d i8 + $i13\n  goto B11\n}",
      "B13 {\n  $r1 \u003d Long.toString(l7)\n  r0.append($r1)\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B14",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B14",
      "B4 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendPaddedInteger(...3)",
        "body": "{\r\n    try {\r\n        appendPaddedInteger((Appendable) buf, value, size);\r\n    } catch (IOException e) {\r\n        // StringBuffer does not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "writePaddedInteger",
    "signature": "void writePaddedInteger(java.io.Writer,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003c 0) {\r\n        out.write(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            for (; size \u003e 10; size--) {\r\n                out.write(\u00270\u0027);\r\n            }\r\n            out.write(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        for (; size \u003e 1; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        out.write(value + \u00270\u0027);\r\n    } else if (value \u003c 100) {\r\n        for (; size \u003e 2; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        out.write(d + \u00270\u0027);\r\n        // Append remainder by calculating (value - d * 10).\r\n        out.write(value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027);\r\n    } else {\r\n        int digits;\r\n        if (value \u003c 1000) {\r\n            digits \u003d 3;\r\n        } else if (value \u003c 10000) {\r\n            digits \u003d 4;\r\n        } else {\r\n            digits \u003d (int) (Math.log(value) / LOG_10) + 1;\r\n        }\r\n        for (; size \u003e digits; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        out.write(Integer.toString(value));\r\n    }\r\n}",
    "nodes": 23,
    "edges": 31,
    "cc": 10,
    "flowSummary": [
      "B0 : If(i10 \u003e\u003d 0) → B1 | else → B6",
      "B1 : If(i10 \u003d\u003d -2147483648) → B2 | else → B3",
      "B3 : If(i11 \u003c\u003d 10) → B4 | else → B5",
      "B6 : If(i10 \u003e\u003d 10) → B7 | else → B10",
      "B7 : If(i11 \u003c\u003d 1) → B8 | else → B9",
      "B10 : If(i10 \u003e\u003d 100) → B11 | else → B14",
      "B11 : If(i11 \u003c\u003d 2) → B12 | else → B13",
      "B14 : If(i10 \u003e\u003d 1000) → B15 | else → B16",
      "B16 : If(i10 \u003e\u003d 10000) → B17 | else → B18",
      "B19 : If(i11 \u003c\u003d i13) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  Writer\n  i10 :\u003d @parameter1: int\n  i11 :\u003d @parameter2: int\n  if (i10 \u003e\u003d 0) goto B1 else B6\n}",
      "B1 {\n  r0.write(45)\n  if (i10 \u003d\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  i10 \u003d neg i10\n  goto B6\n}",
      "B3 {\n  if (i11 \u003c\u003d 10) goto B4 else B5\n}",
      "B4 {\n  r0.write(48)\n  $i15 \u003d (int) -1\n  i11 \u003d i11 + $i15\n  goto B3\n}",
      "B5 {\n  r0.write(\"2147483648\")\n  return\n}",
      "B6 {\n  if (i10 \u003e\u003d 10) goto B7 else B10\n}",
      "B7 {\n  if (i11 \u003c\u003d 1) goto B8 else B9\n}",
      "B8 {\n  r0.write(48)\n  $i17 \u003d (int) -1\n  i11 \u003d i11 + $i17\n  goto B7\n}",
      "B9 {\n  $i9 \u003d i10 + 48\n  r0.write($i9)\n  goto B22\n}",
      "B10 {\n  if (i10 \u003e\u003d 100) goto B11 else B14\n}",
      "B11 {\n  if (i11 \u003c\u003d 2) goto B12 else B13\n}",
      "B12 {\n  r0.write(48)\n  $i19 \u003d (int) -1\n  i11 \u003d i11 + $i19\n  goto B11\n}",
      "B13 {\n  $i1 \u003d i10 + 1\n  $i2 \u003d $i1 * 13421772\n  i12 \u003d $i2 \u003e\u003e 27\n  $i3 \u003d i12 + 48\n  r0.write($i3)\n  $i4 \u003d i12 \u003c\u003c 3\n  $i6 \u003d i10 - $i4\n  $i5 \u003d i12 \u003c\u003c 1\n  $i7 \u003d $i6 - $i5\n  $i8 \u003d $i7 + 48\n  r0.write($i8)\n  goto B22\n}",
      "B14 {\n  if (i10 \u003e\u003d 1000) goto B15 else B16\n}",
      "B15 {\n  i13 \u003d 3\n  goto B19\n}",
      "B16 {\n  if (i10 \u003e\u003d 10000) goto B17 else B18\n}",
      "B17 {\n  i13 \u003d 4\n  goto B19\n}",
      "B18 {\n  $d0 \u003d (double) i10\n  $d2 \u003d Math.log($d0)\n  $d1 \u003d FormatUtils: double LOG_10\u003e\n  $d3 \u003d $d2 / $d1\n  $i0 \u003d (int) $d3\n  i13 \u003d $i0 + 1\n}",
      "B19 {\n  if (i11 \u003c\u003d i13) goto B20 else B21\n}",
      "B20 {\n  r0.write(48)\n  $i21 \u003d (int) -1\n  i11 \u003d i11 + $i21\n  goto B19\n}",
      "B21 {\n  $r1 \u003d Integer.toString(i10)\n  r0.write($r1)\n}",
      "B22 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B22",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B22",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B19",
      "B21 --\u003e B22",
      "B22 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "writePaddedInteger",
    "signature": "void writePaddedInteger(java.io.Writer,long,int)",
    "visibility": "public",
    "body": "{\r\n    int intValue \u003d (int) value;\r\n    if (intValue \u003d\u003d value) {\r\n        writePaddedInteger(out, intValue, size);\r\n    } else if (size \u003c\u003d 19) {\r\n        out.write(Long.toString(value));\r\n    } else {\r\n        if (value \u003c 0) {\r\n            out.write(\u0027-\u0027);\r\n            if (value !\u003d Long.MIN_VALUE) {\r\n                value \u003d -value;\r\n            } else {\r\n                for (; size \u003e 19; size--) {\r\n                    out.write(\u00270\u0027);\r\n                }\r\n                out.write(\"9223372036854775808\");\r\n                return;\r\n            }\r\n        }\r\n        int digits \u003d (int) (Math.log(value) / LOG_10) + 1;\r\n        for (; size \u003e digits; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        out.write(Long.toString(value));\r\n    }\r\n}",
    "nodes": 15,
    "edges": 19,
    "cc": 6,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2",
      "B2 : If(i8 \u003e 19) → B3 | else → B4",
      "B4 : If($i9 \u003e\u003d 0) → B5 | else → B10",
      "B5 : If($b5 \u003d\u003d false) → B6 | else → B7",
      "B7 : If(i8 \u003c\u003d 19) → B8 | else → B9",
      "B11 : If(i8 \u003c\u003d $i6) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Writer\n  l7 :\u003d @parameter1: long\n  i8 :\u003d @parameter2: int\n  i0 \u003d (int) l7\n  $l1 \u003d (long) i0\n  $b2 \u003d $l1 cmp l7\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  FormatUtils.writePaddedInteger(r0, i0, i8)\n  goto B14\n}",
      "B2 {\n  if (i8 \u003e 19) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d Long.toString(l7)\n  r0.write($r2)\n  goto B14\n}",
      "B4 {\n  $b3 \u003d l7 cmp 0L\n  $i9 \u003d (int) $b3\n  if ($i9 \u003e\u003d 0) goto B5 else B10\n}",
      "B5 {\n  r0.write(45)\n  $b5 \u003d l7 cmp -9223372036854775808L\n  if ($b5 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  l7 \u003d neg l7\n  goto B10\n}",
      "B7 {\n  if (i8 \u003c\u003d 19) goto B8 else B9\n}",
      "B8 {\n  r0.write(48)\n  $i11 \u003d (int) -1\n  i8 \u003d i8 + $i11\n  goto B7\n}",
      "B9 {\n  r0.write(\"9223372036854775808\")\n  return\n}",
      "B10 {\n  $d0 \u003d (double) l7\n  $d2 \u003d Math.log($d0)\n  $d1 \u003d FormatUtils: double LOG_10\u003e\n  $d3 \u003d $d2 / $d1\n  $i4 \u003d (int) $d3\n  $i6 \u003d $i4 + 1\n}",
      "B11 {\n  if (i8 \u003c\u003d $i6) goto B12 else B13\n}",
      "B12 {\n  r0.write(48)\n  $i13 \u003d (int) -1\n  i8 \u003d i8 + $i13\n  goto B11\n}",
      "B13 {\n  $r1 \u003d Long.toString(l7)\n  r0.write($r1)\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B14",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B14",
      "B4 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#writePaddedInteger(...3)",
        "body": "{\r\n    if (value \u003c 0) {\r\n        out.write(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            for (; size \u003e 10; size--) {\r\n                out.write(\u00270\u0027);\r\n            }\r\n            out.write(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        for (; size \u003e 1; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        out.write(value + \u00270\u0027);\r\n    } else if (value \u003c 100) {\r\n        for (; size \u003e 2; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        out.write(d + \u00270\u0027);\r\n        // Append remainder by calculating (value - d * 10).\r\n        out.write(value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027);\r\n    } else {\r\n        int digits;\r\n        if (value \u003c 1000) {\r\n            digits \u003d 3;\r\n        } else if (value \u003c 10000) {\r\n            digits \u003d 4;\r\n        } else {\r\n            digits \u003d (int) (Math.log(value) / LOG_10) + 1;\r\n        }\r\n        for (; size \u003e digits; size--) {\r\n            out.write(\u00270\u0027);\r\n        }\r\n        out.write(Integer.toString(value));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendUnpaddedInteger",
    "signature": "void appendUnpaddedInteger(java.lang.StringBuffer,int)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        appendUnpaddedInteger((Appendable) buf, value);\r\n    } catch (IOException e) {\r\n        // StringBuffer do not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  StringBuffer\n  i0 :\u003d @parameter1: int\n  FormatUtils.appendUnpaddedInteger(r0, i0)\n  goto B2\n}",
      "B1 {\n  $r1 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendUnpaddedInteger(...2)",
        "body": "{\r\n    try {\r\n        appendUnpaddedInteger((Appendable) buf, value);\r\n    } catch (IOException e) {\r\n        // StringBuffer do not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendUnpaddedInteger",
    "signature": "void appendUnpaddedInteger(java.lang.Appendable,int)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003c 0) {\r\n        appendable.append(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            appendable.append(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        appendable.append((char) (value + \u00270\u0027));\r\n    } else if (value \u003c 100) {\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        appendable.append((char) (d + \u00270\u0027));\r\n        // Append remainder by calculating (value - d * 10).\r\n        appendable.append((char) (value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027));\r\n    } else {\r\n        appendable.append(Integer.toString(value));\r\n    }\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i13 \u003e\u003d 0) → B1 | else → B4",
      "B1 : If(i13 \u003d\u003d -2147483648) → B2 | else → B3",
      "B4 : If(i13 \u003e\u003d 10) → B5 | else → B6",
      "B6 : If(i13 \u003e\u003d 100) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  Appendable\n  i13 :\u003d @parameter1: int\n  if (i13 \u003e\u003d 0) goto B1 else B4\n}",
      "B1 {\n  r0.append(45)\n  if (i13 \u003d\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  i13 \u003d neg i13\n  goto B4\n}",
      "B3 {\n  r0.append(\"2147483648\")\n  return\n}",
      "B4 {\n  if (i13 \u003e\u003d 10) goto B5 else B6\n}",
      "B5 {\n  $i11 \u003d i13 + 48\n  $c12 \u003d (char) $i11\n  r0.append($c12)\n  goto B9\n}",
      "B6 {\n  if (i13 \u003e\u003d 100) goto B7 else B8\n}",
      "B7 {\n  $i0 \u003d i13 + 1\n  $i1 \u003d $i0 * 13421772\n  i2 \u003d $i1 \u003e\u003e 27\n  $i3 \u003d i2 + 48\n  $c4 \u003d (char) $i3\n  r0.append($c4)\n  $i5 \u003d i2 \u003c\u003c 3\n  $i7 \u003d i13 - $i5\n  $i6 \u003d i2 \u003c\u003c 1\n  $i8 \u003d $i7 - $i6\n  $i9 \u003d $i8 + 48\n  $c10 \u003d (char) $i9\n  r0.append($c10)\n  goto B9\n}",
      "B8 {\n  $r1 \u003d Integer.toString(i13)\n  r0.append($r1)\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendUnpaddedInteger",
    "signature": "void appendUnpaddedInteger(java.lang.StringBuffer,long)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        appendUnpaddedInteger((Appendable) buf, value);\r\n    } catch (IOException e) {\r\n        // StringBuffer do not throw IOException\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  StringBuffer\n  l0 :\u003d @parameter1: long\n  FormatUtils.appendUnpaddedInteger(r0, l0)\n  goto B2\n}",
      "B1 {\n  $r1 :\u003d @caughtexception\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendUnpaddedInteger(...2)",
        "body": "{\r\n    try {\r\n        appendUnpaddedInteger((Appendable) buf, value);\r\n    } catch (IOException e) {\r\n        // StringBuffer do not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "appendUnpaddedInteger",
    "signature": "void appendUnpaddedInteger(java.lang.Appendable,long)",
    "visibility": "public",
    "body": "{\r\n    int intValue \u003d (int) value;\r\n    if (intValue \u003d\u003d value) {\r\n        appendUnpaddedInteger(appendable, intValue);\r\n    } else {\r\n        appendable.append(Long.toString(value));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b3 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Appendable\n  l0 :\u003d @parameter1: long\n  i1 \u003d (int) l0\n  $l2 \u003d (long) i1\n  $b3 \u003d $l2 cmp l0\n  if ($b3 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  FormatUtils.appendUnpaddedInteger(r0, i1)\n  goto B3\n}",
      "B2 {\n  $r1 \u003d Long.toString(l0)\n  r0.append($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#appendUnpaddedInteger(...2)",
        "body": "{\r\n    try {\r\n        appendUnpaddedInteger((Appendable) buf, value);\r\n    } catch (IOException e) {\r\n        // StringBuffer do not throw IOException\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "writeUnpaddedInteger",
    "signature": "void writeUnpaddedInteger(java.io.Writer,int)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003c 0) {\r\n        out.write(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            out.write(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        out.write(value + \u00270\u0027);\r\n    } else if (value \u003c 100) {\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        out.write(d + \u00270\u0027);\r\n        // Append remainder by calculating (value - d * 10).\r\n        out.write(value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027);\r\n    } else {\r\n        out.write(Integer.toString(value));\r\n    }\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i10 \u003e\u003d 0) → B1 | else → B4",
      "B1 : If(i10 \u003d\u003d -2147483648) → B2 | else → B3",
      "B4 : If(i10 \u003e\u003d 10) → B5 | else → B6",
      "B6 : If(i10 \u003e\u003d 100) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  Writer\n  i10 :\u003d @parameter1: int\n  if (i10 \u003e\u003d 0) goto B1 else B4\n}",
      "B1 {\n  r0.write(45)\n  if (i10 \u003d\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  i10 \u003d neg i10\n  goto B4\n}",
      "B3 {\n  r0.write(\"2147483648\")\n  return\n}",
      "B4 {\n  if (i10 \u003e\u003d 10) goto B5 else B6\n}",
      "B5 {\n  $i9 \u003d i10 + 48\n  r0.write($i9)\n  goto B9\n}",
      "B6 {\n  if (i10 \u003e\u003d 100) goto B7 else B8\n}",
      "B7 {\n  $i0 \u003d i10 + 1\n  $i1 \u003d $i0 * 13421772\n  i2 \u003d $i1 \u003e\u003e 27\n  $i3 \u003d i2 + 48\n  r0.write($i3)\n  $i4 \u003d i2 \u003c\u003c 3\n  $i6 \u003d i10 - $i4\n  $i5 \u003d i2 \u003c\u003c 1\n  $i7 \u003d $i6 - $i5\n  $i8 \u003d $i7 + 48\n  r0.write($i8)\n  goto B9\n}",
      "B8 {\n  $r1 \u003d Integer.toString(i10)\n  r0.write($r1)\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "writeUnpaddedInteger",
    "signature": "void writeUnpaddedInteger(java.io.Writer,long)",
    "visibility": "public",
    "body": "{\r\n    int intValue \u003d (int) value;\r\n    if (intValue \u003d\u003d value) {\r\n        writeUnpaddedInteger(out, intValue);\r\n    } else {\r\n        out.write(Long.toString(value));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b3 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Writer\n  l0 :\u003d @parameter1: long\n  i1 \u003d (int) l0\n  $l2 \u003d (long) i1\n  $b3 \u003d $l2 cmp l0\n  if ($b3 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  FormatUtils.writeUnpaddedInteger(r0, i1)\n  goto B3\n}",
      "B2 {\n  $r1 \u003d Long.toString(l0)\n  r0.write($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#writeUnpaddedInteger(...2)",
        "body": "{\r\n    if (value \u003c 0) {\r\n        out.write(\u0027-\u0027);\r\n        if (value !\u003d Integer.MIN_VALUE) {\r\n            value \u003d -value;\r\n        } else {\r\n            out.write(\"\" + -(long) Integer.MIN_VALUE);\r\n            return;\r\n        }\r\n    }\r\n    if (value \u003c 10) {\r\n        out.write(value + \u00270\u0027);\r\n    } else if (value \u003c 100) {\r\n        // Calculate value div/mod by 10 without using two expensive\r\n        // division operations. (2 ^ 27) / 10 \u003d 13421772. Add one to\r\n        // value to correct rounding error.\r\n        int d \u003d ((value + 1) * 13421772) \u003e\u003e 27;\r\n        out.write(d + \u00270\u0027);\r\n        // Append remainder by calculating (value - d * 10).\r\n        out.write(value - (d \u003c\u003c 3) - (d \u003c\u003c 1) + \u00270\u0027);\r\n    } else {\r\n        out.write(Integer.toString(value));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.FormatUtils",
    "methodName": "calculateDigitCount",
    "signature": "int calculateDigitCount(long)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003c 0) {\r\n        if (value !\u003d Long.MIN_VALUE) {\r\n            return calculateDigitCount(-value) + 1;\r\n        } else {\r\n            return 20;\r\n        }\r\n    }\r\n    return (value \u003c 10 ? 1 : (value \u003c 100 ? 2 : (value \u003c 1000 ? 3 : (value \u003c 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1)))));\r\n}",
    "nodes": 14,
    "edges": 17,
    "cc": 5,
    "flowSummary": [
      "B0 : If($i12 \u003e\u003d 0) → B1 | else → B4",
      "B1 : If($b7 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($i13 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i14 \u003e\u003d 0) → B7 | else → B8",
      "B8 : If($i15 \u003e\u003d 0) → B9 | else → B10",
      "B10 : If($i16 \u003e\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i12 \u003d (int) $b1\n  if ($i12 \u003e\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $b7 \u003d l0 cmp -9223372036854775808L\n  if ($b7 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $l8 \u003d neg l0\n  $i9 \u003d FormatUtils.calculateDigitCount($l8)\n  $i10 \u003d $i9 + 1\n  return\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $b2 \u003d l0 cmp 10L\n  $i13 \u003d (int) $b2\n  if ($i13 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i11 \u003d 1\n  goto B13\n}",
      "B6 {\n  $b3 \u003d l0 cmp 100L\n  $i14 \u003d (int) $b3\n  if ($i14 \u003e\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $i11 \u003d 2\n  goto B13\n}",
      "B8 {\n  $b4 \u003d l0 cmp 1000L\n  $i15 \u003d (int) $b4\n  if ($i15 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $i11 \u003d 3\n  goto B13\n}",
      "B10 {\n  $b5 \u003d l0 cmp 10000L\n  $i16 \u003d (int) $b5\n  if ($i16 \u003e\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $i11 \u003d 4\n  goto B13\n}",
      "B12 {\n  $d0 \u003d (double) l0\n  $d2 \u003d Math.log($d0)\n  $d1 \u003d FormatUtils: double LOG_10\u003e\n  $d3 \u003d $d2 / $d1\n  $i6 \u003d (int) $d3\n  $i11 \u003d $i6 + 1\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B13",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FormatUtils#calculateDigitCount(...1)",
        "body": "{\r\n    if (value \u003c 0) {\r\n        if (value !\u003d Long.MIN_VALUE) {\r\n            return calculateDigitCount(-value) + 1;\r\n        } else {\r\n            return 20;\r\n        }\r\n    }\r\n    return (value \u003c 10 ? 1 : (value \u003c 100 ? 2 : (value \u003c 1000 ? 3 : (value \u003c 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1)))));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.ISODateTimeFormat",
    "methodName": "forFields",
    "signature": "org.joda.time.format.DateTimeFormatter forFields(java.util.Collection,boolean,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (fields \u003d\u003d null || fields.size() \u003d\u003d 0) {\r\n        throw new IllegalArgumentException(\"The fields must not be null or empty\");\r\n    }\r\n    Set\u003cDateTimeFieldType\u003e workingFields \u003d new HashSet\u003cDateTimeFieldType\u003e(fields);\r\n    int inputSize \u003d workingFields.size();\r\n    boolean reducedPrec \u003d false;\r\n    DateTimeFormatterBuilder bld \u003d new DateTimeFormatterBuilder();\r\n    // date\r\n    if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\r\n        reducedPrec \u003d dateByMonth(bld, workingFields, extended, strictISO);\r\n    } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\r\n        reducedPrec \u003d dateByOrdinal(bld, workingFields, extended, strictISO);\r\n    } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\r\n        reducedPrec \u003d dateByWeek(bld, workingFields, extended, strictISO);\r\n    } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\r\n        reducedPrec \u003d dateByMonth(bld, workingFields, extended, strictISO);\r\n    } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\r\n        reducedPrec \u003d dateByWeek(bld, workingFields, extended, strictISO);\r\n    } else if (workingFields.remove(DateTimeFieldType.year())) {\r\n        bld.append(Constants.ye);\r\n        reducedPrec \u003d true;\r\n    } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\r\n        bld.append(Constants.we);\r\n        reducedPrec \u003d true;\r\n    }\r\n    boolean datePresent \u003d (workingFields.size() \u003c inputSize);\r\n    // time\r\n    time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\r\n    // result\r\n    if (bld.canBuildFormatter() \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"No valid format for fields: \" + fields);\r\n    }\r\n    // side effect the input collection to indicate the processed fields\r\n    // handling unmodifiable collections with no side effect\r\n    try {\r\n        fields.retainAll(workingFields);\r\n    } catch (UnsupportedOperationException ex) {\r\n        // ignore, so we can handle unmodifiable collections\r\n    }\r\n    return bld.toFormatter();\r\n}",
    "nodes": 25,
    "edges": 33,
    "cc": 10,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11",
      "B11 : If($z4 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z5 \u003d\u003d false) → B14 | else → B15",
      "B15 : If($z6 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($i2 \u003e\u003d i1) → B18 | else → B19",
      "B20 : If($z9 !\u003d 0) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  Collection\n  z7 :\u003d @parameter1: boolean\n  z8 :\u003d @parameter2: boolean\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d r0.size()\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The fields must not be null or empty\")\n  throw $r1\n}",
      "B3 {\n  $r2 \u003d HashSet\n  new HashSet(r0)\n  i1 \u003d $r2.size()\n  z10 \u003d 0\n  $r3 \u003d DateTimeFormatterBuilder\n  new DateTimeFormatterBuilder()\n  $r4 \u003d DateTimeFieldType.monthOfYear()\n  $z0 \u003d $r2.contains($r4)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  z10 \u003d ISODateTimeFormat.dateByMonth($r3, $r2, z7, z8)\n  goto B17\n}",
      "B5 {\n  $r5 \u003d DateTimeFieldType.dayOfYear()\n  $z1 \u003d $r2.contains($r5)\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  z10 \u003d ISODateTimeFormat.dateByOrdinal($r3, $r2, z7, z8)\n  goto B17\n}",
      "B7 {\n  $r6 \u003d DateTimeFieldType.weekOfWeekyear()\n  $z2 \u003d $r2.contains($r6)\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  z10 \u003d ISODateTimeFormat.dateByWeek($r3, $r2, z7, z8)\n  goto B17\n}",
      "B9 {\n  $r7 \u003d DateTimeFieldType.dayOfMonth()\n  $z3 \u003d $r2.contains($r7)\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  z10 \u003d ISODateTimeFormat.dateByMonth($r3, $r2, z7, z8)\n  goto B17\n}",
      "B11 {\n  $r8 \u003d DateTimeFieldType.dayOfWeek()\n  $z4 \u003d $r2.contains($r8)\n  if ($z4 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  z10 \u003d ISODateTimeFormat.dateByWeek($r3, $r2, z7, z8)\n  goto B17\n}",
      "B13 {\n  $r9 \u003d DateTimeFieldType.year()\n  $z5 \u003d $r2.remove($r9)\n  if ($z5 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r16 \u003d DateTimeFormatter ye\u003e\n  $r3.append($r16)\n  z10 \u003d 1\n  goto B17\n}",
      "B15 {\n  $r10 \u003d DateTimeFieldType.weekyear()\n  $z6 \u003d $r2.remove($r10)\n  if ($z6 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r15 \u003d DateTimeFormatter we\u003e\n  $r3.append($r15)\n  z10 \u003d 1\n}",
      "B17 {\n  $i2 \u003d $r2.size()\n  if ($i2 \u003e\u003d i1) goto B18 else B19\n}",
      "B18 {\n  $z11 \u003d 1\n  goto B20\n}",
      "B19 {\n  $z11 \u003d 0\n}",
      "B20 {\n  ISODateTimeFormat.time($r3, $r2, z7, z8, z10, $z11)\n  $z9 \u003d $r3.canBuildFormatter()\n  if ($z9 !\u003d 0) goto B21 else B22\n}",
      "B21 {\n  $r12 \u003d IllegalArgumentException\n  $r13 \u003d String.valueOf(r0)\n  $r14 \u003d dynInvoke makeConcatWithConstants($r13)\n  new IllegalArgumentException($r14)\n  throw $r12\n}",
      "B22 {\n  r0.retainAll($r2)\n  goto B24\n}",
      "B23 {\n  $r17 :\u003d @caughtexception\n}",
      "B24 {\n  $r11 \u003d $r3.toFormatter()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B17",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B17",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B17",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISODateTimeFormat#dateByMonth(...4)",
        "body": "{\r\n    boolean reducedPrec \u003d false;\r\n    if (fields.remove(DateTimeFieldType.year())) {\r\n        bld.append(Constants.ye);\r\n        if (fields.remove(DateTimeFieldType.monthOfYear())) {\r\n            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\r\n                // YYYY-MM-DD/YYYYMMDD\r\n                appendSeparator(bld, extended);\r\n                bld.appendMonthOfYear(2);\r\n                appendSeparator(bld, extended);\r\n                bld.appendDayOfMonth(2);\r\n            } else {\r\n                // YYYY-MM/YYYY-MM\r\n                bld.appendLiteral(\u0027-\u0027);\r\n                bld.appendMonthOfYear(2);\r\n                reducedPrec \u003d true;\r\n            }\r\n        } else {\r\n            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\r\n                // YYYY--DD/YYYY--DD (non-iso)\r\n                checkNotStrictISO(fields, strictISO);\r\n                bld.appendLiteral(\u0027-\u0027);\r\n                bld.appendLiteral(\u0027-\u0027);\r\n                bld.appendDayOfMonth(2);\r\n            } else {\r\n                // YYYY/YYYY\r\n                reducedPrec \u003d true;\r\n            }\r\n        }\r\n    } else if (fields.remove(DateTimeFieldType.monthOfYear())) {\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendMonthOfYear(2);\r\n        if (fields.remove(DateTimeFieldType.dayOfMonth())) {\r\n            // --MM-DD/--MMDD\r\n            appendSeparator(bld, extended);\r\n            bld.appendDayOfMonth(2);\r\n        } else {\r\n            // --MM/--MM\r\n            reducedPrec \u003d true;\r\n        }\r\n    } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {\r\n        // ---DD/---DD\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendDayOfMonth(2);\r\n    }\r\n    return reducedPrec;\r\n}"
      },
      {
        "name": "ISODateTimeFormat#dateByOrdinal(...4)",
        "body": "{\r\n    boolean reducedPrec \u003d false;\r\n    if (fields.remove(DateTimeFieldType.year())) {\r\n        bld.append(Constants.ye);\r\n        if (fields.remove(DateTimeFieldType.dayOfYear())) {\r\n            // YYYY-DDD/YYYYDDD\r\n            appendSeparator(bld, extended);\r\n            bld.appendDayOfYear(3);\r\n        } else {\r\n            // YYYY/YYYY\r\n            reducedPrec \u003d true;\r\n        }\r\n    } else if (fields.remove(DateTimeFieldType.dayOfYear())) {\r\n        // -DDD/-DDD\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendDayOfYear(3);\r\n    }\r\n    return reducedPrec;\r\n}"
      },
      {
        "name": "ISODateTimeFormat#dateByWeek(...4)",
        "body": "{\r\n    boolean reducedPrec \u003d false;\r\n    if (fields.remove(DateTimeFieldType.weekyear())) {\r\n        bld.append(Constants.we);\r\n        if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\r\n            appendSeparator(bld, extended);\r\n            bld.appendLiteral(\u0027W\u0027);\r\n            bld.appendWeekOfWeekyear(2);\r\n            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\r\n                // YYYY-WWW-D/YYYYWWWD\r\n                appendSeparator(bld, extended);\r\n                bld.appendDayOfWeek(1);\r\n            } else {\r\n                // YYYY-WWW/YYYY-WWW\r\n                reducedPrec \u003d true;\r\n            }\r\n        } else {\r\n            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\r\n                // YYYY-W-D/YYYYW-D (non-iso)\r\n                checkNotStrictISO(fields, strictISO);\r\n                appendSeparator(bld, extended);\r\n                bld.appendLiteral(\u0027W\u0027);\r\n                bld.appendLiteral(\u0027-\u0027);\r\n                bld.appendDayOfWeek(1);\r\n            } else {\r\n                // YYYY/YYYY\r\n                reducedPrec \u003d true;\r\n            }\r\n        }\r\n    } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendLiteral(\u0027W\u0027);\r\n        bld.appendWeekOfWeekyear(2);\r\n        if (fields.remove(DateTimeFieldType.dayOfWeek())) {\r\n            // -WWW-D/-WWWD\r\n            appendSeparator(bld, extended);\r\n            bld.appendDayOfWeek(1);\r\n        } else {\r\n            // -WWW/-WWW\r\n            reducedPrec \u003d true;\r\n        }\r\n    } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {\r\n        // -W-D/-W-D\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendLiteral(\u0027W\u0027);\r\n        bld.appendLiteral(\u0027-\u0027);\r\n        bld.appendDayOfWeek(1);\r\n    }\r\n    return reducedPrec;\r\n}"
      },
      {
        "name": "ISODateTimeFormat#time(...6)",
        "body": "{\r\n    boolean hour \u003d fields.remove(DateTimeFieldType.hourOfDay());\r\n    boolean minute \u003d fields.remove(DateTimeFieldType.minuteOfHour());\r\n    boolean second \u003d fields.remove(DateTimeFieldType.secondOfMinute());\r\n    boolean milli \u003d fields.remove(DateTimeFieldType.millisOfSecond());\r\n    if (!hour \u0026\u0026 !minute \u0026\u0026 !second \u0026\u0026 !milli) {\r\n        return;\r\n    }\r\n    if (hour || minute || second || milli) {\r\n        if (strictISO \u0026\u0026 reducedPrec) {\r\n            throw new IllegalArgumentException(\"No valid ISO8601 format for fields because Date was reduced precision: \" + fields);\r\n        }\r\n        if (datePresent) {\r\n            bld.appendLiteral(\u0027T\u0027);\r\n        }\r\n    }\r\n    if (hour \u0026\u0026 minute \u0026\u0026 second || (hour \u0026\u0026 !second \u0026\u0026 !milli)) {\r\n        // OK - HMSm/HMS/HM/H - valid in combination with date\r\n    } else {\r\n        if (strictISO \u0026\u0026 datePresent) {\r\n            throw new IllegalArgumentException(\"No valid ISO8601 format for fields because Time was truncated: \" + fields);\r\n        }\r\n        if (!hour \u0026\u0026 (minute \u0026\u0026 second || (minute \u0026\u0026 !milli) || second)) {\r\n            // OK - MSm/MS/M/Sm/S - valid ISO formats\r\n        } else {\r\n            if (strictISO) {\r\n                throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\r\n            }\r\n        }\r\n    }\r\n    if (hour) {\r\n        bld.appendHourOfDay(2);\r\n    } else if (minute || second || milli) {\r\n        bld.appendLiteral(\u0027-\u0027);\r\n    }\r\n    if (extended \u0026\u0026 hour \u0026\u0026 minute) {\r\n        bld.appendLiteral(\u0027:\u0027);\r\n    }\r\n    if (minute) {\r\n        bld.appendMinuteOfHour(2);\r\n    } else if (second || milli) {\r\n        bld.appendLiteral(\u0027-\u0027);\r\n    }\r\n    if (extended \u0026\u0026 minute \u0026\u0026 second) {\r\n        bld.appendLiteral(\u0027:\u0027);\r\n    }\r\n    if (second) {\r\n        bld.appendSecondOfMinute(2);\r\n    } else if (milli) {\r\n        bld.appendLiteral(\u0027-\u0027);\r\n    }\r\n    if (milli) {\r\n        bld.appendLiteral(\u0027.\u0027);\r\n        bld.appendMillisOfSecond(3);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.ISOPeriodFormat",
    "methodName": "standard",
    "signature": "org.joda.time.format.PeriodFormatter standard()",
    "visibility": "public",
    "body": "{\r\n    if (cStandard \u003d\u003d null) {\r\n        cStandard \u003d new PeriodFormatterBuilder().appendLiteral(\"P\").appendYears().appendSuffix(\"Y\").appendMonths().appendSuffix(\"M\").appendWeeks().appendSuffix(\"W\").appendDays().appendSuffix(\"D\").appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSuffix(\"H\").appendMinutes().appendSuffix(\"M\").appendSecondsWithOptionalMillis().appendSuffix(\"S\").toFormatter();\r\n    }\r\n    return cStandard;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d PeriodFormatter cStandard\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d PeriodFormatterBuilder\n  new PeriodFormatterBuilder()\n  $r3 \u003d $r2.appendLiteral(\"P\")\n  $r4 \u003d $r3.appendYears()\n  $r5 \u003d $r4.appendSuffix(\"Y\")\n  $r6 \u003d $r5.appendMonths()\n  $r7 \u003d $r6.appendSuffix(\"M\")\n  $r8 \u003d $r7.appendWeeks()\n  $r9 \u003d $r8.appendSuffix(\"W\")\n  $r10 \u003d $r9.appendDays()\n  $r11 \u003d $r10.appendSuffix(\"D\")\n  $r12 \u003d $r11.appendSeparatorIfFieldsAfter(\"T\")\n  $r13 \u003d $r12.appendHours()\n  $r14 \u003d $r13.appendSuffix(\"H\")\n  $r15 \u003d $r14.appendMinutes()\n  $r16 \u003d $r15.appendSuffix(\"M\")\n  $r17 \u003d $r16.appendSecondsWithOptionalMillis()\n  $r18 \u003d $r17.appendSuffix(\"S\")\n  $r19 \u003d $r18.toFormatter()\n  PeriodFormatter cStandard\u003e \u003d $r19\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter cStandard\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.ISOPeriodFormat",
    "methodName": "alternate",
    "signature": "org.joda.time.format.PeriodFormatter alternate()",
    "visibility": "public",
    "body": "{\r\n    if (cAlternate \u003d\u003d null) {\r\n        cAlternate \u003d new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendMonths().appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter();\r\n    }\r\n    return cAlternate;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d PeriodFormatter cAlternate\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d PeriodFormatterBuilder\n  new PeriodFormatterBuilder()\n  $r3 \u003d $r2.appendLiteral(\"P\")\n  $r4 \u003d $r3.printZeroAlways()\n  $r5 \u003d $r4.minimumPrintedDigits(4)\n  $r6 \u003d $r5.appendYears()\n  $r7 \u003d $r6.minimumPrintedDigits(2)\n  $r8 \u003d $r7.appendMonths()\n  $r9 \u003d $r8.appendDays()\n  $r10 \u003d $r9.appendSeparatorIfFieldsAfter(\"T\")\n  $r11 \u003d $r10.appendHours()\n  $r12 \u003d $r11.appendMinutes()\n  $r13 \u003d $r12.appendSecondsWithOptionalMillis()\n  $r14 \u003d $r13.toFormatter()\n  PeriodFormatter cAlternate\u003e \u003d $r14\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter cAlternate\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.ISOPeriodFormat",
    "methodName": "alternateExtended",
    "signature": "org.joda.time.format.PeriodFormatter alternateExtended()",
    "visibility": "public",
    "body": "{\r\n    if (cAlternateExtended \u003d\u003d null) {\r\n        cAlternateExtended \u003d new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator(\"-\").minimumPrintedDigits(2).appendMonths().appendSeparator(\"-\").appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSeparator(\":\").appendMinutes().appendSeparator(\":\").appendSecondsWithOptionalMillis().toFormatter();\r\n    }\r\n    return cAlternateExtended;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d PeriodFormatter cAlternateExtended\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d PeriodFormatterBuilder\n  new PeriodFormatterBuilder()\n  $r3 \u003d $r2.appendLiteral(\"P\")\n  $r4 \u003d $r3.printZeroAlways()\n  $r5 \u003d $r4.minimumPrintedDigits(4)\n  $r6 \u003d $r5.appendYears()\n  $r7 \u003d $r6.appendSeparator(\"-\")\n  $r8 \u003d $r7.minimumPrintedDigits(2)\n  $r9 \u003d $r8.appendMonths()\n  $r10 \u003d $r9.appendSeparator(\"-\")\n  $r11 \u003d $r10.appendDays()\n  $r12 \u003d $r11.appendSeparatorIfFieldsAfter(\"T\")\n  $r13 \u003d $r12.appendHours()\n  $r14 \u003d $r13.appendSeparator(\":\")\n  $r15 \u003d $r14.appendMinutes()\n  $r16 \u003d $r15.appendSeparator(\":\")\n  $r17 \u003d $r16.appendSecondsWithOptionalMillis()\n  $r18 \u003d $r17.toFormatter()\n  PeriodFormatter cAlternateExtended\u003e \u003d $r18\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter cAlternateExtended\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.ISOPeriodFormat",
    "methodName": "alternateWithWeeks",
    "signature": "org.joda.time.format.PeriodFormatter alternateWithWeeks()",
    "visibility": "public",
    "body": "{\r\n    if (cAlternateWithWeeks \u003d\u003d null) {\r\n        cAlternateWithWeeks \u003d new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendPrefix(\"W\").appendWeeks().appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter();\r\n    }\r\n    return cAlternateWithWeeks;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d PeriodFormatter cAlternateWithWeeks\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d PeriodFormatterBuilder\n  new PeriodFormatterBuilder()\n  $r3 \u003d $r2.appendLiteral(\"P\")\n  $r4 \u003d $r3.printZeroAlways()\n  $r5 \u003d $r4.minimumPrintedDigits(4)\n  $r6 \u003d $r5.appendYears()\n  $r7 \u003d $r6.minimumPrintedDigits(2)\n  $r8 \u003d $r7.appendPrefix(\"W\")\n  $r9 \u003d $r8.appendWeeks()\n  $r10 \u003d $r9.appendDays()\n  $r11 \u003d $r10.appendSeparatorIfFieldsAfter(\"T\")\n  $r12 \u003d $r11.appendHours()\n  $r13 \u003d $r12.appendMinutes()\n  $r14 \u003d $r13.appendSecondsWithOptionalMillis()\n  $r15 \u003d $r14.toFormatter()\n  PeriodFormatter cAlternateWithWeeks\u003e \u003d $r15\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter cAlternateWithWeeks\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.ISOPeriodFormat",
    "methodName": "alternateExtendedWithWeeks",
    "signature": "org.joda.time.format.PeriodFormatter alternateExtendedWithWeeks()",
    "visibility": "public",
    "body": "{\r\n    if (cAlternateExtendedWihWeeks \u003d\u003d null) {\r\n        cAlternateExtendedWihWeeks \u003d new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator(\"-\").minimumPrintedDigits(2).appendPrefix(\"W\").appendWeeks().appendSeparator(\"-\").appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSeparator(\":\").appendMinutes().appendSeparator(\":\").appendSecondsWithOptionalMillis().toFormatter();\r\n    }\r\n    return cAlternateExtendedWihWeeks;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d PeriodFormatter cAlternateExtendedWihWeeks\u003e\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d PeriodFormatterBuilder\n  new PeriodFormatterBuilder()\n  $r3 \u003d $r2.appendLiteral(\"P\")\n  $r4 \u003d $r3.printZeroAlways()\n  $r5 \u003d $r4.minimumPrintedDigits(4)\n  $r6 \u003d $r5.appendYears()\n  $r7 \u003d $r6.appendSeparator(\"-\")\n  $r8 \u003d $r7.minimumPrintedDigits(2)\n  $r9 \u003d $r8.appendPrefix(\"W\")\n  $r10 \u003d $r9.appendWeeks()\n  $r11 \u003d $r10.appendSeparator(\"-\")\n  $r12 \u003d $r11.appendDays()\n  $r13 \u003d $r12.appendSeparatorIfFieldsAfter(\"T\")\n  $r14 \u003d $r13.appendHours()\n  $r15 \u003d $r14.appendSeparator(\":\")\n  $r16 \u003d $r15.appendMinutes()\n  $r17 \u003d $r16.appendSeparator(\":\")\n  $r18 \u003d $r17.appendSecondsWithOptionalMillis()\n  $r19 \u003d $r18.toFormatter()\n  PeriodFormatter cAlternateExtendedWihWeeks\u003e \u003d $r19\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter cAlternateExtendedWihWeeks\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.PeriodFormat",
    "methodName": "wordBased",
    "signature": "org.joda.time.format.PeriodFormatter wordBased(java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    PeriodFormatter pf \u003d FORMATTERS.get(locale);\r\n    if (pf \u003d\u003d null) {\r\n        DynamicWordBased dynamic \u003d new DynamicWordBased(buildWordBased(locale));\r\n        pf \u003d new PeriodFormatter(dynamic, dynamic, locale, null);\r\n        PeriodFormatter existing \u003d FORMATTERS.putIfAbsent(locale, pf);\r\n        if (existing !\u003d null) {\r\n            pf \u003d existing;\r\n        }\r\n    }\r\n    return pf;\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r9 !\u003d null) → B1 | else → B3",
      "B1 : If(r8 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Locale\n  $r1 \u003d ConcurrentMap FORMATTERS\u003e\n  $r2 \u003d $r1.get(r0)\n  r9 \u003d PeriodFormatter) $r2\n  if (r9 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d PeriodFormat$DynamicWordBased\n  $r4 \u003d PeriodFormat.buildWordBased(r0)\n  new PeriodFormat$DynamicWordBased($r4)\n  $r5 \u003d PeriodFormatter\n  new PeriodFormatter($r3, $r3, r0, null)\n  r9 \u003d $r5\n  $r6 \u003d ConcurrentMap FORMATTERS\u003e\n  $r7 \u003d $r6.putIfAbsent(r0, $r5)\n  r8 \u003d PeriodFormatter) $r7\n  if (r8 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  r9 \u003d r8\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormat#buildWordBased(...1)",
        "body": "{\r\n    ResourceBundle b \u003d ResourceBundle.getBundle(BUNDLE_NAME, locale);\r\n    if (containsKey(b, \"PeriodFormat.regex.separator\")) {\r\n        return buildRegExFormatter(b, locale);\r\n    } else {\r\n        return buildNonRegExFormatter(b, locale);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatter",
    "methodName": "isPrinter",
    "signature": "boolean isPrinter()",
    "visibility": "public",
    "body": "{\r\n    return (iPrinter !\u003d null);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatter\n  $r1 \u003d PeriodPrinter iPrinter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatter",
    "methodName": "isParser",
    "signature": "boolean isParser()",
    "visibility": "public",
    "body": "{\r\n    return (iParser !\u003d null);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatter\n  $r1 \u003d PeriodParser iParser\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatter",
    "methodName": "withLocale",
    "signature": "org.joda.time.format.PeriodFormatter withLocale(java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (locale \u003d\u003d getLocale() || (locale !\u003d null \u0026\u0026 locale.equals(getLocale()))) {\r\n        return this;\r\n    }\r\n    return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r0 \u003d\u003d null) → B2 | else → B4",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatter\n  Locale\n  $r2 \u003d r1.getLocale()\n  if (r0 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  if (r0 \u003d\u003d null) goto B2 else B4\n}",
      "B2 {\n  $r7 \u003d r1.getLocale()\n  $z0 \u003d r0.equals($r7)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d PeriodFormatter\n  $r6 \u003d PeriodPrinter iPrinter\u003e\n  $r5 \u003d PeriodParser iParser\u003e\n  $r4 \u003d PeriodType iParseType\u003e\n  new PeriodFormatter($r6, $r5, r0, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatter#getLocale(...0)",
        "body": "{\r\n    return iLocale;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatter",
    "methodName": "withParseType",
    "signature": "org.joda.time.format.PeriodFormatter withParseType(org.joda.time.PeriodType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d iParseType) {\r\n        return this;\r\n    }\r\n    return new PeriodFormatter(iPrinter, iParser, iLocale, type);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatter\n  PeriodType\n  $r2 \u003d PeriodType iParseType\u003e\n  if (r0 !\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d PeriodFormatter\n  $r6 \u003d PeriodPrinter iPrinter\u003e\n  $r5 \u003d PeriodParser iParser\u003e\n  $r4 \u003d Locale iLocale\u003e\n  new PeriodFormatter($r6, $r5, $r4, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatter",
    "methodName": "parseMutablePeriod",
    "signature": "org.joda.time.MutablePeriod parseMutablePeriod(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    checkParser();\r\n    MutablePeriod period \u003d new MutablePeriod(0, iParseType);\r\n    int newPos \u003d getParser().parseInto(period, text, 0, iLocale);\r\n    if (newPos \u003e\u003d 0) {\r\n        if (newPos \u003e\u003d text.length()) {\r\n            return period;\r\n        }\r\n    } else {\r\n        newPos \u003d ~newPos;\r\n    }\r\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 \u003c 0) → B1 | else → B3",
      "B1 : If(i1 \u003c $i0) → B2 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatter\n  String\n  r0.checkParser()\n  $r8 \u003d MutablePeriod\n  $r2 \u003d PeriodType iParseType\u003e\n  new MutablePeriod(0L, $r2)\n  $r5 \u003d r0.getParser()\n  $r4 \u003d Locale iLocale\u003e\n  i1 \u003d $r5.parseInto($r8, r3, 0, $r4)\n  if (i1 \u003c 0) goto B1 else B3\n}",
      "B1 {\n  $i0 \u003d r3.length()\n  if (i1 \u003c $i0) goto B2 else B4\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $i3 \u003d (int) -1\n  i1 \u003d i1 ^ $i3\n}",
      "B4 {\n  $r9 \u003d IllegalArgumentException\n  $r7 \u003d FormatUtils.createErrorMessage(r3, i1)\n  new IllegalArgumentException($r7)\n  throw $r9\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatter#checkParser(...0)",
        "body": "{\r\n    if (iParser \u003d\u003d null) {\r\n        throw new UnsupportedOperationException(\"Parsing not supported\");\r\n    }\r\n}"
      },
      {
        "name": "PeriodFormatter#getParser(...0)",
        "body": "{\r\n    return iParser;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "toFormatter",
    "signature": "org.joda.time.format.PeriodFormatter toFormatter()",
    "visibility": "public",
    "body": "{\r\n    PeriodFormatter formatter \u003d toFormatter(iElementPairs, iNotPrinter, iNotParser);\r\n    for (FieldFormatter fieldFormatter : iFieldFormatters) {\r\n        if (fieldFormatter !\u003d null) {\r\n            fieldFormatter.finish(iFieldFormatters);\r\n        }\r\n    }\r\n    iFieldFormatters \u003d (FieldFormatter[]) iFieldFormatters.clone();\r\n    return formatter;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If(r7 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  $r1 \u003d List iElementPairs\u003e\n  $z1 \u003d PeriodFormatterBuilder: boolean iNotPrinter\u003e\n  $z0 \u003d PeriodFormatterBuilder: boolean iNotParser\u003e\n  r2 \u003d PeriodFormatterBuilder.toFormatter($r1, $z1, $z0)\n  r3 \u003d PeriodFormatterBuilder$FieldFormatter[] iFieldFormatters\u003e\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r7 \u003d r3[i1]\n  if (r7 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d PeriodFormatterBuilder$FieldFormatter[] iFieldFormatters\u003e\n  r7.finish($r8)\n}",
      "B4 {\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B5 {\n  $r4 \u003d PeriodFormatterBuilder$FieldFormatter[] iFieldFormatters\u003e\n  $r5 \u003d $r4.clone()\n  $r6 \u003d PeriodFormatterBuilder$FieldFormatter[]) $r5\n  PeriodFormatterBuilder$FieldFormatter[] iFieldFormatters\u003e \u003d $r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#toFormatter(...3)",
        "body": "{\r\n    if (notPrinter \u0026\u0026 notParser) {\r\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\r\n    }\r\n    int size \u003d elementPairs.size();\r\n    if (size \u003e\u003d 2 \u0026\u0026 elementPairs.get(0) instanceof Separator) {\r\n        Separator sep \u003d (Separator) elementPairs.get(0);\r\n        if (sep.iAfterParser \u003d\u003d null \u0026\u0026 sep.iAfterPrinter \u003d\u003d null) {\r\n            PeriodFormatter f \u003d toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\r\n            sep \u003d sep.finish(f.getPrinter(), f.getParser());\r\n            return new PeriodFormatter(sep, sep);\r\n        }\r\n    }\r\n    Object[] comp \u003d createComposite(elementPairs);\r\n    if (notPrinter) {\r\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\r\n    } else if (notParser) {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\r\n    } else {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "toPrinter",
    "signature": "org.joda.time.format.PeriodPrinter toPrinter()",
    "visibility": "public",
    "body": "{\r\n    if (iNotPrinter) {\r\n        return null;\r\n    }\r\n    return toFormatter().getPrinter();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  $z0 \u003d PeriodFormatterBuilder: boolean iNotPrinter\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.toFormatter()\n  $r2 \u003d $r1.getPrinter()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#toFormatter(...0)",
        "body": "{\r\n    PeriodFormatter formatter \u003d toFormatter(iElementPairs, iNotPrinter, iNotParser);\r\n    for (FieldFormatter fieldFormatter : iFieldFormatters) {\r\n        if (fieldFormatter !\u003d null) {\r\n            fieldFormatter.finish(iFieldFormatters);\r\n        }\r\n    }\r\n    iFieldFormatters \u003d (FieldFormatter[]) iFieldFormatters.clone();\r\n    return formatter;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "toParser",
    "signature": "org.joda.time.format.PeriodParser toParser()",
    "visibility": "public",
    "body": "{\r\n    if (iNotParser) {\r\n        return null;\r\n    }\r\n    return toFormatter().getParser();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  $z0 \u003d PeriodFormatterBuilder: boolean iNotParser\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.toFormatter()\n  $r2 \u003d $r1.getParser()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#toFormatter(...0)",
        "body": "{\r\n    PeriodFormatter formatter \u003d toFormatter(iElementPairs, iNotPrinter, iNotParser);\r\n    for (FieldFormatter fieldFormatter : iFieldFormatters) {\r\n        if (fieldFormatter !\u003d null) {\r\n            fieldFormatter.finish(iFieldFormatters);\r\n        }\r\n    }\r\n    iFieldFormatters \u003d (FieldFormatter[]) iFieldFormatters.clone();\r\n    return formatter;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "clear",
    "signature": "void clear()",
    "visibility": "public",
    "body": "{\r\n    iMinPrintedDigits \u003d 1;\r\n    iPrintZeroSetting \u003d PRINT_ZERO_RARELY_LAST;\r\n    iMaxParsedDigits \u003d 10;\r\n    iRejectSignedValues \u003d false;\r\n    iPrefix \u003d null;\r\n    if (iElementPairs \u003d\u003d null) {\r\n        iElementPairs \u003d new ArrayList\u003cObject\u003e();\r\n    } else {\r\n        iElementPairs.clear();\r\n    }\r\n    iNotPrinter \u003d false;\r\n    iNotParser \u003d false;\r\n    iFieldFormatters \u003d new FieldFormatter[10];\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  PeriodFormatterBuilder: int iMinPrintedDigits\u003e \u003d 1\n  PeriodFormatterBuilder: int iPrintZeroSetting\u003e \u003d 2\n  PeriodFormatterBuilder: int iMaxParsedDigits\u003e \u003d 10\n  PeriodFormatterBuilder: boolean iRejectSignedValues\u003e \u003d 0\n  PeriodFormatterBuilder$PeriodFieldAffix iPrefix\u003e \u003d null\n  $r1 \u003d List iElementPairs\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d ArrayList\n  new ArrayList()\n  List iElementPairs\u003e \u003d $r4\n  goto B3\n}",
      "B2 {\n  $r2 \u003d List iElementPairs\u003e\n  $r2.clear()\n}",
      "B3 {\n  PeriodFormatterBuilder: boolean iNotPrinter\u003e \u003d 0\n  PeriodFormatterBuilder: boolean iNotParser\u003e \u003d 0\n  $r3 \u003d PeriodFormatterBuilder$FieldFormatter)[10]\n  PeriodFormatterBuilder$FieldFormatter[] iFieldFormatters\u003e \u003d $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "append",
    "signature": "org.joda.time.format.PeriodFormatterBuilder append(org.joda.time.format.PeriodFormatter)",
    "visibility": "public",
    "body": "{\r\n    if (formatter \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"No formatter supplied\");\r\n    }\r\n    clearPrefix();\r\n    append0(formatter.getPrinter(), formatter.getParser());\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  PeriodFormatter\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No formatter supplied\")\n  throw $r4\n}",
      "B2 {\n  r1.clearPrefix()\n  $r3 \u003d r0.getPrinter()\n  $r2 \u003d r0.getParser()\n  r1.append0($r3, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#append0(...2)",
        "body": "{\r\n    iElementPairs.add(printer);\r\n    iElementPairs.add(parser);\r\n    iNotPrinter |\u003d (printer \u003d\u003d null);\r\n    iNotParser |\u003d (parser \u003d\u003d null);\r\n    return this;\r\n}"
      },
      {
        "name": "PeriodFormatterBuilder#clearPrefix(...0)",
        "body": "{\r\n    if (iPrefix !\u003d null) {\r\n        throw new IllegalStateException(\"Prefix not followed by field\");\r\n    }\r\n    iPrefix \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "append",
    "signature": "org.joda.time.format.PeriodFormatterBuilder append(org.joda.time.format.PeriodPrinter,org.joda.time.format.PeriodParser)",
    "visibility": "public",
    "body": "{\r\n    if (printer \u003d\u003d null \u0026\u0026 parser \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"No printer or parser supplied\");\r\n    }\r\n    clearPrefix();\r\n    append0(printer, parser);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B3",
      "B1 : If(r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  PeriodPrinter\n  PeriodParser\n  if (r0 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No printer or parser supplied\")\n  throw $r3\n}",
      "B3 {\n  r1.clearPrefix()\n  r1.append0(r0, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#append0(...2)",
        "body": "{\r\n    iElementPairs.add(printer);\r\n    iElementPairs.add(parser);\r\n    iNotPrinter |\u003d (printer \u003d\u003d null);\r\n    iNotParser |\u003d (parser \u003d\u003d null);\r\n    return this;\r\n}"
      },
      {
        "name": "PeriodFormatterBuilder#clearPrefix(...0)",
        "body": "{\r\n    if (iPrefix !\u003d null) {\r\n        throw new IllegalStateException(\"Prefix not followed by field\");\r\n    }\r\n    iPrefix \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendLiteral",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendLiteral(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Literal must not be null\");\r\n    }\r\n    clearPrefix();\r\n    Literal literal \u003d new Literal(text);\r\n    append0(literal, literal);\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Literal must not be null\")\n  throw $r3\n}",
      "B2 {\n  r1.clearPrefix()\n  $r2 \u003d PeriodFormatterBuilder$Literal\n  new PeriodFormatterBuilder$Literal(r0)\n  r1.append0($r2, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#append0(...2)",
        "body": "{\r\n    iElementPairs.add(printer);\r\n    iElementPairs.add(parser);\r\n    iNotPrinter |\u003d (printer \u003d\u003d null);\r\n    iNotParser |\u003d (parser \u003d\u003d null);\r\n    return this;\r\n}"
      },
      {
        "name": "PeriodFormatterBuilder#clearPrefix(...0)",
        "body": "{\r\n    if (iPrefix !\u003d null) {\r\n        throw new IllegalStateException(\"Prefix not followed by field\");\r\n    }\r\n    iPrefix \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendPrefix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendPrefix(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new SimpleAffix(text));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d PeriodFormatterBuilder$SimpleAffix\n  new PeriodFormatterBuilder$SimpleAffix(r0)\n  $r3 \u003d r1.appendPrefix($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendPrefix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendPrefix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendPrefix(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (singularText \u003d\u003d null || pluralText \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new PluralAffix(singularText, pluralText));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String\n  String\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r1\n}",
      "B3 {\n  $r4 \u003d PeriodFormatterBuilder$PluralAffix\n  new PeriodFormatterBuilder$PluralAffix(r0, r2)\n  $r5 \u003d r3.appendPrefix($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendPrefix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendPrefix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendPrefix(java.lang.String[],java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    if (singularText \u003d\u003d null || pluralText \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new PluralAffix(singularText, pluralText));\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B4",
      "B1 : If(r1 \u003d\u003d null) → B2 | else → B4",
      "B2 : If($i0 \u003c 1) → B3 | else → B4",
      "B3 : If($i2 \u003d\u003d $i1) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String[]\n  String[]\n  if (r0 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  if (r1 \u003d\u003d null) goto B2 else B4\n}",
      "B2 {\n  $i0 \u003d lengthof r0\n  if ($i0 \u003c 1) goto B3 else B4\n}",
      "B3 {\n  $i2 \u003d lengthof r0\n  $i1 \u003d lengthof r1\n  if ($i2 \u003d\u003d $i1) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r5\n}",
      "B5 {\n  $r3 \u003d PeriodFormatterBuilder$RegExAffix\n  new PeriodFormatterBuilder$RegExAffix(r0, r1)\n  $r4 \u003d r2.appendPrefix($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendPrefix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendPrefix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendSuffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendSuffix(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new SimpleAffix(text));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d PeriodFormatterBuilder$SimpleAffix\n  new PeriodFormatterBuilder$SimpleAffix(r0)\n  $r3 \u003d r1.appendSuffix($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendSuffix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendSuffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendSuffix(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (singularText \u003d\u003d null || pluralText \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new PluralAffix(singularText, pluralText));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String\n  String\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r1\n}",
      "B3 {\n  $r4 \u003d PeriodFormatterBuilder$PluralAffix\n  new PeriodFormatterBuilder$PluralAffix(r0, r2)\n  $r5 \u003d r3.appendSuffix($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendSuffix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.format.PeriodFormatterBuilder",
    "methodName": "appendSuffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder appendSuffix(java.lang.String[],java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    if (singularText \u003d\u003d null || pluralText \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new PluralAffix(singularText, pluralText));\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B4",
      "B1 : If(r1 \u003d\u003d null) → B2 | else → B4",
      "B2 : If($i0 \u003c 1) → B3 | else → B4",
      "B3 : If($i2 \u003d\u003d $i1) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  PeriodFormatterBuilder\n  String[]\n  String[]\n  if (r0 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  if (r1 \u003d\u003d null) goto B2 else B4\n}",
      "B2 {\n  $i0 \u003d lengthof r0\n  if ($i0 \u003c 1) goto B3 else B4\n}",
      "B3 {\n  $i2 \u003d lengthof r0\n  $i1 \u003d lengthof r1\n  if ($i2 \u003d\u003d $i1) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r5\n}",
      "B5 {\n  $r3 \u003d PeriodFormatterBuilder$RegExAffix\n  new PeriodFormatterBuilder$RegExAffix(r0, r1)\n  $r4 \u003d r2.appendSuffix($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodFormatterBuilder#appendSuffix(...1)",
        "body": "{\r\n    if (text \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return appendSuffix(new SimpleAffix(text));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "hours",
    "signature": "org.joda.time.Hours hours(int)",
    "visibility": "public",
    "body": "{\r\n    switch(hours) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case 8:\r\n            return EIGHT;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Hours(hours);\r\n    }\r\n}",
    "nodes": 13,
    "edges": 12,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B11 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Hours; }\n}",
      "B1 {\n  $r9 \u003d Hours ZERO\u003e\n  return\n}",
      "B2 {\n  $r8 \u003d Hours ONE\u003e\n  return\n}",
      "B3 {\n  $r7 \u003d Hours TWO\u003e\n  return\n}",
      "B4 {\n  $r6 \u003d Hours THREE\u003e\n  return\n}",
      "B5 {\n  $r5 \u003d Hours FOUR\u003e\n  return\n}",
      "B6 {\n  $r4 \u003d Hours FIVE\u003e\n  return\n}",
      "B7 {\n  $r3 \u003d Hours SIX\u003e\n  return\n}",
      "B8 {\n  $r2 \u003d Hours SEVEN\u003e\n  return\n}",
      "B9 {\n  $r1 \u003d Hours EIGHT\u003e\n  return\n}",
      "B10 {\n  $r0 \u003d Hours MAX_VALUE\u003e\n  return\n}",
      "B11 {\n  $r10 \u003d Hours MIN_VALUE\u003e\n  return\n}",
      "B12 {\n  $r11 \u003d Hours\n  new Hours(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B11",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B0 --\u003e B7",
      "B0 --\u003e B8",
      "B0 --\u003e B9",
      "B0 --\u003e B10",
      "B0 --\u003e B12",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "hoursBetween",
    "signature": "org.joda.time.Hours hoursBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalTime \u0026\u0026 end instanceof LocalTime) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int hours \u003d chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Hours.hours(hours);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Hours.hours(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalTime\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalTime\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.hours()\n  $r5 \u003d LocalTime) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalTime) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Hours.hours(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Hours ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Hours.hours($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "hoursIn",
    "signature": "org.joda.time.Hours hoursIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Hours.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\r\n    return Hours.hours(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Hours ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.hours()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Hours.hours(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "parseHours",
    "signature": "org.joda.time.Hours parseHours(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Hours.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Hours.hours(p.getHours());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Hours ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getHours()\n  $r3 \u003d Hours.hours($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "plus",
    "signature": "org.joda.time.Hours plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Hours.hours(FieldUtils.safeAdd(getValue(), hours));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Hours\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Hours.hours($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "plus",
    "signature": "org.joda.time.Hours plus(org.joda.time.Hours)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(hours.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Hours\n  Hours\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#plus(...1)",
        "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Hours.hours(FieldUtils.safeAdd(getValue(), hours));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "minus",
    "signature": "org.joda.time.Hours minus(org.joda.time.Hours)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(hours.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Hours\n  Hours\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(hours));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Hours dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Hours.hours(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Hours\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Hours.hours($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Hours)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Hours\n  Hours\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Hours",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Hours)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Hours\n  Hours\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Hours#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.IllegalFieldValueException",
    "methodName": "getIllegalValueAsString",
    "signature": "java.lang.String getIllegalValueAsString()",
    "visibility": "public",
    "body": "{\r\n    String value \u003d iStringValue;\r\n    if (value \u003d\u003d null) {\r\n        value \u003d String.valueOf(iNumberValue);\r\n    }\r\n    return value;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IllegalFieldValueException\n  r2 \u003d String iStringValue\u003e\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Number iNumberValue\u003e\n  r2 \u003d String.valueOf($r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.IllegalFieldValueException",
    "methodName": "prependMessage",
    "signature": "void prependMessage(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (iMessage \u003d\u003d null) {\r\n        iMessage \u003d message;\r\n    } else if (message !\u003d null) {\r\n        iMessage \u003d message + \": \" + iMessage;\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If(r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  IllegalFieldValueException\n  String\n  $r1 \u003d String iMessage\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  String iMessage\u003e \u003d r2\n  goto B4\n}",
      "B2 {\n  if (r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d String iMessage\u003e\n  $r4 \u003d dynInvoke makeConcatWithConstants(r2, $r3)\n  String iMessage\u003e \u003d $r4\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.IllegalInstantException",
    "methodName": "isIllegalInstant",
    "signature": "boolean isIllegalInstant(java.lang.Throwable)",
    "visibility": "public",
    "body": "{\r\n    if (ex instanceof IllegalInstantException) {\r\n        return true;\r\n    }\r\n    while (ex.getCause() !\u003d null \u0026\u0026 ex.getCause() !\u003d ex) {\r\n        return isIllegalInstant(ex.getCause());\r\n    }\r\n    return false;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($r2 \u003d\u003d r0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Throwable\n  $z0 \u003d IllegalInstantException\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getCause()\n  if ($r1 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r2 \u003d r0.getCause()\n  if ($r2 \u003d\u003d r0) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d r0.getCause()\n  $z1 \u003d IllegalInstantException.isIllegalInstant($r3)\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IllegalInstantException#isIllegalInstant(...1)",
        "body": "{\r\n    if (ex instanceof IllegalInstantException) {\r\n        return true;\r\n    }\r\n    while (ex.getCause() !\u003d null \u0026\u0026 ex.getCause() !\u003d ex) {\r\n        return isIllegalInstant(ex.getCause());\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Instant",
    "methodName": "withMillis",
    "signature": "org.joda.time.Instant withMillis(long)",
    "visibility": "public",
    "body": "{\r\n    return (newMillis \u003d\u003d iMillis ? this : new Instant(newMillis));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Instant\n  l0 :\u003d @parameter0: long\n  $l1 \u003d Instant: long iMillis\u003e\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r1 \u003d Instant\n  new Instant(l0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Instant",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.Instant withDurationAdded(long,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 \u003d\u003d false) → B1 | else → B2",
      "B1 : If(i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Instant\n  l0 :\u003d @parameter0: long\n  i2 :\u003d @parameter1: int\n  $b1 \u003d l0 cmp 0L\n  if ($b1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  if (i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d r0.getChronology()\n  $l3 \u003d r0.getMillis()\n  l4 \u003d $r1.add($l3, l0, i2)\n  $r2 \u003d r0.withMillis(l4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Instant#getMillis(...0)",
        "body": "{\r\n    return iMillis;\r\n}"
      },
      {
        "name": "Instant#getChronology(...0)",
        "body": "{\r\n    return ISOChronology.getInstanceUTC();\r\n}"
      },
      {
        "name": "Instant#withMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d iMillis ? this : new Instant(newMillis));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Instant",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.Instant withDurationAdded(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Instant\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $l1 \u003d r0.getMillis()\n  $r2 \u003d r1.withDurationAdded($l1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Instant#withDurationAdded(...2)",
        "body": "{\r\n    if (durationToAdd \u003d\u003d 0 || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getMillis(), durationToAdd, scalar);\r\n    return withMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "parseWithOffset",
    "signature": "org.joda.time.Interval parseWithOffset(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    int separator \u003d str.indexOf(\u0027/\u0027);\r\n    if (separator \u003c 0) {\r\n        throw new IllegalArgumentException(\"Format requires a \u0027/\u0027 separator: \" + str);\r\n    }\r\n    String leftStr \u003d str.substring(0, separator);\r\n    if (leftStr.length() \u003c\u003d 0) {\r\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\r\n    }\r\n    String rightStr \u003d str.substring(separator + 1);\r\n    if (rightStr.length() \u003c\u003d 0) {\r\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\r\n    }\r\n    DateTimeFormatter dateTimeParser \u003d ISODateTimeFormat.dateTimeParser().withOffsetParsed();\r\n    PeriodFormatter periodParser \u003d ISOPeriodFormat.standard();\r\n    DateTime start \u003d null;\r\n    Period period \u003d null;\r\n    // before slash\r\n    char c \u003d leftStr.charAt(0);\r\n    if (c \u003d\u003d \u0027P\u0027 || c \u003d\u003d \u0027p\u0027) {\r\n        period \u003d periodParser.withParseType(PeriodType.standard()).parsePeriod(leftStr);\r\n    } else {\r\n        start \u003d dateTimeParser.parseDateTime(leftStr);\r\n    }\r\n    // after slash\r\n    c \u003d rightStr.charAt(0);\r\n    if (c \u003d\u003d \u0027P\u0027 || c \u003d\u003d \u0027p\u0027) {\r\n        if (period !\u003d null) {\r\n            throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\r\n        }\r\n        period \u003d periodParser.withParseType(PeriodType.standard()).parsePeriod(rightStr);\r\n        return new Interval(start, period);\r\n    } else {\r\n        DateTime end \u003d dateTimeParser.parseDateTime(rightStr);\r\n        if (period !\u003d null) {\r\n            return new Interval(period, end);\r\n        } else {\r\n            return new Interval(start, end);\r\n        }\r\n    }\r\n}",
    "nodes": 18,
    "edges": 20,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2",
      "B2 : If($i1 \u003e 0) → B3 | else → B4",
      "B4 : If($i3 \u003e 0) → B5 | else → B6",
      "B6 : If($i6 \u003d\u003d 80) → B7 | else → B8",
      "B7 : If($i7 !\u003d 112) → B8 | else → B9",
      "B10 : If($i8 \u003d\u003d 80) → B11 | else → B12",
      "B11 : If($i9 !\u003d 112) → B12 | else → B15",
      "B12 : If(r23 \u003d\u003d null) → B13 | else → B14",
      "B15 : If(r23 \u003d\u003d null) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  String\n  i0 \u003d r0.indexOf(47)\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r25 \u003d IllegalArgumentException\n  $r21 \u003d dynInvoke makeConcatWithConstants(r0)\n  new IllegalArgumentException($r21)\n  throw $r25\n}",
      "B2 {\n  r1 \u003d r0.substring(0, i0)\n  $i1 \u003d r1.length()\n  if ($i1 \u003e 0) goto B3 else B4\n}",
      "B3 {\n  $r26 \u003d IllegalArgumentException\n  $r19 \u003d dynInvoke makeConcatWithConstants(r0)\n  new IllegalArgumentException($r19)\n  throw $r26\n}",
      "B4 {\n  $i2 \u003d i0 + 1\n  r2 \u003d r0.substring($i2)\n  $i3 \u003d r2.length()\n  if ($i3 \u003e 0) goto B5 else B6\n}",
      "B5 {\n  $r27 \u003d IllegalArgumentException\n  $r17 \u003d dynInvoke makeConcatWithConstants(r0)\n  new IllegalArgumentException($r17)\n  throw $r27\n}",
      "B6 {\n  $r3 \u003d ISODateTimeFormat.dateTimeParser()\n  r4 \u003d $r3.withOffsetParsed()\n  r5 \u003d ISOPeriodFormat.standard()\n  r22 \u003d null\n  r23 \u003d null\n  c5 \u003d r1.charAt(0)\n  $i6 \u003d (int) c5\n  if ($i6 \u003d\u003d 80) goto B7 else B8\n}",
      "B7 {\n  $i7 \u003d (int) c5\n  if ($i7 !\u003d 112) goto B8 else B9\n}",
      "B8 {\n  $r6 \u003d PeriodType.standard()\n  $r7 \u003d r5.withParseType($r6)\n  r23 \u003d $r7.parsePeriod(r1)\n  goto B10\n}",
      "B9 {\n  r22 \u003d r4.parseDateTime(r1)\n}",
      "B10 {\n  $c4 \u003d r2.charAt(0)\n  $i8 \u003d (int) $c4\n  if ($i8 \u003d\u003d 80) goto B11 else B12\n}",
      "B11 {\n  $i9 \u003d (int) $c4\n  if ($i9 !\u003d 112) goto B12 else B15\n}",
      "B12 {\n  if (r23 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $r28 \u003d IllegalArgumentException\n  $r12 \u003d dynInvoke makeConcatWithConstants(r0)\n  new IllegalArgumentException($r12)\n  throw $r28\n}",
      "B14 {\n  $r8 \u003d PeriodType.standard()\n  $r9 \u003d r5.withParseType($r8)\n  r24 \u003d $r9.parsePeriod(r2)\n  $r29 \u003d Interval\n  new Interval(r22, r24)\n  return\n}",
      "B15 {\n  r13 \u003d r4.parseDateTime(r2)\n  if (r23 \u003d\u003d null) goto B16 else B17\n}",
      "B16 {\n  $r30 \u003d Interval\n  new Interval(r23, r13)\n  return\n}",
      "B17 {\n  $r31 \u003d Interval\n  new Interval(r22, r13)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "overlap",
    "signature": "org.joda.time.Interval overlap(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    interval \u003d DateTimeUtils.getReadableInterval(interval);\r\n    if (overlaps(interval) \u003d\u003d false) {\r\n        return null;\r\n    }\r\n    long start \u003d Math.max(getStartMillis(), interval.getStartMillis());\r\n    long end \u003d Math.min(getEndMillis(), interval.getEndMillis());\r\n    return new Interval(start, end, getChronology());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadableInterval\n  r4 \u003d DateTimeUtils.getReadableInterval(r3)\n  $z0 \u003d r0.overlaps(r4)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l1 \u003d r0.getStartMillis()\n  $l0 \u003d r4.getStartMillis()\n  l2 \u003d Math.max($l1, $l0)\n  $l4 \u003d r0.getEndMillis()\n  $l3 \u003d r4.getEndMillis()\n  l5 \u003d Math.min($l4, $l3)\n  $r1 \u003d Interval\n  $r2 \u003d r0.getChronology()\n  new Interval(l2, l5, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#overlaps(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "gap",
    "signature": "org.joda.time.Interval gap(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    interval \u003d DateTimeUtils.getReadableInterval(interval);\r\n    long otherStart \u003d interval.getStartMillis();\r\n    long otherEnd \u003d interval.getEndMillis();\r\n    long thisStart \u003d getStartMillis();\r\n    long thisEnd \u003d getEndMillis();\r\n    if (thisStart \u003e otherEnd) {\r\n        return new Interval(otherEnd, thisStart, getChronology());\r\n    } else if (otherStart \u003e thisEnd) {\r\n        return new Interval(thisEnd, otherStart, getChronology());\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i6 \u003c\u003d 0) → B1 | else → B2",
      "B2 : If($i7 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadableInterval\n  r6 \u003d DateTimeUtils.getReadableInterval(r5)\n  l0 \u003d r6.getStartMillis()\n  l1 \u003d r6.getEndMillis()\n  l2 \u003d r0.getStartMillis()\n  l3 \u003d r0.getEndMillis()\n  $b4 \u003d l2 cmp l1\n  $i6 \u003d (int) $b4\n  if ($i6 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d Interval\n  $r4 \u003d r0.getChronology()\n  new Interval(l1, l2, $r4)\n  return\n}",
      "B2 {\n  $b5 \u003d l0 cmp l3\n  $i7 \u003d (int) $b5\n  if ($i7 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d Interval\n  $r2 \u003d r0.getChronology()\n  new Interval(l3, l0, $r2)\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "abuts",
    "signature": "boolean abuts(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        long now \u003d DateTimeUtils.currentTimeMillis();\r\n        return (getStartMillis() \u003d\u003d now || getEndMillis() \u003d\u003d now);\r\n    } else {\r\n        return (interval.getEndMillis() \u003d\u003d getStartMillis() || getEndMillis() \u003d\u003d interval.getStartMillis());\r\n    }\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B6",
      "B1 : If($b8 \u003d\u003d false) → B2 | else → B3",
      "B2 : If($b10 !\u003d 0) → B3 | else → B4",
      "B6 : If($b2 \u003d\u003d false) → B7 | else → B8",
      "B7 : If($b5 !\u003d 0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B6\n}",
      "B1 {\n  l6 \u003d DateTimeUtils.currentTimeMillis()\n  $l7 \u003d r1.getStartMillis()\n  $b8 \u003d $l7 cmp l6\n  if ($b8 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $l9 \u003d r1.getEndMillis()\n  $b10 \u003d $l9 cmp l6\n  if ($b10 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $l1 \u003d r0.getEndMillis()\n  $l0 \u003d r1.getStartMillis()\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $l4 \u003d r1.getEndMillis()\n  $l3 \u003d r0.getStartMillis()\n  $b5 \u003d $l4 cmp $l3\n  if ($b5 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $z1 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z1 \u003d 0\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withChronology",
    "signature": "org.joda.time.Interval withChronology(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (getChronology() \u003d\u003d chronology) {\r\n        return this;\r\n    }\r\n    return new Interval(getStartMillis(), getEndMillis(), chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  Chronology\n  $r2 \u003d r0.getChronology()\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d Interval\n  $l1 \u003d r0.getStartMillis()\n  $l0 \u003d r0.getEndMillis()\n  new Interval($l1, $l0, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withStartMillis",
    "signature": "org.joda.time.Interval withStartMillis(long)",
    "visibility": "public",
    "body": "{\r\n    if (startInstant \u003d\u003d getStartMillis()) {\r\n        return this;\r\n    }\r\n    return new Interval(startInstant, getEndMillis(), getChronology());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  l0 :\u003d @parameter0: long\n  $l1 \u003d r0.getStartMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d Interval\n  $l3 \u003d r0.getEndMillis()\n  $r2 \u003d r0.getChronology()\n  new Interval(l0, $l3, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withEndMillis",
    "signature": "org.joda.time.Interval withEndMillis(long)",
    "visibility": "public",
    "body": "{\r\n    if (endInstant \u003d\u003d getEndMillis()) {\r\n        return this;\r\n    }\r\n    return new Interval(getStartMillis(), endInstant, getChronology());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  l0 :\u003d @parameter0: long\n  $l1 \u003d r0.getEndMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d Interval\n  $l3 \u003d r0.getStartMillis()\n  $r2 \u003d r0.getChronology()\n  new Interval($l3, l0, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withDurationAfterStart",
    "signature": "org.joda.time.Interval withDurationAfterStart(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    long durationMillis \u003d DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis \u003d\u003d toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long startMillis \u003d getStartMillis();\r\n    long endMillis \u003d chrono.add(startMillis, durationMillis, 1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadableDuration\n  l0 \u003d DateTimeUtils.getDurationMillis(r0)\n  $l1 \u003d r1.toDurationMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d r1.getChronology()\n  l3 \u003d r1.getStartMillis()\n  l4 \u003d r2.add(l3, l0, 1)\n  $r3 \u003d Interval\n  new Interval(l3, l4, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#toDurationMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withDurationBeforeEnd",
    "signature": "org.joda.time.Interval withDurationBeforeEnd(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    long durationMillis \u003d DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis \u003d\u003d toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long endMillis \u003d getEndMillis();\r\n    long startMillis \u003d chrono.add(endMillis, durationMillis, -1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadableDuration\n  l0 \u003d DateTimeUtils.getDurationMillis(r0)\n  $l1 \u003d r1.toDurationMillis()\n  $b2 \u003d l0 cmp $l1\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d r1.getChronology()\n  l3 \u003d r1.getEndMillis()\n  $i6 \u003d (int) -1\n  l4 \u003d r2.add(l3, l0, $i6)\n  $r4 \u003d Interval\n  new Interval(l4, l3, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#toDurationMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withPeriodAfterStart",
    "signature": "org.joda.time.Interval withPeriodAfterStart(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        return withDurationAfterStart(null);\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long startMillis \u003d getStartMillis();\r\n    long endMillis \u003d chrono.add(period, startMillis, 1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.withDurationAfterStart(null)\n  return\n}",
      "B2 {\n  r2 \u003d r1.getChronology()\n  l0 \u003d r1.getStartMillis()\n  l1 \u003d r2.add(r0, l0, 1)\n  $r3 \u003d Interval\n  new Interval(l0, l1, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#withDurationAfterStart(...1)",
        "body": "{\r\n    long durationMillis \u003d DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis \u003d\u003d toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long startMillis \u003d getStartMillis();\r\n    long endMillis \u003d chrono.add(startMillis, durationMillis, 1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Interval",
    "methodName": "withPeriodBeforeEnd",
    "signature": "org.joda.time.Interval withPeriodBeforeEnd(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        return withDurationBeforeEnd(null);\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long endMillis \u003d getEndMillis();\r\n    long startMillis \u003d chrono.add(period, endMillis, -1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Interval\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.withDurationBeforeEnd(null)\n  return\n}",
      "B2 {\n  r2 \u003d r1.getChronology()\n  l0 \u003d r1.getEndMillis()\n  $i3 \u003d (int) -1\n  l1 \u003d r2.add(r0, l0, $i3)\n  $r5 \u003d Interval\n  new Interval(l1, l0, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Interval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Interval#withDurationBeforeEnd(...1)",
        "body": "{\r\n    long durationMillis \u003d DateTimeUtils.getDurationMillis(duration);\r\n    if (durationMillis \u003d\u003d toDurationMillis()) {\r\n        return this;\r\n    }\r\n    Chronology chrono \u003d getChronology();\r\n    long endMillis \u003d getEndMillis();\r\n    long startMillis \u003d chrono.add(endMillis, durationMillis, -1);\r\n    return new Interval(startMillis, endMillis, chrono);\r\n}"
      },
      {
        "name": "Interval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "now",
    "signature": "org.joda.time.LocalDate now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new LocalDate(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalDate\n  new LocalDate(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "now",
    "signature": "org.joda.time.LocalDate now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new LocalDate(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalDate\n  new LocalDate(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.LocalDate fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    int era \u003d calendar.get(Calendar.ERA);\r\n    int yearOfEra \u003d calendar.get(Calendar.YEAR);\r\n    return new LocalDate((era \u003d\u003d GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  i0 \u003d r0.get(0)\n  i1 \u003d r0.get(1)\n  $r1 \u003d LocalDate\n  if (i0 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d i1\n  goto B5\n}",
      "B4 {\n  $i5 \u003d 1 - i1\n}",
      "B5 {\n  $i2 \u003d r0.get(2)\n  $i4 \u003d $i2 + 1\n  $i3 \u003d r0.get(5)\n  new LocalDate($i5, $i4, $i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.LocalDate fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    if (date.getTime() \u003c 0) {\r\n        // handle years in era BC\r\n        GregorianCalendar cal \u003d new GregorianCalendar();\r\n        cal.setTime(date);\r\n        return fromCalendarFields(cal);\r\n    }\r\n    return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($i7 \u003e\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r5\n}",
      "B2 {\n  $l0 \u003d r0.getTime()\n  $b1 \u003d $l0 cmp 0L\n  $i7 \u003d (int) $b1\n  if ($i7 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d GregorianCalendar\n  new GregorianCalendar()\n  $r6.setTime(r0)\n  $r3 \u003d LocalDate.fromCalendarFields($r6)\n  return\n}",
      "B4 {\n  $r7 \u003d LocalDate\n  $i2 \u003d r0.getYear()\n  $i6 \u003d $i2 + 1900\n  $i3 \u003d r0.getMonth()\n  $i5 \u003d $i3 + 1\n  $i4 \u003d r0.getDate()\n  new LocalDate($i6, $i5, $i4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#fromCalendarFields(...1)",
        "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    int era \u003d calendar.get(Calendar.ERA);\r\n    int yearOfEra \u003d calendar.get(Calendar.YEAR);\r\n    return new LocalDate((era \u003d\u003d GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "getValue",
    "signature": "int getValue(int)",
    "visibility": "public",
    "body": "{\r\n    switch(index) {\r\n        case YEAR:\r\n            return getChronology().year().get(getLocalMillis());\r\n        case MONTH_OF_YEAR:\r\n            return getChronology().monthOfYear().get(getLocalMillis());\r\n        case DAY_OF_MONTH:\r\n            return getChronology().dayOfMonth().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  IndexOutOfBoundsException; }\n}",
      "B1 {\n  $r5 \u003d r0.getChronology()\n  $r6 \u003d $r5.year()\n  $l5 \u003d r0.getLocalMillis()\n  $i6 \u003d $r6.get($l5)\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getChronology()\n  $r4 \u003d $r3.monthOfYear()\n  $l3 \u003d r0.getLocalMillis()\n  $i4 \u003d $r4.get($l3)\n  return\n}",
      "B3 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.dayOfMonth()\n  $l1 \u003d r0.getLocalMillis()\n  $i2 \u003d $r2.get($l1)\n  return\n}",
      "B4 {\n  $r7 \u003d IndexOutOfBoundsException\n  $r8 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IndexOutOfBoundsException($r8)\n  throw $r7\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "get",
    "signature": "int get(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    return fieldType.getField(getChronology()).get(getLocalMillis());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r7\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IllegalArgumentException\n  $r5 \u003d String.valueOf(r0)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IllegalArgumentException($r6)\n  throw $r4\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l0 \u003d r1.getLocalMillis()\n  $i1 \u003d $r3.get($l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B3 : If($i3 \u003c 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getDurationType()\n  $r2 \u003d Set DATE_DURATION_TYPES\u003e\n  $z0 \u003d $r2.contains(r1)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r3.getChronology()\n  $r7 \u003d r1.getField($r6)\n  $l1 \u003d $r7.getUnitMillis()\n  $r8 \u003d r3.getChronology()\n  $r9 \u003d $r8.days()\n  $l0 \u003d $r9.getUnitMillis()\n  $b2 \u003d $l1 cmp $l0\n  $i3 \u003d (int) $b2\n  if ($i3 \u003c 0) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d r3.getChronology()\n  $r5 \u003d r0.getField($r4)\n  $z1 \u003d $r5.isSupported()\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationField field \u003d type.getField(getChronology());\r\n    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return field.isSupported();\r\n    }\r\n    return false;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B3 : If($i3 \u003c 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DurationFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  r3 \u003d r0.getField($r2)\n  $r4 \u003d Set DATE_DURATION_TYPES\u003e\n  $z0 \u003d $r4.contains(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $l1 \u003d r3.getUnitMillis()\n  $r5 \u003d r1.getChronology()\n  $r6 \u003d $r5.days()\n  $l0 \u003d $r6.getUnitMillis()\n  $b2 \u003d $l1 cmp $l0\n  $i3 \u003d (int) $b2\n  if ($i3 \u003c 0) goto B4 else B5\n}",
      "B4 {\n  $z1 \u003d r3.isSupported()\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalDate) {\r\n        LocalDate other \u003d (LocalDate) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis \u003d\u003d other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($b2 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d LocalDate) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z2 \u003d $r4.equals($r3)\n  if ($z2 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $l1 \u003d LocalDate: long iLocalMillis\u003e\n  $l0 \u003d LocalDate: long iLocalMillis\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z3 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z3 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z1 \u003d r0.equals(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    // override for performance\r\n    int hash \u003d iHash;\r\n    if (hash \u003d\u003d 0) {\r\n        hash \u003d iHash \u003d super.hashCode();\r\n    }\r\n    return hash;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i1 \u003d LocalDate: int iHash\u003e\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d r0.hashCode()\n  LocalDate: int iHash\u003e \u003d $i0\n  i1 \u003d $i0\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "compareTo",
    "signature": "int compareTo(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return 0;\r\n    }\r\n    if (partial instanceof LocalDate) {\r\n        LocalDate other \u003d (LocalDate) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return (iLocalMillis \u003c other.iLocalMillis ? -1 : (iLocalMillis \u003d\u003d other.iLocalMillis ? 0 : 1));\r\n        }\r\n    }\r\n    return super.compareTo(partial);\r\n}",
    "nodes": 11,
    "edges": 13,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B10",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B10",
      "B4 : If($i8 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($b6 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  ReadablePartial\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B3 else B10\n}",
      "B3 {\n  r2 \u003d LocalDate) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B4 else B10\n}",
      "B4 {\n  $l2 \u003d LocalDate: long iLocalMillis\u003e\n  $l1 \u003d LocalDate: long iLocalMillis\u003e\n  $b3 \u003d $l2 cmp $l1\n  $i8 \u003d (int) $b3\n  if ($i8 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $b7 \u003d -1\n  goto B9\n}",
      "B6 {\n  $l5 \u003d LocalDate: long iLocalMillis\u003e\n  $l4 \u003d LocalDate: long iLocalMillis\u003e\n  $b6 \u003d $l5 cmp $l4\n  if ($b6 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $b7 \u003d 0\n  goto B9\n}",
      "B8 {\n  $b7 \u003d 1\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $i0 \u003d r0.compareTo(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "toLocalDateTime",
    "signature": "org.joda.time.LocalDateTime toLocalDateTime(org.joda.time.LocalTime)",
    "visibility": "public",
    "body": "{\r\n    if (time \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The time must not be null\");\r\n    }\r\n    if (getChronology() !\u003d time.getChronology()) {\r\n        throw new IllegalArgumentException(\"The chronology of the time does not match\");\r\n    }\r\n    long localMillis \u003d getLocalMillis() + time.getLocalMillis();\r\n    return new LocalDateTime(localMillis, getChronology());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  LocalTime\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The time must not be null\")\n  throw $r7\n}",
      "B2 {\n  $r3 \u003d r1.getChronology()\n  $r2 \u003d r0.getChronology()\n  if ($r3 \u003d\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The chronology of the time does not match\")\n  throw $r6\n}",
      "B4 {\n  $l1 \u003d r1.getLocalMillis()\n  $l0 \u003d r0.getLocalMillis()\n  l2 \u003d $l1 + $l0\n  $r4 \u003d LocalDateTime\n  $r5 \u003d r1.getChronology()\n  new LocalDateTime(l2, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "toDateTime",
    "signature": "org.joda.time.DateTime toDateTime(org.joda.time.LocalTime,org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (time \u003d\u003d null) {\r\n        return toDateTimeAtCurrentTime(zone);\r\n    }\r\n    if (getChronology() !\u003d time.getChronology()) {\r\n        throw new IllegalArgumentException(\"The chronology of the time does not match\");\r\n    }\r\n    Chronology chrono \u003d getChronology().withZone(zone);\r\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), time.getHourOfDay(), time.getMinuteOfHour(), time.getSecondOfMinute(), time.getMillisOfSecond(), chrono);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  LocalTime\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d r1.toDateTimeAtCurrentTime(r4)\n  return\n}",
      "B2 {\n  $r3 \u003d r1.getChronology()\n  $r2 \u003d r0.getChronology()\n  if ($r3 \u003d\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The chronology of the time does not match\")\n  throw $r8\n}",
      "B4 {\n  $r5 \u003d r1.getChronology()\n  r6 \u003d $r5.withZone(r4)\n  $r7 \u003d DateTime\n  $i6 \u003d r1.getYear()\n  $i5 \u003d r1.getMonthOfYear()\n  $i4 \u003d r1.getDayOfMonth()\n  $i3 \u003d r0.getHourOfDay()\n  $i2 \u003d r0.getMinuteOfHour()\n  $i1 \u003d r0.getSecondOfMinute()\n  $i0 \u003d r0.getMillisOfSecond()\n  new DateTime($i6, $i5, $i4, $i3, $i2, $i1, $i0, r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#toDateTimeAtCurrentTime(...1)",
        "body": "{\r\n    zone \u003d DateTimeUtils.getZone(zone);\r\n    Chronology chrono \u003d getChronology().withZone(zone);\r\n    long instantMillis \u003d DateTimeUtils.currentTimeMillis();\r\n    long resolved \u003d chrono.set(this, instantMillis);\r\n    return new DateTime(resolved, chrono);\r\n}"
      },
      {
        "name": "LocalDate#getYear(...0)",
        "body": "{\r\n    return getChronology().year().get(getLocalMillis());\r\n}"
      },
      {
        "name": "LocalDate#getDayOfMonth(...0)",
        "body": "{\r\n    return getChronology().dayOfMonth().get(getLocalMillis());\r\n}"
      },
      {
        "name": "LocalDate#getMonthOfYear(...0)",
        "body": "{\r\n    return getChronology().monthOfYear().get(getLocalMillis());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "toDate",
    "signature": "java.util.Date toDate()",
    "visibility": "public",
    "body": "{\r\n    int dom \u003d getDayOfMonth();\r\n    Date date \u003d new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\r\n    LocalDate check \u003d LocalDate.fromDateFields(date);\r\n    if (check.isBefore(this)) {\r\n        // DST gap (no midnight)\r\n        // move forward in units of one hour until date correct\r\n        while (check.equals(this) \u003d\u003d false) {\r\n            date.setTime(date.getTime() + 3600000);\r\n            check \u003d LocalDate.fromDateFields(date);\r\n        }\r\n        // move back in units of one second until date wrong\r\n        while (date.getDate() \u003d\u003d dom) {\r\n            date.setTime(date.getTime() - 1000);\r\n        }\r\n        // fix result\r\n        date.setTime(date.getTime() + 1000);\r\n    } else if (check.equals(this)) {\r\n        // check for DST overlap (two midnights)\r\n        Date earlier \u003d new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\r\n        if (earlier.getDate() \u003d\u003d dom) {\r\n            date \u003d earlier;\r\n        }\r\n    }\r\n    return date;\r\n}",
    "nodes": 10,
    "edges": 14,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B6",
      "B1 : If($z2 !\u003d 0) → B2 | else → B3",
      "B3 : If($i10 !\u003d i0) → B4 | else → B5",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B9",
      "B7 : If($i9 !\u003d i0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 \u003d r0.getDayOfMonth()\n  $r1 \u003d Date\n  $i1 \u003d r0.getYear()\n  $i4 \u003d $i1 - 1900\n  $i2 \u003d r0.getMonthOfYear()\n  $i3 \u003d $i2 - 1\n  new Date($i4, $i3, i0)\n  r4 \u003d $r1\n  r5 \u003d LocalDate.fromDateFields($r1)\n  $z0 \u003d r5.isBefore(r0)\n  if ($z0 \u003d\u003d false) goto B1 else B6\n}",
      "B1 {\n  $z2 \u003d r5.equals(r0)\n  if ($z2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $l15 \u003d $r1.getTime()\n  $l16 \u003d $l15 + 3600000L\n  $r1.setTime($l16)\n  r5 \u003d LocalDate.fromDateFields($r1)\n  goto B1\n}",
      "B3 {\n  $i10 \u003d $r1.getDate()\n  if ($i10 !\u003d i0) goto B4 else B5\n}",
      "B4 {\n  $l13 \u003d $r1.getTime()\n  $l14 \u003d $l13 - 1000L\n  $r1.setTime($l14)\n  goto B3\n}",
      "B5 {\n  $l11 \u003d $r1.getTime()\n  $l12 \u003d $l11 + 1000L\n  $r1.setTime($l12)\n  goto B9\n}",
      "B6 {\n  $z1 \u003d r5.equals(r0)\n  if ($z1 \u003d\u003d false) goto B7 else B9\n}",
      "B7 {\n  $r2 \u003d Date\n  $l7 \u003d $r1.getTime()\n  $r3 \u003d TimeZone.getDefault()\n  $i5 \u003d $r3.getDSTSavings()\n  $l6 \u003d (long) $i5\n  $l8 \u003d $l7 - $l6\n  new Date($l8)\n  $i9 \u003d $r2.getDate()\n  if ($i9 !\u003d i0) goto B8 else B9\n}",
      "B8 {\n  r4 \u003d $r2\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getDayOfMonth(...0)",
        "body": "{\r\n    return getChronology().dayOfMonth().get(getLocalMillis());\r\n}"
      },
      {
        "name": "LocalDate#getYear(...0)",
        "body": "{\r\n    return getChronology().year().get(getLocalMillis());\r\n}"
      },
      {
        "name": "LocalDate#getMonthOfYear(...0)",
        "body": "{\r\n    return getChronology().monthOfYear().get(getLocalMillis());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "withFields",
    "signature": "org.joda.time.LocalDate withFields(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getLocalMillis()\n  $l1 \u003d $r2.set(r0, $l0)\n  $r3 \u003d r1.withLocalMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "withField",
    "signature": "org.joda.time.LocalDate withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).set(getLocalMillis(), value);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.set($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalDate#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.LocalDate withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).add(getLocalMillis(), amount);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If(i0 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  if (i0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.add($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalDate#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.LocalDate withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getLocalMillis();\r\n    Chronology chrono \u003d getChronology();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        long value \u003d FieldUtils.safeMultiply(period.getValue(i), scalar);\r\n        DurationFieldType type \u003d period.getFieldType(i);\r\n        if (isSupported(type)) {\r\n            instant \u003d type.getField(chrono).add(instant, value);\r\n        }\r\n    }\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i6 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  l5 \u003d r1.getLocalMillis()\n  r2 \u003d r1.getChronology()\n  i6 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i6 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  $i2 \u003d r0.getValue(i6)\n  $i3 \u003d FieldUtils.safeMultiply($i2, i0)\n  l4 \u003d (long) $i3\n  r4 \u003d r0.getFieldType(i6)\n  $z0 \u003d r1.isSupported(r4)\n  if ($z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r5 \u003d r4.getField(r2)\n  l5 \u003d $r5.add(l5, l4)\n}",
      "B7 {\n  i6 \u003d i6 + 1\n  goto B4\n}",
      "B8 {\n  $r3 \u003d r1.withLocalMillis(l5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalDate#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "plusYears",
    "signature": "org.joda.time.LocalDate plusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().add(getLocalMillis(), years);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "plusMonths",
    "signature": "org.joda.time.LocalDate plusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().add(getLocalMillis(), months);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "plusWeeks",
    "signature": "org.joda.time.LocalDate plusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().add(getLocalMillis(), weeks);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "plusDays",
    "signature": "org.joda.time.LocalDate plusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().add(getLocalMillis(), days);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "minusYears",
    "signature": "org.joda.time.LocalDate minusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().subtract(getLocalMillis(), years);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "minusMonths",
    "signature": "org.joda.time.LocalDate minusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().subtract(getLocalMillis(), months);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "minusWeeks",
    "signature": "org.joda.time.LocalDate minusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().subtract(getLocalMillis(), weeks);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "minusDays",
    "signature": "org.joda.time.LocalDate minusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().subtract(getLocalMillis(), days);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#withLocalMillis(...1)",
        "body": "{\r\n    newMillis \u003d iChronology.dayOfMonth().roundFloor(newMillis);\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "property",
    "signature": "org.joda.time.LocalDate$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, fieldType.getField(getChronology()));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r2 \u003d LocalDate$Property\n  $r3 \u003d r1.getChronology()\n  $r4 \u003d r0.getField($r3)\n  new LocalDate$Property(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDate#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationFieldType durType \u003d type.getDurationType();\r\n    if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() \u003e\u003d getChronology().days().getUnitMillis()) {\r\n        return type.getField(getChronology()).isSupported();\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.date().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDate",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDate\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDate#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.date().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "now",
    "signature": "org.joda.time.LocalDateTime now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new LocalDateTime(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalDateTime\n  new LocalDateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "now",
    "signature": "org.joda.time.LocalDateTime now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new LocalDateTime(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalDateTime\n  new LocalDateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.LocalDateTime fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    int era \u003d calendar.get(Calendar.ERA);\r\n    int yearOfEra \u003d calendar.get(Calendar.YEAR);\r\n    return new LocalDateTime((era \u003d\u003d GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  i0 \u003d r0.get(0)\n  i1 \u003d r0.get(1)\n  $r1 \u003d LocalDateTime\n  if (i0 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $i9 \u003d i1\n  goto B5\n}",
      "B4 {\n  $i9 \u003d 1 - i1\n}",
      "B5 {\n  $i2 \u003d r0.get(2)\n  $i8 \u003d $i2 + 1\n  $i7 \u003d r0.get(5)\n  $i6 \u003d r0.get(11)\n  $i5 \u003d r0.get(12)\n  $i4 \u003d r0.get(13)\n  $i3 \u003d r0.get(14)\n  new LocalDateTime($i9, $i8, $i7, $i6, $i5, $i4, $i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.LocalDateTime fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    if (date.getTime() \u003c 0) {\r\n        // handle years in era BC\r\n        GregorianCalendar cal \u003d new GregorianCalendar();\r\n        cal.setTime(date);\r\n        return fromCalendarFields(cal);\r\n    }\r\n    return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($i15 \u003e\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r5\n}",
      "B2 {\n  $l0 \u003d r0.getTime()\n  $b1 \u003d $l0 cmp 0L\n  $i15 \u003d (int) $b1\n  if ($i15 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d GregorianCalendar\n  new GregorianCalendar()\n  $r6.setTime(r0)\n  $r3 \u003d LocalDateTime.fromCalendarFields($r6)\n  return\n}",
      "B4 {\n  $r7 \u003d LocalDateTime\n  $i2 \u003d r0.getYear()\n  $i14 \u003d $i2 + 1900\n  $i3 \u003d r0.getMonth()\n  $i13 \u003d $i3 + 1\n  $i12 \u003d r0.getDate()\n  $i11 \u003d r0.getHours()\n  $i10 \u003d r0.getMinutes()\n  $i9 \u003d r0.getSeconds()\n  $l4 \u003d r0.getTime()\n  $l5 \u003d $l4 % 1000L\n  $i6 \u003d (int) $l5\n  $i7 \u003d $i6 + 1000\n  $i8 \u003d $i7 % 1000\n  new LocalDateTime($i14, $i13, $i12, $i11, $i10, $i9, $i8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#fromCalendarFields(...1)",
        "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    int era \u003d calendar.get(Calendar.ERA);\r\n    int yearOfEra \u003d calendar.get(Calendar.YEAR);\r\n    return new LocalDateTime((era \u003d\u003d GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "getValue",
    "signature": "int getValue(int)",
    "visibility": "public",
    "body": "{\r\n    switch(index) {\r\n        case YEAR:\r\n            return getChronology().year().get(getLocalMillis());\r\n        case MONTH_OF_YEAR:\r\n            return getChronology().monthOfYear().get(getLocalMillis());\r\n        case DAY_OF_MONTH:\r\n            return getChronology().dayOfMonth().get(getLocalMillis());\r\n        case MILLIS_OF_DAY:\r\n            return getChronology().millisOfDay().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  IndexOutOfBoundsException; }\n}",
      "B1 {\n  $r7 \u003d r0.getChronology()\n  $r8 \u003d $r7.year()\n  $l7 \u003d r0.getLocalMillis()\n  $i8 \u003d $r8.get($l7)\n  return\n}",
      "B2 {\n  $r5 \u003d r0.getChronology()\n  $r6 \u003d $r5.monthOfYear()\n  $l5 \u003d r0.getLocalMillis()\n  $i6 \u003d $r6.get($l5)\n  return\n}",
      "B3 {\n  $r3 \u003d r0.getChronology()\n  $r4 \u003d $r3.dayOfMonth()\n  $l3 \u003d r0.getLocalMillis()\n  $i4 \u003d $r4.get($l3)\n  return\n}",
      "B4 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millisOfDay()\n  $l1 \u003d r0.getLocalMillis()\n  $i2 \u003d $r2.get($l1)\n  return\n}",
      "B5 {\n  $r9 \u003d IndexOutOfBoundsException\n  $r10 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IndexOutOfBoundsException($r10)\n  throw $r9\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "get",
    "signature": "int get(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    return type.getField(getChronology()).get(getLocalMillis());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l0 \u003d r1.getLocalMillis()\n  $i1 \u003d $r3.get($l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    return type.getField(getChronology()).isSupported();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $z0 \u003d $r3.isSupported()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    return type.getField(getChronology()).isSupported();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DurationFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $z0 \u003d $r3.isSupported()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalDateTime) {\r\n        LocalDateTime other \u003d (LocalDateTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis \u003d\u003d other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($b2 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalDateTime\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d LocalDateTime) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z2 \u003d $r4.equals($r3)\n  if ($z2 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $l1 \u003d LocalDateTime: long iLocalMillis\u003e\n  $l0 \u003d LocalDateTime: long iLocalMillis\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z3 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z3 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z1 \u003d r0.equals(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "compareTo",
    "signature": "int compareTo(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return 0;\r\n    }\r\n    if (partial instanceof LocalDateTime) {\r\n        LocalDateTime other \u003d (LocalDateTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return (iLocalMillis \u003c other.iLocalMillis ? -1 : (iLocalMillis \u003d\u003d other.iLocalMillis ? 0 : 1));\r\n        }\r\n    }\r\n    return super.compareTo(partial);\r\n}",
    "nodes": 11,
    "edges": 13,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B10",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B10",
      "B4 : If($i8 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($b6 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  ReadablePartial\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalDateTime\n  if ($z0 \u003d\u003d false) goto B3 else B10\n}",
      "B3 {\n  r2 \u003d LocalDateTime) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B4 else B10\n}",
      "B4 {\n  $l2 \u003d LocalDateTime: long iLocalMillis\u003e\n  $l1 \u003d LocalDateTime: long iLocalMillis\u003e\n  $b3 \u003d $l2 cmp $l1\n  $i8 \u003d (int) $b3\n  if ($i8 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $b7 \u003d -1\n  goto B9\n}",
      "B6 {\n  $l5 \u003d LocalDateTime: long iLocalMillis\u003e\n  $l4 \u003d LocalDateTime: long iLocalMillis\u003e\n  $b6 \u003d $l5 cmp $l4\n  if ($b6 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $b7 \u003d 0\n  goto B9\n}",
      "B8 {\n  $b7 \u003d 1\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $i0 \u003d r0.compareTo(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "withFields",
    "signature": "org.joda.time.LocalDateTime withFields(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getLocalMillis()\n  $l1 \u003d $r2.set(r0, $l0)\n  $r3 \u003d r1.withLocalMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "withField",
    "signature": "org.joda.time.LocalDateTime withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).set(getLocalMillis(), value);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.set($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.LocalDateTime withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).add(getLocalMillis(), amount);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  if (i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.add($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "withDurationAdded",
    "signature": "org.joda.time.LocalDateTime withDurationAdded(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (durationToAdd \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $l2 \u003d r1.getLocalMillis()\n  $l1 \u003d r0.getMillis()\n  l3 \u003d $r2.add($l2, $l1, i0)\n  $r3 \u003d r1.withLocalMillis(l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.LocalDateTime withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(period, getLocalMillis(), scalar);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r2.add(r0, $l1, i0)\n  $r3 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusYears",
    "signature": "org.joda.time.LocalDateTime plusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().add(getLocalMillis(), years);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusMonths",
    "signature": "org.joda.time.LocalDateTime plusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().add(getLocalMillis(), months);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusWeeks",
    "signature": "org.joda.time.LocalDateTime plusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().add(getLocalMillis(), weeks);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusDays",
    "signature": "org.joda.time.LocalDateTime plusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().add(getLocalMillis(), days);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusHours",
    "signature": "org.joda.time.LocalDateTime plusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().add(getLocalMillis(), hours);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusMinutes",
    "signature": "org.joda.time.LocalDateTime plusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().add(getLocalMillis(), minutes);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusSeconds",
    "signature": "org.joda.time.LocalDateTime plusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().add(getLocalMillis(), seconds);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "plusMillis",
    "signature": "org.joda.time.LocalDateTime plusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().add(getLocalMillis(), millis);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusYears",
    "signature": "org.joda.time.LocalDateTime minusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().years().subtract(getLocalMillis(), years);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusMonths",
    "signature": "org.joda.time.LocalDateTime minusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().months().subtract(getLocalMillis(), months);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusWeeks",
    "signature": "org.joda.time.LocalDateTime minusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().weeks().subtract(getLocalMillis(), weeks);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusDays",
    "signature": "org.joda.time.LocalDateTime minusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().days().subtract(getLocalMillis(), days);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusHours",
    "signature": "org.joda.time.LocalDateTime minusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().subtract(getLocalMillis(), hours);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusMinutes",
    "signature": "org.joda.time.LocalDateTime minusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().subtract(getLocalMillis(), minutes);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusSeconds",
    "signature": "org.joda.time.LocalDateTime minusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().subtract(getLocalMillis(), seconds);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "minusMillis",
    "signature": "org.joda.time.LocalDateTime minusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().subtract(getLocalMillis(), millis);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "property",
    "signature": "org.joda.time.LocalDateTime$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, fieldType.getField(getChronology()));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r2 \u003d LocalDateTime$Property\n  $r3 \u003d r1.getChronology()\n  $r4 \u003d r0.getField($r3)\n  new LocalDateTime$Property(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalDateTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    return type.getField(getChronology()).isSupported();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.dateTime().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalDateTime",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalDateTime\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalDateTime#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.dateTime().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "now",
    "signature": "org.joda.time.LocalTime now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new LocalTime(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalTime\n  new LocalTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "now",
    "signature": "org.joda.time.LocalTime now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new LocalTime(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalTime\n  new LocalTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.LocalTime fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new LocalTime(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalTime\n  $i3 \u003d r0.get(11)\n  $i2 \u003d r0.get(12)\n  $i1 \u003d r0.get(13)\n  $i0 \u003d r0.get(14)\n  new LocalTime($i3, $i2, $i1, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.LocalTime fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new LocalTime(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d LocalTime\n  $i7 \u003d r0.getHours()\n  $i6 \u003d r0.getMinutes()\n  $i5 \u003d r0.getSeconds()\n  $l0 \u003d r0.getTime()\n  $l1 \u003d $l0 % 1000L\n  $i2 \u003d (int) $l1\n  $i3 \u003d $i2 + 1000\n  $i4 \u003d $i3 % 1000\n  new LocalTime($i7, $i6, $i5, $i4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "getValue",
    "signature": "int getValue(int)",
    "visibility": "public",
    "body": "{\r\n    switch(index) {\r\n        case HOUR_OF_DAY:\r\n            return getChronology().hourOfDay().get(getLocalMillis());\r\n        case MINUTE_OF_HOUR:\r\n            return getChronology().minuteOfHour().get(getLocalMillis());\r\n        case SECOND_OF_MINUTE:\r\n            return getChronology().secondOfMinute().get(getLocalMillis());\r\n        case MILLIS_OF_SECOND:\r\n            return getChronology().millisOfSecond().get(getLocalMillis());\r\n        default:\r\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  IndexOutOfBoundsException; }\n}",
      "B1 {\n  $r7 \u003d r0.getChronology()\n  $r8 \u003d $r7.hourOfDay()\n  $l7 \u003d r0.getLocalMillis()\n  $i8 \u003d $r8.get($l7)\n  return\n}",
      "B2 {\n  $r5 \u003d r0.getChronology()\n  $r6 \u003d $r5.minuteOfHour()\n  $l5 \u003d r0.getLocalMillis()\n  $i6 \u003d $r6.get($l5)\n  return\n}",
      "B3 {\n  $r3 \u003d r0.getChronology()\n  $r4 \u003d $r3.secondOfMinute()\n  $l3 \u003d r0.getLocalMillis()\n  $i4 \u003d $r4.get($l3)\n  return\n}",
      "B4 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millisOfSecond()\n  $l1 \u003d r0.getLocalMillis()\n  $i2 \u003d $r2.get($l1)\n  return\n}",
      "B5 {\n  $r9 \u003d IndexOutOfBoundsException\n  $r10 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IndexOutOfBoundsException($r10)\n  throw $r9\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "get",
    "signature": "int get(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    return fieldType.getField(getChronology()).get(getLocalMillis());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r7\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IllegalArgumentException\n  $r5 \u003d String.valueOf(r0)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IllegalArgumentException($r6)\n  throw $r4\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l0 \u003d r1.getLocalMillis()\n  $i1 \u003d $r3.get($l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B5 : If(r3 !\u003d $r4) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getDurationType()\n  $z0 \u003d r1.isSupported($r2)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r3 \u003d r0.getRangeDurationType()\n  $z1 \u003d r1.isSupported(r3)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d DurationFieldType.days()\n  if (r3 !\u003d $r4) goto B6 else B7\n}",
      "B6 {\n  $z2 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z2 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    DurationField field \u003d type.getField(getChronology());\r\n    if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() \u003c getChronology().days().getUnitMillis()) {\r\n        return field.isSupported();\r\n    }\r\n    return false;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B3 : If($i3 \u003e\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DurationFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  r3 \u003d r0.getField($r2)\n  $r4 \u003d Set TIME_DURATION_TYPES\u003e\n  $z0 \u003d $r4.contains(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $l1 \u003d r3.getUnitMillis()\n  $r5 \u003d r1.getChronology()\n  $r6 \u003d $r5.days()\n  $l0 \u003d $r6.getUnitMillis()\n  $b2 \u003d $l1 cmp $l0\n  $i3 \u003d (int) $b2\n  if ($i3 \u003e\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $z1 \u003d r3.isSupported()\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return true;\r\n    }\r\n    if (partial instanceof LocalTime) {\r\n        LocalTime other \u003d (LocalTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return iLocalMillis \u003d\u003d other.iLocalMillis;\r\n        }\r\n    }\r\n    return super.equals(partial);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($b2 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalTime\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d LocalTime) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z2 \u003d $r4.equals($r3)\n  if ($z2 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $l1 \u003d LocalTime: long iLocalMillis\u003e\n  $l0 \u003d LocalTime: long iLocalMillis\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z3 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z3 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z1 \u003d r0.equals(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "compareTo",
    "signature": "int compareTo(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    // override to perform faster\r\n    if (this \u003d\u003d partial) {\r\n        return 0;\r\n    }\r\n    if (partial instanceof LocalTime) {\r\n        LocalTime other \u003d (LocalTime) partial;\r\n        if (iChronology.equals(other.iChronology)) {\r\n            return (iLocalMillis \u003c other.iLocalMillis ? -1 : (iLocalMillis \u003d\u003d other.iLocalMillis ? 0 : 1));\r\n        }\r\n    }\r\n    return super.compareTo(partial);\r\n}",
    "nodes": 11,
    "edges": 13,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B10",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B10",
      "B4 : If($i8 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($b6 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  ReadablePartial\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LocalTime\n  if ($z0 \u003d\u003d false) goto B3 else B10\n}",
      "B3 {\n  r2 \u003d LocalTime) r1\n  $r4 \u003d Chronology iChronology\u003e\n  $r3 \u003d Chronology iChronology\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B4 else B10\n}",
      "B4 {\n  $l2 \u003d LocalTime: long iLocalMillis\u003e\n  $l1 \u003d LocalTime: long iLocalMillis\u003e\n  $b3 \u003d $l2 cmp $l1\n  $i8 \u003d (int) $b3\n  if ($i8 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $b7 \u003d -1\n  goto B9\n}",
      "B6 {\n  $l5 \u003d LocalTime: long iLocalMillis\u003e\n  $l4 \u003d LocalTime: long iLocalMillis\u003e\n  $b6 \u003d $l5 cmp $l4\n  if ($b6 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $b7 \u003d 0\n  goto B9\n}",
      "B8 {\n  $b7 \u003d 1\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $i0 \u003d r0.compareTo(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "withFields",
    "signature": "org.joda.time.LocalTime withFields(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getLocalMillis()\n  $l1 \u003d $r2.set(r0, $l0)\n  $r3 \u003d r1.withLocalMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "withField",
    "signature": "org.joda.time.LocalTime withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).set(getLocalMillis(), value);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.set($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.LocalTime withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d fieldType.getField(getChronology()).add(getLocalMillis(), amount);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If(i0 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  if (i0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r3.add($l1, i0)\n  $r4 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      },
      {
        "name": "LocalTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.LocalTime withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().add(period, getLocalMillis(), scalar);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $l1 \u003d r1.getLocalMillis()\n  l2 \u003d $r2.add(r0, $l1, i0)\n  $r3 \u003d r1.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "plusHours",
    "signature": "org.joda.time.LocalTime plusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().add(getLocalMillis(), hours);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "plusMinutes",
    "signature": "org.joda.time.LocalTime plusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().add(getLocalMillis(), minutes);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "plusSeconds",
    "signature": "org.joda.time.LocalTime plusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().add(getLocalMillis(), seconds);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "plusMillis",
    "signature": "org.joda.time.LocalTime plusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().add(getLocalMillis(), millis);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.add($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "minusHours",
    "signature": "org.joda.time.LocalTime minusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().hours().subtract(getLocalMillis(), hours);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "minusMinutes",
    "signature": "org.joda.time.LocalTime minusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().minutes().subtract(getLocalMillis(), minutes);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "minusSeconds",
    "signature": "org.joda.time.LocalTime minusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().seconds().subtract(getLocalMillis(), seconds);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "minusMillis",
    "signature": "org.joda.time.LocalTime minusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    long instant \u003d getChronology().millis().subtract(getLocalMillis(), millis);\r\n    return withLocalMillis(instant);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getLocalMillis()\n  l2 \u003d $r2.subtract($l1, i0)\n  $r3 \u003d r0.withLocalMillis(l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getLocalMillis(...0)",
        "body": "{\r\n    return iLocalMillis;\r\n}"
      },
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#withLocalMillis(...1)",
        "body": "{\r\n    return (newMillis \u003d\u003d getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "property",
    "signature": "org.joda.time.LocalTime$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    if (isSupported(fieldType) \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + fieldType + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, fieldType.getField(getChronology()));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r1.isSupported(r0)\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r2 \u003d LocalTime$Property\n  $r3 \u003d r1.getChronology()\n  $r4 \u003d r0.getField($r3)\n  new LocalTime$Property(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      },
      {
        "name": "LocalTime#isSupported(...1)",
        "body": "{\r\n    if (type \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (isSupported(type.getDurationType()) \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    DurationFieldType range \u003d type.getRangeDurationType();\r\n    return (isSupported(range) || range \u003d\u003d DurationFieldType.days());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.time().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.LocalTime",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LocalTime\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LocalTime#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.time().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "minutes",
    "signature": "org.joda.time.Minutes minutes(int)",
    "visibility": "public",
    "body": "{\r\n    switch(minutes) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Minutes(minutes);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 7,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B6 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Minutes; }\n}",
      "B1 {\n  $r4 \u003d Minutes ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d Minutes ONE\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d Minutes TWO\u003e\n  return\n}",
      "B4 {\n  $r1 \u003d Minutes THREE\u003e\n  return\n}",
      "B5 {\n  $r0 \u003d Minutes MAX_VALUE\u003e\n  return\n}",
      "B6 {\n  $r5 \u003d Minutes MIN_VALUE\u003e\n  return\n}",
      "B7 {\n  $r6 \u003d Minutes\n  new Minutes(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B6",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B7",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "minutesBetween",
    "signature": "org.joda.time.Minutes minutesBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalTime \u0026\u0026 end instanceof LocalTime) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int minutes \u003d chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Minutes.minutes(minutes);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Minutes.minutes(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalTime\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalTime\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.minutes()\n  $r5 \u003d LocalTime) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalTime) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Minutes.minutes(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Minutes ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Minutes.minutes($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "minutesIn",
    "signature": "org.joda.time.Minutes minutesIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Minutes.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\r\n    return Minutes.minutes(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Minutes ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.minutes()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Minutes.minutes(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "parseMinutes",
    "signature": "org.joda.time.Minutes parseMinutes(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Minutes.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Minutes.minutes(p.getMinutes());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Minutes ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getMinutes()\n  $r3 \u003d Minutes.minutes($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "plus",
    "signature": "org.joda.time.Minutes plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Minutes.minutes($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "plus",
    "signature": "org.joda.time.Minutes plus(org.joda.time.Minutes)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(minutes.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  Minutes\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#plus(...1)",
        "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "minus",
    "signature": "org.joda.time.Minutes minus(org.joda.time.Minutes)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(minutes.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  Minutes\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(minutes));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Minutes dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Minutes.minutes(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Minutes.minutes($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Minutes)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  Minutes\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Minutes",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Minutes)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Minutes\n  Minutes\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Minutes#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "now",
    "signature": "org.joda.time.MonthDay now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new MonthDay(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MonthDay\n  new MonthDay(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "now",
    "signature": "org.joda.time.MonthDay now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new MonthDay(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MonthDay\n  new MonthDay(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.MonthDay fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MonthDay\n  $i0 \u003d r0.get(2)\n  $i2 \u003d $i0 + 1\n  $i1 \u003d r0.get(5)\n  new MonthDay($i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.MonthDay fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new MonthDay(date.getMonth() + 1, date.getDate());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MonthDay\n  $i0 \u003d r0.getMonth()\n  $i2 \u003d $i0 + 1\n  $i1 \u003d r0.getDate()\n  new MonthDay($i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "withChronologyRetainFields",
    "signature": "org.joda.time.MonthDay withChronologyRetainFields(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    newChronology \u003d newChronology.withUTC();\r\n    if (newChronology \u003d\u003d getChronology()) {\r\n        return this;\r\n    } else {\r\n        MonthDay newMonthDay \u003d new MonthDay(this, newChronology);\r\n        newChronology.validate(newMonthDay, getValues());\r\n        return newMonthDay;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  Chronology\n  r5 \u003d DateTimeUtils.getChronology(r4)\n  r6 \u003d r5.withUTC()\n  $r1 \u003d r0.getChronology()\n  if (r6 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d MonthDay\n  new MonthDay(r0, r6)\n  $r3 \u003d r0.getValues()\n  r6.validate($r2, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "withField",
    "signature": "org.joda.time.MonthDay withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new MonthDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  $i2 \u003d r0.getValue(i0)\n  if (i1 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.set(r0, i0, r4, i1)\n  $r3 \u003d MonthDay\n  new MonthDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#indexOfSupported(...1)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#getValue(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.MonthDay withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).add(this, index, newValues, amount);\r\n    return new MonthDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.add(r0, i0, r4, i1)\n  $r3 \u003d MonthDay\n  new MonthDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.MonthDay withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        DurationFieldType fieldType \u003d period.getFieldType(i);\r\n        int index \u003d indexOf(fieldType);\r\n        if (index \u003e\u003d 0) {\r\n            newValues \u003d getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\r\n        }\r\n    }\r\n    return new MonthDay(this, newValues);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i5 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If(i2 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r5 \u003d r1.getValues()\n  i5 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i5 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  r3 \u003d r0.getFieldType(i5)\n  i2 \u003d r1.indexOf(r3)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getField(i2)\n  $i3 \u003d r0.getValue(i5)\n  $i4 \u003d FieldUtils.safeMultiply($i3, i0)\n  r5 \u003d $r4.add(r1, i2, r5, $i4)\n}",
      "B7 {\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B8 {\n  $r2 \u003d MonthDay\n  new MonthDay(r1, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "MonthDay#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#toString(...0)",
        "body": "{\r\n    List\u003cDateTimeFieldType\u003e fields \u003d new ArrayList\u003cDateTimeFieldType\u003e();\r\n    fields.add(DateTimeFieldType.monthOfYear());\r\n    fields.add(DateTimeFieldType.dayOfMonth());\r\n    return ISODateTimeFormat.forFields(fields, true, true).print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MonthDay",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MonthDay\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MonthDay#toString(...0)",
        "body": "{\r\n    List\u003cDateTimeFieldType\u003e fields \u003d new ArrayList\u003cDateTimeFieldType\u003e();\r\n    fields.add(DateTimeFieldType.monthOfYear());\r\n    fields.add(DateTimeFieldType.dayOfMonth());\r\n    return ISODateTimeFormat.forFields(fields, true, true).print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "months",
    "signature": "org.joda.time.Months months(int)",
    "visibility": "public",
    "body": "{\r\n    switch(months) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case 4:\r\n            return FOUR;\r\n        case 5:\r\n            return FIVE;\r\n        case 6:\r\n            return SIX;\r\n        case 7:\r\n            return SEVEN;\r\n        case 8:\r\n            return EIGHT;\r\n        case 9:\r\n            return NINE;\r\n        case 10:\r\n            return TEN;\r\n        case 11:\r\n            return ELEVEN;\r\n        case 12:\r\n            return TWELVE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Months(months);\r\n    }\r\n}",
    "nodes": 17,
    "edges": 16,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B15 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Months; }\n}",
      "B1 {\n  $r13 \u003d Months ZERO\u003e\n  return\n}",
      "B2 {\n  $r12 \u003d Months ONE\u003e\n  return\n}",
      "B3 {\n  $r11 \u003d Months TWO\u003e\n  return\n}",
      "B4 {\n  $r10 \u003d Months THREE\u003e\n  return\n}",
      "B5 {\n  $r9 \u003d Months FOUR\u003e\n  return\n}",
      "B6 {\n  $r8 \u003d Months FIVE\u003e\n  return\n}",
      "B7 {\n  $r7 \u003d Months SIX\u003e\n  return\n}",
      "B8 {\n  $r6 \u003d Months SEVEN\u003e\n  return\n}",
      "B9 {\n  $r5 \u003d Months EIGHT\u003e\n  return\n}",
      "B10 {\n  $r4 \u003d Months NINE\u003e\n  return\n}",
      "B11 {\n  $r3 \u003d Months TEN\u003e\n  return\n}",
      "B12 {\n  $r2 \u003d Months ELEVEN\u003e\n  return\n}",
      "B13 {\n  $r1 \u003d Months TWELVE\u003e\n  return\n}",
      "B14 {\n  $r0 \u003d Months MAX_VALUE\u003e\n  return\n}",
      "B15 {\n  $r14 \u003d Months MIN_VALUE\u003e\n  return\n}",
      "B16 {\n  $r15 \u003d Months\n  new Months(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B15",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B0 --\u003e B7",
      "B0 --\u003e B8",
      "B0 --\u003e B9",
      "B0 --\u003e B10",
      "B0 --\u003e B11",
      "B0 --\u003e B12",
      "B0 --\u003e B13",
      "B0 --\u003e B14",
      "B0 --\u003e B16",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "monthsBetween",
    "signature": "org.joda.time.Months monthsBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalDate \u0026\u0026 end instanceof LocalDate) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int months \u003d chrono.months().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Months.months(months);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Months.months(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalDate\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.months()\n  $r5 \u003d LocalDate) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalDate) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Months.months(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Months ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Months.months($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "monthsIn",
    "signature": "org.joda.time.Months monthsIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Months.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\r\n    return Months.months(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Months ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.months()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Months.months(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "parseMonths",
    "signature": "org.joda.time.Months parseMonths(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Months.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Months.months(p.getMonths());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Months ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getMonths()\n  $r3 \u003d Months.months($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "plus",
    "signature": "org.joda.time.Months plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Months.months(FieldUtils.safeAdd(getValue(), months));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Months\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Months.months($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "plus",
    "signature": "org.joda.time.Months plus(org.joda.time.Months)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(months.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Months\n  Months\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#plus(...1)",
        "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Months.months(FieldUtils.safeAdd(getValue(), months));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "minus",
    "signature": "org.joda.time.Months minus(org.joda.time.Months)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(months.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Months\n  Months\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(months));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Months dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Months.months(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Months\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Months.months($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Months)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Months\n  Months\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Months",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Months)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Months\n  Months\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Months#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "now",
    "signature": "org.joda.time.MutableDateTime now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new MutableDateTime(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MutableDateTime\n  new MutableDateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "now",
    "signature": "org.joda.time.MutableDateTime now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new MutableDateTime(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d MutableDateTime\n  new MutableDateTime(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setRounding",
    "signature": "void setRounding(org.joda.time.DateTimeField,int)",
    "visibility": "public",
    "body": "{\r\n    if (field !\u003d null \u0026\u0026 (mode \u003c ROUND_NONE || mode \u003e ROUND_HALF_EVEN)) {\r\n        throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\r\n    }\r\n    iRoundingField \u003d (mode \u003d\u003d ROUND_NONE ? null : field);\r\n    iRoundingMode \u003d (field \u003d\u003d null ? ROUND_NONE : mode);\r\n    setMillis(getMillis());\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B4",
      "B1 : If(i0 \u003c 0) → B2 | else → B3",
      "B2 : If(i0 \u003c\u003d 5) → B3 | else → B4",
      "B4 : If(i0 !\u003d 0) → B5 | else → B6",
      "B7 : If(r0 !\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DateTimeField\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  if (i0 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  if (i0 \u003c\u003d 5) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d IllegalArgumentException\n  $r3 \u003d dynInvoke makeConcatWithConstants(i0)\n  new IllegalArgumentException($r3)\n  throw $r2\n}",
      "B4 {\n  if (i0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d null\n  goto B7\n}",
      "B6 {\n  $r4 \u003d r0\n}",
      "B7 {\n  DateTimeField iRoundingField\u003e \u003d $r4\n  if (r0 !\u003d null) goto B8 else B9\n}",
      "B8 {\n  $i2 \u003d 0\n  goto B10\n}",
      "B9 {\n  $i2 \u003d i0\n}",
      "B10 {\n  MutableDateTime: int iRoundingMode\u003e \u003d $i2\n  $l1 \u003d r1.getMillis()\n  r1.setMillis($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setMillis",
    "signature": "void setMillis(long)",
    "visibility": "public",
    "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}",
    "nodes": 8,
    "edges": 13,
    "cc": 7,
    "flowSummary": [
      "B0 : If(switch-on $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  l1 :\u003d @parameter0: long\n  $i0 \u003d MutableDateTime: int iRoundingMode\u003e\n  BaseDateTime: void setMillis(long)\u003e(l1); }\n}",
      "B1 {\n  goto B7\n}",
      "B2 {\n  $r5 \u003d DateTimeField iRoundingField\u003e\n  l1 \u003d $r5.roundFloor(l1)\n  goto B7\n}",
      "B3 {\n  $r4 \u003d DateTimeField iRoundingField\u003e\n  l1 \u003d $r4.roundCeiling(l1)\n  goto B7\n}",
      "B4 {\n  $r3 \u003d DateTimeField iRoundingField\u003e\n  l1 \u003d $r3.roundHalfFloor(l1)\n  goto B7\n}",
      "B5 {\n  $r2 \u003d DateTimeField iRoundingField\u003e\n  l1 \u003d $r2.roundHalfCeiling(l1)\n  goto B7\n}",
      "B6 {\n  $r1 \u003d DateTimeField iRoundingField\u003e\n  l1 \u003d $r1.roundHalfEven(l1)\n}",
      "B7 {\n  r0.setMillis(l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B0 --\u003e B7",
      "B1 --\u003e B7",
      "B2 --\u003e B7",
      "B3 --\u003e B7",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "add",
    "signature": "void add(org.joda.time.ReadableDuration,int)",
    "visibility": "public",
    "body": "{\r\n    if (duration !\u003d null) {\r\n        add(FieldUtils.safeMultiply(duration.getMillis(), scalar));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  ReadableDuration\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d FieldUtils.safeMultiply($l1, i0)\n  r1.add($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#add(...1)",
        "body": "{\r\n    // set via this class not super\r\n    setMillis(FieldUtils.safeAdd(getMillis(), duration));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "add",
    "signature": "void add(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period !\u003d null) {\r\n        // set via this class not super\r\n        setMillis(getChronology().add(period, getMillis(), scalar));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1.getChronology()\n  $l1 \u003d r1.getMillis()\n  $l2 \u003d $r2.add(r0, $l1, i0)\n  r1.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setZone",
    "signature": "void setZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    newZone \u003d DateTimeUtils.getZone(newZone);\r\n    Chronology chrono \u003d getChronology();\r\n    if (chrono.getZone() !\u003d newZone) {\r\n        // set via this class not super\r\n        setChronology(chrono.withZone(newZone));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d r5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DateTimeZone\n  r5 \u003d DateTimeUtils.getZone(r4)\n  r1 \u003d r0.getChronology()\n  $r2 \u003d r1.getZone()\n  if ($r2 \u003d\u003d r5) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.withZone(r5)\n  r0.setChronology($r3)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#setChronology(...1)",
        "body": "{\r\n    super.setChronology(chronology);\r\n}"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setZoneRetainFields",
    "signature": "void setZoneRetainFields(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    newZone \u003d DateTimeUtils.getZone(newZone);\r\n    DateTimeZone originalZone \u003d DateTimeUtils.getZone(getZone());\r\n    if (newZone \u003d\u003d originalZone) {\r\n        return;\r\n    }\r\n    long millis \u003d originalZone.getMillisKeepLocal(newZone, getMillis());\r\n    // set via this class not super\r\n    setChronology(getChronology().withZone(newZone));\r\n    setMillis(millis);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 !\u003d r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DateTimeZone\n  r6 \u003d DateTimeUtils.getZone(r5)\n  $r1 \u003d r0.getZone()\n  r2 \u003d DateTimeUtils.getZone($r1)\n  if (r6 !\u003d r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d r0.getMillis()\n  l1 \u003d r2.getMillisKeepLocal(r6, $l0)\n  $r3 \u003d r0.getChronology()\n  $r4 \u003d $r3.withZone(r6)\n  r0.setChronology($r4)\n  r0.setMillis(l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setChronology(...1)",
        "body": "{\r\n    super.setChronology(chronology);\r\n}"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "set",
    "signature": "void set(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    setMillis(type.getField(getChronology()).set(getMillis(), value));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DateTimeFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r4\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  $l2 \u003d $r3.set($l1, i0)\n  r1.setMillis($l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "add",
    "signature": "void add(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (amount !\u003d 0) {\r\n        setMillis(type.getField(getChronology()).add(getMillis(), amount));\r\n    }\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r4\n}",
      "B2 {\n  if (i0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d r1.getChronology()\n  $r3 \u003d r0.getField($r2)\n  $l1 \u003d r1.getMillis()\n  $l2 \u003d $r3.add($l1, i0)\n  r1.setMillis($l2)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addYears",
    "signature": "void addYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years !\u003d 0) {\r\n        setMillis(getChronology().years().add(getMillis(), years));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.years()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addWeekyears",
    "signature": "void addWeekyears(int)",
    "visibility": "public",
    "body": "{\r\n    if (weekyears !\u003d 0) {\r\n        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weekyears()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addMonths",
    "signature": "void addMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months !\u003d 0) {\r\n        setMillis(getChronology().months().add(getMillis(), months));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.months()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addWeeks",
    "signature": "void addWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks !\u003d 0) {\r\n        setMillis(getChronology().weeks().add(getMillis(), weeks));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.weeks()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addDays",
    "signature": "void addDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days !\u003d 0) {\r\n        setMillis(getChronology().days().add(getMillis(), days));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.days()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addHours",
    "signature": "void addHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours !\u003d 0) {\r\n        setMillis(getChronology().hours().add(getMillis(), hours));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.hours()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addMinutes",
    "signature": "void addMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes !\u003d 0) {\r\n        setMillis(getChronology().minutes().add(getMillis(), minutes));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.minutes()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addSeconds",
    "signature": "void addSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds !\u003d 0) {\r\n        setMillis(getChronology().seconds().add(getMillis(), seconds));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.seconds()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "addMillis",
    "signature": "void addMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis !\u003d 0) {\r\n        setMillis(getChronology().millis().add(getMillis(), millis));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  i0 :\u003d @parameter0: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getChronology()\n  $r2 \u003d $r1.millis()\n  $l1 \u003d r0.getMillis()\n  $l2 \u003d $r2.add($l1, i0)\n  r0.setMillis($l2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setMillis(...1)",
        "body": "{\r\n    switch(iRoundingMode) {\r\n        case ROUND_NONE:\r\n            break;\r\n        case ROUND_FLOOR:\r\n            instant \u003d iRoundingField.roundFloor(instant);\r\n            break;\r\n        case ROUND_CEILING:\r\n            instant \u003d iRoundingField.roundCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_FLOOR:\r\n            instant \u003d iRoundingField.roundHalfFloor(instant);\r\n            break;\r\n        case ROUND_HALF_CEILING:\r\n            instant \u003d iRoundingField.roundHalfCeiling(instant);\r\n            break;\r\n        case ROUND_HALF_EVEN:\r\n            instant \u003d iRoundingField.roundHalfEven(instant);\r\n            break;\r\n    }\r\n    super.setMillis(instant);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setDate",
    "signature": "void setDate(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    long instantMillis \u003d DateTimeUtils.getInstantMillis(instant);\r\n    if (instant instanceof ReadableDateTime) {\r\n        ReadableDateTime rdt \u003d (ReadableDateTime) instant;\r\n        Chronology instantChrono \u003d DateTimeUtils.getChronology(rdt.getChronology());\r\n        DateTimeZone zone \u003d instantChrono.getZone();\r\n        if (zone !\u003d null) {\r\n            instantMillis \u003d zone.getMillisKeepLocal(getZone(), instantMillis);\r\n        }\r\n    }\r\n    setDate(instantMillis);\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If(r5 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  ReadableInstant\n  l0 \u003d DateTimeUtils.getInstantMillis(r0)\n  $z0 \u003d ReadableDateTime\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  r2 \u003d ReadableDateTime) r0\n  $r3 \u003d r2.getChronology()\n  r4 \u003d DateTimeUtils.getChronology($r3)\n  r5 \u003d r4.getZone()\n  if (r5 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d r1.getZone()\n  l0 \u003d r5.getMillisKeepLocal($r6, l0)\n}",
      "B3 {\n  r1.setDate(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getZone(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableDateTime#setDate(...1)",
        "body": "{\r\n    setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "setTime",
    "signature": "void setTime(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    long instantMillis \u003d DateTimeUtils.getInstantMillis(instant);\r\n    Chronology instantChrono \u003d DateTimeUtils.getInstantChronology(instant);\r\n    DateTimeZone zone \u003d instantChrono.getZone();\r\n    if (zone !\u003d null) {\r\n        instantMillis \u003d zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\r\n    }\r\n    setTime(instantMillis);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  ReadableInstant\n  l0 \u003d DateTimeUtils.getInstantMillis(r0)\n  r1 \u003d DateTimeUtils.getInstantChronology(r0)\n  r2 \u003d r1.getZone()\n  if (r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DateTimeZone UTC\u003e\n  l0 \u003d r2.getMillisKeepLocal($r4, l0)\n}",
      "B2 {\n  r3.setTime(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#setTime(...1)",
        "body": "{\r\n    int millisOfDay \u003d ISOChronology.getInstanceUTC().millisOfDay().get(millis);\r\n    setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableDateTime",
    "methodName": "property",
    "signature": "org.joda.time.MutableDateTime$Property property(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\r\n    }\r\n    DateTimeField field \u003d type.getField(getChronology());\r\n    if (field.isSupported() \u003d\u003d false) {\r\n        throw new IllegalArgumentException(\"Field \u0027\" + type + \"\u0027 is not supported\");\r\n    }\r\n    return new Property(this, field);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  MutableDateTime\n  DateTimeFieldType\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The DateTimeFieldType must not be null\")\n  throw $r8\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  r3 \u003d r0.getField($r2)\n  $z0 \u003d r3.isSupported()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d String.valueOf(r0)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalArgumentException($r7)\n  throw $r5\n}",
      "B4 {\n  $r4 \u003d MutableDateTime$Property\n  new MutableDateTime$Property(r1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableDateTime#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableInterval",
    "methodName": "setInterval",
    "signature": "void setInterval(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Interval must not be null\");\r\n    }\r\n    long startMillis \u003d interval.getStartMillis();\r\n    long endMillis \u003d interval.getEndMillis();\r\n    Chronology chrono \u003d interval.getChronology();\r\n    super.setInterval(startMillis, endMillis, chrono);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableInterval\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Interval must not be null\")\n  throw $r3\n}",
      "B2 {\n  l0 \u003d r0.getStartMillis()\n  l1 \u003d r0.getEndMillis()\n  r1 \u003d r0.getChronology()\n  r2.setInterval(l0, l1, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.MutableInterval",
    "methodName": "setInterval",
    "signature": "void setInterval(org.joda.time.ReadableInstant,org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    if (start \u003d\u003d null \u0026\u0026 end \u003d\u003d null) {\r\n        long now \u003d DateTimeUtils.currentTimeMillis();\r\n        setInterval(now, now);\r\n    } else {\r\n        long startMillis \u003d DateTimeUtils.getInstantMillis(start);\r\n        long endMillis \u003d DateTimeUtils.getInstantMillis(end);\r\n        Chronology chrono \u003d DateTimeUtils.getInstantChronology(start);\r\n        super.setInterval(startMillis, endMillis, chrono);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B3",
      "B1 : If(r1 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  MutableInterval\n  ReadableInstant\n  ReadableInstant\n  if (r0 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  if (r1 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  l2 \u003d DateTimeUtils.currentTimeMillis()\n  r2.setInterval(l2, l2)\n  goto B4\n}",
      "B3 {\n  $l0 \u003d DateTimeUtils.getInstantMillis(r0)\n  $l1 \u003d DateTimeUtils.getInstantMillis(r1)\n  $r3 \u003d DateTimeUtils.getInstantChronology(r0)\n  r2.setInterval($l0, $l1, $r3)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableInterval#setInterval(...2)",
        "body": "{\r\n    super.setInterval(startInstant, endInstant, getChronology());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableInterval",
    "methodName": "setPeriodAfterStart",
    "signature": "void setPeriodAfterStart(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        setEndMillis(getStartMillis());\r\n    } else {\r\n        setEndMillis(getChronology().add(period, getStartMillis(), 1));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableInterval\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l2 \u003d r1.getStartMillis()\n  r1.setEndMillis($l2)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getStartMillis()\n  $l1 \u003d $r2.add(r0, $l0, 1)\n  r1.setEndMillis($l1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableInterval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableInterval#getStartMillis(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableInterval#setEndMillis(...1)",
        "body": "{\r\n    super.setInterval(getStartMillis(), endInstant, getChronology());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutableInterval",
    "methodName": "setPeriodBeforeEnd",
    "signature": "void setPeriodBeforeEnd(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        setStartMillis(getEndMillis());\r\n    } else {\r\n        setStartMillis(getChronology().add(period, getEndMillis(), -1));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutableInterval\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l2 \u003d r1.getEndMillis()\n  r1.setStartMillis($l2)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1.getChronology()\n  $l0 \u003d r1.getEndMillis()\n  $i4 \u003d (int) -1\n  $l1 \u003d $r2.add(r0, $l0, $i4)\n  r1.setStartMillis($l1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutableInterval#getChronology(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutableInterval#setStartMillis(...1)",
        "body": "{\r\n    super.setInterval(startInstant, getEndMillis(), getChronology());\r\n}"
      },
      {
        "name": "MutableInterval#getEndMillis(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutablePeriod",
    "methodName": "setPeriod",
    "signature": "void setPeriod(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        setPeriod(0L);\r\n    } else {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(interval.getChronology());\r\n        setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutablePeriod\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3.setPeriod(0L)\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getChronology()\n  r2 \u003d DateTimeUtils.getChronology($r1)\n  $l1 \u003d r0.getStartMillis()\n  $l0 \u003d r0.getEndMillis()\n  r3.setPeriod($l1, $l0, r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutablePeriod#setPeriod(...1)",
        "body": "{\r\n    super.setPeriod(period);\r\n}"
      },
      {
        "name": "MutablePeriod#setPeriod(...3)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    setValues(chrono.get(this, startInstant, endInstant));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutablePeriod",
    "methodName": "setPeriod",
    "signature": "void setPeriod(org.joda.time.ReadableInstant,org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    if (start \u003d\u003d end) {\r\n        setPeriod(0L);\r\n    } else {\r\n        long startMillis \u003d DateTimeUtils.getInstantMillis(start);\r\n        long endMillis \u003d DateTimeUtils.getInstantMillis(end);\r\n        Chronology chrono \u003d DateTimeUtils.getIntervalChronology(start, end);\r\n        setPeriod(startMillis, endMillis, chrono);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutablePeriod\n  ReadableInstant\n  ReadableInstant\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  r3.setPeriod(0L)\n  goto B3\n}",
      "B2 {\n  l0 \u003d DateTimeUtils.getInstantMillis(r0)\n  l1 \u003d DateTimeUtils.getInstantMillis(r1)\n  r2 \u003d DateTimeUtils.getIntervalChronology(r0, r1)\n  r3.setPeriod(l0, l1, r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutablePeriod#setPeriod(...1)",
        "body": "{\r\n    super.setPeriod(period);\r\n}"
      },
      {
        "name": "MutablePeriod#setPeriod(...3)",
        "body": "{\r\n    chrono \u003d DateTimeUtils.getChronology(chrono);\r\n    setValues(chrono.get(this, startInstant, endInstant));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutablePeriod",
    "methodName": "add",
    "signature": "void add(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval !\u003d null) {\r\n        add(interval.toPeriod(getPeriodType()));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutablePeriod\n  ReadableInterval\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1.getPeriodType()\n  $r3 \u003d r0.toPeriod($r2)\n  r1.add($r3)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutablePeriod#getPeriodType(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutablePeriod#add(...1)",
        "body": "{\r\n    super.addPeriod(period);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.MutablePeriod",
    "methodName": "add",
    "signature": "void add(org.joda.time.ReadableDuration)",
    "visibility": "public",
    "body": "{\r\n    if (duration !\u003d null) {\r\n        add(new Period(duration.getMillis(), getPeriodType()));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MutablePeriod\n  ReadableDuration\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Period\n  $l0 \u003d r0.getMillis()\n  $r3 \u003d r1.getPeriodType()\n  new Period($l0, $r3)\n  r1.add($r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MutablePeriod#getPeriodType(...0)",
        "body": "(source not found)"
      },
      {
        "name": "MutablePeriod#add(...1)",
        "body": "{\r\n    super.addPeriod(period);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "withChronologyRetainFields",
    "signature": "org.joda.time.Partial withChronologyRetainFields(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    newChronology \u003d newChronology.withUTC();\r\n    if (newChronology \u003d\u003d getChronology()) {\r\n        return this;\r\n    } else {\r\n        Partial newPartial \u003d new Partial(newChronology, iTypes, iValues);\r\n        newChronology.validate(newPartial, iValues);\r\n        return newPartial;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r8 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  Chronology\n  r7 \u003d DateTimeUtils.getChronology(r6)\n  r8 \u003d r7.withUTC()\n  $r1 \u003d r0.getChronology()\n  if (r8 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Partial\n  $r4 \u003d DateTimeFieldType[] iTypes\u003e\n  $r3 \u003d Partial: int[] iValues\u003e\n  new Partial(r8, $r4, $r3)\n  $r5 \u003d Partial: int[] iValues\u003e\n  r8.validate($r2, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getChronology(...0)",
        "body": "{\r\n    return iChronology;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "with",
    "signature": "org.joda.time.Partial \u0027with\u0027(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (fieldType \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The field type must not be null\");\r\n    }\r\n    int index \u003d indexOf(fieldType);\r\n    if (index \u003d\u003d -1) {\r\n        DateTimeFieldType[] newTypes \u003d new DateTimeFieldType[iTypes.length + 1];\r\n        int[] newValues \u003d new int[newTypes.length];\r\n        // find correct insertion point to keep largest-smallest order\r\n        int i \u003d 0;\r\n        DurationField unitField \u003d fieldType.getDurationType().getField(iChronology);\r\n        if (unitField.isSupported()) {\r\n            for (; i \u003c iTypes.length; i++) {\r\n                DateTimeFieldType loopType \u003d iTypes[i];\r\n                DurationField loopUnitField \u003d loopType.getDurationType().getField(iChronology);\r\n                if (loopUnitField.isSupported()) {\r\n                    int compare \u003d unitField.compareTo(loopUnitField);\r\n                    if (compare \u003e 0) {\r\n                        break;\r\n                    } else if (compare \u003d\u003d 0) {\r\n                        if (fieldType.getRangeDurationType() \u003d\u003d null) {\r\n                            break;\r\n                        }\r\n                        if (loopType.getRangeDurationType() \u003d\u003d null) {\r\n                            continue;\r\n                        }\r\n                        DurationField rangeField \u003d fieldType.getRangeDurationType().getField(iChronology);\r\n                        DurationField loopRangeField \u003d loopType.getRangeDurationType().getField(iChronology);\r\n                        if (rangeField.compareTo(loopRangeField) \u003e 0) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\r\n        System.arraycopy(iValues, 0, newValues, 0, i);\r\n        newTypes[i] \u003d fieldType;\r\n        newValues[i] \u003d value;\r\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\r\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\r\n        // use public constructor to ensure full validation\r\n        // this isn\u0027t overly efficient, but is safe\r\n        Partial newPartial \u003d new Partial(newTypes, newValues, iChronology);\r\n        iChronology.validate(newPartial, newValues);\r\n        return newPartial;\r\n    }\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new Partial(this, newValues);\r\n}",
    "nodes": 20,
    "edges": 27,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d $i19) → B3 | else → B17",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B16",
      "B4 : If(i9 \u003e\u003d $i6) → B5 | else → B16",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B15",
      "B6 : If(i7 \u003c\u003d 0) → B7 | else → B8",
      "B8 : If(i7 !\u003d 0) → B9 | else → B15",
      "B9 : If($r14 !\u003d null) → B10 | else → B11",
      "B11 : If($r15 !\u003d null) → B12 | else → B13",
      "B13 : If($i8 \u003c\u003d 0) → B14 | else → B15",
      "B17 : If(i1 !\u003d $i2) → B18 | else → B19"
    ],
    "blockList": [
      "B0 {\n  Partial\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r34 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The field type must not be null\")\n  throw $r34\n}",
      "B2 {\n  i0 \u003d r1.indexOf(r0)\n  $i19 \u003d (int) -1\n  if (i0 !\u003d $i19) goto B3 else B17\n}",
      "B3 {\n  $r4 \u003d DateTimeFieldType[] iTypes\u003e\n  $i3 \u003d lengthof $r4\n  $i4 \u003d $i3 + 1\n  r23 \u003d DateTimeFieldType)[$i4]\n  $i5 \u003d lengthof r23\n  r5 \u003d newarray (int)[$i5]\n  i9 \u003d 0\n  $r7 \u003d r0.getDurationType()\n  $r6 \u003d Chronology iChronology\u003e\n  r8 \u003d $r7.getField($r6)\n  $z0 \u003d r8.isSupported()\n  if ($z0 \u003d\u003d false) goto B4 else B16\n}",
      "B4 {\n  $r9 \u003d DateTimeFieldType[] iTypes\u003e\n  $i6 \u003d lengthof $r9\n  if (i9 \u003e\u003d $i6) goto B5 else B16\n}",
      "B5 {\n  $r10 \u003d DateTimeFieldType[] iTypes\u003e\n  r24 \u003d $r10[i9]\n  $r12 \u003d r24.getDurationType()\n  $r11 \u003d Chronology iChronology\u003e\n  r13 \u003d $r12.getField($r11)\n  $z1 \u003d r13.isSupported()\n  if ($z1 \u003d\u003d false) goto B6 else B15\n}",
      "B6 {\n  i7 \u003d r8.compareTo(r13)\n  if (i7 \u003c\u003d 0) goto B7 else B8\n}",
      "B7 {\n  goto B16\n}",
      "B8 {\n  if (i7 !\u003d 0) goto B9 else B15\n}",
      "B9 {\n  $r14 \u003d r0.getRangeDurationType()\n  if ($r14 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  goto B16\n}",
      "B11 {\n  $r15 \u003d r24.getRangeDurationType()\n  if ($r15 !\u003d null) goto B12 else B13\n}",
      "B12 {\n  goto B15\n}",
      "B13 {\n  $r17 \u003d r0.getRangeDurationType()\n  $r16 \u003d Chronology iChronology\u003e\n  r18 \u003d $r17.getField($r16)\n  $r20 \u003d r24.getRangeDurationType()\n  $r19 \u003d Chronology iChronology\u003e\n  r21 \u003d $r20.getField($r19)\n  $i8 \u003d r18.compareTo(r21)\n  if ($i8 \u003c\u003d 0) goto B14 else B15\n}",
      "B14 {\n  goto B16\n}",
      "B15 {\n  i9 \u003d i9 + 1\n  goto B4\n}",
      "B16 {\n  $r25 \u003d DateTimeFieldType[] iTypes\u003e\n  System.arraycopy($r25, 0, r23, 0, i9)\n  $r26 \u003d Partial: int[] iValues\u003e\n  System.arraycopy($r26, 0, r5, 0, i9)\n  r23[i9] \u003d r0\n  r5[i9] \u003d i1\n  $r27 \u003d DateTimeFieldType[] iTypes\u003e\n  $i10 \u003d i9 + 1\n  $i11 \u003d lengthof r23\n  $i12 \u003d $i11 - i9\n  $i13 \u003d $i12 - 1\n  System.arraycopy($r27, i9, r23, $i10, $i13)\n  $r28 \u003d Partial: int[] iValues\u003e\n  $i14 \u003d i9 + 1\n  $i15 \u003d lengthof r5\n  $i16 \u003d $i15 - i9\n  $i17 \u003d $i16 - 1\n  System.arraycopy($r28, i9, r5, $i14, $i17)\n  $r35 \u003d Partial\n  $r30 \u003d Chronology iChronology\u003e\n  new Partial(r23, r5, $r30)\n  $r31 \u003d Chronology iChronology\u003e\n  $r31.validate($r35, r5)\n  return\n}",
      "B17 {\n  $i2 \u003d r1.getValue(i0)\n  if (i1 !\u003d $i2) goto B18 else B19\n}",
      "B18 {\n  return\n}",
      "B19 {\n  r32 \u003d r1.getValues()\n  $r2 \u003d r1.getField(i0)\n  r33 \u003d $r2.set(r1, i0, r32, i1)\n  $r36 \u003d Partial\n  new Partial(r1, r33)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B17",
      "B3 --\u003e B4",
      "B3 --\u003e B16",
      "B4 --\u003e B5",
      "B4 --\u003e B16",
      "B5 --\u003e B6",
      "B5 --\u003e B15",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B16",
      "B8 --\u003e B9",
      "B8 --\u003e B15",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B4",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getValues(...0)",
        "body": "{\r\n    return (int[]) iValues.clone();\r\n}"
      },
      {
        "name": "Partial#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#getValue(...1)",
        "body": "{\r\n    return iValues[index];\r\n}"
      },
      {
        "name": "Partial#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "without",
    "signature": "org.joda.time.Partial without(org.joda.time.DateTimeFieldType)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOf(fieldType);\r\n    if (index !\u003d -1) {\r\n        DateTimeFieldType[] newTypes \u003d new DateTimeFieldType[size() - 1];\r\n        int[] newValues \u003d new int[size() - 1];\r\n        System.arraycopy(iTypes, 0, newTypes, 0, index);\r\n        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\r\n        System.arraycopy(iValues, 0, newValues, 0, index);\r\n        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\r\n        Partial newPartial \u003d new Partial(iChronology, newTypes, newValues);\r\n        iChronology.validate(newPartial, newValues);\r\n        return newPartial;\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d $i12) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  DateTimeFieldType\n  i0 \u003d r0.indexOf(r1)\n  $i12 \u003d (int) -1\n  if (i0 \u003d\u003d $i12) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d r0.size()\n  $i2 \u003d $i1 - 1\n  r2 \u003d DateTimeFieldType)[$i2]\n  $i3 \u003d r0.size()\n  $i4 \u003d $i3 - 1\n  r3 \u003d newarray (int)[$i4]\n  $r4 \u003d DateTimeFieldType[] iTypes\u003e\n  System.arraycopy($r4, 0, r2, 0, i0)\n  $r5 \u003d DateTimeFieldType[] iTypes\u003e\n  $i7 \u003d i0 + 1\n  $i5 \u003d lengthof r2\n  $i6 \u003d $i5 - i0\n  System.arraycopy($r5, $i7, r2, i0, $i6)\n  $r6 \u003d Partial: int[] iValues\u003e\n  System.arraycopy($r6, 0, r3, 0, i0)\n  $r7 \u003d Partial: int[] iValues\u003e\n  $i10 \u003d i0 + 1\n  $i8 \u003d lengthof r3\n  $i9 \u003d $i8 - i0\n  System.arraycopy($r7, $i10, r3, i0, $i9)\n  $r11 \u003d Partial\n  $r9 \u003d Chronology iChronology\u003e\n  new Partial($r9, r2, r3)\n  $r10 \u003d Chronology iChronology\u003e\n  $r10.validate($r11, r3)\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#size(...0)",
        "body": "{\r\n    return iTypes.length;\r\n}"
      },
      {
        "name": "Partial#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "withField",
    "signature": "org.joda.time.Partial withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new Partial(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  $i2 \u003d r0.getValue(i0)\n  if (i1 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.set(r0, i0, r4, i1)\n  $r3 \u003d Partial\n  new Partial(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getValues(...0)",
        "body": "{\r\n    return (int[]) iValues.clone();\r\n}"
      },
      {
        "name": "Partial#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#indexOfSupported(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#getValue(...1)",
        "body": "{\r\n    return iValues[index];\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.Partial withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).add(this, index, newValues, amount);\r\n    return new Partial(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.add(r0, i0, r4, i1)\n  $r3 \u003d Partial\n  new Partial(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getValues(...0)",
        "body": "{\r\n    return (int[]) iValues.clone();\r\n}"
      },
      {
        "name": "Partial#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "withFieldAddWrapped",
    "signature": "org.joda.time.Partial withFieldAddWrapped(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).addWrapPartial(this, index, newValues, amount);\r\n    return new Partial(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.addWrapPartial(r0, i0, r4, i1)\n  $r3 \u003d Partial\n  new Partial(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getValues(...0)",
        "body": "{\r\n    return (int[]) iValues.clone();\r\n}"
      },
      {
        "name": "Partial#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.Partial withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        DurationFieldType fieldType \u003d period.getFieldType(i);\r\n        int index \u003d indexOf(fieldType);\r\n        if (index \u003e\u003d 0) {\r\n            newValues \u003d getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\r\n        }\r\n    }\r\n    return new Partial(this, newValues);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i5 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If(i2 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Partial\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r5 \u003d r1.getValues()\n  i5 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i5 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  r3 \u003d r0.getFieldType(i5)\n  i2 \u003d r1.indexOf(r3)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getField(i2)\n  $i3 \u003d r0.getValue(i5)\n  $i4 \u003d FieldUtils.safeMultiply($i3, i0)\n  r5 \u003d $r4.add(r1, i2, r5, $i4)\n}",
      "B7 {\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B8 {\n  $r2 \u003d Partial\n  new Partial(r1, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getValues(...0)",
        "body": "{\r\n    return (int[]) iValues.clone();\r\n}"
      },
      {
        "name": "Partial#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Partial#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "isMatch",
    "signature": "boolean isMatch(org.joda.time.ReadableInstant)",
    "visibility": "public",
    "body": "{\r\n    long millis \u003d DateTimeUtils.getInstantMillis(instant);\r\n    Chronology chrono \u003d DateTimeUtils.getInstantChronology(instant);\r\n    for (int i \u003d 0; i \u003c iTypes.length; i++) {\r\n        int value \u003d iTypes[i].getField(chrono).get(millis);\r\n        if (value !\u003d iValues[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d $i1) → B2 | else → B5",
      "B2 : If(i2 \u003d\u003d $i3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Partial\n  ReadableInstant\n  l0 \u003d DateTimeUtils.getInstantMillis(r0)\n  r1 \u003d DateTimeUtils.getInstantChronology(r0)\n  i4 \u003d 0\n}",
      "B1 {\n  $r3 \u003d DateTimeFieldType[] iTypes\u003e\n  $i1 \u003d lengthof $r3\n  if (i4 \u003e\u003d $i1) goto B2 else B5\n}",
      "B2 {\n  $r4 \u003d DateTimeFieldType[] iTypes\u003e\n  $r5 \u003d $r4[i4]\n  $r6 \u003d $r5.getField(r1)\n  i2 \u003d $r6.get(l0)\n  $r7 \u003d Partial: int[] iValues\u003e\n  $i3 \u003d $r7[i4]\n  if (i2 \u003d\u003d $i3) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "isMatch",
    "signature": "boolean isMatch(org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (partial \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The partial must not be null\");\r\n    }\r\n    for (int i \u003d 0; i \u003c iTypes.length; i++) {\r\n        int value \u003d partial.get(iTypes[i]);\r\n        if (value !\u003d iValues[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B3 : If(i3 \u003e\u003d $i0) → B4 | else → B7",
      "B4 : If(i1 \u003d\u003d $i2) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Partial\n  ReadablePartial\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The partial must not be null\")\n  throw $r6\n}",
      "B2 {\n  i3 \u003d 0\n}",
      "B3 {\n  $r2 \u003d DateTimeFieldType[] iTypes\u003e\n  $i0 \u003d lengthof $r2\n  if (i3 \u003e\u003d $i0) goto B4 else B7\n}",
      "B4 {\n  $r3 \u003d DateTimeFieldType[] iTypes\u003e\n  $r4 \u003d $r3[i3]\n  i1 \u003d r0.get($r4)\n  $r5 \u003d Partial: int[] iValues\u003e\n  $i2 \u003d $r5[i3]\n  if (i1 \u003d\u003d $i2) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i3 \u003d i3 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "getFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter getFormatter()",
    "visibility": "public",
    "body": "{\r\n    DateTimeFormatter[] f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        if (size() \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        f \u003d new DateTimeFormatter[2];\r\n        try {\r\n            List\u003cDateTimeFieldType\u003e list \u003d new ArrayList\u003cDateTimeFieldType\u003e(Arrays.asList(iTypes));\r\n            f[0] \u003d ISODateTimeFormat.forFields(list, true, false);\r\n            if (list.size() \u003d\u003d 0) {\r\n                f[1] \u003d f[0];\r\n            }\r\n        } catch (IllegalArgumentException ex) {\r\n            // ignore\r\n        }\r\n        iFormatter \u003d f;\r\n    }\r\n    return f[0];\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B8",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3",
      "B3 : If($i1 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Partial\n  r7 \u003d DateTimeFormatter[] iFormatter\u003e\n  if (r7 !\u003d null) goto B1 else B8\n}",
      "B1 {\n  $i0 \u003d r0.size()\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r7 \u003d DateTimeFormatter)[2]\n  $r1 \u003d ArrayList\n  $r2 \u003d DateTimeFieldType[] iTypes\u003e\n  $r3 \u003d Arrays.asList($r2)\n  new ArrayList($r3)\n  $r4 \u003d ISODateTimeFormat.forFields($r1, 1, 0)\n  r7[0] \u003d $r4\n  $i1 \u003d $r1.size()\n  if ($i1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d r7[0]\n  r7[1] \u003d $r5\n}",
      "B5 {\n  goto B7\n}",
      "B6 {\n  $r6 :\u003d @caughtexception\n}",
      "B7 {\n  DateTimeFormatter[] iFormatter\u003e \u003d r7\n}",
      "B8 {\n  $r8 \u003d r7[0]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#size(...0)",
        "body": "{\r\n    return iTypes.length;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    DateTimeFormatter[] f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        getFormatter();\r\n        f \u003d iFormatter;\r\n        if (f \u003d\u003d null) {\r\n            return toStringList();\r\n        }\r\n    }\r\n    DateTimeFormatter f1 \u003d f[1];\r\n    if (f1 \u003d\u003d null) {\r\n        return toStringList();\r\n    }\r\n    return f1.print(this);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B3",
      "B1 : If(r5 !\u003d null) → B2 | else → B3",
      "B3 : If($r3 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Partial\n  r5 \u003d DateTimeFormatter[] iFormatter\u003e\n  if (r5 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  r0.getFormatter()\n  r5 \u003d DateTimeFormatter[] iFormatter\u003e\n  if (r5 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.toStringList()\n  return\n}",
      "B3 {\n  $r3 \u003d r5[1]\n  if ($r3 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r2 \u003d r0.toStringList()\n  return\n}",
      "B5 {\n  $r1 \u003d $r3.print(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#getFormatter(...0)",
        "body": "{\r\n    DateTimeFormatter[] f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        if (size() \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        f \u003d new DateTimeFormatter[2];\r\n        try {\r\n            List\u003cDateTimeFieldType\u003e list \u003d new ArrayList\u003cDateTimeFieldType\u003e(Arrays.asList(iTypes));\r\n            f[0] \u003d ISODateTimeFormat.forFields(list, true, false);\r\n            if (list.size() \u003d\u003d 0) {\r\n                f[1] \u003d f[0];\r\n            }\r\n        } catch (IllegalArgumentException ex) {\r\n            // ignore\r\n        }\r\n        iFormatter \u003d f;\r\n    }\r\n    return f[0];\r\n}"
      },
      {
        "name": "Partial#toStringList(...0)",
        "body": "{\r\n    int size \u003d size();\r\n    StringBuilder buf \u003d new StringBuilder(20 * size);\r\n    buf.append(\u0027[\u0027);\r\n    for (int i \u003d 0; i \u003c size; i++) {\r\n        if (i \u003e 0) {\r\n            buf.append(\u0027,\u0027).append(\u0027 \u0027);\r\n        }\r\n        buf.append(iTypes[i].getName());\r\n        buf.append(\u0027\u003d\u0027);\r\n        buf.append(iValues[i]);\r\n    }\r\n    buf.append(\u0027]\u0027);\r\n    return buf.toString();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "toStringList",
    "signature": "java.lang.String toStringList()",
    "visibility": "public",
    "body": "{\r\n    int size \u003d size();\r\n    StringBuilder buf \u003d new StringBuilder(20 * size);\r\n    buf.append(\u0027[\u0027);\r\n    for (int i \u003d 0; i \u003c size; i++) {\r\n        if (i \u003e 0) {\r\n            buf.append(\u0027,\u0027).append(\u0027 \u0027);\r\n        }\r\n        buf.append(iTypes[i].getName());\r\n        buf.append(\u0027\u003d\u0027);\r\n        buf.append(iValues[i]);\r\n    }\r\n    buf.append(\u0027]\u0027);\r\n    return buf.toString();\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If(i3 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Partial\n  i0 \u003d r0.size()\n  $r1 \u003d StringBuilder\n  $i1 \u003d 20 * i0\n  new StringBuilder($i1)\n  $r1.append(91)\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  if (i3 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d $r1.append(44)\n  $r7.append(32)\n}",
      "B4 {\n  $r3 \u003d DateTimeFieldType[] iTypes\u003e\n  $r4 \u003d $r3[i3]\n  $r5 \u003d $r4.getName()\n  $r1.append($r5)\n  $r1.append(61)\n  $r6 \u003d Partial: int[] iValues\u003e\n  $i2 \u003d $r6[i3]\n  $r1.append($i2)\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  $r1.append(93)\n  $r2 \u003d $r1.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#size(...0)",
        "body": "{\r\n    return iTypes.length;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#toString(...0)",
        "body": "{\r\n    DateTimeFormatter[] f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        getFormatter();\r\n        f \u003d iFormatter;\r\n        if (f \u003d\u003d null) {\r\n            return toStringList();\r\n        }\r\n    }\r\n    DateTimeFormatter f1 \u003d f[1];\r\n    if (f1 \u003d\u003d null) {\r\n        return toStringList();\r\n    }\r\n    return f1.print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Partial",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Partial\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Partial#toString(...0)",
        "body": "{\r\n    DateTimeFormatter[] f \u003d iFormatter;\r\n    if (f \u003d\u003d null) {\r\n        getFormatter();\r\n        f \u003d iFormatter;\r\n        if (f \u003d\u003d null) {\r\n            return toStringList();\r\n        }\r\n    }\r\n    DateTimeFormatter f1 \u003d f[1];\r\n    if (f1 \u003d\u003d null) {\r\n        return toStringList();\r\n    }\r\n    return f1.print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "fieldDifference",
    "signature": "org.joda.time.Period fieldDifference(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start \u003d\u003d null || end \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\r\n    }\r\n    if (start.size() !\u003d end.size()) {\r\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\r\n    }\r\n    DurationFieldType[] types \u003d new DurationFieldType[start.size()];\r\n    int[] values \u003d new int[start.size()];\r\n    for (int i \u003d 0, isize \u003d start.size(); i \u003c isize; i++) {\r\n        if (start.getFieldType(i) !\u003d end.getFieldType(i)) {\r\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\r\n        }\r\n        types[i] \u003d start.getFieldType(i).getDurationType();\r\n        if (i \u003e 0 \u0026\u0026 types[i - 1].equals(types[i])) {\r\n            throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\r\n        }\r\n        values[i] \u003d end.getValue(i) - start.getValue(i);\r\n    }\r\n    return new Period(values, PeriodType.forFields(types));\r\n}",
    "nodes": 14,
    "edges": 16,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3",
      "B3 : If($i1 \u003d\u003d $i0) → B4 | else → B5",
      "B6 : If(i9 \u003e\u003d i4) → B7 | else → B13",
      "B7 : If($r8 \u003d\u003d $r7) → B8 | else → B9",
      "B9 : If(i9 \u003c\u003d 0) → B10 | else → B12",
      "B10 : If($z0 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"ReadablePartial objects must not be null\")\n  throw $r1\n}",
      "B3 {\n  $i1 \u003d r0.size()\n  $i0 \u003d r2.size()\n  if ($i1 \u003d\u003d $i0) goto B4 else B5\n}",
      "B4 {\n  $r15 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\")\n  throw $r15\n}",
      "B5 {\n  $i2 \u003d r0.size()\n  r3 \u003d DurationFieldType)[$i2]\n  $i3 \u003d r0.size()\n  r4 \u003d newarray (int)[$i3]\n  i9 \u003d 0\n  i4 \u003d r0.size()\n}",
      "B6 {\n  if (i9 \u003e\u003d i4) goto B7 else B13\n}",
      "B7 {\n  $r8 \u003d r0.getFieldType(i9)\n  $r7 \u003d r2.getFieldType(i9)\n  if ($r8 \u003d\u003d $r7) goto B8 else B9\n}",
      "B8 {\n  $r14 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\")\n  throw $r14\n}",
      "B9 {\n  $r9 \u003d r0.getFieldType(i9)\n  $r10 \u003d $r9.getDurationType()\n  r3[i9] \u003d $r10\n  if (i9 \u003c\u003d 0) goto B10 else B12\n}",
      "B10 {\n  $i8 \u003d i9 - 1\n  $r12 \u003d r3[$i8]\n  $r11 \u003d r3[i9]\n  $z0 \u003d $r12.equals($r11)\n  if ($z0 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r13 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\")\n  throw $r13\n}",
      "B12 {\n  $i6 \u003d r2.getValue(i9)\n  $i5 \u003d r0.getValue(i9)\n  $i7 \u003d $i6 - $i5\n  r4[i9] \u003d $i7\n  i9 \u003d i9 + 1\n  goto B6\n}",
      "B13 {\n  $r5 \u003d Period\n  $r6 \u003d PeriodType.forFields(r3)\n  new Period(r4, $r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B6",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "withPeriodType",
    "signature": "org.joda.time.Period withPeriodType(org.joda.time.PeriodType)",
    "visibility": "public",
    "body": "{\r\n    type \u003d DateTimeUtils.getPeriodType(type);\r\n    if (type.equals(getPeriodType())) {\r\n        return this;\r\n    }\r\n    return new Period(this, type);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  PeriodType\n  r4 \u003d DateTimeUtils.getPeriodType(r3)\n  $r1 \u003d r0.getPeriodType()\n  $z0 \u003d r4.equals($r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Period\n  new Period(r0, r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "withFields",
    "signature": "org.joda.time.Period withFields(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d super.mergePeriodInto(newValues, period);\r\n    return new Period(newValues, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r1.getValues()\n  r5 \u003d r1.mergePeriodInto(r4, r0)\n  $r2 \u003d Period\n  $r3 \u003d r1.getPeriodType()\n  new Period(r5, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "withField",
    "signature": "org.joda.time.Period withField(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (field \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    // cloned\r\n    int[] newValues \u003d getValues();\r\n    super.setFieldInto(newValues, field, value);\r\n    return new Period(newValues, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  r2 \u003d r1.getValues()\n  r1.setFieldInto(r2, r0, i0)\n  $r3 \u003d Period\n  $r4 \u003d r1.getPeriodType()\n  new Period(r2, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.Period withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    if (field \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Field must not be null\");\r\n    }\r\n    if (value \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] newValues \u003d getValues();\r\n    super.addFieldInto(newValues, field, value);\r\n    return new Period(newValues, getPeriodType());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Period\n  DurationFieldType\n  i0 :\u003d @parameter1: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Field must not be null\")\n  throw $r5\n}",
      "B2 {\n  if (i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d r1.getValues()\n  r1.addFieldInto(r2, r0, i0)\n  $r3 \u003d Period\n  $r4 \u003d r1.getPeriodType()\n  new Period(r2, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plus",
    "signature": "org.joda.time.Period plus(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d r1.getValues()\n  $r4 \u003d r1.getPeriodType()\n  $i0 \u003d PeriodType: int YEAR_INDEX\u003e\n  $r3 \u003d DurationFieldType YEARS_TYPE\u003e\n  $i1 \u003d r0.get($r3)\n  $r4.addIndexedField(r1, $i0, r2, $i1)\n  $r6 \u003d r1.getPeriodType()\n  $i2 \u003d PeriodType: int MONTH_INDEX\u003e\n  $r5 \u003d DurationFieldType MONTHS_TYPE\u003e\n  $i3 \u003d r0.get($r5)\n  $r6.addIndexedField(r1, $i2, r2, $i3)\n  $r8 \u003d r1.getPeriodType()\n  $i4 \u003d PeriodType: int WEEK_INDEX\u003e\n  $r7 \u003d DurationFieldType WEEKS_TYPE\u003e\n  $i5 \u003d r0.get($r7)\n  $r8.addIndexedField(r1, $i4, r2, $i5)\n  $r10 \u003d r1.getPeriodType()\n  $i6 \u003d PeriodType: int DAY_INDEX\u003e\n  $r9 \u003d DurationFieldType DAYS_TYPE\u003e\n  $i7 \u003d r0.get($r9)\n  $r10.addIndexedField(r1, $i6, r2, $i7)\n  $r12 \u003d r1.getPeriodType()\n  $i8 \u003d PeriodType: int HOUR_INDEX\u003e\n  $r11 \u003d DurationFieldType HOURS_TYPE\u003e\n  $i9 \u003d r0.get($r11)\n  $r12.addIndexedField(r1, $i8, r2, $i9)\n  $r14 \u003d r1.getPeriodType()\n  $i10 \u003d PeriodType: int MINUTE_INDEX\u003e\n  $r13 \u003d DurationFieldType MINUTES_TYPE\u003e\n  $i11 \u003d r0.get($r13)\n  $r14.addIndexedField(r1, $i10, r2, $i11)\n  $r16 \u003d r1.getPeriodType()\n  $i12 \u003d PeriodType: int SECOND_INDEX\u003e\n  $r15 \u003d DurationFieldType SECONDS_TYPE\u003e\n  $i13 \u003d r0.get($r15)\n  $r16.addIndexedField(r1, $i12, r2, $i13)\n  $r18 \u003d r1.getPeriodType()\n  $i14 \u003d PeriodType: int MILLI_INDEX\u003e\n  $r17 \u003d DurationFieldType MILLIS_TYPE\u003e\n  $i15 \u003d r0.get($r17)\n  $r18.addIndexedField(r1, $i14, r2, $i15)\n  $r19 \u003d Period\n  $r20 \u003d r1.getPeriodType()\n  new Period(r2, $r20)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusYears",
    "signature": "org.joda.time.Period plusYears(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int YEAR_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusMonths",
    "signature": "org.joda.time.Period plusMonths(int)",
    "visibility": "public",
    "body": "{\r\n    if (months \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int MONTH_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusWeeks",
    "signature": "org.joda.time.Period plusWeeks(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int WEEK_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusDays",
    "signature": "org.joda.time.Period plusDays(int)",
    "visibility": "public",
    "body": "{\r\n    if (days \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int DAY_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusHours",
    "signature": "org.joda.time.Period plusHours(int)",
    "visibility": "public",
    "body": "{\r\n    if (hours \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int HOUR_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusMinutes",
    "signature": "org.joda.time.Period plusMinutes(int)",
    "visibility": "public",
    "body": "{\r\n    if (minutes \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int MINUTE_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusSeconds",
    "signature": "org.joda.time.Period plusSeconds(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int SECOND_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "plusMillis",
    "signature": "org.joda.time.Period plusMillis(int)",
    "visibility": "public",
    "body": "{\r\n    if (millis \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d r0.getValues()\n  $r2 \u003d r0.getPeriodType()\n  $i1 \u003d PeriodType: int MILLI_INDEX\u003e\n  $r2.addIndexedField(r0, $i1, r1, i0)\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "minus",
    "signature": "org.joda.time.Period minus(org.joda.time.ReadablePeriod)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\r\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Period\n  ReadablePeriod\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d r1.getValues()\n  $r4 \u003d r1.getPeriodType()\n  $i0 \u003d PeriodType: int YEAR_INDEX\u003e\n  $r3 \u003d DurationFieldType YEARS_TYPE\u003e\n  $i1 \u003d r0.get($r3)\n  $i2 \u003d neg $i1\n  $r4.addIndexedField(r1, $i0, r2, $i2)\n  $r6 \u003d r1.getPeriodType()\n  $i3 \u003d PeriodType: int MONTH_INDEX\u003e\n  $r5 \u003d DurationFieldType MONTHS_TYPE\u003e\n  $i4 \u003d r0.get($r5)\n  $i5 \u003d neg $i4\n  $r6.addIndexedField(r1, $i3, r2, $i5)\n  $r8 \u003d r1.getPeriodType()\n  $i6 \u003d PeriodType: int WEEK_INDEX\u003e\n  $r7 \u003d DurationFieldType WEEKS_TYPE\u003e\n  $i7 \u003d r0.get($r7)\n  $i8 \u003d neg $i7\n  $r8.addIndexedField(r1, $i6, r2, $i8)\n  $r10 \u003d r1.getPeriodType()\n  $i9 \u003d PeriodType: int DAY_INDEX\u003e\n  $r9 \u003d DurationFieldType DAYS_TYPE\u003e\n  $i10 \u003d r0.get($r9)\n  $i11 \u003d neg $i10\n  $r10.addIndexedField(r1, $i9, r2, $i11)\n  $r12 \u003d r1.getPeriodType()\n  $i12 \u003d PeriodType: int HOUR_INDEX\u003e\n  $r11 \u003d DurationFieldType HOURS_TYPE\u003e\n  $i13 \u003d r0.get($r11)\n  $i14 \u003d neg $i13\n  $r12.addIndexedField(r1, $i12, r2, $i14)\n  $r14 \u003d r1.getPeriodType()\n  $i15 \u003d PeriodType: int MINUTE_INDEX\u003e\n  $r13 \u003d DurationFieldType MINUTES_TYPE\u003e\n  $i16 \u003d r0.get($r13)\n  $i17 \u003d neg $i16\n  $r14.addIndexedField(r1, $i15, r2, $i17)\n  $r16 \u003d r1.getPeriodType()\n  $i18 \u003d PeriodType: int SECOND_INDEX\u003e\n  $r15 \u003d DurationFieldType SECONDS_TYPE\u003e\n  $i19 \u003d r0.get($r15)\n  $i20 \u003d neg $i19\n  $r16.addIndexedField(r1, $i18, r2, $i20)\n  $r18 \u003d r1.getPeriodType()\n  $i21 \u003d PeriodType: int MILLI_INDEX\u003e\n  $r17 \u003d DurationFieldType MILLIS_TYPE\u003e\n  $i22 \u003d r0.get($r17)\n  $i23 \u003d neg $i22\n  $r18.addIndexedField(r1, $i21, r2, $i23)\n  $r19 \u003d Period\n  $r20 \u003d r1.getPeriodType()\n  new Period(r2, $r20)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "multipliedBy",
    "signature": "org.joda.time.Period multipliedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d ZERO || scalar \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    // cloned\r\n    int[] values \u003d getValues();\r\n    for (int i \u003d 0; i \u003c values.length; i++) {\r\n        values[i] \u003d FieldUtils.safeMultiply(values[i], scalar);\r\n    }\r\n    return new Period(values, getPeriodType());\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r1) → B1 | else → B2",
      "B1 : If(i0 !\u003d 1) → B2 | else → B3",
      "B4 : If(i4 \u003e\u003d $i1) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Period\n  i0 :\u003d @parameter0: int\n  $r1 \u003d Period ZERO\u003e\n  if (r0 \u003d\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 1) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r2 \u003d r0.getValues()\n  i4 \u003d 0\n}",
      "B4 {\n  $i1 \u003d lengthof r2\n  if (i4 \u003e\u003d $i1) goto B5 else B6\n}",
      "B5 {\n  $i2 \u003d r2[i4]\n  $i3 \u003d FieldUtils.safeMultiply($i2, i0)\n  r2[i4] \u003d $i3\n  i4 \u003d i4 + 1\n  goto B4\n}",
      "B6 {\n  $r3 \u003d Period\n  $r4 \u003d r0.getPeriodType()\n  new Period(r2, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getPeriodType(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Period",
    "methodName": "normalizedStandard",
    "signature": "org.joda.time.Period normalizedStandard(org.joda.time.PeriodType)",
    "visibility": "public",
    "body": "{\r\n    type \u003d DateTimeUtils.getPeriodType(type);\r\n    // no overflow can happen, even with Integer.MAX_VALUEs\r\n    long millis \u003d getMillis();\r\n    millis +\u003d (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\r\n    millis +\u003d (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\r\n    millis +\u003d (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\r\n    millis +\u003d (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\r\n    millis +\u003d (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\r\n    Period result \u003d new Period(millis, type, ISOChronology.getInstanceUTC());\r\n    int years \u003d getYears();\r\n    int months \u003d getMonths();\r\n    if (years !\u003d 0 || months !\u003d 0) {\r\n        long totalMonths \u003d years * 12L + months;\r\n        if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\r\n            int normalizedYears \u003d FieldUtils.safeToInt(totalMonths / 12);\r\n            result \u003d result.withYears(normalizedYears);\r\n            totalMonths \u003d totalMonths - (normalizedYears * 12L);\r\n        }\r\n        if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\r\n            int normalizedMonths \u003d FieldUtils.safeToInt(totalMonths);\r\n            result \u003d result.withMonths(normalizedMonths);\r\n            totalMonths \u003d totalMonths - normalizedMonths;\r\n        }\r\n        if (totalMonths !\u003d 0) {\r\n            throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i16 !\u003d 0) → B1 | else → B2",
      "B1 : If(i17 \u003d\u003d false) → B2 | else → B8",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($b21 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  Period\n  PeriodType\n  r9 \u003d DateTimeUtils.getPeriodType(r8)\n  $i0 \u003d r0.getMillis()\n  l27 \u003d (long) $i0\n  $i1 \u003d r0.getSeconds()\n  $l2 \u003d (long) $i1\n  $l3 \u003d $l2 * 1000L\n  l28 \u003d l27 + $l3\n  $i4 \u003d r0.getMinutes()\n  $l5 \u003d (long) $i4\n  $l6 \u003d $l5 * 60000L\n  l29 \u003d l28 + $l6\n  $i7 \u003d r0.getHours()\n  $l8 \u003d (long) $i7\n  $l9 \u003d $l8 * 3600000L\n  l30 \u003d l29 + $l9\n  $i10 \u003d r0.getDays()\n  $l11 \u003d (long) $i10\n  $l12 \u003d $l11 * 86400000L\n  l31 \u003d l30 + $l12\n  $i13 \u003d r0.getWeeks()\n  $l14 \u003d (long) $i13\n  $l15 \u003d $l14 * 604800000L\n  l32 \u003d l31 + $l15\n  $r1 \u003d Period\n  $r2 \u003d ISOChronology.getInstanceUTC()\n  new Period(l32, r9, $r2)\n  r10 \u003d $r1\n  i16 \u003d r0.getYears()\n  i17 \u003d r0.getMonths()\n  if (i16 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  if (i17 \u003d\u003d false) goto B2 else B8\n}",
      "B2 {\n  $l18 \u003d (long) i16\n  $l20 \u003d $l18 * 12L\n  $l19 \u003d (long) i17\n  $l26 \u003d $l20 + $l19\n  l33 \u003d $l26\n  $r3 \u003d DurationFieldType YEARS_TYPE\u003e\n  $z0 \u003d r9.isSupported($r3)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $l23 \u003d $l26 / 12L\n  i34 \u003d FieldUtils.safeToInt($l23)\n  r10 \u003d $r1.withYears(i34)\n  $l24 \u003d (long) i34\n  $l25 \u003d $l24 * 12L\n  l33 \u003d $l26 - $l25\n}",
      "B4 {\n  $r4 \u003d DurationFieldType MONTHS_TYPE\u003e\n  $z1 \u003d r9.isSupported($r4)\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  i35 \u003d FieldUtils.safeToInt(l33)\n  r10 \u003d r10.withMonths(i35)\n  $l22 \u003d (long) i35\n  l33 \u003d l33 - $l22\n}",
      "B6 {\n  $b21 \u003d l33 cmp 0L\n  if ($b21 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r5 \u003d UnsupportedOperationException\n  $r6 \u003d r0.toString()\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new UnsupportedOperationException($r7)\n  throw $r5\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Period#getMillis(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\r\n}"
      },
      {
        "name": "Period#toString(...0)",
        "body": "(source not found)"
      },
      {
        "name": "Period#getDays(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\r\n}"
      },
      {
        "name": "Period#getHours(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\r\n}"
      },
      {
        "name": "Period#getMonths(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\r\n}"
      },
      {
        "name": "Period#getMinutes(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\r\n}"
      },
      {
        "name": "Period#getSeconds(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\r\n}"
      },
      {
        "name": "Period#getWeeks(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\r\n}"
      },
      {
        "name": "Period#getYears(...0)",
        "body": "{\r\n    return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "standard",
    "signature": "org.joda.time.PeriodType standard()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cStandard;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Standard\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 });\r\n        cStandard \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r11 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r11 \u003d PeriodType cStandard\u003e\n  if (r11 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[8]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.months()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.weeks()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.days()\n  $r1[3] \u003d $r5\n  $r6 \u003d DurationFieldType.hours()\n  $r1[4] \u003d $r6\n  $r7 \u003d DurationFieldType.minutes()\n  $r1[5] \u003d $r7\n  $r8 \u003d DurationFieldType.seconds()\n  $r1[6] \u003d $r8\n  $r9 \u003d DurationFieldType.millis()\n  $r1[7] \u003d $r9\n  $r10 \u003d newarray (int)[8]\n  $r10[0] \u003d 0\n  $r10[1] \u003d 1\n  $r10[2] \u003d 2\n  $r10[3] \u003d 3\n  $r10[4] \u003d 4\n  $r10[5] \u003d 5\n  $r10[6] \u003d 6\n  $r10[7] \u003d 7\n  new PeriodType(\"Standard\", $r1, $r10)\n  r11 \u003d $r0\n  PeriodType cStandard\u003e \u003d $r0\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearMonthDayTime",
    "signature": "org.joda.time.PeriodType yearMonthDayTime()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYMDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearMonthDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 });\r\n        cYMDTime \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r10 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r10 \u003d PeriodType cYMDTime\u003e\n  if (r10 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[7]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.months()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.days()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.hours()\n  $r1[3] \u003d $r5\n  $r6 \u003d DurationFieldType.minutes()\n  $r1[4] \u003d $r6\n  $r7 \u003d DurationFieldType.seconds()\n  $r1[5] \u003d $r7\n  $r8 \u003d DurationFieldType.millis()\n  $r1[6] \u003d $r8\n  $r9 \u003d newarray (int)[8]\n  $r9[0] \u003d 0\n  $r9[1] \u003d 1\n  $i1 \u003d (int) -1\n  $r9[2] \u003d $i1\n  $r9[3] \u003d 2\n  $r9[4] \u003d 3\n  $r9[5] \u003d 4\n  $r9[6] \u003d 5\n  $r9[7] \u003d 6\n  new PeriodType(\"YearMonthDayTime\", $r1, $r9)\n  r10 \u003d $r11\n  PeriodType cYMDTime\u003e \u003d $r11\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearMonthDay",
    "signature": "org.joda.time.PeriodType yearMonthDay()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYMD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearMonthDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 });\r\n        cYMD \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r6 \u003d PeriodType cYMD\u003e\n  if (r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[3]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.months()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.days()\n  $r1[2] \u003d $r4\n  $r5 \u003d newarray (int)[8]\n  $r5[0] \u003d 0\n  $r5[1] \u003d 1\n  $i1 \u003d (int) -1\n  $r5[2] \u003d $i1\n  $r5[3] \u003d 2\n  $i3 \u003d (int) -1\n  $r5[4] \u003d $i3\n  $i5 \u003d (int) -1\n  $r5[5] \u003d $i5\n  $i7 \u003d (int) -1\n  $r5[6] \u003d $i7\n  $i9 \u003d (int) -1\n  $r5[7] \u003d $i9\n  new PeriodType(\"YearMonthDay\", $r1, $r5)\n  r6 \u003d $r7\n  PeriodType cYMD\u003e \u003d $r7\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearWeekDayTime",
    "signature": "org.joda.time.PeriodType yearWeekDayTime()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYWDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearWeekDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 });\r\n        cYWDTime \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r10 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r10 \u003d PeriodType cYWDTime\u003e\n  if (r10 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[7]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.weeks()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.days()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.hours()\n  $r1[3] \u003d $r5\n  $r6 \u003d DurationFieldType.minutes()\n  $r1[4] \u003d $r6\n  $r7 \u003d DurationFieldType.seconds()\n  $r1[5] \u003d $r7\n  $r8 \u003d DurationFieldType.millis()\n  $r1[6] \u003d $r8\n  $r9 \u003d newarray (int)[8]\n  $r9[0] \u003d 0\n  $i1 \u003d (int) -1\n  $r9[1] \u003d $i1\n  $r9[2] \u003d 1\n  $r9[3] \u003d 2\n  $r9[4] \u003d 3\n  $r9[5] \u003d 4\n  $r9[6] \u003d 5\n  $r9[7] \u003d 6\n  new PeriodType(\"YearWeekDayTime\", $r1, $r9)\n  r10 \u003d $r11\n  PeriodType cYWDTime\u003e \u003d $r11\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearWeekDay",
    "signature": "org.joda.time.PeriodType yearWeekDay()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYWD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearWeekDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 });\r\n        cYWD \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r6 \u003d PeriodType cYWD\u003e\n  if (r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[3]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.weeks()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.days()\n  $r1[2] \u003d $r4\n  $r5 \u003d newarray (int)[8]\n  $r5[0] \u003d 0\n  $i1 \u003d (int) -1\n  $r5[1] \u003d $i1\n  $r5[2] \u003d 1\n  $r5[3] \u003d 2\n  $i3 \u003d (int) -1\n  $r5[4] \u003d $i3\n  $i5 \u003d (int) -1\n  $r5[5] \u003d $i5\n  $i7 \u003d (int) -1\n  $r5[6] \u003d $i7\n  $i9 \u003d (int) -1\n  $r5[7] \u003d $i9\n  new PeriodType(\"YearWeekDay\", $r1, $r5)\n  r6 \u003d $r7\n  PeriodType cYWD\u003e \u003d $r7\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearDayTime",
    "signature": "org.joda.time.PeriodType yearDayTime()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 });\r\n        cYDTime \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r9 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r9 \u003d PeriodType cYDTime\u003e\n  if (r9 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[6]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.days()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.hours()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.minutes()\n  $r1[3] \u003d $r5\n  $r6 \u003d DurationFieldType.seconds()\n  $r1[4] \u003d $r6\n  $r7 \u003d DurationFieldType.millis()\n  $r1[5] \u003d $r7\n  $r8 \u003d newarray (int)[8]\n  $r8[0] \u003d 0\n  $i1 \u003d (int) -1\n  $r8[1] \u003d $i1\n  $i3 \u003d (int) -1\n  $r8[2] \u003d $i3\n  $r8[3] \u003d 1\n  $r8[4] \u003d 2\n  $r8[5] \u003d 3\n  $r8[6] \u003d 4\n  $r8[7] \u003d 5\n  new PeriodType(\"YearDayTime\", $r1, $r8)\n  r9 \u003d $r10\n  PeriodType cYDTime\u003e \u003d $r10\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "yearDay",
    "signature": "org.joda.time.PeriodType yearDay()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 });\r\n        cYD \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r5 \u003d PeriodType cYD\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[2]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.days()\n  $r1[1] \u003d $r3\n  $r4 \u003d newarray (int)[8]\n  $r4[0] \u003d 0\n  $i1 \u003d (int) -1\n  $r4[1] \u003d $i1\n  $i3 \u003d (int) -1\n  $r4[2] \u003d $i3\n  $r4[3] \u003d 1\n  $i5 \u003d (int) -1\n  $r4[4] \u003d $i5\n  $i7 \u003d (int) -1\n  $r4[5] \u003d $i7\n  $i9 \u003d (int) -1\n  $r4[6] \u003d $i9\n  $i11 \u003d (int) -1\n  $r4[7] \u003d $i11\n  new PeriodType(\"YearDay\", $r1, $r4)\n  r5 \u003d $r6\n  PeriodType cYD\u003e \u003d $r6\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "dayTime",
    "signature": "org.joda.time.PeriodType dayTime()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"DayTime\", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 });\r\n        cDTime \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r8 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r8 \u003d PeriodType cDTime\u003e\n  if (r8 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[5]\n  $r2 \u003d DurationFieldType.days()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.hours()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.minutes()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.seconds()\n  $r1[3] \u003d $r5\n  $r6 \u003d DurationFieldType.millis()\n  $r1[4] \u003d $r6\n  $r7 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r7[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r7[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r7[2] \u003d $i5\n  $r7[3] \u003d 0\n  $r7[4] \u003d 1\n  $r7[5] \u003d 2\n  $r7[6] \u003d 3\n  $r7[7] \u003d 4\n  new PeriodType(\"DayTime\", $r1, $r7)\n  r8 \u003d $r9\n  PeriodType cDTime\u003e \u003d $r9\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "time",
    "signature": "org.joda.time.PeriodType time()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Time\", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 });\r\n        cTime \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r7 \u003d PeriodType cTime\u003e\n  if (r7 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[4]\n  $r2 \u003d DurationFieldType.hours()\n  $r1[0] \u003d $r2\n  $r3 \u003d DurationFieldType.minutes()\n  $r1[1] \u003d $r3\n  $r4 \u003d DurationFieldType.seconds()\n  $r1[2] \u003d $r4\n  $r5 \u003d DurationFieldType.millis()\n  $r1[3] \u003d $r5\n  $r6 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r6[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r6[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r6[2] \u003d $i5\n  $i7 \u003d (int) -1\n  $r6[3] \u003d $i7\n  $r6[4] \u003d 0\n  $r6[5] \u003d 1\n  $r6[6] \u003d 2\n  $r6[7] \u003d 3\n  new PeriodType(\"Time\", $r1, $r6)\n  r7 \u003d $r8\n  PeriodType cTime\u003e \u003d $r8\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "years",
    "signature": "org.joda.time.PeriodType years()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cYears;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Years\", new DurationFieldType[] { DurationFieldType.years() }, new int[] { 0, -1, -1, -1, -1, -1, -1, -1 });\r\n        cYears \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cYears\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.years()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $r3[0] \u003d 0\n  $i1 \u003d (int) -1\n  $r3[1] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[2] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[3] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[4] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[5] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Years\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cYears\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "months",
    "signature": "org.joda.time.PeriodType months()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cMonths;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Months\", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 });\r\n        cMonths \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cMonths\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.months()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $r3[1] \u003d 0\n  $i3 \u003d (int) -1\n  $r3[2] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[3] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[4] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[5] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Months\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cMonths\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "weeks",
    "signature": "org.joda.time.PeriodType weeks()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cWeeks;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Weeks\", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 });\r\n        cWeeks \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cWeeks\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.weeks()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $r3[2] \u003d 0\n  $i5 \u003d (int) -1\n  $r3[3] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[4] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[5] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Weeks\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cWeeks\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "days",
    "signature": "org.joda.time.PeriodType days()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cDays;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Days\", new DurationFieldType[] { DurationFieldType.days() }, new int[] { -1, -1, -1, 0, -1, -1, -1, -1 });\r\n        cDays \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cDays\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.days()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[2] \u003d $i5\n  $r3[3] \u003d 0\n  $i7 \u003d (int) -1\n  $r3[4] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[5] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Days\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cDays\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "hours",
    "signature": "org.joda.time.PeriodType hours()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cHours;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Hours\", new DurationFieldType[] { DurationFieldType.hours() }, new int[] { -1, -1, -1, -1, 0, -1, -1, -1 });\r\n        cHours \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cHours\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.hours()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[2] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[3] \u003d $i7\n  $r3[4] \u003d 0\n  $i9 \u003d (int) -1\n  $r3[5] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Hours\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cHours\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "minutes",
    "signature": "org.joda.time.PeriodType minutes()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cMinutes;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Minutes\", new DurationFieldType[] { DurationFieldType.minutes() }, new int[] { -1, -1, -1, -1, -1, 0, -1, -1 });\r\n        cMinutes \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cMinutes\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.minutes()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[2] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[3] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[4] \u003d $i9\n  $r3[5] \u003d 0\n  $i11 \u003d (int) -1\n  $r3[6] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Minutes\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cMinutes\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "seconds",
    "signature": "org.joda.time.PeriodType seconds()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cSeconds;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Seconds\", new DurationFieldType[] { DurationFieldType.seconds() }, new int[] { -1, -1, -1, -1, -1, -1, 0, -1 });\r\n        cSeconds \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cSeconds\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.seconds()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[2] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[3] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[4] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[5] \u003d $i11\n  $r3[6] \u003d 0\n  $i13 \u003d (int) -1\n  $r3[7] \u003d $i13\n  new PeriodType(\"Seconds\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cSeconds\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "millis",
    "signature": "org.joda.time.PeriodType millis()",
    "visibility": "public",
    "body": "{\r\n    PeriodType type \u003d cMillis;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Millis\", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 });\r\n        cMillis \u003d type;\r\n    }\r\n    return type;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r4 \u003d PeriodType cMillis\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d PeriodType\n  $r1 \u003d DurationFieldType)[1]\n  $r2 \u003d DurationFieldType.millis()\n  $r1[0] \u003d $r2\n  $r3 \u003d newarray (int)[8]\n  $i1 \u003d (int) -1\n  $r3[0] \u003d $i1\n  $i3 \u003d (int) -1\n  $r3[1] \u003d $i3\n  $i5 \u003d (int) -1\n  $r3[2] \u003d $i5\n  $i7 \u003d (int) -1\n  $r3[3] \u003d $i7\n  $i9 \u003d (int) -1\n  $r3[4] \u003d $i9\n  $i11 \u003d (int) -1\n  $r3[5] \u003d $i11\n  $i13 \u003d (int) -1\n  $r3[6] \u003d $i13\n  $r3[7] \u003d 0\n  new PeriodType(\"Millis\", $r1, $r3)\n  r4 \u003d $r5\n  PeriodType cMillis\u003e \u003d $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "forFields",
    "signature": "org.joda.time.PeriodType forFields(org.joda.time.DurationFieldType[])",
    "visibility": "public",
    "body": "{\r\n    if (types \u003d\u003d null || types.length \u003d\u003d 0) {\r\n        throw new IllegalArgumentException(\"Types array must not be null or empty\");\r\n    }\r\n    for (int i \u003d 0; i \u003c types.length; i++) {\r\n        if (types[i] \u003d\u003d null) {\r\n            throw new IllegalArgumentException(\"Types array must not contain null\");\r\n        }\r\n    }\r\n    Map\u003cPeriodType, Object\u003e cache \u003d cTypes;\r\n    if (cache.isEmpty()) {\r\n        cache.put(standard(), standard());\r\n        cache.put(yearMonthDayTime(), yearMonthDayTime());\r\n        cache.put(yearMonthDay(), yearMonthDay());\r\n        cache.put(yearWeekDayTime(), yearWeekDayTime());\r\n        cache.put(yearWeekDay(), yearWeekDay());\r\n        cache.put(yearDayTime(), yearDayTime());\r\n        cache.put(yearDay(), yearDay());\r\n        cache.put(dayTime(), dayTime());\r\n        cache.put(time(), time());\r\n        cache.put(years(), years());\r\n        cache.put(months(), months());\r\n        cache.put(weeks(), weeks());\r\n        cache.put(days(), days());\r\n        cache.put(hours(), hours());\r\n        cache.put(minutes(), minutes());\r\n        cache.put(seconds(), seconds());\r\n        cache.put(millis(), millis());\r\n    }\r\n    PeriodType inPartType \u003d new PeriodType(null, types, null);\r\n    Object cached \u003d cache.get(inPartType);\r\n    if (cached instanceof PeriodType) {\r\n        return (PeriodType) cached;\r\n    }\r\n    if (cached !\u003d null) {\r\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\r\n    }\r\n    PeriodType type \u003d standard();\r\n    List\u003cDurationFieldType\u003e list \u003d new ArrayList\u003cDurationFieldType\u003e(Arrays.asList(types));\r\n    if (list.remove(DurationFieldType.years()) \u003d\u003d false) {\r\n        type \u003d type.withYearsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.months()) \u003d\u003d false) {\r\n        type \u003d type.withMonthsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.weeks()) \u003d\u003d false) {\r\n        type \u003d type.withWeeksRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.days()) \u003d\u003d false) {\r\n        type \u003d type.withDaysRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.hours()) \u003d\u003d false) {\r\n        type \u003d type.withHoursRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.minutes()) \u003d\u003d false) {\r\n        type \u003d type.withMinutesRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.seconds()) \u003d\u003d false) {\r\n        type \u003d type.withSecondsRemoved();\r\n    }\r\n    if (list.remove(DurationFieldType.millis()) \u003d\u003d false) {\r\n        type \u003d type.withMillisRemoved();\r\n    }\r\n    if (list.size() \u003e 0) {\r\n        cache.put(inPartType, list);\r\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\r\n    }\r\n    // recheck cache in case initial array order was wrong\r\n    PeriodType checkPartType \u003d new PeriodType(null, type.iTypes, null);\r\n    PeriodType checkedType \u003d (PeriodType) cache.get(checkPartType);\r\n    if (checkedType !\u003d null) {\r\n        cache.put(checkPartType, checkedType);\r\n        return checkedType;\r\n    }\r\n    cache.put(checkPartType, type);\r\n    return type;\r\n}",
    "nodes": 35,
    "edges": 45,
    "cc": 12,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i3 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If($r59 !\u003d null) → B6 | else → B7",
      "B8 : If($z0 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z1 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($r58 \u003d\u003d null) → B13 | else → B14",
      "B14 : If($z2 !\u003d 0) → B15 | else → B16",
      "B16 : If($z3 !\u003d 0) → B17 | else → B18",
      "B18 : If($z4 !\u003d 0) → B19 | else → B20",
      "B20 : If($z5 !\u003d 0) → B21 | else → B22",
      "B22 : If($z6 !\u003d 0) → B23 | else → B24",
      "B24 : If($z7 !\u003d 0) → B25 | else → B26",
      "B26 : If($z8 !\u003d 0) → B27 | else → B28",
      "B28 : If($z9 !\u003d 0) → B29 | else → B30",
      "B30 : If($i2 \u003c\u003d 0) → B31 | else → B32",
      "B32 : If(r16 \u003d\u003d null) → B33 | else → B34"
    ],
    "blockList": [
      "B0 {\n  DurationFieldType[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d lengthof r0\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Types array must not be null or empty\")\n  throw $r1\n}",
      "B3 {\n  i3 \u003d 0\n}",
      "B4 {\n  $i1 \u003d lengthof r0\n  if (i3 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  $r59 \u003d r0[i3]\n  if ($r59 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r60 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Types array must not contain null\")\n  throw $r60\n}",
      "B7 {\n  i3 \u003d i3 + 1\n  goto B4\n}",
      "B8 {\n  r61 \u003d Map cTypes\u003e\n  $z0 \u003d r61.isEmpty()\n  if ($z0 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r25 \u003d PeriodType.standard()\n  $r24 \u003d PeriodType.standard()\n  r61.put($r25, $r24)\n  $r27 \u003d PeriodType.yearMonthDayTime()\n  $r26 \u003d PeriodType.yearMonthDayTime()\n  r61.put($r27, $r26)\n  $r29 \u003d PeriodType.yearMonthDay()\n  $r28 \u003d PeriodType.yearMonthDay()\n  r61.put($r29, $r28)\n  $r31 \u003d PeriodType.yearWeekDayTime()\n  $r30 \u003d PeriodType.yearWeekDayTime()\n  r61.put($r31, $r30)\n  $r33 \u003d PeriodType.yearWeekDay()\n  $r32 \u003d PeriodType.yearWeekDay()\n  r61.put($r33, $r32)\n  $r35 \u003d PeriodType.yearDayTime()\n  $r34 \u003d PeriodType.yearDayTime()\n  r61.put($r35, $r34)\n  $r37 \u003d PeriodType.yearDay()\n  $r36 \u003d PeriodType.yearDay()\n  r61.put($r37, $r36)\n  $r39 \u003d PeriodType.dayTime()\n  $r38 \u003d PeriodType.dayTime()\n  r61.put($r39, $r38)\n  $r41 \u003d PeriodType.time()\n  $r40 \u003d PeriodType.time()\n  r61.put($r41, $r40)\n  $r43 \u003d PeriodType.years()\n  $r42 \u003d PeriodType.years()\n  r61.put($r43, $r42)\n  $r45 \u003d PeriodType.months()\n  $r44 \u003d PeriodType.months()\n  r61.put($r45, $r44)\n  $r47 \u003d PeriodType.weeks()\n  $r46 \u003d PeriodType.weeks()\n  r61.put($r47, $r46)\n  $r49 \u003d PeriodType.days()\n  $r48 \u003d PeriodType.days()\n  r61.put($r49, $r48)\n  $r51 \u003d PeriodType.hours()\n  $r50 \u003d PeriodType.hours()\n  r61.put($r51, $r50)\n  $r53 \u003d PeriodType.minutes()\n  $r52 \u003d PeriodType.minutes()\n  r61.put($r53, $r52)\n  $r55 \u003d PeriodType.seconds()\n  $r54 \u003d PeriodType.seconds()\n  r61.put($r55, $r54)\n  $r57 \u003d PeriodType.millis()\n  $r56 \u003d PeriodType.millis()\n  r61.put($r57, $r56)\n}",
      "B10 {\n  $r2 \u003d PeriodType\n  new PeriodType(null, r0, null)\n  $r58 \u003d r61.get($r2)\n  $z1 \u003d PeriodType\n  if ($z1 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r23 \u003d PeriodType) $r58\n  return\n}",
      "B12 {\n  if ($r58 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $r20 \u003d IllegalArgumentException\n  $r21 \u003d String.valueOf($r58)\n  $r22 \u003d dynInvoke makeConcatWithConstants($r21)\n  new IllegalArgumentException($r22)\n  throw $r20\n}",
      "B14 {\n  r62 \u003d PeriodType.standard()\n  $r3 \u003d ArrayList\n  $r4 \u003d Arrays.asList(r0)\n  new ArrayList($r4)\n  $r5 \u003d DurationFieldType.years()\n  $z2 \u003d $r3.remove($r5)\n  if ($z2 !\u003d 0) goto B15 else B16\n}",
      "B15 {\n  r62 \u003d r62.withYearsRemoved()\n}",
      "B16 {\n  $r6 \u003d DurationFieldType.months()\n  $z3 \u003d $r3.remove($r6)\n  if ($z3 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  r62 \u003d r62.withMonthsRemoved()\n}",
      "B18 {\n  $r7 \u003d DurationFieldType.weeks()\n  $z4 \u003d $r3.remove($r7)\n  if ($z4 !\u003d 0) goto B19 else B20\n}",
      "B19 {\n  r62 \u003d r62.withWeeksRemoved()\n}",
      "B20 {\n  $r8 \u003d DurationFieldType.days()\n  $z5 \u003d $r3.remove($r8)\n  if ($z5 !\u003d 0) goto B21 else B22\n}",
      "B21 {\n  r62 \u003d r62.withDaysRemoved()\n}",
      "B22 {\n  $r9 \u003d DurationFieldType.hours()\n  $z6 \u003d $r3.remove($r9)\n  if ($z6 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  r62 \u003d r62.withHoursRemoved()\n}",
      "B24 {\n  $r10 \u003d DurationFieldType.minutes()\n  $z7 \u003d $r3.remove($r10)\n  if ($z7 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  r62 \u003d r62.withMinutesRemoved()\n}",
      "B26 {\n  $r11 \u003d DurationFieldType.seconds()\n  $z8 \u003d $r3.remove($r11)\n  if ($z8 !\u003d 0) goto B27 else B28\n}",
      "B27 {\n  r62 \u003d r62.withSecondsRemoved()\n}",
      "B28 {\n  $r12 \u003d DurationFieldType.millis()\n  $z9 \u003d $r3.remove($r12)\n  if ($z9 !\u003d 0) goto B29 else B30\n}",
      "B29 {\n  r62 \u003d r62.withMillisRemoved()\n}",
      "B30 {\n  $i2 \u003d $r3.size()\n  if ($i2 \u003c\u003d 0) goto B31 else B32\n}",
      "B31 {\n  r61.put($r2, $r3)\n  $r17 \u003d IllegalArgumentException\n  $r18 \u003d String.valueOf($r3)\n  $r19 \u003d dynInvoke makeConcatWithConstants($r18)\n  new IllegalArgumentException($r19)\n  throw $r17\n}",
      "B32 {\n  $r13 \u003d PeriodType\n  $r14 \u003d DurationFieldType[] iTypes\u003e\n  new PeriodType(null, $r14, null)\n  $r15 \u003d r61.get($r13)\n  r16 \u003d PeriodType) $r15\n  if (r16 \u003d\u003d null) goto B33 else B34\n}",
      "B33 {\n  r61.put($r13, r16)\n  return\n}",
      "B34 {\n  r61.put($r13, r62)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B4",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e [EXIT]",
      "B34 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodType#yearDay(...0)",
        "body": "{\r\n    PeriodType type \u003d cYD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 });\r\n        cYD \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#yearMonthDay(...0)",
        "body": "{\r\n    PeriodType type \u003d cYMD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearMonthDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 });\r\n        cYMD \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#hours(...0)",
        "body": "{\r\n    PeriodType type \u003d cHours;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Hours\", new DurationFieldType[] { DurationFieldType.hours() }, new int[] { -1, -1, -1, -1, 0, -1, -1, -1 });\r\n        cHours \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#months(...0)",
        "body": "{\r\n    PeriodType type \u003d cMonths;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Months\", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 });\r\n        cMonths \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#years(...0)",
        "body": "{\r\n    PeriodType type \u003d cYears;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Years\", new DurationFieldType[] { DurationFieldType.years() }, new int[] { 0, -1, -1, -1, -1, -1, -1, -1 });\r\n        cYears \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#seconds(...0)",
        "body": "{\r\n    PeriodType type \u003d cSeconds;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Seconds\", new DurationFieldType[] { DurationFieldType.seconds() }, new int[] { -1, -1, -1, -1, -1, -1, 0, -1 });\r\n        cSeconds \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#time(...0)",
        "body": "{\r\n    PeriodType type \u003d cTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Time\", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 });\r\n        cTime \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#standard(...0)",
        "body": "{\r\n    PeriodType type \u003d cStandard;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Standard\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 });\r\n        cStandard \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#yearWeekDayTime(...0)",
        "body": "{\r\n    PeriodType type \u003d cYWDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearWeekDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 });\r\n        cYWDTime \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#yearDayTime(...0)",
        "body": "{\r\n    PeriodType type \u003d cYDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 });\r\n        cYDTime \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#millis(...0)",
        "body": "{\r\n    PeriodType type \u003d cMillis;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Millis\", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 });\r\n        cMillis \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#yearMonthDayTime(...0)",
        "body": "{\r\n    PeriodType type \u003d cYMDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearMonthDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 });\r\n        cYMDTime \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#dayTime(...0)",
        "body": "{\r\n    PeriodType type \u003d cDTime;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"DayTime\", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 });\r\n        cDTime \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#days(...0)",
        "body": "{\r\n    PeriodType type \u003d cDays;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Days\", new DurationFieldType[] { DurationFieldType.days() }, new int[] { -1, -1, -1, 0, -1, -1, -1, -1 });\r\n        cDays \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#minutes(...0)",
        "body": "{\r\n    PeriodType type \u003d cMinutes;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Minutes\", new DurationFieldType[] { DurationFieldType.minutes() }, new int[] { -1, -1, -1, -1, -1, 0, -1, -1 });\r\n        cMinutes \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#weeks(...0)",
        "body": "{\r\n    PeriodType type \u003d cWeeks;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"Weeks\", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 });\r\n        cWeeks \u003d type;\r\n    }\r\n    return type;\r\n}"
      },
      {
        "name": "PeriodType#yearWeekDay(...0)",
        "body": "{\r\n    PeriodType type \u003d cYWD;\r\n    if (type \u003d\u003d null) {\r\n        type \u003d new PeriodType(\"YearWeekDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 });\r\n        cYWD \u003d type;\r\n    }\r\n    return type;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "isSupported",
    "signature": "boolean isSupported(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    return (indexOf(type) \u003e\u003d 0);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PeriodType\n  DurationFieldType\n  $i0 \u003d r0.indexOf(r1)\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodType#indexOf(...1)",
        "body": "{\r\n    for (int i \u003d 0, isize \u003d size(); i \u003c isize; i++) {\r\n        if (iTypes[i].equals(type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "indexOf",
    "signature": "int indexOf(org.joda.time.DurationFieldType)",
    "visibility": "public",
    "body": "{\r\n    for (int i \u003d 0, isize \u003d size(); i \u003c isize; i++) {\r\n        if (iTypes[i].equals(type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PeriodType\n  DurationFieldType\n  i1 \u003d 0\n  i0 \u003d r0.size()\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $r1 \u003d DurationFieldType[] iTypes\u003e\n  $r3 \u003d $r1[i1]\n  $z0 \u003d $r3.equals(r2)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B5 {\n  $i3 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PeriodType#size(...0)",
        "body": "{\r\n    return iTypes.length;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof PeriodType \u003d\u003d false) {\r\n        return false;\r\n    }\r\n    PeriodType other \u003d (PeriodType) obj;\r\n    return (Arrays.equals(iTypes, other.iTypes));\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PeriodType\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d PeriodType\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d PeriodType) r1\n  $r4 \u003d DurationFieldType[] iTypes\u003e\n  $r3 \u003d DurationFieldType[] iTypes\u003e\n  $z1 \u003d Arrays.equals($r4, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.PeriodType",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    int hash \u003d 0;\r\n    for (int i \u003d 0; i \u003c iTypes.length; i++) {\r\n        hash +\u003d iTypes[i].hashCode();\r\n    }\r\n    return hash;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d $i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  PeriodType\n  i2 \u003d 0\n  i3 \u003d 0\n}",
      "B1 {\n  $r1 \u003d DurationFieldType[] iTypes\u003e\n  $i0 \u003d lengthof $r1\n  if (i3 \u003e\u003d $i0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d DurationFieldType[] iTypes\u003e\n  $r3 \u003d $r2[i3]\n  $i1 \u003d $r3.hashCode()\n  i2 \u003d i2 + $i1\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "seconds",
    "signature": "org.joda.time.Seconds seconds(int)",
    "visibility": "public",
    "body": "{\r\n    switch(seconds) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Seconds(seconds);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 7,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B6 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Seconds; }\n}",
      "B1 {\n  $r4 \u003d Seconds ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d Seconds ONE\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d Seconds TWO\u003e\n  return\n}",
      "B4 {\n  $r1 \u003d Seconds THREE\u003e\n  return\n}",
      "B5 {\n  $r0 \u003d Seconds MAX_VALUE\u003e\n  return\n}",
      "B6 {\n  $r5 \u003d Seconds MIN_VALUE\u003e\n  return\n}",
      "B7 {\n  $r6 \u003d Seconds\n  new Seconds(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B6",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B7",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "secondsBetween",
    "signature": "org.joda.time.Seconds secondsBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalTime \u0026\u0026 end instanceof LocalTime) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int seconds \u003d chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\r\n        return Seconds.seconds(seconds);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Seconds.seconds(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalTime\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalTime\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.seconds()\n  $r5 \u003d LocalTime) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalTime) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Seconds.seconds(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Seconds ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Seconds.seconds($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "secondsIn",
    "signature": "org.joda.time.Seconds secondsIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Seconds.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\r\n    return Seconds.seconds(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Seconds ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.seconds()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Seconds.seconds(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "parseSeconds",
    "signature": "org.joda.time.Seconds parseSeconds(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Seconds.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Seconds.seconds(p.getSeconds());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Seconds ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getSeconds()\n  $r3 \u003d Seconds.seconds($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "plus",
    "signature": "org.joda.time.Seconds plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Seconds.seconds($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "plus",
    "signature": "org.joda.time.Seconds plus(org.joda.time.Seconds)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(seconds.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  Seconds\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#plus(...1)",
        "body": "{\r\n    if (seconds \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "minus",
    "signature": "org.joda.time.Seconds minus(org.joda.time.Seconds)",
    "visibility": "public",
    "body": "{\r\n    if (seconds \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(seconds.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  Seconds\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(seconds));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Seconds dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Seconds.seconds(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Seconds.seconds($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Seconds)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  Seconds\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Seconds",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Seconds)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Seconds\n  Seconds\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Seconds#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.TimeOfDay fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new TimeOfDay(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d TimeOfDay\n  $i3 \u003d r0.get(11)\n  $i2 \u003d r0.get(12)\n  $i1 \u003d r0.get(13)\n  $i0 \u003d r0.get(14)\n  new TimeOfDay($i3, $i2, $i1, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.TimeOfDay fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d TimeOfDay\n  $i7 \u003d r0.getHours()\n  $i6 \u003d r0.getMinutes()\n  $i5 \u003d r0.getSeconds()\n  $l0 \u003d r0.getTime()\n  $l1 \u003d $l0 % 1000L\n  $i2 \u003d (int) $l1\n  $i3 \u003d $i2 + 1000\n  $i4 \u003d $i3 % 1000\n  new TimeOfDay($i7, $i6, $i5, $i4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "withChronologyRetainFields",
    "signature": "org.joda.time.TimeOfDay withChronologyRetainFields(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    newChronology \u003d newChronology.withUTC();\r\n    if (newChronology \u003d\u003d getChronology()) {\r\n        return this;\r\n    } else {\r\n        TimeOfDay newTimeOfDay \u003d new TimeOfDay(this, newChronology);\r\n        newChronology.validate(newTimeOfDay, getValues());\r\n        return newTimeOfDay;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TimeOfDay\n  Chronology\n  r5 \u003d DateTimeUtils.getChronology(r4)\n  r6 \u003d r5.withUTC()\n  $r1 \u003d r0.getChronology()\n  if (r6 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d TimeOfDay\n  new TimeOfDay(r0, r6)\n  $r3 \u003d r0.getValues()\n  r6.validate($r2, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TimeOfDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "withField",
    "signature": "org.joda.time.TimeOfDay withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new TimeOfDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TimeOfDay\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  $i2 \u003d r0.getValue(i0)\n  if (i1 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.set(r0, i0, r4, i1)\n  $r3 \u003d TimeOfDay\n  new TimeOfDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TimeOfDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#indexOfSupported(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#getValue(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.TimeOfDay withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).addWrapPartial(this, index, newValues, amount);\r\n    return new TimeOfDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TimeOfDay\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.addWrapPartial(r0, i0, r4, i1)\n  $r3 \u003d TimeOfDay\n  new TimeOfDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TimeOfDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.TimeOfDay",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.TimeOfDay withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        DurationFieldType fieldType \u003d period.getFieldType(i);\r\n        int index \u003d indexOf(fieldType);\r\n        if (index \u003e\u003d 0) {\r\n            newValues \u003d getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\r\n        }\r\n    }\r\n    return new TimeOfDay(this, newValues);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i5 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If(i2 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  TimeOfDay\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r5 \u003d r1.getValues()\n  i5 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i5 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  r3 \u003d r0.getFieldType(i5)\n  i2 \u003d r1.indexOf(r3)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getField(i2)\n  $i3 \u003d r0.getValue(i5)\n  $i4 \u003d FieldUtils.safeMultiply($i3, i0)\n  r5 \u003d $r4.addWrapPartial(r1, i2, r5, $i4)\n}",
      "B7 {\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B8 {\n  $r2 \u003d TimeOfDay\n  new TimeOfDay(r1, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TimeOfDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TimeOfDay#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.CachedDateTimeZone",
    "methodName": "forZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone forZone(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone instanceof CachedDateTimeZone) {\r\n        return (CachedDateTimeZone) zone;\r\n    }\r\n    return new CachedDateTimeZone(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  $z0 \u003d CachedDateTimeZone\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d CachedDateTimeZone) r0\n  return\n}",
      "B2 {\n  $r1 \u003d CachedDateTimeZone\n  new CachedDateTimeZone(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.tz.CachedDateTimeZone",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof CachedDateTimeZone) {\r\n        return iZone.equals(((CachedDateTimeZone) obj).iZone);\r\n    }\r\n    return false;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CachedDateTimeZone\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d CachedDateTimeZone\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d DateTimeZone iZone\u003e\n  $r2 \u003d CachedDateTimeZone) r1\n  $r3 \u003d DateTimeZone iZone\u003e\n  $z1 \u003d $r4.equals($r3)\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "readFrom",
    "signature": "org.joda.time.DateTimeZone readFrom(java.io.InputStream,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (in instanceof DataInput) {\r\n        return readFrom((DataInput) in, id);\r\n    } else {\r\n        return readFrom((DataInput) new DataInputStream(in), id);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  InputStream\n  String\n  $z0 \u003d DataInput\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DataInput) r0\n  $r5 \u003d DateTimeZoneBuilder.readFrom($r4, r2)\n  return\n}",
      "B2 {\n  $r1 \u003d DataInputStream\n  new DataInputStream(r0)\n  $r3 \u003d DateTimeZoneBuilder.readFrom($r1, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#readFrom(...2)",
        "body": "{\r\n    if (in instanceof DataInput) {\r\n        return readFrom((DataInput) in, id);\r\n    } else {\r\n        return readFrom((DataInput) new DataInputStream(in), id);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "readFrom",
    "signature": "org.joda.time.DateTimeZone readFrom(java.io.DataInput,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    switch(in.readUnsignedByte()) {\r\n        case \u0027F\u0027:\r\n            DateTimeZone fixed \u003d new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in));\r\n            if (fixed.equals(DateTimeZone.UTC)) {\r\n                fixed \u003d DateTimeZone.UTC;\r\n            }\r\n            return fixed;\r\n        case \u0027C\u0027:\r\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\r\n        case \u0027P\u0027:\r\n            return PrecalculatedZone.readFrom(in, id);\r\n        default:\r\n            throw new IOException(\"Invalid encoding\");\r\n    }\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(switch-on $i0) → B4 | else → B1",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DataInput\n  String\n  $i0 \u003d r0.readUnsignedByte()\n  IOException; }\n}",
      "B1 {\n  $r3 \u003d FixedDateTimeZone\n  $r4 \u003d r0.readUTF()\n  $l1 \u003d DateTimeZoneBuilder.readMillis(r0)\n  $i4 \u003d (int) $l1\n  $l2 \u003d DateTimeZoneBuilder.readMillis(r0)\n  $i3 \u003d (int) $l2\n  new FixedDateTimeZone(r1, $r4, $i4, $i3)\n  r9 \u003d $r3\n  $r5 \u003d DateTimeZone UTC\u003e\n  $z0 \u003d $r3.equals($r5)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  r9 \u003d DateTimeZone UTC\u003e\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r6 \u003d DateTimeZoneBuilder$PrecalculatedZone.readFrom(r0, r1)\n  $r7 \u003d CachedDateTimeZone.forZone($r6)\n  return\n}",
      "B5 {\n  $r2 \u003d DateTimeZoneBuilder$PrecalculatedZone.readFrom(r0, r1)\n  return\n}",
      "B6 {\n  $r8 \u003d IOException\n  new IOException(\"Invalid encoding\")\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B4",
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#readMillis(...1)",
        "body": "{\r\n    int v \u003d in.readUnsignedByte();\r\n    switch(v \u003e\u003e 6) {\r\n        case 0:\r\n        default:\r\n            // Form 00 (6 bits effective precision)\r\n            v \u003d (v \u003c\u003c (32 - 6)) \u003e\u003e (32 - 6);\r\n            return v * (30 * 60000L);\r\n        case 1:\r\n            // Form 01 (30 bits effective precision)\r\n            v \u003d (v \u003c\u003c (32 - 6)) \u003e\u003e (32 - 30);\r\n            v |\u003d (in.readUnsignedByte()) \u003c\u003c 16;\r\n            v |\u003d (in.readUnsignedByte()) \u003c\u003c 8;\r\n            v |\u003d (in.readUnsignedByte());\r\n            return v * 60000L;\r\n        case 2:\r\n            // Form 10 (38 bits effective precision)\r\n            long w \u003d (((long) v) \u003c\u003c (64 - 6)) \u003e\u003e (64 - 38);\r\n            w |\u003d (in.readUnsignedByte()) \u003c\u003c 24;\r\n            w |\u003d (in.readUnsignedByte()) \u003c\u003c 16;\r\n            w |\u003d (in.readUnsignedByte()) \u003c\u003c 8;\r\n            w |\u003d (in.readUnsignedByte());\r\n            return w * 1000L;\r\n        case 3:\r\n            // Form 11 (64-bits effective precision)\r\n            return in.readLong();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "addCutover",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder addCutover(int,char,int,int,int,boolean,int)",
    "visibility": "public",
    "body": "{\r\n    if (iRuleSets.size() \u003e 0) {\r\n        OfYear ofYear \u003d new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\r\n        RuleSet lastRuleSet \u003d iRuleSets.get(iRuleSets.size() - 1);\r\n        lastRuleSet.setUpperLimit(year, ofYear);\r\n    }\r\n    iRuleSets.add(new RuleSet());\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZoneBuilder\n  i8 :\u003d @parameter0: int\n  c1 :\u003d @parameter1: char\n  i2 :\u003d @parameter2: int\n  i3 :\u003d @parameter3: int\n  i4 :\u003d @parameter4: int\n  z0 :\u003d @parameter5: boolean\n  i5 :\u003d @parameter6: int\n  $r1 \u003d ArrayList iRuleSets\u003e\n  $i0 \u003d $r1.size()\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DateTimeZoneBuilder$OfYear\n  new DateTimeZoneBuilder$OfYear(c1, i2, i3, i4, z0, i5)\n  $r6 \u003d ArrayList iRuleSets\u003e\n  $r5 \u003d ArrayList iRuleSets\u003e\n  $i6 \u003d $r5.size()\n  $i7 \u003d $i6 - 1\n  $r7 \u003d $r6.get($i7)\n  r8 \u003d DateTimeZoneBuilder$RuleSet) $r7\n  r8.setUpperLimit(i8, $r4)\n}",
      "B2 {\n  $r3 \u003d ArrayList iRuleSets\u003e\n  $r2 \u003d DateTimeZoneBuilder$RuleSet\n  new DateTimeZoneBuilder$RuleSet()\n  $r3.add($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "addRecurringSavings",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder addRecurringSavings(java.lang.String,int,int,int,char,int,int,int,boolean,int)",
    "visibility": "public",
    "body": "{\r\n    if (fromYear \u003c\u003d toYear) {\r\n        OfYear ofYear \u003d new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\r\n        Recurrence recurrence \u003d new Recurrence(ofYear, nameKey, saveMillis);\r\n        Rule rule \u003d new Rule(recurrence, fromYear, toYear);\r\n        getLastRuleSet().addRule(rule);\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZoneBuilder\n  String\n  i7 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  c2 :\u003d @parameter4: char\n  i3 :\u003d @parameter5: int\n  i4 :\u003d @parameter6: int\n  i5 :\u003d @parameter7: int\n  z0 :\u003d @parameter8: boolean\n  i6 :\u003d @parameter9: int\n  if (i0 \u003e i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d DateTimeZoneBuilder$OfYear\n  new DateTimeZoneBuilder$OfYear(c2, i3, i4, i5, z0, i6)\n  $r2 \u003d DateTimeZoneBuilder$Recurrence\n  new DateTimeZoneBuilder$Recurrence($r1, r3, i7)\n  $r4 \u003d DateTimeZoneBuilder$Rule\n  new DateTimeZoneBuilder$Rule($r2, i0, i1)\n  $r5 \u003d r0.getLastRuleSet()\n  $r5.addRule($r4)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#getLastRuleSet(...0)",
        "body": "{\r\n    if (iRuleSets.size() \u003d\u003d 0) {\r\n        addCutover(Integer.MIN_VALUE, \u0027w\u0027, 1, 1, 0, false, 0);\r\n    }\r\n    return iRuleSets.get(iRuleSets.size() - 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "toDateTimeZone",
    "signature": "org.joda.time.DateTimeZone toDateTimeZone(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (id \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    // Discover where all the transitions occur and store the results in\r\n    // these lists.\r\n    ArrayList\u003cTransition\u003e transitions \u003d new ArrayList\u003cTransition\u003e();\r\n    // Tail zone picks up remaining transitions in the form of an endless\r\n    // DST cycle.\r\n    DSTZone tailZone \u003d null;\r\n    long millis \u003d Long.MIN_VALUE;\r\n    int saveMillis \u003d 0;\r\n    int ruleSetCount \u003d iRuleSets.size();\r\n    for (int i \u003d 0; i \u003c ruleSetCount; i++) {\r\n        RuleSet rs \u003d iRuleSets.get(i);\r\n        Transition next \u003d rs.firstTransition(millis);\r\n        if (next \u003d\u003d null) {\r\n            continue;\r\n        }\r\n        addTransition(transitions, next);\r\n        millis \u003d next.getMillis();\r\n        saveMillis \u003d next.getSaveMillis();\r\n        // Copy it since we\u0027re going to destroy it.\r\n        rs \u003d new RuleSet(rs);\r\n        while ((next \u003d rs.nextTransition(millis, saveMillis)) !\u003d null) {\r\n            if (addTransition(transitions, next) \u0026\u0026 tailZone !\u003d null) {\r\n                // Got the extra transition before DSTZone.\r\n                break;\r\n            }\r\n            millis \u003d next.getMillis();\r\n            saveMillis \u003d next.getSaveMillis();\r\n            if (tailZone \u003d\u003d null \u0026\u0026 i \u003d\u003d ruleSetCount - 1) {\r\n                tailZone \u003d rs.buildTailZone(id);\r\n                // If tailZone is not null, don\u0027t break out of main loop until\r\n                // at least one more transition is calculated. This ensures a\r\n                // correct \u0027seam\u0027 to the DSTZone.\r\n            }\r\n        }\r\n        millis \u003d rs.getUpperLimit(saveMillis);\r\n    }\r\n    // Check if a simpler zone implementation can be returned.\r\n    if (transitions.size() \u003d\u003d 0) {\r\n        if (tailZone !\u003d null) {\r\n            // This shouldn\u0027t happen, but handle just in case.\r\n            return tailZone;\r\n        }\r\n        return buildFixedZone(id, \"UTC\", 0, 0);\r\n    }\r\n    if (transitions.size() \u003d\u003d 1 \u0026\u0026 tailZone \u003d\u003d null) {\r\n        Transition tr \u003d transitions.get(0);\r\n        return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset());\r\n    }\r\n    PrecalculatedZone zone \u003d PrecalculatedZone.create(id, outputID, transitions, tailZone);\r\n    if (zone.isCachable()) {\r\n        return CachedDateTimeZone.forZone(zone);\r\n    }\r\n    return zone;\r\n}",
    "nodes": 26,
    "edges": 33,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B3 : If(i7 \u003e\u003d i0) → B4 | else → B16",
      "B4 : If(r16 !\u003d null) → B5 | else → B6",
      "B7 : If($r17 \u003d\u003d null) → B8 | else → B14",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B11",
      "B9 : If(r14 \u003d\u003d null) → B10 | else → B11",
      "B11 : If(r14 !\u003d null) → B12 | else → B7",
      "B12 : If(i7 !\u003d $i5) → B13 | else → B7",
      "B16 : If($i1 !\u003d 0) → B17 | else → B20",
      "B17 : If(r14 \u003d\u003d null) → B18 | else → B19",
      "B20 : If($i2 !\u003d 1) → B21 | else → B23",
      "B21 : If(r14 !\u003d null) → B22 | else → B23",
      "B23 : If($z1 \u003d\u003d false) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  DateTimeZoneBuilder\n  String\n  z0 :\u003d @parameter1: boolean\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r13\n}",
      "B2 {\n  $r1 \u003d ArrayList\n  new ArrayList()\n  r14 \u003d null\n  l6 \u003d -9223372036854775808L\n  $r3 \u003d ArrayList iRuleSets\u003e\n  i0 \u003d $r3.size()\n  i7 \u003d 0\n}",
      "B3 {\n  if (i7 \u003e\u003d i0) goto B4 else B16\n}",
      "B4 {\n  $r10 \u003d ArrayList iRuleSets\u003e\n  $r11 \u003d $r10.get(i7)\n  r15 \u003d DateTimeZoneBuilder$RuleSet) $r11\n  r16 \u003d r15.firstTransition(l6)\n  if (r16 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  goto B15\n}",
      "B6 {\n  r2.addTransition($r1, r16)\n  l8 \u003d r16.getMillis()\n  i9 \u003d r16.getSaveMillis()\n  $r12 \u003d DateTimeZoneBuilder$RuleSet\n  new DateTimeZoneBuilder$RuleSet(r15)\n}",
      "B7 {\n  $r17 \u003d $r12.nextTransition(l8, i9)\n  if ($r17 \u003d\u003d null) goto B8 else B14\n}",
      "B8 {\n  $z2 \u003d r2.addTransition($r1, $r17)\n  if ($z2 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  if (r14 \u003d\u003d null) goto B10 else B11\n}",
      "B10 {\n  goto B14\n}",
      "B11 {\n  l8 \u003d $r17.getMillis()\n  i9 \u003d $r17.getSaveMillis()\n  if (r14 !\u003d null) goto B12 else B7\n}",
      "B12 {\n  $i5 \u003d i0 - 1\n  if (i7 !\u003d $i5) goto B13 else B7\n}",
      "B13 {\n  r14 \u003d $r12.buildTailZone(r0)\n  goto B7\n}",
      "B14 {\n  l6 \u003d $r12.getUpperLimit(i9)\n}",
      "B15 {\n  i7 \u003d i7 + 1\n  goto B3\n}",
      "B16 {\n  $i1 \u003d $r1.size()\n  if ($i1 !\u003d 0) goto B17 else B20\n}",
      "B17 {\n  if (r14 \u003d\u003d null) goto B18 else B19\n}",
      "B18 {\n  return\n}",
      "B19 {\n  $r9 \u003d DateTimeZoneBuilder.buildFixedZone(r0, \"UTC\", 0, 0)\n  return\n}",
      "B20 {\n  $i2 \u003d $r1.size()\n  if ($i2 !\u003d 1) goto B21 else B23\n}",
      "B21 {\n  if (r14 !\u003d null) goto B22 else B23\n}",
      "B22 {\n  $r6 \u003d $r1.get(0)\n  r18 \u003d DateTimeZoneBuilder$Transition) $r6\n  $r7 \u003d r18.getNameKey()\n  $i4 \u003d r18.getWallOffset()\n  $i3 \u003d r18.getStandardOffset()\n  $r8 \u003d DateTimeZoneBuilder.buildFixedZone(r0, $r7, $i4, $i3)\n  return\n}",
      "B23 {\n  $r5 \u003d DateTimeZoneBuilder$PrecalculatedZone.create(r0, z0, $r1, r14)\n  $z1 \u003d $r5.isCachable()\n  if ($z1 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $r4 \u003d CachedDateTimeZone.forZone($r5)\n  return\n}",
      "B25 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B16",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B15",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B14",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B7",
      "B12 --\u003e B13",
      "B12 --\u003e B7",
      "B13 --\u003e B7",
      "B14 --\u003e B15",
      "B15 --\u003e B3",
      "B16 --\u003e B17",
      "B16 --\u003e B20",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B23",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#addTransition(...2)",
        "body": "{\r\n    int size \u003d transitions.size();\r\n    if (size \u003d\u003d 0) {\r\n        //            System.out.println(\"Adding   \" + tr);\r\n        transitions.add(tr);\r\n        return true;\r\n    }\r\n    Transition last \u003d transitions.get(size - 1);\r\n    if (!tr.isTransitionFrom(last)) {\r\n        //            System.out.println(\"Rejected \" + tr);\r\n        return false;\r\n    }\r\n    // If local time of new transition is same as last local time, just\r\n    // replace last transition with new one.\r\n    int offsetForLast \u003d 0;\r\n    if (size \u003e\u003d 2) {\r\n        offsetForLast \u003d transitions.get(size - 2).getWallOffset();\r\n    }\r\n    int offsetForNew \u003d last.getWallOffset();\r\n    long lastLocal \u003d last.getMillis() + offsetForLast;\r\n    long newLocal \u003d tr.getMillis() + offsetForNew;\r\n    if (newLocal !\u003d lastLocal) {\r\n        transitions.add(tr);\r\n        //            System.out.println(\"Adding   \" + tr);\r\n        return true;\r\n    }\r\n    Transition previous \u003d transitions.remove(size - 1);\r\n    Transition adjusted \u003d tr.withMillis(previous.getMillis());\r\n    //        System.out.println(\"Current  \" + tr);\r\n    //        System.out.println(\"Previous \" + previous);\r\n    //        System.out.println(\"Adjusted \" + adjusted);\r\n    return addTransition(transitions, adjusted);\r\n}"
      },
      {
        "name": "DateTimeZoneBuilder#buildFixedZone(...4)",
        "body": "{\r\n    if (\"UTC\".equals(id) \u0026\u0026 id.equals(nameKey) \u0026\u0026 wallOffset \u003d\u003d 0 \u0026\u0026 standardOffset \u003d\u003d 0) {\r\n        return DateTimeZone.UTC;\r\n    }\r\n    return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "writeTo",
    "signature": "void writeTo(java.lang.String,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    if (out instanceof DataOutput) {\r\n        writeTo(zoneID, (DataOutput) out);\r\n    } else {\r\n        DataOutputStream dout \u003d new DataOutputStream(out);\r\n        writeTo(zoneID, (DataOutput) dout);\r\n        dout.flush();\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZoneBuilder\n  String\n  OutputStream\n  $z0 \u003d DataOutput\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d DataOutput) r0\n  r2.writeTo(r3, $r4)\n  goto B3\n}",
      "B2 {\n  $r1 \u003d DataOutputStream\n  new DataOutputStream(r0)\n  r2.writeTo(r3, $r1)\n  $r1.flush()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#writeTo(...2)",
        "body": "{\r\n    if (out instanceof DataOutput) {\r\n        writeTo(zoneID, (DataOutput) out);\r\n    } else {\r\n        DataOutputStream dout \u003d new DataOutputStream(out);\r\n        writeTo(zoneID, (DataOutput) dout);\r\n        dout.flush();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DateTimeZoneBuilder",
    "methodName": "writeTo",
    "signature": "void writeTo(java.lang.String,java.io.DataOutput)",
    "visibility": "public",
    "body": "{\r\n    // pass false so zone id is not written out\r\n    DateTimeZone zone \u003d toDateTimeZone(zoneID, false);\r\n    if (zone instanceof FixedDateTimeZone) {\r\n        // \u0027F\u0027 for fixed\r\n        out.writeByte(\u0027F\u0027);\r\n        out.writeUTF(zone.getNameKey(0));\r\n        writeMillis(out, zone.getOffset(0));\r\n        writeMillis(out, zone.getStandardOffset(0));\r\n    } else {\r\n        if (zone instanceof CachedDateTimeZone) {\r\n            // \u0027C\u0027 for cached, precalculated\r\n            out.writeByte(\u0027C\u0027);\r\n            zone \u003d ((CachedDateTimeZone) zone).getUncachedZone();\r\n        } else {\r\n            // \u0027P\u0027 for precalculated, uncached\r\n            out.writeByte(\u0027P\u0027);\r\n        }\r\n        ((PrecalculatedZone) zone).writeTo(out);\r\n    }\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DateTimeZoneBuilder\n  String\n  DataOutput\n  r6 \u003d r0.toDateTimeZone(r1, 0)\n  $z0 \u003d FixedDateTimeZone\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r2.writeByte(70)\n  $r5 \u003d r6.getNameKey(0L)\n  r2.writeUTF($r5)\n  $i0 \u003d r6.getOffset(0L)\n  $l1 \u003d (long) $i0\n  DateTimeZoneBuilder.writeMillis(r2, $l1)\n  $i2 \u003d r6.getStandardOffset(0L)\n  $l3 \u003d (long) $i2\n  DateTimeZoneBuilder.writeMillis(r2, $l3)\n  goto B6\n}",
      "B2 {\n  $z1 \u003d CachedDateTimeZone\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r2.writeByte(67)\n  $r4 \u003d CachedDateTimeZone) r6\n  r6 \u003d $r4.getUncachedZone()\n  goto B5\n}",
      "B4 {\n  r2.writeByte(80)\n}",
      "B5 {\n  $r3 \u003d DateTimeZoneBuilder$PrecalculatedZone) r6\n  $r3.writeTo(r2)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTimeZoneBuilder#toDateTimeZone(...2)",
        "body": "{\r\n    if (id \u003d\u003d null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    // Discover where all the transitions occur and store the results in\r\n    // these lists.\r\n    ArrayList\u003cTransition\u003e transitions \u003d new ArrayList\u003cTransition\u003e();\r\n    // Tail zone picks up remaining transitions in the form of an endless\r\n    // DST cycle.\r\n    DSTZone tailZone \u003d null;\r\n    long millis \u003d Long.MIN_VALUE;\r\n    int saveMillis \u003d 0;\r\n    int ruleSetCount \u003d iRuleSets.size();\r\n    for (int i \u003d 0; i \u003c ruleSetCount; i++) {\r\n        RuleSet rs \u003d iRuleSets.get(i);\r\n        Transition next \u003d rs.firstTransition(millis);\r\n        if (next \u003d\u003d null) {\r\n            continue;\r\n        }\r\n        addTransition(transitions, next);\r\n        millis \u003d next.getMillis();\r\n        saveMillis \u003d next.getSaveMillis();\r\n        // Copy it since we\u0027re going to destroy it.\r\n        rs \u003d new RuleSet(rs);\r\n        while ((next \u003d rs.nextTransition(millis, saveMillis)) !\u003d null) {\r\n            if (addTransition(transitions, next) \u0026\u0026 tailZone !\u003d null) {\r\n                // Got the extra transition before DSTZone.\r\n                break;\r\n            }\r\n            millis \u003d next.getMillis();\r\n            saveMillis \u003d next.getSaveMillis();\r\n            if (tailZone \u003d\u003d null \u0026\u0026 i \u003d\u003d ruleSetCount - 1) {\r\n                tailZone \u003d rs.buildTailZone(id);\r\n                // If tailZone is not null, don\u0027t break out of main loop until\r\n                // at least one more transition is calculated. This ensures a\r\n                // correct \u0027seam\u0027 to the DSTZone.\r\n            }\r\n        }\r\n        millis \u003d rs.getUpperLimit(saveMillis);\r\n    }\r\n    // Check if a simpler zone implementation can be returned.\r\n    if (transitions.size() \u003d\u003d 0) {\r\n        if (tailZone !\u003d null) {\r\n            // This shouldn\u0027t happen, but handle just in case.\r\n            return tailZone;\r\n        }\r\n        return buildFixedZone(id, \"UTC\", 0, 0);\r\n    }\r\n    if (transitions.size() \u003d\u003d 1 \u0026\u0026 tailZone \u003d\u003d null) {\r\n        Transition tr \u003d transitions.get(0);\r\n        return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset());\r\n    }\r\n    PrecalculatedZone zone \u003d PrecalculatedZone.create(id, outputID, transitions, tailZone);\r\n    if (zone.isCachable()) {\r\n        return CachedDateTimeZone.forZone(zone);\r\n    }\r\n    return zone;\r\n}"
      },
      {
        "name": "DateTimeZoneBuilder#writeMillis(...2)",
        "body": "{\r\n    if (millis % (30 * 60000L) \u003d\u003d 0) {\r\n        // Try to write in 30 minute units.\r\n        long units \u003d millis / (30 * 60000L);\r\n        if (((units \u003c\u003c (64 - 6)) \u003e\u003e (64 - 6)) \u003d\u003d units) {\r\n            // Form 00 (6 bits effective precision)\r\n            out.writeByte((int) (units \u0026 0x3f));\r\n            return;\r\n        }\r\n    }\r\n    if (millis % 60000L \u003d\u003d 0) {\r\n        // Try to write minutes.\r\n        long minutes \u003d millis / 60000L;\r\n        if (((minutes \u003c\u003c (64 - 30)) \u003e\u003e (64 - 30)) \u003d\u003d minutes) {\r\n            // Form 01 (30 bits effective precision)\r\n            out.writeInt(0x40000000 | (int) (minutes \u0026 0x3fffffff));\r\n            return;\r\n        }\r\n    }\r\n    if (millis % 1000L \u003d\u003d 0) {\r\n        // Try to write seconds.\r\n        long seconds \u003d millis / 1000L;\r\n        if (((seconds \u003c\u003c (64 - 38)) \u003e\u003e (64 - 38)) \u003d\u003d seconds) {\r\n            // Form 10 (38 bits effective precision)\r\n            out.writeByte(0x80 | (int) ((seconds \u003e\u003e 32) \u0026 0x3f));\r\n            out.writeInt((int) (seconds \u0026 0xffffffff));\r\n            return;\r\n        }\r\n    }\r\n    // Write milliseconds either because the additional precision is\r\n    // required or the minutes didn\u0027t fit in the field.\r\n    // Form 11 (64-bits effective precision, but write as if 70 bits)\r\n    out.writeByte(millis \u003c 0 ? 0xff : 0xc0);\r\n    out.writeLong(millis);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DefaultNameProvider",
    "methodName": "getShortName",
    "signature": "java.lang.String getShortName(java.util.Locale,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    String[] nameSet \u003d getNameSet(locale, id, nameKey);\r\n    return nameSet \u003d\u003d null ? null : nameSet[0];\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultNameProvider\n  Locale\n  String\n  String\n  r4 \u003d r0.getNameSet(r1, r2, r3)\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d null\n  goto B3\n}",
      "B2 {\n  $r5 \u003d r4[0]\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultNameProvider#getNameSet(...3)",
        "body": "{\r\n    if (locale \u003d\u003d null || id \u003d\u003d null || nameKey \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Map\u003cString, Map\u003cString, Object\u003e\u003e byIdCache \u003d iByLocaleCache.get(locale);\r\n    if (byIdCache \u003d\u003d null) {\r\n        iByLocaleCache.put(locale, byIdCache \u003d createCache());\r\n    }\r\n    Map\u003cString, Object\u003e byNameKeyCache \u003d byIdCache.get(id);\r\n    if (byNameKeyCache \u003d\u003d null) {\r\n        byIdCache.put(id, byNameKeyCache \u003d createCache());\r\n        String[][] zoneStringsEn \u003d DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\r\n        String[] setEn \u003d null;\r\n        for (String[] strings : zoneStringsEn) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setEn \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        String[][] zoneStringsLoc \u003d DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\r\n        String[] setLoc \u003d null;\r\n        for (String[] strings : zoneStringsLoc) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setLoc \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        if (setEn !\u003d null \u0026\u0026 setLoc !\u003d null) {\r\n            byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] });\r\n            // need to handle case where summer and winter have the same\r\n            // abbreviation, such as EST in Australia [1716305]\r\n            // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\r\n            if (setEn[2].equals(setEn[4])) {\r\n                byNameKeyCache.put(setEn[4] + \"-Summer\", new String[] { setLoc[4], setLoc[3] });\r\n            } else {\r\n                byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] });\r\n            }\r\n        }\r\n    }\r\n    return (String[]) byNameKeyCache.get(nameKey);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DefaultNameProvider",
    "methodName": "getName",
    "signature": "java.lang.String getName(java.util.Locale,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    String[] nameSet \u003d getNameSet(locale, id, nameKey);\r\n    return nameSet \u003d\u003d null ? null : nameSet[1];\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultNameProvider\n  Locale\n  String\n  String\n  r4 \u003d r0.getNameSet(r1, r2, r3)\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d null\n  goto B3\n}",
      "B2 {\n  $r5 \u003d r4[1]\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultNameProvider#getNameSet(...3)",
        "body": "{\r\n    if (locale \u003d\u003d null || id \u003d\u003d null || nameKey \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Map\u003cString, Map\u003cString, Object\u003e\u003e byIdCache \u003d iByLocaleCache.get(locale);\r\n    if (byIdCache \u003d\u003d null) {\r\n        iByLocaleCache.put(locale, byIdCache \u003d createCache());\r\n    }\r\n    Map\u003cString, Object\u003e byNameKeyCache \u003d byIdCache.get(id);\r\n    if (byNameKeyCache \u003d\u003d null) {\r\n        byIdCache.put(id, byNameKeyCache \u003d createCache());\r\n        String[][] zoneStringsEn \u003d DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\r\n        String[] setEn \u003d null;\r\n        for (String[] strings : zoneStringsEn) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setEn \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        String[][] zoneStringsLoc \u003d DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\r\n        String[] setLoc \u003d null;\r\n        for (String[] strings : zoneStringsLoc) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setLoc \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        if (setEn !\u003d null \u0026\u0026 setLoc !\u003d null) {\r\n            byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] });\r\n            // need to handle case where summer and winter have the same\r\n            // abbreviation, such as EST in Australia [1716305]\r\n            // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\r\n            if (setEn[2].equals(setEn[4])) {\r\n                byNameKeyCache.put(setEn[4] + \"-Summer\", new String[] { setLoc[4], setLoc[3] });\r\n            } else {\r\n                byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] });\r\n            }\r\n        }\r\n    }\r\n    return (String[]) byNameKeyCache.get(nameKey);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DefaultNameProvider",
    "methodName": "getShortName",
    "signature": "java.lang.String getShortName(java.util.Locale,java.lang.String,java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    String[] nameSet \u003d getNameSet(locale, id, nameKey, standardTime);\r\n    return nameSet \u003d\u003d null ? null : nameSet[0];\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultNameProvider\n  Locale\n  String\n  String\n  z0 :\u003d @parameter3: boolean\n  r4 \u003d r0.getNameSet(r1, r2, r3, z0)\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d null\n  goto B3\n}",
      "B2 {\n  $r5 \u003d r4[0]\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultNameProvider#getNameSet(...4)",
        "body": "{\r\n    if (locale \u003d\u003d null || id \u003d\u003d null || nameKey \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (id.startsWith(\"Etc/\")) {\r\n        id \u003d id.substring(4);\r\n    }\r\n    Map\u003cString, Map\u003cBoolean, Object\u003e\u003e byIdCache \u003d iByLocaleCache2.get(locale);\r\n    if (byIdCache \u003d\u003d null) {\r\n        iByLocaleCache2.put(locale, byIdCache \u003d createCache());\r\n    }\r\n    Map\u003cBoolean, Object\u003e byNameKeyCache \u003d byIdCache.get(id);\r\n    if (byNameKeyCache \u003d\u003d null) {\r\n        byIdCache.put(id, byNameKeyCache \u003d createCache());\r\n        String[][] zoneStringsEn \u003d DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\r\n        String[] setEn \u003d null;\r\n        for (String[] strings : zoneStringsEn) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setEn \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        String[][] zoneStringsLoc \u003d DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\r\n        String[] setLoc \u003d null;\r\n        for (String[] strings : zoneStringsLoc) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setLoc \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        if (setEn !\u003d null \u0026\u0026 setLoc !\u003d null) {\r\n            byNameKeyCache.put(Boolean.TRUE, new String[] { setLoc[2], setLoc[1] });\r\n            byNameKeyCache.put(Boolean.FALSE, new String[] { setLoc[4], setLoc[3] });\r\n        }\r\n    }\r\n    return (String[]) byNameKeyCache.get(Boolean.valueOf(standardTime));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.DefaultNameProvider",
    "methodName": "getName",
    "signature": "java.lang.String getName(java.util.Locale,java.lang.String,java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    String[] nameSet \u003d getNameSet(locale, id, nameKey, standardTime);\r\n    return nameSet \u003d\u003d null ? null : nameSet[1];\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultNameProvider\n  Locale\n  String\n  String\n  z0 :\u003d @parameter3: boolean\n  r4 \u003d r0.getNameSet(r1, r2, r3, z0)\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d null\n  goto B3\n}",
      "B2 {\n  $r5 \u003d r4[1]\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultNameProvider#getNameSet(...4)",
        "body": "{\r\n    if (locale \u003d\u003d null || id \u003d\u003d null || nameKey \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (id.startsWith(\"Etc/\")) {\r\n        id \u003d id.substring(4);\r\n    }\r\n    Map\u003cString, Map\u003cBoolean, Object\u003e\u003e byIdCache \u003d iByLocaleCache2.get(locale);\r\n    if (byIdCache \u003d\u003d null) {\r\n        iByLocaleCache2.put(locale, byIdCache \u003d createCache());\r\n    }\r\n    Map\u003cBoolean, Object\u003e byNameKeyCache \u003d byIdCache.get(id);\r\n    if (byNameKeyCache \u003d\u003d null) {\r\n        byIdCache.put(id, byNameKeyCache \u003d createCache());\r\n        String[][] zoneStringsEn \u003d DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\r\n        String[] setEn \u003d null;\r\n        for (String[] strings : zoneStringsEn) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setEn \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        String[][] zoneStringsLoc \u003d DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\r\n        String[] setLoc \u003d null;\r\n        for (String[] strings : zoneStringsLoc) {\r\n            if (strings !\u003d null \u0026\u0026 strings.length \u003e\u003d 5 \u0026\u0026 id.equals(strings[0])) {\r\n                setLoc \u003d strings;\r\n                break;\r\n            }\r\n        }\r\n        if (setEn !\u003d null \u0026\u0026 setLoc !\u003d null) {\r\n            byNameKeyCache.put(Boolean.TRUE, new String[] { setLoc[2], setLoc[1] });\r\n            byNameKeyCache.put(Boolean.FALSE, new String[] { setLoc[4], setLoc[3] });\r\n        }\r\n    }\r\n    return (String[]) byNameKeyCache.get(Boolean.valueOf(standardTime));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.FixedDateTimeZone",
    "methodName": "toTimeZone",
    "signature": "java.util.TimeZone toTimeZone()",
    "visibility": "public",
    "body": "{\r\n    String id \u003d getID();\r\n    if (id.length() \u003d\u003d 6 \u0026\u0026 (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\r\n        // standard format offset [+-]hh:mm\r\n        // our ID is without any prefix, so we need to add the GMT back\r\n        return java.util.TimeZone.getTimeZone(\"GMT\" + getID());\r\n    }\r\n    // unusual offset, so setup a SimpleTimeZone as best we can\r\n    return new java.util.SimpleTimeZone(iWallOffset, getID());\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 !\u003d 6) → B1 | else → B4",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FixedDateTimeZone\n  r1 \u003d r0.getID()\n  $i0 \u003d r1.length()\n  if ($i0 !\u003d 6) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d r1.startsWith(\"+\")\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d r1.startsWith(\"-\")\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d r0.getID()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4)\n  $r6 \u003d TimeZone.getTimeZone($r5)\n  return\n}",
      "B4 {\n  $r2 \u003d SimpleTimeZone\n  $i1 \u003d FixedDateTimeZone: int iWallOffset\u003e\n  $r3 \u003d r0.getID()\n  new SimpleTimeZone($i1, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedDateTimeZone#getID(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.FixedDateTimeZone",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof FixedDateTimeZone) {\r\n        FixedDateTimeZone other \u003d (FixedDateTimeZone) obj;\r\n        return getID().equals(other.getID()) \u0026\u0026 iStandardOffset \u003d\u003d other.iStandardOffset \u0026\u0026 iWallOffset \u003d\u003d other.iWallOffset;\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B9",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B7",
      "B4 : If($i1 !\u003d $i0) → B5 | else → B7",
      "B5 : If($i3 !\u003d $i2) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  FixedDateTimeZone\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d FixedDateTimeZone\n  if ($z0 \u003d\u003d false) goto B3 else B9\n}",
      "B3 {\n  r2 \u003d FixedDateTimeZone) r1\n  $r4 \u003d r0.getID()\n  $r3 \u003d r2.getID()\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  $i1 \u003d FixedDateTimeZone: int iStandardOffset\u003e\n  $i0 \u003d FixedDateTimeZone: int iStandardOffset\u003e\n  if ($i1 !\u003d $i0) goto B5 else B7\n}",
      "B5 {\n  $i3 \u003d FixedDateTimeZone: int iWallOffset\u003e\n  $i2 \u003d FixedDateTimeZone: int iWallOffset\u003e\n  if ($i3 !\u003d $i2) goto B6 else B7\n}",
      "B6 {\n  $z2 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z2 \u003d 0\n}",
      "B8 {\n  return\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedDateTimeZone#getID(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.UTCProvider",
    "methodName": "getZone",
    "signature": "org.joda.time.DateTimeZone getZone(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (\"UTC\".equalsIgnoreCase(id)) {\r\n        return DateTimeZone.UTC;\r\n    }\r\n    return null;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTCProvider\n  String\n  $r1 \u003d \"UTC\"\n  $z0 \u003d $r1.equalsIgnoreCase(r0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d DateTimeZone UTC\u003e\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.tz.ZoneInfoCompiler",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    if (args.length \u003d\u003d 0) {\r\n        printUsage();\r\n        return;\r\n    }\r\n    File inputDir \u003d null;\r\n    File outputDir \u003d null;\r\n    boolean verbose \u003d false;\r\n    int i;\r\n    for (i \u003d 0; i \u003c args.length; i++) {\r\n        if (\"-src\".equals(args[i])) {\r\n            if (++i \u003e\u003d args.length) {\r\n                printUsage();\r\n                return;\r\n            }\r\n            inputDir \u003d new File(args[i]);\r\n        } else if (\"-dst\".equals(args[i])) {\r\n            if (++i \u003e\u003d args.length) {\r\n                printUsage();\r\n                return;\r\n            }\r\n            outputDir \u003d new File(args[i]);\r\n        } else if (\"-verbose\".equals(args[i])) {\r\n            verbose \u003d true;\r\n        } else if (\"-?\".equals(args[i])) {\r\n            printUsage();\r\n            return;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if (i \u003e\u003d args.length) {\r\n        printUsage();\r\n        return;\r\n    }\r\n    File[] sources \u003d new File[args.length - i];\r\n    for (int j \u003d 0; i \u003c args.length; i++, j++) {\r\n        sources[j] \u003d inputDir \u003d\u003d null ? new File(args[i]) : new File(inputDir, args[i]);\r\n    }\r\n    ZoneInfoLogger.set(verbose);\r\n    ZoneInfoCompiler zic \u003d new ZoneInfoCompiler();\r\n    zic.compile(outputDir, sources);\r\n}",
    "nodes": 26,
    "edges": 31,
    "cc": 7,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B3 : If(i9 \u003e\u003d $i1) → B4 | else → B17",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B8",
      "B5 : If(i9 \u003c $i8) → B6 | else → B7",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B12",
      "B9 : If(i9 \u003c $i7) → B10 | else → B11",
      "B12 : If($z2 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($z3 \u003d\u003d false) → B15 | else → B17",
      "B17 : If(i9 \u003c $i2) → B18 | else → B19",
      "B20 : If(i9 \u003e\u003d $i5) → B21 | else → B25",
      "B21 : If(r17 !\u003d null) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $i0 \u003d lengthof r0\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  ZoneInfoCompiler.printUsage()\n  return\n}",
      "B2 {\n  r17 \u003d null\n  r18 \u003d null\n  z4 \u003d 0\n  i9 \u003d 0\n}",
      "B3 {\n  $i1 \u003d lengthof r0\n  if (i9 \u003e\u003d $i1) goto B4 else B17\n}",
      "B4 {\n  $r6 \u003d \"-src\"\n  $r5 \u003d r0[i9]\n  $z0 \u003d $r6.equals($r5)\n  if ($z0 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  i9 \u003d i9 + 1\n  $i8 \u003d lengthof r0\n  if (i9 \u003c $i8) goto B6 else B7\n}",
      "B6 {\n  ZoneInfoCompiler.printUsage()\n  return\n}",
      "B7 {\n  $r15 \u003d File\n  $r16 \u003d r0[i9]\n  new File($r16)\n  r17 \u003d $r15\n  goto B16\n}",
      "B8 {\n  $r8 \u003d \"-dst\"\n  $r7 \u003d r0[i9]\n  $z1 \u003d $r8.equals($r7)\n  if ($z1 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  i9 \u003d i9 + 1\n  $i7 \u003d lengthof r0\n  if (i9 \u003c $i7) goto B10 else B11\n}",
      "B10 {\n  ZoneInfoCompiler.printUsage()\n  return\n}",
      "B11 {\n  $r13 \u003d File\n  $r14 \u003d r0[i9]\n  new File($r14)\n  r18 \u003d $r13\n  goto B16\n}",
      "B12 {\n  $r10 \u003d \"-verbose\"\n  $r9 \u003d r0[i9]\n  $z2 \u003d $r10.equals($r9)\n  if ($z2 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  z4 \u003d 1\n  goto B16\n}",
      "B14 {\n  $r12 \u003d \"-?\"\n  $r11 \u003d r0[i9]\n  $z3 \u003d $r12.equals($r11)\n  if ($z3 \u003d\u003d false) goto B15 else B17\n}",
      "B15 {\n  ZoneInfoCompiler.printUsage()\n  return\n}",
      "B16 {\n  i9 \u003d i9 + 1\n  goto B3\n}",
      "B17 {\n  $i2 \u003d lengthof r0\n  if (i9 \u003c $i2) goto B18 else B19\n}",
      "B18 {\n  ZoneInfoCompiler.printUsage()\n  return\n}",
      "B19 {\n  $i3 \u003d lengthof r0\n  $i4 \u003d $i3 - i9\n  r1 \u003d File)[$i4]\n  i10 \u003d 0\n}",
      "B20 {\n  $i5 \u003d lengthof r0\n  if (i9 \u003e\u003d $i5) goto B21 else B25\n}",
      "B21 {\n  $i6 \u003d i10\n  if (r17 !\u003d null) goto B22 else B23\n}",
      "B22 {\n  $r19 \u003d File\n  $r4 \u003d r0[i9]\n  new File($r4)\n  goto B24\n}",
      "B23 {\n  $r19 \u003d File\n  $r3 \u003d r0[i9]\n  new File(r17, $r3)\n}",
      "B24 {\n  r1[$i6] \u003d $r19\n  i9 \u003d i9 + 1\n  i10 \u003d i10 + 1\n  goto B20\n}",
      "B25 {\n  ZoneInfoLogger.set(z4)\n  $r2 \u003d ZoneInfoCompiler\n  new ZoneInfoCompiler()\n  $r2.compile(r18, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B17",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B16",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B3",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B20",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZoneInfoCompiler#printUsage(...0)",
        "body": "{\r\n    System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler \u003coptions\u003e \u003csource files\u003e\");\r\n    System.out.println(\"where possible options include:\");\r\n    System.out.println(\"  -src \u003cdirectory\u003e    Specify where to read source files\");\r\n    System.out.println(\"  -dst \u003cdirectory\u003e    Specify where to write generated files\");\r\n    System.out.println(\"  -verbose            Output verbosely (default false)\");\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.ZoneInfoCompiler",
    "methodName": "compile",
    "signature": "java.util.Map compile(java.io.File,java.io.File[])",
    "visibility": "public",
    "body": "{\r\n    if (sources !\u003d null) {\r\n        for (int i \u003d 0; i \u003c sources.length; i++) {\r\n            BufferedReader in \u003d null;\r\n            try {\r\n                in \u003d new BufferedReader(new FileReader(sources[i]));\r\n                parseDataFile(in, \"backward\".equals(sources[i].getName()));\r\n            } finally {\r\n                if (in !\u003d null) {\r\n                    in.close();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (outputDir !\u003d null) {\r\n        if (!outputDir.exists() \u0026\u0026 !outputDir.mkdirs()) {\r\n            throw new IOException(\"Destination directory doesn\u0027t exist and cannot be created: \" + outputDir);\r\n        }\r\n        if (!outputDir.isDirectory()) {\r\n            throw new IOException(\"Destination is not a directory: \" + outputDir);\r\n        }\r\n    }\r\n    Map\u003cString, DateTimeZone\u003e map \u003d new TreeMap\u003cString, DateTimeZone\u003e();\r\n    Map\u003cString, Zone\u003e sourceMap \u003d new TreeMap\u003cString, Zone\u003e();\r\n    System.out.println(\"Writing zoneinfo files\");\r\n    // write out the standard entries\r\n    for (int i \u003d 0; i \u003c iZones.size(); i++) {\r\n        Zone zone \u003d iZones.get(i);\r\n        DateTimeZoneBuilder builder \u003d new DateTimeZoneBuilder();\r\n        zone.addToBuilder(builder, iRuleSets);\r\n        DateTimeZone tz \u003d builder.toDateTimeZone(zone.iName, true);\r\n        if (test(tz.getID(), tz)) {\r\n            map.put(tz.getID(), tz);\r\n            sourceMap.put(tz.getID(), zone);\r\n            if (outputDir !\u003d null) {\r\n                writeZone(outputDir, builder, tz);\r\n            }\r\n        }\r\n    }\r\n    // revive zones from \"good\" links\r\n    for (int i \u003d 0; i \u003c iGoodLinks.size(); i +\u003d 2) {\r\n        String baseId \u003d iGoodLinks.get(i);\r\n        String alias \u003d iGoodLinks.get(i + 1);\r\n        Zone sourceZone \u003d sourceMap.get(baseId);\r\n        if (sourceZone \u003d\u003d null) {\r\n            System.out.println(\"Cannot find source zone \u0027\" + baseId + \"\u0027 to link alias \u0027\" + alias + \"\u0027 to\");\r\n        } else {\r\n            DateTimeZoneBuilder builder \u003d new DateTimeZoneBuilder();\r\n            sourceZone.addToBuilder(builder, iRuleSets);\r\n            DateTimeZone revived \u003d builder.toDateTimeZone(alias, true);\r\n            if (test(revived.getID(), revived)) {\r\n                map.put(revived.getID(), revived);\r\n                if (outputDir !\u003d null) {\r\n                    writeZone(outputDir, builder, revived);\r\n                }\r\n            }\r\n            map.put(revived.getID(), revived);\r\n            if (ZoneInfoLogger.verbose()) {\r\n                System.out.println(\"Good link: \" + alias + \" -\u003e \" + baseId + \" revived\");\r\n            }\r\n        }\r\n    }\r\n    // store \"back\" links as aliases (where name is permanently mapped)\r\n    for (int pass \u003d 0; pass \u003c 2; pass++) {\r\n        for (int i \u003d 0; i \u003c iBackLinks.size(); i +\u003d 2) {\r\n            String id \u003d iBackLinks.get(i);\r\n            String alias \u003d iBackLinks.get(i + 1);\r\n            DateTimeZone tz \u003d map.get(id);\r\n            if (tz \u003d\u003d null) {\r\n                if (pass \u003e 0) {\r\n                    System.out.println(\"Cannot find time zone \u0027\" + id + \"\u0027 to link alias \u0027\" + alias + \"\u0027 to\");\r\n                }\r\n            } else {\r\n                map.put(alias, tz);\r\n                if (ZoneInfoLogger.verbose()) {\r\n                    System.out.println(\"Back link: \" + alias + \" -\u003e \" + tz.getID());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // write map that unites the time-zone data, pointing aliases and real zones at files\r\n    if (outputDir !\u003d null) {\r\n        System.out.println(\"Writing ZoneInfoMap\");\r\n        File file \u003d new File(outputDir, \"ZoneInfoMap\");\r\n        if (!file.getParentFile().exists()) {\r\n            file.getParentFile().mkdirs();\r\n        }\r\n        OutputStream out \u003d new FileOutputStream(file);\r\n        DataOutputStream dout \u003d new DataOutputStream(out);\r\n        try {\r\n            // Sort and filter out any duplicates that match case.\r\n            Map\u003cString, DateTimeZone\u003e zimap \u003d new TreeMap\u003cString, DateTimeZone\u003e(String.CASE_INSENSITIVE_ORDER);\r\n            zimap.putAll(map);\r\n            writeZoneInfoMap(dout, zimap);\r\n        } finally {\r\n            dout.close();\r\n        }\r\n    }\r\n    return map;\r\n}",
    "nodes": 48,
    "edges": 66,
    "cc": 20,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B9",
      "B2 : If(i5 \u003e\u003d $i4) → B3 | else → B9",
      "B3 : If($r54 \u003d\u003d null) → B4 | else → B8",
      "B5 : If(r62 \u003d\u003d null) → B6 | else → B7",
      "B9 : If(r1 \u003d\u003d null) → B10 | else → B15",
      "B10 : If($z4 !\u003d 0) → B11 | else → B13",
      "B11 : If($z6 !\u003d 0) → B12 | else → B13",
      "B13 : If($z5 !\u003d 0) → B14 | else → B15",
      "B16 : If(i6 \u003e\u003d $i7) → B17 | else → B21",
      "B17 : If($z3 \u003d\u003d false) → B18 | else → B20",
      "B18 : If(r1 \u003d\u003d null) → B19 | else → B20",
      "B22 : If(i8 \u003e\u003d $i0) → B23 | else → B31",
      "B23 : If(r68 !\u003d null) → B24 | else → B25",
      "B25 : If($z2 \u003d\u003d false) → B26 | else → B28",
      "B26 : If(r1 \u003d\u003d null) → B27 | else → B28",
      "B28 : If($z8 \u003d\u003d false) → B29 | else → B30",
      "B32 : If(i9 \u003e\u003d 2) → B33 | else → B42",
      "B34 : If(i10 \u003e\u003d $i1) → B35 | else → B41",
      "B35 : If(r72 !\u003d null) → B36 | else → B38",
      "B36 : If(i9 \u003c\u003d 0) → B37 | else → B40",
      "B38 : If($z1 \u003d\u003d false) → B39 | else → B40",
      "B42 : If(r1 \u003d\u003d null) → B43 | else → B47",
      "B43 : If($z0 !\u003d 0) → B44 | else → B45"
    ],
    "blockList": [
      "B0 {\n  ZoneInfoCompiler\n  File\n  File[]\n  if (r0 \u003d\u003d null) goto B1 else B9\n}",
      "B1 {\n  i5 \u003d 0\n}",
      "B2 {\n  $i4 \u003d lengthof r0\n  if (i5 \u003e\u003d $i4) goto B3 else B9\n}",
      "B3 {\n  r62 \u003d null\n  $r54 \u003d BufferedReader\n  $r55 \u003d FileReader\n  $r56 \u003d r0[i5]\n  new FileReader($r56)\n  new BufferedReader($r55)\n  r62 \u003d $r54\n  $r59 \u003d \"backward\"\n  $r57 \u003d r0[i5]\n  $r58 \u003d $r57.getName()\n  $z7 \u003d $r59.equals($r58)\n  r5.parseDataFile($r54, $z7)\n  if ($r54 \u003d\u003d null) goto B4 else B8\n}",
      "B4 {\n  $r54.close()\n  goto B8\n}",
      "B5 {\n  $r61 :\u003d @caughtexception\n  if (r62 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  r62.close()\n}",
      "B7 {\n  throw $r61\n}",
      "B8 {\n  i5 \u003d i5 + 1\n  goto B2\n}",
      "B9 {\n  if (r1 \u003d\u003d null) goto B10 else B15\n}",
      "B10 {\n  $z4 \u003d r1.exists()\n  if ($z4 !\u003d 0) goto B11 else B13\n}",
      "B11 {\n  $z6 \u003d r1.mkdirs()\n  if ($z6 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r51 \u003d IOException\n  $r52 \u003d String.valueOf(r1)\n  $r53 \u003d dynInvoke makeConcatWithConstants($r52)\n  new IOException($r53)\n  throw $r51\n}",
      "B13 {\n  $z5 \u003d r1.isDirectory()\n  if ($z5 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r48 \u003d IOException\n  $r49 \u003d String.valueOf(r1)\n  $r50 \u003d dynInvoke makeConcatWithConstants($r49)\n  new IOException($r50)\n  throw $r48\n}",
      "B15 {\n  $r2 \u003d TreeMap\n  new TreeMap()\n  $r3 \u003d TreeMap\n  new TreeMap()\n  $r4 \u003d PrintStream out\u003e\n  $r4.println(\"Writing zoneinfo files\")\n  i6 \u003d 0\n}",
      "B16 {\n  $r63 \u003d List iZones\u003e\n  $i7 \u003d $r63.size()\n  if (i6 \u003e\u003d $i7) goto B17 else B21\n}",
      "B17 {\n  $r40 \u003d List iZones\u003e\n  $r41 \u003d $r40.get(i6)\n  r64 \u003d ZoneInfoCompiler$Zone) $r41\n  $r42 \u003d DateTimeZoneBuilder\n  new DateTimeZoneBuilder()\n  $r43 \u003d Map iRuleSets\u003e\n  r64.addToBuilder($r42, $r43)\n  $r44 \u003d String iName\u003e\n  r65 \u003d $r42.toDateTimeZone($r44, 1)\n  $r45 \u003d r65.getID()\n  $z3 \u003d ZoneInfoCompiler.test($r45, r65)\n  if ($z3 \u003d\u003d false) goto B18 else B20\n}",
      "B18 {\n  $r46 \u003d r65.getID()\n  $r2.put($r46, r65)\n  $r47 \u003d r65.getID()\n  $r3.put($r47, r64)\n  if (r1 \u003d\u003d null) goto B19 else B20\n}",
      "B19 {\n  r5.writeZone(r1, $r42, r65)\n}",
      "B20 {\n  i6 \u003d i6 + 1\n  goto B16\n}",
      "B21 {\n  i8 \u003d 0\n}",
      "B22 {\n  $r6 \u003d List iGoodLinks\u003e\n  $i0 \u003d $r6.size()\n  if (i8 \u003e\u003d $i0) goto B23 else B31\n}",
      "B23 {\n  $r26 \u003d List iGoodLinks\u003e\n  $r27 \u003d $r26.get(i8)\n  r66 \u003d String) $r27\n  $r28 \u003d List iGoodLinks\u003e\n  $i3 \u003d i8 + 1\n  $r29 \u003d $r28.get($i3)\n  r67 \u003d String) $r29\n  $r30 \u003d $r3.get(r66)\n  r68 \u003d ZoneInfoCompiler$Zone) $r30\n  if (r68 !\u003d null) goto B24 else B25\n}",
      "B24 {\n  $r38 \u003d PrintStream out\u003e\n  $r39 \u003d dynInvoke makeConcatWithConstants(r66, r67)\n  $r38.println($r39)\n  goto B30\n}",
      "B25 {\n  $r31 \u003d DateTimeZoneBuilder\n  new DateTimeZoneBuilder()\n  $r32 \u003d Map iRuleSets\u003e\n  r68.addToBuilder($r31, $r32)\n  r33 \u003d $r31.toDateTimeZone(r67, 1)\n  $r34 \u003d r33.getID()\n  $z2 \u003d ZoneInfoCompiler.test($r34, r33)\n  if ($z2 \u003d\u003d false) goto B26 else B28\n}",
      "B26 {\n  $r37 \u003d r33.getID()\n  $r2.put($r37, r33)\n  if (r1 \u003d\u003d null) goto B27 else B28\n}",
      "B27 {\n  r5.writeZone(r1, $r31, r33)\n}",
      "B28 {\n  $r69 \u003d r33.getID()\n  $r2.put($r69, r33)\n  $z8 \u003d ZoneInfoLogger.verbose()\n  if ($z8 \u003d\u003d false) goto B29 else B30\n}",
      "B29 {\n  $r35 \u003d PrintStream out\u003e\n  $r36 \u003d dynInvoke makeConcatWithConstants(r67, r66)\n  $r35.println($r36)\n}",
      "B30 {\n  i8 \u003d i8 + 2\n  goto B22\n}",
      "B31 {\n  i9 \u003d 0\n}",
      "B32 {\n  if (i9 \u003e\u003d 2) goto B33 else B42\n}",
      "B33 {\n  i10 \u003d 0\n}",
      "B34 {\n  $r15 \u003d List iBackLinks\u003e\n  $i1 \u003d $r15.size()\n  if (i10 \u003e\u003d $i1) goto B35 else B41\n}",
      "B35 {\n  $r16 \u003d List iBackLinks\u003e\n  $r17 \u003d $r16.get(i10)\n  r70 \u003d String) $r17\n  $r18 \u003d List iBackLinks\u003e\n  $i2 \u003d i10 + 1\n  $r19 \u003d $r18.get($i2)\n  r71 \u003d String) $r19\n  $r20 \u003d $r2.get(r70)\n  r72 \u003d DateTimeZone) $r20\n  if (r72 !\u003d null) goto B36 else B38\n}",
      "B36 {\n  if (i9 \u003c\u003d 0) goto B37 else B40\n}",
      "B37 {\n  $r24 \u003d PrintStream out\u003e\n  $r25 \u003d dynInvoke makeConcatWithConstants(r70, r71)\n  $r24.println($r25)\n  goto B40\n}",
      "B38 {\n  $r2.put(r71, r72)\n  $z1 \u003d ZoneInfoLogger.verbose()\n  if ($z1 \u003d\u003d false) goto B39 else B40\n}",
      "B39 {\n  $r21 \u003d PrintStream out\u003e\n  $r22 \u003d r72.getID()\n  $r23 \u003d dynInvoke makeConcatWithConstants(r71, $r22)\n  $r21.println($r23)\n}",
      "B40 {\n  i10 \u003d i10 + 2\n  goto B34\n}",
      "B41 {\n  i9 \u003d i9 + 1\n  goto B32\n}",
      "B42 {\n  if (r1 \u003d\u003d null) goto B43 else B47\n}",
      "B43 {\n  $r7 \u003d PrintStream out\u003e\n  $r7.println(\"Writing ZoneInfoMap\")\n  $r8 \u003d File\n  new File(r1, \"ZoneInfoMap\")\n  $r9 \u003d $r8.getParentFile()\n  $z0 \u003d $r9.exists()\n  if ($z0 !\u003d 0) goto B44 else B45\n}",
      "B44 {\n  $r14 \u003d $r8.getParentFile()\n  $r14.mkdirs()\n}",
      "B45 {\n  $r10 \u003d FileOutputStream\n  new FileOutputStream($r8)\n  $r11 \u003d DataOutputStream\n  new DataOutputStream($r10)\n  $r12 \u003d TreeMap\n  $r13 \u003d Comparator CASE_INSENSITIVE_ORDER\u003e\n  new TreeMap($r13)\n  $r12.putAll($r2)\n  ZoneInfoCompiler.writeZoneInfoMap($r11, $r12)\n  $r11.close()\n  goto B47\n}",
      "B46 {\n  $r60 :\u003d @caughtexception\n  $r11.close()\n  throw $r60\n}",
      "B47 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B9",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B2",
      "B9 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B21",
      "B17 --\u003e B18",
      "B17 --\u003e B20",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B16",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B31",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B30",
      "B25 --\u003e B26",
      "B25 --\u003e B28",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B22",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B42",
      "B33 --\u003e B34",
      "B34 --\u003e B35",
      "B34 --\u003e B41",
      "B35 --\u003e B36",
      "B35 --\u003e B38",
      "B36 --\u003e B37",
      "B36 --\u003e B40",
      "B37 --\u003e B40",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e B40",
      "B40 --\u003e B34",
      "B41 --\u003e B32",
      "B42 --\u003e B43",
      "B42 --\u003e B47",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e B45",
      "B45 --\u003e B47",
      "B46 --\u003e [EXIT]",
      "B47 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZoneInfoCompiler#test(...2)",
        "body": "{\r\n    if (!id.equals(tz.getID())) {\r\n        return true;\r\n    }\r\n    // Test to ensure that reported transitions are not duplicated.\r\n    long millis \u003d ISOChronology.getInstanceUTC().year().set(0, 1850);\r\n    long end \u003d ISOChronology.getInstanceUTC().year().set(0, 2050);\r\n    int offset \u003d tz.getOffset(millis);\r\n    int stdOffset \u003d tz.getStandardOffset(millis);\r\n    String key \u003d tz.getNameKey(millis);\r\n    List\u003cLong\u003e transitions \u003d new ArrayList\u003cLong\u003e();\r\n    while (true) {\r\n        long next \u003d tz.nextTransition(millis);\r\n        if (next \u003d\u003d millis || next \u003e end) {\r\n            break;\r\n        }\r\n        millis \u003d next;\r\n        int nextOffset \u003d tz.getOffset(millis);\r\n        int nextStdOffset \u003d tz.getStandardOffset(millis);\r\n        String nextKey \u003d tz.getNameKey(millis);\r\n        if (offset \u003d\u003d nextOffset \u0026\u0026 stdOffset \u003d\u003d nextStdOffset \u0026\u0026 key.equals(nextKey)) {\r\n            System.out.println(\"*d* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()));\r\n            return false;\r\n        }\r\n        if (nextKey \u003d\u003d null || (nextKey.length() \u003c 3 \u0026\u0026 !\"??\".equals(nextKey) \u0026\u0026 !\"%z\".equals(nextKey))) {\r\n            System.out.println(\"*s* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()) + \", nameKey\u003d\" + nextKey);\r\n            return false;\r\n        }\r\n        transitions.add(Long.valueOf(millis));\r\n        offset \u003d nextOffset;\r\n        key \u003d nextKey;\r\n    }\r\n    // Now verify that reverse transitions match up.\r\n    millis \u003d ISOChronology.getInstanceUTC().year().set(0, 2050);\r\n    end \u003d ISOChronology.getInstanceUTC().year().set(0, 1850);\r\n    for (int i \u003d transitions.size(); --i \u003e\u003d 0; ) {\r\n        long prev \u003d tz.previousTransition(millis);\r\n        if (prev \u003d\u003d millis || prev \u003c end) {\r\n            break;\r\n        }\r\n        millis \u003d prev;\r\n        long trans \u003d transitions.get(i).longValue();\r\n        if (trans - 1 !\u003d millis) {\r\n            System.out.println(\"*r* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()) + \" !\u003d \" + new DateTime(trans - 1, ISOChronology.getInstanceUTC()));\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
      },
      {
        "name": "ZoneInfoCompiler#writeZone(...3)",
        "body": "{\r\n    if (ZoneInfoLogger.verbose()) {\r\n        System.out.println(\"Writing \" + tz.getID());\r\n    }\r\n    File file \u003d new File(outputDir, tz.getID());\r\n    if (!file.getParentFile().exists()) {\r\n        file.getParentFile().mkdirs();\r\n    }\r\n    OutputStream out \u003d new FileOutputStream(file);\r\n    try {\r\n        builder.writeTo(tz.getID(), out);\r\n    } finally {\r\n        out.close();\r\n    }\r\n    // Test if it can be read back.\r\n    InputStream in \u003d new FileInputStream(file);\r\n    DateTimeZone tz2 \u003d DateTimeZoneBuilder.readFrom(in, tz.getID());\r\n    in.close();\r\n    if (!tz.equals(tz2)) {\r\n        System.out.println(\"*e* Error in \" + tz.getID() + \": Didn\u0027t read properly from file\");\r\n    }\r\n}"
      },
      {
        "name": "ZoneInfoCompiler#writeZoneInfoMap(...2)",
        "body": "{\r\n    if (dout \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"DataOutputStream must not be null.\");\r\n    }\r\n    // Build the string pool.\r\n    Map\u003cString, Short\u003e idToIndex \u003d new HashMap\u003cString, Short\u003e(zimap.size());\r\n    TreeMap\u003cShort, String\u003e indexToId \u003d new TreeMap\u003cShort, String\u003e();\r\n    short count \u003d 0;\r\n    for (Entry\u003cString, DateTimeZone\u003e entry : zimap.entrySet()) {\r\n        String id \u003d (String) entry.getKey();\r\n        if (!idToIndex.containsKey(id)) {\r\n            Short index \u003d Short.valueOf(count);\r\n            idToIndex.put(id, index);\r\n            indexToId.put(index, id);\r\n            if (++count \u003d\u003d Short.MAX_VALUE) {\r\n                throw new InternalError(\"Too many time zone ids\");\r\n            }\r\n        }\r\n        id \u003d ((DateTimeZone) entry.getValue()).getID();\r\n        if (!idToIndex.containsKey(id)) {\r\n            Short index \u003d Short.valueOf(count);\r\n            idToIndex.put(id, index);\r\n            indexToId.put(index, id);\r\n            if (++count \u003d\u003d Short.MAX_VALUE) {\r\n                throw new InternalError(\"Too many time zone ids\");\r\n            }\r\n        }\r\n    }\r\n    // Write the string pool, ordered by index.\r\n    dout.writeShort(indexToId.size());\r\n    for (String id : indexToId.values()) {\r\n        dout.writeUTF(id);\r\n    }\r\n    // Write the mappings.\r\n    dout.writeShort(zimap.size());\r\n    for (Entry\u003cString, DateTimeZone\u003e entry : zimap.entrySet()) {\r\n        String id \u003d entry.getKey();\r\n        dout.writeShort(idToIndex.get(id).shortValue());\r\n        id \u003d entry.getValue().getID();\r\n        dout.writeShort(idToIndex.get(id).shortValue());\r\n    }\r\n}"
      },
      {
        "name": "ZoneInfoCompiler#parseDataFile(...2)",
        "body": "{\r\n    Zone zone \u003d null;\r\n    String line;\r\n    while ((line \u003d in.readLine()) !\u003d null) {\r\n        // SPEC: Leading and trailing white space on input lines is ignored.\r\n        String trimmed \u003d line.trim();\r\n        // SPEC: An unquoted sharp character (#) in the input\r\n        // introduces a comment which extends to the end of the line the\r\n        // sharp character appears on.\r\n        // Any line that is blank (after comment stripping) is ignored\r\n        // (Note that we do not support quoted fields)\r\n        if (trimmed.length() \u003d\u003d 0 || trimmed.charAt(0) \u003d\u003d \u0027#\u0027) {\r\n            continue;\r\n        }\r\n        int index \u003d line.indexOf(\u0027#\u0027);\r\n        if (index \u003e\u003d 0) {\r\n            line \u003d line.substring(0, index);\r\n        }\r\n        //System.out.println(line);\r\n        // SPEC: Fields are separated from one\r\n        // another by one or more white space characters.  The white space\r\n        // characters are space, form feed, carriage return, newline, tab,\r\n        // and vertical tab.\r\n        StringTokenizer st \u003d new StringTokenizer(line, \" \\f\\r\\t\\u000b\");\r\n        if (Character.isWhitespace(line.charAt(0)) \u0026\u0026 st.hasMoreTokens()) {\r\n            if (zone !\u003d null) {\r\n                // Zone continuation\r\n                zone.chain(st);\r\n            }\r\n            continue;\r\n        } else {\r\n            if (zone !\u003d null) {\r\n                iZones.add(zone);\r\n            }\r\n            zone \u003d null;\r\n        }\r\n        // SPEC: Names must be in English and are case insensitive.  They appear\r\n        // in several contexts, and include month and weekday names and\r\n        // keywords such as maximum, only, Rolling, and Zone.  A name can be\r\n        // abbreviated by omitting all but an initial prefix; any\r\n        // abbreviation must be unambiguous in context.\r\n        if (st.hasMoreTokens()) {\r\n            String token \u003d st.nextToken().toLowerCase(Locale.ENGLISH);\r\n            if (RULE_LOOKUP.contains(token)) {\r\n                Rule r \u003d new Rule(st);\r\n                RuleSet rs \u003d iRuleSets.get(r.iName);\r\n                if (rs \u003d\u003d null) {\r\n                    rs \u003d new RuleSet(r);\r\n                    iRuleSets.put(r.iName, rs);\r\n                } else {\r\n                    rs.addRule(r);\r\n                }\r\n            } else if (ZONE_LOOKUP.contains(token)) {\r\n                if (st.countTokens() \u003c 4) {\r\n                    throw new IllegalArgumentException(\"Attempting to create a Zone from an incomplete tokenizer\");\r\n                }\r\n                zone \u003d new Zone(st);\r\n            } else if (LINK_LOOKUP.contains(token)) {\r\n                String real \u003d st.nextToken();\r\n                String alias \u003d st.nextToken();\r\n                // links in \"backward\" are deprecated names\r\n                // links in other files should be kept\r\n                // special case a few to try to repair terrible damage to tzdb\r\n                if (alias.equals(\"WET\") || alias.equals(\"CET\") || alias.equals(\"EET\")) {\r\n                    iGoodLinks.add(real);\r\n                    iGoodLinks.add(alias);\r\n                } else if (alias.equals(\"MET\")) {\r\n                    // map MET -\u003e CET (not Europe/Brussels)\r\n                    iBackLinks.add(\"CET\");\r\n                    iBackLinks.add(alias);\r\n                } else if (backward || alias.equals(\"US/Pacific-New\") || alias.startsWith(\"Etc/\") || alias.equals(\"GMT\")) {\r\n                    iBackLinks.add(real);\r\n                    iBackLinks.add(alias);\r\n                } else {\r\n                    iGoodLinks.add(real);\r\n                    iGoodLinks.add(alias);\r\n                }\r\n            } else {\r\n                System.out.println(\"Unknown line: \" + line);\r\n            }\r\n        }\r\n    }\r\n    if (zone !\u003d null) {\r\n        iZones.add(zone);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.tz.ZoneInfoCompiler",
    "methodName": "parseDataFile",
    "signature": "void parseDataFile(java.io.BufferedReader,boolean)",
    "visibility": "public",
    "body": "{\r\n    Zone zone \u003d null;\r\n    String line;\r\n    while ((line \u003d in.readLine()) !\u003d null) {\r\n        // SPEC: Leading and trailing white space on input lines is ignored.\r\n        String trimmed \u003d line.trim();\r\n        // SPEC: An unquoted sharp character (#) in the input\r\n        // introduces a comment which extends to the end of the line the\r\n        // sharp character appears on.\r\n        // Any line that is blank (after comment stripping) is ignored\r\n        // (Note that we do not support quoted fields)\r\n        if (trimmed.length() \u003d\u003d 0 || trimmed.charAt(0) \u003d\u003d \u0027#\u0027) {\r\n            continue;\r\n        }\r\n        int index \u003d line.indexOf(\u0027#\u0027);\r\n        if (index \u003e\u003d 0) {\r\n            line \u003d line.substring(0, index);\r\n        }\r\n        //System.out.println(line);\r\n        // SPEC: Fields are separated from one\r\n        // another by one or more white space characters.  The white space\r\n        // characters are space, form feed, carriage return, newline, tab,\r\n        // and vertical tab.\r\n        StringTokenizer st \u003d new StringTokenizer(line, \" \\f\\r\\t\\u000b\");\r\n        if (Character.isWhitespace(line.charAt(0)) \u0026\u0026 st.hasMoreTokens()) {\r\n            if (zone !\u003d null) {\r\n                // Zone continuation\r\n                zone.chain(st);\r\n            }\r\n            continue;\r\n        } else {\r\n            if (zone !\u003d null) {\r\n                iZones.add(zone);\r\n            }\r\n            zone \u003d null;\r\n        }\r\n        // SPEC: Names must be in English and are case insensitive.  They appear\r\n        // in several contexts, and include month and weekday names and\r\n        // keywords such as maximum, only, Rolling, and Zone.  A name can be\r\n        // abbreviated by omitting all but an initial prefix; any\r\n        // abbreviation must be unambiguous in context.\r\n        if (st.hasMoreTokens()) {\r\n            String token \u003d st.nextToken().toLowerCase(Locale.ENGLISH);\r\n            if (RULE_LOOKUP.contains(token)) {\r\n                Rule r \u003d new Rule(st);\r\n                RuleSet rs \u003d iRuleSets.get(r.iName);\r\n                if (rs \u003d\u003d null) {\r\n                    rs \u003d new RuleSet(r);\r\n                    iRuleSets.put(r.iName, rs);\r\n                } else {\r\n                    rs.addRule(r);\r\n                }\r\n            } else if (ZONE_LOOKUP.contains(token)) {\r\n                if (st.countTokens() \u003c 4) {\r\n                    throw new IllegalArgumentException(\"Attempting to create a Zone from an incomplete tokenizer\");\r\n                }\r\n                zone \u003d new Zone(st);\r\n            } else if (LINK_LOOKUP.contains(token)) {\r\n                String real \u003d st.nextToken();\r\n                String alias \u003d st.nextToken();\r\n                // links in \"backward\" are deprecated names\r\n                // links in other files should be kept\r\n                // special case a few to try to repair terrible damage to tzdb\r\n                if (alias.equals(\"WET\") || alias.equals(\"CET\") || alias.equals(\"EET\")) {\r\n                    iGoodLinks.add(real);\r\n                    iGoodLinks.add(alias);\r\n                } else if (alias.equals(\"MET\")) {\r\n                    // map MET -\u003e CET (not Europe/Brussels)\r\n                    iBackLinks.add(\"CET\");\r\n                    iBackLinks.add(alias);\r\n                } else if (backward || alias.equals(\"US/Pacific-New\") || alias.startsWith(\"Etc/\") || alias.equals(\"GMT\")) {\r\n                    iBackLinks.add(real);\r\n                    iBackLinks.add(alias);\r\n                } else {\r\n                    iGoodLinks.add(real);\r\n                    iGoodLinks.add(alias);\r\n                }\r\n            } else {\r\n                System.out.println(\"Unknown line: \" + line);\r\n            }\r\n        }\r\n    }\r\n    if (zone !\u003d null) {\r\n        iZones.add(zone);\r\n    }\r\n}",
    "nodes": 42,
    "edges": 63,
    "cc": 23,
    "flowSummary": [
      "B1 : If($r28 \u003d\u003d null) → B2 | else → B39",
      "B2 : If($i0 \u003d\u003d false) → B3 | else → B1",
      "B3 : If($i5 !\u003d 35) → B4 | else → B5",
      "B5 : If(i2 \u003c 0) → B6 | else → B7",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B11",
      "B8 : If($z13 \u003d\u003d false) → B9 | else → B11",
      "B9 : If(r27 \u003d\u003d null) → B10 | else → B1",
      "B11 : If(r27 \u003d\u003d null) → B12 | else → B13",
      "B13 : If($z1 \u003d\u003d false) → B14 | else → B38",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B19",
      "B15 : If(r30 !\u003d null) → B16 | else → B17",
      "B19 : If($z3 \u003d\u003d false) → B20 | else → B23",
      "B20 : If($i4 \u003e\u003d 4) → B21 | else → B22",
      "B23 : If($z4 \u003d\u003d false) → B24 | else → B37",
      "B24 : If($z5 !\u003d 0) → B25 | else → B27",
      "B25 : If($z6 !\u003d 0) → B26 | else → B27",
      "B26 : If($z7 \u003d\u003d false) → B27 | else → B28",
      "B28 : If($z8 \u003d\u003d false) → B29 | else → B30",
      "B30 : If(z9 !\u003d 0) → B31 | else → B34",
      "B31 : If($z10 !\u003d 0) → B32 | else → B34",
      "B32 : If($z11 !\u003d 0) → B33 | else → B34",
      "B33 : If($z12 \u003d\u003d false) → B34 | else → B35",
      "B39 : If(r27 \u003d\u003d null) → B40 | else → B41"
    ],
    "blockList": [
      "B0 {\n  ZoneInfoCompiler\n  BufferedReader\n  z9 :\u003d @parameter1: boolean\n  r27 \u003d null\n}",
      "B1 {\n  $r28 \u003d r0.readLine()\n  r29 \u003d $r28\n  if ($r28 \u003d\u003d null) goto B2 else B39\n}",
      "B2 {\n  r3 \u003d $r28.trim()\n  $i0 \u003d r3.length()\n  if ($i0 \u003d\u003d false) goto B3 else B1\n}",
      "B3 {\n  $c1 \u003d r3.charAt(0)\n  $i5 \u003d (int) $c1\n  if ($i5 !\u003d 35) goto B4 else B5\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  i2 \u003d $r28.indexOf(35)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  r29 \u003d $r28.substring(0, i2)\n}",
      "B7 {\n  $r37 \u003d StringTokenizer\n  new StringTokenizer(r29, \" \\f\\r\\t\\u000b\")\n  $c3 \u003d r29.charAt(0)\n  $z0 \u003d Character.isWhitespace($c3)\n  if ($z0 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  $z13 \u003d $r37.hasMoreTokens()\n  if ($z13 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  if (r27 \u003d\u003d null) goto B10 else B1\n}",
      "B10 {\n  r27.chain($r37)\n  goto B1\n}",
      "B11 {\n  if (r27 \u003d\u003d null) goto B12 else B13\n}",
      "B12 {\n  $r26 \u003d List iZones\u003e\n  $r26.add(r27)\n}",
      "B13 {\n  r27 \u003d null\n  $z1 \u003d $r37.hasMoreTokens()\n  if ($z1 \u003d\u003d false) goto B14 else B38\n}",
      "B14 {\n  $r6 \u003d $r37.nextToken()\n  $r5 \u003d Locale ENGLISH\u003e\n  r7 \u003d $r6.toLowerCase($r5)\n  $r8 \u003d Set RULE_LOOKUP\u003e\n  $z2 \u003d $r8.contains(r7)\n  if ($z2 \u003d\u003d false) goto B15 else B19\n}",
      "B15 {\n  $r38 \u003d ZoneInfoCompiler$Rule\n  new ZoneInfoCompiler$Rule($r37)\n  $r21 \u003d Map iRuleSets\u003e\n  $r20 \u003d String iName\u003e\n  $r22 \u003d $r21.get($r20)\n  r30 \u003d ZoneInfoCompiler$RuleSet) $r22\n  if (r30 !\u003d null) goto B16 else B17\n}",
      "B16 {\n  $r39 \u003d ZoneInfoCompiler$RuleSet\n  new ZoneInfoCompiler$RuleSet($r38)\n  $r25 \u003d Map iRuleSets\u003e\n  $r24 \u003d String iName\u003e\n  $r25.put($r24, $r39)\n  goto B18\n}",
      "B17 {\n  r30.addRule($r38)\n}",
      "B18 {\n  goto B38\n}",
      "B19 {\n  $r9 \u003d Set ZONE_LOOKUP\u003e\n  $z3 \u003d $r9.contains(r7)\n  if ($z3 \u003d\u003d false) goto B20 else B23\n}",
      "B20 {\n  $i4 \u003d $r37.countTokens()\n  if ($i4 \u003e\u003d 4) goto B21 else B22\n}",
      "B21 {\n  $r40 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Attempting to create a Zone from an incomplete tokenizer\")\n  throw $r40\n}",
      "B22 {\n  $r41 \u003d ZoneInfoCompiler$Zone\n  new ZoneInfoCompiler$Zone($r37)\n  r27 \u003d $r41\n  goto B38\n}",
      "B23 {\n  $r10 \u003d Set LINK_LOOKUP\u003e\n  $z4 \u003d $r10.contains(r7)\n  if ($z4 \u003d\u003d false) goto B24 else B37\n}",
      "B24 {\n  r31 \u003d $r37.nextToken()\n  r32 \u003d $r37.nextToken()\n  $z5 \u003d r32.equals(\"WET\")\n  if ($z5 !\u003d 0) goto B25 else B27\n}",
      "B25 {\n  $z6 \u003d r32.equals(\"CET\")\n  if ($z6 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  $z7 \u003d r32.equals(\"EET\")\n  if ($z7 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  $r33 \u003d List iGoodLinks\u003e\n  $r33.add(r31)\n  $r34 \u003d List iGoodLinks\u003e\n  $r34.add(r32)\n  goto B36\n}",
      "B28 {\n  $z8 \u003d r32.equals(\"MET\")\n  if ($z8 \u003d\u003d false) goto B29 else B30\n}",
      "B29 {\n  $r15 \u003d List iBackLinks\u003e\n  $r15.add(\"CET\")\n  $r16 \u003d List iBackLinks\u003e\n  $r16.add(r32)\n  goto B36\n}",
      "B30 {\n  if (z9 !\u003d 0) goto B31 else B34\n}",
      "B31 {\n  $z10 \u003d r32.equals(\"US/Pacific-New\")\n  if ($z10 !\u003d 0) goto B32 else B34\n}",
      "B32 {\n  $z11 \u003d r32.startsWith(\"Etc/\")\n  if ($z11 !\u003d 0) goto B33 else B34\n}",
      "B33 {\n  $z12 \u003d r32.equals(\"GMT\")\n  if ($z12 \u003d\u003d false) goto B34 else B35\n}",
      "B34 {\n  $r35 \u003d List iBackLinks\u003e\n  $r35.add(r31)\n  $r36 \u003d List iBackLinks\u003e\n  $r36.add(r32)\n  goto B36\n}",
      "B35 {\n  $r13 \u003d List iGoodLinks\u003e\n  $r13.add(r31)\n  $r14 \u003d List iGoodLinks\u003e\n  $r14.add(r32)\n}",
      "B36 {\n  goto B38\n}",
      "B37 {\n  $r11 \u003d PrintStream out\u003e\n  $r12 \u003d dynInvoke makeConcatWithConstants(r29)\n  $r11.println($r12)\n}",
      "B38 {\n  goto B1\n}",
      "B39 {\n  if (r27 \u003d\u003d null) goto B40 else B41\n}",
      "B40 {\n  $r2 \u003d List iZones\u003e\n  $r2.add(r27)\n}",
      "B41 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B39",
      "B2 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B1",
      "B10 --\u003e B1",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B38",
      "B14 --\u003e B15",
      "B14 --\u003e B19",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B38",
      "B19 --\u003e B20",
      "B19 --\u003e B23",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B38",
      "B23 --\u003e B24",
      "B23 --\u003e B37",
      "B24 --\u003e B25",
      "B24 --\u003e B27",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B36",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B36",
      "B30 --\u003e B31",
      "B30 --\u003e B34",
      "B31 --\u003e B32",
      "B31 --\u003e B34",
      "B32 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B38",
      "B37 --\u003e B38",
      "B38 --\u003e B1",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e B41",
      "B41 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.tz.ZoneInfoProvider",
    "methodName": "getZone",
    "signature": "org.joda.time.DateTimeZone getZone(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (id \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Object obj \u003d iZoneInfoMap.get(id);\r\n    if (obj \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (obj instanceof SoftReference\u003c?\u003e) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        SoftReference\u003cDateTimeZone\u003e ref \u003d (SoftReference\u003cDateTimeZone\u003e) obj;\r\n        DateTimeZone tz \u003d ref.get();\r\n        if (tz !\u003d null) {\r\n            return tz;\r\n        }\r\n        // Reference cleared; load data again.\r\n        return loadZoneData(id);\r\n    } else if (id.equals(obj)) {\r\n        // Load zone data for the first time.\r\n        return loadZoneData(id);\r\n    }\r\n    // If this point is reached, mapping must link to another.\r\n    return getZone((String) obj);\r\n}",
    "nodes": 11,
    "edges": 10,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r3 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B8",
      "B5 : If(r9 \u003d\u003d null) → B6 | else → B7",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ZoneInfoProvider\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Map iZoneInfoMap\u003e\n  r3 \u003d $r2.get(r0)\n  if (r3 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z0 \u003d SoftReference\n  if ($z0 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  r7 \u003d SoftReference) r3\n  $r8 \u003d r7.get()\n  r9 \u003d DateTimeZone) $r8\n  if (r9 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  $r10 \u003d r1.loadZoneData(r0)\n  return\n}",
      "B8 {\n  $z1 \u003d r0.equals(r3)\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r6 \u003d r1.loadZoneData(r0)\n  return\n}",
      "B10 {\n  $r4 \u003d String) r3\n  $r5 \u003d r1.getZone($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZoneInfoProvider#getZone(...1)",
        "body": "{\r\n    if (id \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    Object obj \u003d iZoneInfoMap.get(id);\r\n    if (obj \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (obj instanceof SoftReference\u003c?\u003e) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        SoftReference\u003cDateTimeZone\u003e ref \u003d (SoftReference\u003cDateTimeZone\u003e) obj;\r\n        DateTimeZone tz \u003d ref.get();\r\n        if (tz !\u003d null) {\r\n            return tz;\r\n        }\r\n        // Reference cleared; load data again.\r\n        return loadZoneData(id);\r\n    } else if (id.equals(obj)) {\r\n        // Load zone data for the first time.\r\n        return loadZoneData(id);\r\n    }\r\n    // If this point is reached, mapping must link to another.\r\n    return getZone((String) obj);\r\n}"
      },
      {
        "name": "ZoneInfoProvider#loadZoneData(...1)",
        "body": "{\r\n    InputStream in \u003d null;\r\n    try {\r\n        in \u003d openResource(id);\r\n        DateTimeZone tz \u003d DateTimeZoneBuilder.readFrom(in, id);\r\n        iZoneInfoMap.put(id, new SoftReference\u003cDateTimeZone\u003e(tz));\r\n        return tz;\r\n    } catch (IOException ex) {\r\n        uncaughtException(ex);\r\n        iZoneInfoMap.remove(id);\r\n        return null;\r\n    } finally {\r\n        try {\r\n            if (in !\u003d null) {\r\n                in.close();\r\n            }\r\n        } catch (IOException ex) {\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "weeks",
    "signature": "org.joda.time.Weeks weeks(int)",
    "visibility": "public",
    "body": "{\r\n    switch(weeks) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Weeks(weeks);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 7,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B6 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Weeks; }\n}",
      "B1 {\n  $r4 \u003d Weeks ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d Weeks ONE\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d Weeks TWO\u003e\n  return\n}",
      "B4 {\n  $r1 \u003d Weeks THREE\u003e\n  return\n}",
      "B5 {\n  $r0 \u003d Weeks MAX_VALUE\u003e\n  return\n}",
      "B6 {\n  $r5 \u003d Weeks MIN_VALUE\u003e\n  return\n}",
      "B7 {\n  $r6 \u003d Weeks\n  new Weeks(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B6",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B7",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "weeksBetween",
    "signature": "org.joda.time.Weeks weeksBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalDate \u0026\u0026 end instanceof LocalDate) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int weeks \u003d chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Weeks.weeks(weeks);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Weeks.weeks(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalDate\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.weeks()\n  $r5 \u003d LocalDate) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalDate) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Weeks.weeks(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Weeks ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Weeks.weeks($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "weeksIn",
    "signature": "org.joda.time.Weeks weeksIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Weeks.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\r\n    return Weeks.weeks(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Weeks ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.weeks()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Weeks.weeks(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "parseWeeks",
    "signature": "org.joda.time.Weeks parseWeeks(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Weeks.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Weeks.weeks(p.getWeeks());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Weeks ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getWeeks()\n  $r3 \u003d Weeks.weeks($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "plus",
    "signature": "org.joda.time.Weeks plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Weeks.weeks($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "plus",
    "signature": "org.joda.time.Weeks plus(org.joda.time.Weeks)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(weeks.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  Weeks\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#plus(...1)",
        "body": "{\r\n    if (weeks \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "minus",
    "signature": "org.joda.time.Weeks minus(org.joda.time.Weeks)",
    "visibility": "public",
    "body": "{\r\n    if (weeks \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(weeks.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  Weeks\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(weeks));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Weeks dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Weeks.weeks(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Weeks.weeks($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Weeks)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  Weeks\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Weeks",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Weeks)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Weeks\n  Weeks\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Weeks#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "now",
    "signature": "org.joda.time.YearMonth now(org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    if (zone \u003d\u003d null) {\r\n        throw new NullPointerException(\"Zone must not be null\");\r\n    }\r\n    return new YearMonth(zone);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTimeZone\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Zone must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonth\n  new YearMonth(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "now",
    "signature": "org.joda.time.YearMonth now(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    if (chronology \u003d\u003d null) {\r\n        throw new NullPointerException(\"Chronology must not be null\");\r\n    }\r\n    return new YearMonth(chronology);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Chronology\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NullPointerException\n  new NullPointerException(\"Chronology must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonth\n  new YearMonth(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.YearMonth fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonth\n  $i2 \u003d r0.get(1)\n  $i0 \u003d r0.get(2)\n  $i1 \u003d $i0 + 1\n  new YearMonth($i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.YearMonth fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonth\n  $i0 \u003d r0.getYear()\n  $i3 \u003d $i0 + 1900\n  $i1 \u003d r0.getMonth()\n  $i2 \u003d $i1 + 1\n  new YearMonth($i3, $i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "withChronologyRetainFields",
    "signature": "org.joda.time.YearMonth withChronologyRetainFields(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    newChronology \u003d newChronology.withUTC();\r\n    if (newChronology \u003d\u003d getChronology()) {\r\n        return this;\r\n    } else {\r\n        YearMonth newYearMonth \u003d new YearMonth(this, newChronology);\r\n        newChronology.validate(newYearMonth, getValues());\r\n        return newYearMonth;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  Chronology\n  r5 \u003d DateTimeUtils.getChronology(r4)\n  r6 \u003d r5.withUTC()\n  $r1 \u003d r0.getChronology()\n  if (r6 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d YearMonth\n  new YearMonth(r0, r6)\n  $r3 \u003d r0.getValues()\n  r6.validate($r2, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "withField",
    "signature": "org.joda.time.YearMonth withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new YearMonth(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  $i2 \u003d r0.getValue(i0)\n  if (i1 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.set(r0, i0, r4, i1)\n  $r3 \u003d YearMonth\n  new YearMonth(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#indexOfSupported(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#getValue(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.YearMonth withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).add(this, index, newValues, amount);\r\n    return new YearMonth(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.add(r0, i0, r4, i1)\n  $r3 \u003d YearMonth\n  new YearMonth(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.YearMonth withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        DurationFieldType fieldType \u003d period.getFieldType(i);\r\n        int index \u003d indexOf(fieldType);\r\n        if (index \u003e\u003d 0) {\r\n            newValues \u003d getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\r\n        }\r\n    }\r\n    return new YearMonth(this, newValues);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i5 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If(i2 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r5 \u003d r1.getValues()\n  i5 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i5 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  r3 \u003d r0.getFieldType(i5)\n  i2 \u003d r1.indexOf(r3)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getField(i2)\n  $i3 \u003d r0.getValue(i5)\n  $i4 \u003d FieldUtils.safeMultiply($i3, i0)\n  r5 \u003d $r4.add(r1, i2, r5, $i4)\n}",
      "B7 {\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B8 {\n  $r2 \u003d YearMonth\n  new YearMonth(r1, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonth#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r1.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r3 \u003d $r2.print(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.yearMonth().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonth",
    "methodName": "toString",
    "signature": "java.lang.String toString(java.lang.String,java.util.Locale)",
    "visibility": "public",
    "body": "{\r\n    if (pattern \u003d\u003d null) {\r\n        return toString();\r\n    }\r\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonth\n  String\n  Locale\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r3.toString()\n  return\n}",
      "B2 {\n  $r2 \u003d DateTimeFormat.forPattern(r0)\n  $r4 \u003d $r2.withLocale(r1)\n  $r5 \u003d $r4.print(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonth#toString(...0)",
        "body": "{\r\n    return ISODateTimeFormat.yearMonth().print(this);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "fromCalendarFields",
    "signature": "org.joda.time.YearMonthDay fromCalendarFields(java.util.Calendar)",
    "visibility": "public",
    "body": "{\r\n    if (calendar \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The calendar must not be null\");\r\n    }\r\n    return new YearMonthDay(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Calendar\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The calendar must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonthDay\n  $i3 \u003d r0.get(1)\n  $i0 \u003d r0.get(2)\n  $i2 \u003d $i0 + 1\n  $i1 \u003d r0.get(5)\n  new YearMonthDay($i3, $i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "fromDateFields",
    "signature": "org.joda.time.YearMonthDay fromDateFields(java.util.Date)",
    "visibility": "public",
    "body": "{\r\n    if (date \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return new YearMonthDay(date.getYear() + 1900, date.getMonth() + 1, date.getDate());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Date\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The date must not be null\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d YearMonthDay\n  $i0 \u003d r0.getYear()\n  $i4 \u003d $i0 + 1900\n  $i1 \u003d r0.getMonth()\n  $i3 \u003d $i1 + 1\n  $i2 \u003d r0.getDate()\n  new YearMonthDay($i4, $i3, $i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "withChronologyRetainFields",
    "signature": "org.joda.time.YearMonthDay withChronologyRetainFields(org.joda.time.Chronology)",
    "visibility": "public",
    "body": "{\r\n    newChronology \u003d DateTimeUtils.getChronology(newChronology);\r\n    newChronology \u003d newChronology.withUTC();\r\n    if (newChronology \u003d\u003d getChronology()) {\r\n        return this;\r\n    } else {\r\n        YearMonthDay newYearMonthDay \u003d new YearMonthDay(this, newChronology);\r\n        newChronology.validate(newYearMonthDay, getValues());\r\n        return newYearMonthDay;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonthDay\n  Chronology\n  r5 \u003d DateTimeUtils.getChronology(r4)\n  r6 \u003d r5.withUTC()\n  $r1 \u003d r0.getChronology()\n  if (r6 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d YearMonthDay\n  new YearMonthDay(r0, r6)\n  $r3 \u003d r0.getValues()\n  r6.validate($r2, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "withField",
    "signature": "org.joda.time.YearMonthDay withField(org.joda.time.DateTimeFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (value \u003d\u003d getValue(index)) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).set(this, index, newValues, value);\r\n    return new YearMonthDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonthDay\n  DateTimeFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  $i2 \u003d r0.getValue(i0)\n  if (i1 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.set(r0, i0, r4, i1)\n  $r3 \u003d YearMonthDay\n  new YearMonthDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#indexOfSupported(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#getValue(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "withFieldAdded",
    "signature": "org.joda.time.YearMonthDay withFieldAdded(org.joda.time.DurationFieldType,int)",
    "visibility": "public",
    "body": "{\r\n    int index \u003d indexOfSupported(fieldType);\r\n    if (amount \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    newValues \u003d getField(index).add(this, index, newValues, amount);\r\n    return new YearMonthDay(this, newValues);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonthDay\n  DurationFieldType\n  i1 :\u003d @parameter1: int\n  i0 \u003d r0.indexOfSupported(r1)\n  if (i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d r0.getValues()\n  $r2 \u003d r0.getField(i0)\n  r5 \u003d $r2.add(r0, i0, r4, i1)\n  $r3 \u003d YearMonthDay\n  new YearMonthDay(r0, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#indexOfSupported(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "withPeriodAdded",
    "signature": "org.joda.time.YearMonthDay withPeriodAdded(org.joda.time.ReadablePeriod,int)",
    "visibility": "public",
    "body": "{\r\n    if (period \u003d\u003d null || scalar \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    int[] newValues \u003d getValues();\r\n    for (int i \u003d 0; i \u003c period.size(); i++) {\r\n        DurationFieldType fieldType \u003d period.getFieldType(i);\r\n        int index \u003d indexOf(fieldType);\r\n        if (index \u003e\u003d 0) {\r\n            newValues \u003d getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\r\n        }\r\n    }\r\n    return new YearMonthDay(this, newValues);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3",
      "B4 : If(i5 \u003e\u003d $i1) → B5 | else → B8",
      "B5 : If(i2 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  YearMonthDay\n  ReadablePeriod\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r5 \u003d r1.getValues()\n  i5 \u003d 0\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if (i5 \u003e\u003d $i1) goto B5 else B8\n}",
      "B5 {\n  r3 \u003d r0.getFieldType(i5)\n  i2 \u003d r1.indexOf(r3)\n  if (i2 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d r1.getField(i2)\n  $i3 \u003d r0.getValue(i5)\n  $i4 \u003d FieldUtils.safeMultiply($i3, i0)\n  r5 \u003d $r4.add(r1, i2, r5, $i4)\n}",
      "B7 {\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B8 {\n  $r2 \u003d YearMonthDay\n  new YearMonthDay(r1, r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B4",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonthDay#getValues(...0)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#getField(...1)",
        "body": "(source not found)"
      },
      {
        "name": "YearMonthDay#indexOf(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.YearMonthDay",
    "methodName": "toDateTime",
    "signature": "org.joda.time.DateTime toDateTime(org.joda.time.TimeOfDay,org.joda.time.DateTimeZone)",
    "visibility": "public",
    "body": "{\r\n    Chronology chrono \u003d getChronology().withZone(zone);\r\n    long instant \u003d DateTimeUtils.currentTimeMillis();\r\n    instant \u003d chrono.set(this, instant);\r\n    if (time !\u003d null) {\r\n        instant \u003d chrono.set(time, instant);\r\n    }\r\n    return new DateTime(instant, chrono);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  YearMonthDay\n  TimeOfDay\n  DateTimeZone\n  $r2 \u003d r0.getChronology()\n  r3 \u003d $r2.withZone(r1)\n  l0 \u003d DateTimeUtils.currentTimeMillis()\n  l1 \u003d r3.set(r0, l0)\n  if (r4 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  l1 \u003d r3.set(r4, l1)\n}",
      "B2 {\n  $r5 \u003d DateTime\n  new DateTime(l1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "YearMonthDay#getChronology(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "years",
    "signature": "org.joda.time.Years years(int)",
    "visibility": "public",
    "body": "{\r\n    switch(years) {\r\n        case 0:\r\n            return ZERO;\r\n        case 1:\r\n            return ONE;\r\n        case 2:\r\n            return TWO;\r\n        case 3:\r\n            return THREE;\r\n        case Integer.MAX_VALUE:\r\n            return MAX_VALUE;\r\n        case Integer.MIN_VALUE:\r\n            return MIN_VALUE;\r\n        default:\r\n            return new Years(years);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 7,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B6 | else → B1"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  Years; }\n}",
      "B1 {\n  $r4 \u003d Years ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d Years ONE\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d Years TWO\u003e\n  return\n}",
      "B4 {\n  $r1 \u003d Years THREE\u003e\n  return\n}",
      "B5 {\n  $r0 \u003d Years MAX_VALUE\u003e\n  return\n}",
      "B6 {\n  $r5 \u003d Years MIN_VALUE\u003e\n  return\n}",
      "B7 {\n  $r6 \u003d Years\n  new Years(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B6",
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B0 --\u003e B7",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "yearsBetween",
    "signature": "org.joda.time.Years yearsBetween(org.joda.time.ReadablePartial,org.joda.time.ReadablePartial)",
    "visibility": "public",
    "body": "{\r\n    if (start instanceof LocalDate \u0026\u0026 end instanceof LocalDate) {\r\n        Chronology chrono \u003d DateTimeUtils.getChronology(start.getChronology());\r\n        int years \u003d chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\r\n        return Years.years(years);\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(start, end, ZERO);\r\n    return Years.years(amount);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReadablePartial\n  ReadablePartial\n  $z0 \u003d LocalDate\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d LocalDate\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d r0.getChronology()\n  r9 \u003d DateTimeUtils.getChronology($r4)\n  $r7 \u003d r9.years()\n  $r5 \u003d LocalDate) r1\n  $l2 \u003d $r5.getLocalMillis()\n  $r6 \u003d LocalDate) r0\n  $l1 \u003d $r6.getLocalMillis()\n  i3 \u003d $r7.getDifference($l2, $l1)\n  $r8 \u003d Years.years(i3)\n  return\n}",
      "B3 {\n  $r2 \u003d Years ZERO\u003e\n  $i0 \u003d BaseSingleFieldPeriod.between(r0, r1, $r2)\n  $r3 \u003d Years.years($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "yearsIn",
    "signature": "org.joda.time.Years yearsIn(org.joda.time.ReadableInterval)",
    "visibility": "public",
    "body": "{\r\n    if (interval \u003d\u003d null) {\r\n        return Years.ZERO;\r\n    }\r\n    int amount \u003d BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\r\n    return Years.years(amount);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableInterval\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Years ZERO\u003e\n  return\n}",
      "B2 {\n  $r3 \u003d r0.getStart()\n  $r2 \u003d r0.getEnd()\n  $r1 \u003d DurationFieldType.years()\n  i0 \u003d BaseSingleFieldPeriod.between($r3, $r2, $r1)\n  $r4 \u003d Years.years(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "parseYears",
    "signature": "org.joda.time.Years parseYears(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (periodStr \u003d\u003d null) {\r\n        return Years.ZERO;\r\n    }\r\n    Period p \u003d PARSER.parsePeriod(periodStr);\r\n    return Years.years(p.getYears());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Years ZERO\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d PeriodFormatter PARSER\u003e\n  r2 \u003d $r1.parsePeriod(r0)\n  $i0 \u003d r2.getYears()\n  $r3 \u003d Years.years($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "plus",
    "signature": "org.joda.time.Years plus(int)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Years.years(FieldUtils.safeAdd(getValue(), years));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Years\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d FieldUtils.safeAdd($i1, i0)\n  $r1 \u003d Years.years($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "plus",
    "signature": "org.joda.time.Years plus(org.joda.time.Years)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return plus(years.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Years\n  Years\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.plus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#plus(...1)",
        "body": "{\r\n    if (years \u003d\u003d 0) {\r\n        return this;\r\n    }\r\n    return Years.years(FieldUtils.safeAdd(getValue(), years));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "minus",
    "signature": "org.joda.time.Years minus(org.joda.time.Years)",
    "visibility": "public",
    "body": "{\r\n    if (years \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    return minus(years.getValue());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Years\n  Years\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.getValue()\n  $r2 \u003d r1.minus($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#minus(...1)",
        "body": "{\r\n    return plus(FieldUtils.safeNegate(years));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "dividedBy",
    "signature": "org.joda.time.Years dividedBy(int)",
    "visibility": "public",
    "body": "{\r\n    if (divisor \u003d\u003d 1) {\r\n        return this;\r\n    }\r\n    return Years.years(getValue() / divisor);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Years\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d r0.getValue()\n  $i2 \u003d $i1 / i0\n  $r1 \u003d Years.years($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "isGreaterThan",
    "signature": "boolean isGreaterThan(org.joda.time.Years)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003e 0;\r\n    }\r\n    return getValue() \u003e other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003c\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003c\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Years\n  Years\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003c\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.joda.time.Years",
    "methodName": "isLessThan",
    "signature": "boolean isLessThan(org.joda.time.Years)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d null) {\r\n        return getValue() \u003c 0;\r\n    }\r\n    return getValue() \u003c other.getValue();\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B5",
      "B1 : If($i2 \u003e\u003d 0) → B2 | else → B3",
      "B5 : If($i1 \u003e\u003d $i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Years\n  Years\n  if (r0 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r1.getValue()\n  if ($i2 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.getValue()\n  $i0 \u003d r0.getValue()\n  if ($i1 \u003e\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Years#getValue(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "SootCFGAnalysis",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    //        String targetDir \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\benchmark\\\\commons-collections4-4.5.0-M1-src\\\\commons-collections4-4.5.0-M1-src\\\\target\\\\classes\"; // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    //        String outputCsv \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\cfg_analysis_result.tsv\"; // 결과 저장할 CSV 파일 경로\r\n    // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    String targetDir \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\joda-time-2.14.0\\\\target\\\\classes\";\r\n    // 결과 저장할 CSV 파일 경로\r\n    String outputCsv \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_time.csv\";\r\n    if (System.getProperty(\"sun.boot.class.path\") \u003d\u003d null)\r\n        System.setProperty(\"sun.boot.class.path\", \"\");\r\n    if (System.getProperty(\"java.ext.dirs\") \u003d\u003d null)\r\n        System.setProperty(\"java.ext.dirs\", \"\");\r\n    // (1) 기본 Soot 설정\r\n    Options.v().set_prepend_classpath(true);\r\n    Options.v().set_process_dir(Collections.singletonList(targetDir));\r\n    Options.v().set_whole_program(true);\r\n    // 출력 없음\r\n    Options.v().set_output_format(Options.output_format_none);\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_allow_phantom_refs(true);\r\n    Options.v().set_keep_line_number(true);\r\n    // phantom 클래스에 바디 생성 안 함\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_process_dir(// 내 클래스만\r\n    Collections.singletonList(\"target/classes\"));\r\n    Options.v().set_src_prec(Options.src_prec_class);\r\n    Options.v().setPhaseOption(\"jb\", \"use-original-names:true\");\r\n    Scene.v().loadNecessaryClasses();\r\n    // (★) 이미 본 메서드 서명을 기억할 Set\r\n    Set\u003cString\u003e seen \u003d new HashSet\u003c\u003e();\r\n    // (2) 애플리케이션 클래스들 순회\r\n    try (CSVWriter writer \u003d new CSVWriter(new FileWriter(outputCsv))) {\r\n        // CSV 헤더 작성\r\n        writer.writeNext(new String[] { \"Class\", \"Method\", \"MethodSig\", \"Nodes\", \"Edges\", \"McCabe_CC\", \"StartLine\", \"EndLine\", \"LineCount\" });\r\n        List\u003cSootClass\u003e classes \u003d new ArrayList\u003c\u003e(Scene.v().getApplicationClasses());\r\n        for (SootClass cls : classes) {\r\n            for (SootMethod method : cls.getMethods()) {\r\n                if (!method.isConcrete())\r\n                    continue;\r\n                try {\r\n                    Body body \u003d method.retrieveActiveBody();\r\n                    // 기본 블록 단위\r\n                    BlockGraph cfg \u003d new BriefBlockGraph(body);\r\n                    int nodeCount \u003d cfg.size();\r\n                    int edgeCount \u003d 0;\r\n                    for (Block b : cfg) edgeCount +\u003d cfg.getSuccsOf(b).size();\r\n                    int cc \u003d edgeCount - nodeCount + 2;\r\n                    int startLine \u003d Integer.MAX_VALUE;\r\n                    int endLine \u003d Integer.MIN_VALUE;\r\n                    for (Unit unit : body.getUnits()) {\r\n                        int line \u003d unit.getJavaSourceStartLineNumber();\r\n                        if (line \u003e 0) {\r\n                            startLine \u003d Math.min(startLine, line);\r\n                            endLine \u003d Math.max(endLine, line);\r\n                        }\r\n                    }\r\n                    int lineCount \u003d (startLine \u003c\u003d endLine) ? (endLine - startLine + 1) : 0;\r\n                    if (!isTopLevelPublic(cls) || !isRealMethod(method))\r\n                        continue;\r\n                    if (nodeCount \u003d\u003d 0 || edgeCount \u003d\u003d 0)\r\n                        continue;\r\n                    if (cc \u003c\u003d 0)\r\n                        continue;\r\n                    String methodSig \u003d method.getSubSignature();\r\n                    String uniqueKey \u003d method.getSignature();\r\n                    // (★) 이미 기록된 서명이라면 건너뛰기\r\n                    if (!seen.add(uniqueKey))\r\n                        continue;\r\n                    // 결과를 CSV로 저장\r\n                    String[] row \u003d { cls.getName(), method.getName(), uniqueKey, String.valueOf(nodeCount), String.valueOf(edgeCount), String.valueOf(cc), String.valueOf(startLine), String.valueOf(endLine), String.valueOf(lineCount) };\r\n                    writer.writeNext(row);\r\n                } catch (Exception e) {\r\n                    System.out.printf(\"[⚠️ 오류] %s.%s: %s\\n\", cls.getName(), method.getName(), e.getMessage());\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"✅ 분석 완료: \" + outputCsv + \"에 저장됨\");\r\n    } catch (IOException e) {\r\n        System.err.println(\"❌ CSV 저장 중 오류: \" + e.getMessage());\r\n    }\r\n}",
    "nodes": 42,
    "edges": 55,
    "cc": 15,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B5 : If($z6 \u003d\u003d false) → B6 | else → B35",
      "B7 : If($z7 \u003d\u003d false) → B8 | else → B34",
      "B8 : If($z0 !\u003d 0) → B9 | else → B10",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i8 \u003c\u003d 0) → B16 | else → B17",
      "B18 : If(i6 \u003e i7) → B19 | else → B20",
      "B21 : If($z3 \u003d\u003d false) → B22 | else → B23",
      "B22 : If($z4 !\u003d 0) → B23 | else → B24",
      "B24 : If(i0 \u003d\u003d false) → B25 | else → B26",
      "B25 : If(i4 !\u003d 0) → B26 | else → B27",
      "B27 : If(i5 \u003e 0) → B28 | else → B29",
      "B29 : If($z5 !\u003d 0) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $r0 \u003d System.getProperty(\"sun.boot.class.path\")\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  System.setProperty(\"sun.boot.class.path\", \"\")\n}",
      "B2 {\n  $r1 \u003d System.getProperty(\"java.ext.dirs\")\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  System.setProperty(\"java.ext.dirs\", \"\")\n}",
      "B4 {\n  $r2 \u003d Options.v()\n  $r2.set_prepend_classpath(1)\n  $r4 \u003d Options.v()\n  $r3 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\joda-time-2.14.0\\\\target\\\\classes\")\n  $r4.set_process_dir($r3)\n  $r5 \u003d Options.v()\n  $r5.set_whole_program(1)\n  $r6 \u003d Options.v()\n  $r6.set_output_format(12)\n  $r7 \u003d Options.v()\n  $r7.set_no_bodies_for_excluded(1)\n  $r8 \u003d Options.v()\n  $r8.set_allow_phantom_refs(1)\n  $r9 \u003d Options.v()\n  $r9.set_keep_line_number(1)\n  $r10 \u003d Options.v()\n  $r10.set_no_bodies_for_excluded(1)\n  $r12 \u003d Options.v()\n  $r11 \u003d Collections.singletonList(\"target/classes\")\n  $r12.set_process_dir($r11)\n  $r13 \u003d Options.v()\n  $r13.set_src_prec(1)\n  $r14 \u003d Options.v()\n  $r14.setPhaseOption(\"jb\", \"use-original-names:true\")\n  $r15 \u003d Scene.v()\n  $r15.loadNecessaryClasses()\n  $r16 \u003d HashSet\n  new HashSet()\n  $r17 \u003d CSVWriter\n  $r18 \u003d FileWriter\n  new FileWriter(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_time.csv\")\n  new CSVWriter($r18)\n  $r19 \u003d String)[9]\n  $r19[0] \u003d \"Class\"\n  $r19[1] \u003d \"Method\"\n  $r19[2] \u003d \"MethodSig\"\n  $r19[3] \u003d \"Nodes\"\n  $r19[4] \u003d \"Edges\"\n  $r19[5] \u003d \"McCabe_CC\"\n  $r19[6] \u003d \"StartLine\"\n  $r19[7] \u003d \"EndLine\"\n  $r19[8] \u003d \"LineCount\"\n  $r17.writeNext($r19)\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  $r45 \u003d $r20.iterator()\n}",
      "B5 {\n  $z6 \u003d $r45.hasNext()\n  if ($z6 \u003d\u003d false) goto B6 else B35\n}",
      "B6 {\n  $r25 \u003d $r45.next()\n  r26 \u003d SootClass) $r25\n  $r27 \u003d r26.getMethods()\n  r28 \u003d $r27.iterator()\n}",
      "B7 {\n  $z7 \u003d r28.hasNext()\n  if ($z7 \u003d\u003d false) goto B8 else B34\n}",
      "B8 {\n  $r29 \u003d r28.next()\n  r30 \u003d SootMethod) $r29\n  $z0 \u003d r30.isConcrete()\n  if ($z0 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  goto B7\n}",
      "B10 {\n  r59 \u003d r30.retrieveActiveBody()\n  $r31 \u003d BriefBlockGraph\n  new BriefBlockGraph(r59)\n  i0 \u003d $r31.size()\n  i4 \u003d 0\n  r60 \u003d $r31.iterator()\n}",
      "B11 {\n  $z1 \u003d r60.hasNext()\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r43 \u003d r60.next()\n  r61 \u003d Block) $r43\n  $r44 \u003d $r31.getSuccsOf(r61)\n  $i3 \u003d $r44.size()\n  i4 \u003d i4 + $i3\n  goto B11\n}",
      "B13 {\n  $i1 \u003d i4 - i0\n  i5 \u003d $i1 + 2\n  i6 \u003d 2147483647\n  i7 \u003d -2147483648\n  $r32 \u003d r59.getUnits()\n  r62 \u003d $r32.iterator()\n}",
      "B14 {\n  $z2 \u003d r62.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r42 \u003d r62.next()\n  r63 \u003d Unit) $r42\n  i8 \u003d r63.getJavaSourceStartLineNumber()\n  if (i8 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i6 \u003d Math.min(i6, i8)\n  i7 \u003d Math.max(i7, i8)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  if (i6 \u003e i7) goto B19 else B20\n}",
      "B19 {\n  $i2 \u003d i7 - i6\n  $i9 \u003d $i2 + 1\n  goto B21\n}",
      "B20 {\n  $i9 \u003d 0\n}",
      "B21 {\n  $z3 \u003d SootCFGAnalysis.isTopLevelPublic(r26)\n  if ($z3 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $z4 \u003d SootCFGAnalysis.isRealMethod(r30)\n  if ($z4 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  goto B7\n}",
      "B24 {\n  if (i0 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  if (i4 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B7\n}",
      "B27 {\n  if (i5 \u003e 0) goto B28 else B29\n}",
      "B28 {\n  goto B7\n}",
      "B29 {\n  r30.getSubSignature()\n  r64 \u003d r30.getSignature()\n  $z5 \u003d $r16.add(r64)\n  if ($z5 !\u003d 0) goto B30 else B31\n}",
      "B30 {\n  goto B7\n}",
      "B31 {\n  $r33 \u003d String)[9]\n  $r34 \u003d r26.getName()\n  $r33[0] \u003d $r34\n  $r35 \u003d r30.getName()\n  $r33[1] \u003d $r35\n  $r33[2] \u003d r64\n  $r36 \u003d String.valueOf(i0)\n  $r33[3] \u003d $r36\n  $r37 \u003d String.valueOf(i4)\n  $r33[4] \u003d $r37\n  $r38 \u003d String.valueOf(i5)\n  $r33[5] \u003d $r38\n  $r39 \u003d String.valueOf(i6)\n  $r33[6] \u003d $r39\n  $r40 \u003d String.valueOf(i7)\n  $r33[7] \u003d $r40\n  $r41 \u003d String.valueOf($i9)\n  $r33[8] \u003d $r41\n  $r17.writeNext($r33)\n  goto B33\n}",
      "B32 {\n  $r52 :\u003d @caughtexception\n  $r54 \u003d PrintStream out\u003e\n  $r53 \u003d Object)[3]\n  $r55 \u003d r26.getName()\n  $r53[0] \u003d $r55\n  $r56 \u003d r30.getName()\n  $r53[1] \u003d $r56\n  $r57 \u003d $r52.getMessage()\n  $r53[2] \u003d $r57\n  $r54.printf(\"\\u26a0\\ufe0f \\uc624\\ub958 %s.%s: %s\\n\", $r53)\n}",
      "B33 {\n  goto B7\n}",
      "B34 {\n  goto B5\n}",
      "B35 {\n  $r23 \u003d PrintStream out\u003e\n  $r24 \u003d dynInvoke makeConcatWithConstants(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_time.csv\")\n  $r23.println($r24)\n  $r17.close()\n  goto B39\n}",
      "B36 {\n  $r51 :\u003d @caughtexception\n  $r17.close()\n  goto B38\n}",
      "B37 {\n  $r50 :\u003d @caughtexception\n  $r51.addSuppressed($r50)\n}",
      "B38 {\n  throw $r51\n}",
      "B39 {\n  goto B41\n}",
      "B40 {\n  $r46 :\u003d @caughtexception\n  $r47 \u003d PrintStream err\u003e\n  $r48 \u003d $r46.getMessage()\n  $r49 \u003d dynInvoke makeConcatWithConstants($r48)\n  $r47.println($r49)\n}",
      "B41 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B35",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B34",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B7",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B7",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B7",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B7",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B7",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B7",
      "B34 --\u003e B5",
      "B35 --\u003e B39",
      "B36 --\u003e B38",
      "B37 --\u003e B38",
      "B38 --\u003e [EXIT]",
      "B39 --\u003e B41",
      "B40 --\u003e B41",
      "B41 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SootCFGAnalysis#isTopLevelPublic(...1)",
        "body": "{\r\n    return c.isPublic() \u0026\u0026 !c.getName().contains(\"$\") \u0026\u0026 !c.isInterface() \u0026\u0026 !c.isAbstract();\r\n}"
      },
      {
        "name": "SootCFGAnalysis#isRealMethod(...1)",
        "body": "{\r\n    // (1) 바디 없는 메서드는 제외\r\n    if (!m.isConcrete())\r\n        return false;\r\n    // (2) 생성자/클래스 초기화자 제외\r\n    if (m.isConstructor() || m.isStaticInitializer())\r\n        return false;\r\n    // (3) 컴파일러 생성 메서드 제외 (synthetic, bridge)\r\n    final int ACC_BRIDGE \u003d 0x0040;\r\n    final int ACC_SYNTHETIC \u003d 0x1000;\r\n    int mod \u003d m.getModifiers();\r\n    // (4) public 이 아닌 메서드 제외\r\n    if (!Modifier.isPublic(mod))\r\n        return false;\r\n    return (mod \u0026 ACC_BRIDGE) \u003d\u003d 0 \u0026\u0026 (mod \u0026 ACC_SYNTHETIC) \u003d\u003d 0;\r\n}"
      }
    ]
  }
]