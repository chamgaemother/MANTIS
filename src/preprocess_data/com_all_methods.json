[
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ArArchiveEntry other \u003d (ArArchiveEntry) obj;\r\n    return Objects.equals(name, other.name);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ArArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d ArArchiveEntry) r1\n  $r6 \u003d String name\u003e\n  $r5 \u003d String name\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    // 3c21 7261 6863 0a3e\r\n    // @formatter:off\r\n    return length \u003e\u003d 8 \u0026\u0026 signature[0] \u003d\u003d 0x21 \u0026\u0026 signature[1] \u003d\u003d 0x3c \u0026\u0026 signature[2] \u003d\u003d 0x61 \u0026\u0026 signature[3] \u003d\u003d 0x72 \u0026\u0026 signature[4] \u003d\u003d 0x63 \u0026\u0026 signature[5] \u003d\u003d 0x68 \u0026\u0026 signature[6] \u003d\u003d 0x3e \u0026\u0026 signature[7] \u003d\u003d 0x0a;\r\n    // @formatter:on\r\n}",
    "nodes": 12,
    "edges": 20,
    "cc": 10,
    "flowSummary": [
      "B0 : If(i0 \u003c 8) → B1 | else → B10",
      "B1 : If($i9 !\u003d 33) → B2 | else → B10",
      "B2 : If($i10 !\u003d 60) → B3 | else → B10",
      "B3 : If($i11 !\u003d 97) → B4 | else → B10",
      "B4 : If($i12 !\u003d 114) → B5 | else → B10",
      "B5 : If($i13 !\u003d 99) → B6 | else → B10",
      "B6 : If($i14 !\u003d 104) → B7 | else → B10",
      "B7 : If($i15 !\u003d 62) → B8 | else → B10",
      "B8 : If($i16 !\u003d 10) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c 8) goto B1 else B10\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $i9 \u003d (int) $b1\n  if ($i9 !\u003d 33) goto B2 else B10\n}",
      "B2 {\n  $b2 \u003d r0[1]\n  $i10 \u003d (int) $b2\n  if ($i10 !\u003d 60) goto B3 else B10\n}",
      "B3 {\n  $b3 \u003d r0[2]\n  $i11 \u003d (int) $b3\n  if ($i11 !\u003d 97) goto B4 else B10\n}",
      "B4 {\n  $b4 \u003d r0[3]\n  $i12 \u003d (int) $b4\n  if ($i12 !\u003d 114) goto B5 else B10\n}",
      "B5 {\n  $b5 \u003d r0[4]\n  $i13 \u003d (int) $b5\n  if ($i13 !\u003d 99) goto B6 else B10\n}",
      "B6 {\n  $b6 \u003d r0[5]\n  $i14 \u003d (int) $b6\n  if ($i14 !\u003d 104) goto B7 else B10\n}",
      "B7 {\n  $b7 \u003d r0[6]\n  $i15 \u003d (int) $b7\n  if ($i15 !\u003d 62) goto B8 else B10\n}",
      "B8 {\n  $b8 \u003d r0[7]\n  $i16 \u003d (int) $b8\n  if ($i16 !\u003d 10) goto B9 else B10\n}",
      "B9 {\n  $z0 \u003d 1\n  goto B11\n}",
      "B10 {\n  $z0 \u003d 0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B10",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!closed) {\r\n        closed \u003d true;\r\n        in.close();\r\n    }\r\n    currentEntry \u003d null;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArArchiveInputStream\n  $z0 \u003d ArArchiveInputStream: boolean closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  ArArchiveInputStream: boolean closed\u003e \u003d 1\n  $r1 \u003d InputStream in\u003e\n  $r1.close()\n}",
      "B2 {\n  ArArchiveEntry currentEntry\u003e \u003d null\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream",
    "methodName": "getNextArEntry",
    "signature": "org.apache.commons.compress.archivers.ar.ArArchiveEntry getNextArEntry()",
    "visibility": "public",
    "body": "{\r\n    if (currentEntry !\u003d null) {\r\n        final long entryEnd \u003d entryOffset + currentEntry.getLength();\r\n        final long skipped \u003d org.apache.commons.io.IOUtils.skip(in, entryEnd - offset);\r\n        trackReadBytes(skipped);\r\n        currentEntry \u003d null;\r\n    }\r\n    if (offset \u003d\u003d 0) {\r\n        final byte[] expected \u003d ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\r\n        final byte[] realized \u003d IOUtils.readRange(in, expected.length);\r\n        final int read \u003d realized.length;\r\n        trackReadBytes(read);\r\n        if (read !\u003d expected.length) {\r\n            throw new IOException(\"Failed to read header. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        if (!Arrays.equals(expected, realized)) {\r\n            throw new IOException(\"Invalid header \" + ArchiveUtils.toAsciiString(realized));\r\n        }\r\n    }\r\n    if (offset % 2 !\u003d 0) {\r\n        if (in.read() \u003c 0) {\r\n            // hit eof\r\n            return null;\r\n        }\r\n        trackReadBytes(1);\r\n    }\r\n    {\r\n        final int read \u003d IOUtils.readFully(in, metaData);\r\n        trackReadBytes(read);\r\n        if (read \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        if (read \u003c metaData.length) {\r\n            throw new IOException(\"Truncated ar archive\");\r\n        }\r\n    }\r\n    {\r\n        final byte[] expected \u003d ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\r\n        final byte[] realized \u003d IOUtils.readRange(in, expected.length);\r\n        final int read \u003d realized.length;\r\n        trackReadBytes(read);\r\n        if (read !\u003d expected.length) {\r\n            throw new IOException(\"Failed to read entry trailer. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        if (!Arrays.equals(expected, realized)) {\r\n            throw new IOException(\"Invalid entry trailer. not read the content? Occurred at byte: \" + getBytesRead());\r\n        }\r\n    }\r\n    entryOffset \u003d offset;\r\n    // GNU ar uses a \u0027/\u0027 to mark the end of the file name; this allows for the use of spaces without the use of an extended file name.\r\n    // entry name is stored as ASCII string\r\n    String temp \u003d ArchiveUtils.toAsciiString(metaData, NAME_OFFSET, NAME_LEN).trim();\r\n    if (isGNUStringTable(temp)) {\r\n        // GNU extended file names entry\r\n        currentEntry \u003d readGNUStringTable(metaData, LENGTH_OFFSET, LENGTH_LEN);\r\n        return getNextArEntry();\r\n    }\r\n    long len;\r\n    try {\r\n        len \u003d asLong(metaData, LENGTH_OFFSET, LENGTH_LEN);\r\n    } catch (final NumberFormatException ex) {\r\n        throw new IOException(\"Broken archive, unable to parse ar_size field as a number\", ex);\r\n    }\r\n    if (temp.endsWith(\"/\")) {\r\n        // GNU terminator\r\n        temp \u003d temp.substring(0, temp.length() - 1);\r\n    } else if (isGNULongName(temp)) {\r\n        // get the offset\r\n        final int off \u003d ParsingUtils.parseIntValue(temp.substring(1));\r\n        // convert to the long name\r\n        temp \u003d getExtendedName(off);\r\n    } else if (isBSDLongName(temp)) {\r\n        temp \u003d getBSDLongName(temp);\r\n        // entry length contained the length of the file name in\r\n        // addition to the real length of the entry.\r\n        // assume file name was ASCII, there is no \"standard\" otherwise\r\n        final int nameLen \u003d temp.length();\r\n        len -\u003d nameLen;\r\n        entryOffset +\u003d nameLen;\r\n    }\r\n    if (len \u003c 0) {\r\n        throw new IOException(\"broken archive, entry with negative size\");\r\n    }\r\n    try {\r\n        currentEntry \u003d new ArArchiveEntry(temp, len, asInt(metaData, USER_ID_OFFSET, USER_ID_LEN, true), asInt(metaData, GROUP_ID_OFFSET, GROUP_ID_LEN, true), asInt(metaData, FILE_MODE_OFFSET, FILE_MODE_LEN, 8), asLong(metaData, LAST_MODIFIED_OFFSET, LAST_MODIFIED_LEN));\r\n        return currentEntry;\r\n    } catch (final NumberFormatException ex) {\r\n        throw new IOException(\"Broken archive, unable to parse entry metadata fields as numbers\", ex);\r\n    }\r\n}",
    "nodes": 33,
    "edges": 36,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($b1 !\u003d 0) → B3 | else → B7",
      "B3 : If(i35 \u003d\u003d $i27) → B4 | else → B5",
      "B5 : If($z5 !\u003d 0) → B6 | else → B7",
      "B7 : If($b4 \u003d\u003d false) → B8 | else → B11",
      "B8 : If($i23 \u003e\u003d 0) → B9 | else → B10",
      "B11 : If($i24 !\u003d 0) → B12 | else → B13",
      "B13 : If($i24 \u003e\u003d $i6) → B14 | else → B15",
      "B15 : If(i36 \u003d\u003d $i9) → B16 | else → B17",
      "B17 : If($z0 !\u003d 0) → B18 | else → B19",
      "B19 : If($z1 \u003d\u003d false) → B20 | else → B21",
      "B23 : If($z2 \u003d\u003d false) → B24 | else → B25",
      "B25 : If($z3 \u003d\u003d false) → B26 | else → B27",
      "B27 : If($z4 \u003d\u003d false) → B28 | else → B29",
      "B29 : If($i41 \u003e\u003d 0) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  ArArchiveInputStream\n  $r1 \u003d ArArchiveEntry currentEntry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $l29 \u003d ArArchiveInputStream: long entryOffset\u003e\n  $r44 \u003d ArArchiveEntry currentEntry\u003e\n  $l30 \u003d $r44.getLength()\n  l33 \u003d $l29 + $l30\n  $r45 \u003d InputStream in\u003e\n  $l31 \u003d ArArchiveInputStream: long offset\u003e\n  $l32 \u003d l33 - $l31\n  l34 \u003d IOUtils.skip($r45, $l32)\n  r0.trackReadBytes(l34)\n  ArArchiveEntry currentEntry\u003e \u003d null\n}",
      "B2 {\n  $l0 \u003d ArArchiveInputStream: long offset\u003e\n  $b1 \u003d $l0 cmp 0L\n  if ($b1 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  r50 \u003d ArchiveUtils.toAsciiBytes(\"!\u003carch\u003e\\n\")\n  $r32 \u003d InputStream in\u003e\n  $i25 \u003d lengthof r50\n  r51 \u003d IOUtils.readRange($r32, $i25)\n  i35 \u003d lengthof r51\n  $l26 \u003d (long) i35\n  r0.trackReadBytes($l26)\n  $i27 \u003d lengthof r50\n  if (i35 \u003d\u003d $i27) goto B4 else B5\n}",
      "B4 {\n  $r56 \u003d IOException\n  $r55 \u003d StringBuilder\n  new StringBuilder()\n  $r41 \u003d $r55.append(\"Failed to read header. Occurred at byte: \")\n  $l28 \u003d r0.getBytesRead()\n  $r42 \u003d $r41.append($l28)\n  $r43 \u003d $r42.toString()\n  new IOException($r43)\n  throw $r56\n}",
      "B5 {\n  $z5 \u003d Arrays.equals(r50, r51)\n  if ($z5 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r58 \u003d IOException\n  $r57 \u003d StringBuilder\n  new StringBuilder()\n  $r36 \u003d $r57.append(\"Invalid header \")\n  $r35 \u003d ArchiveUtils.toAsciiString(r51)\n  $r37 \u003d $r36.append($r35)\n  $r38 \u003d $r37.toString()\n  new IOException($r38)\n  throw $r58\n}",
      "B7 {\n  $l2 \u003d ArArchiveInputStream: long offset\u003e\n  $l3 \u003d $l2 % 2L\n  $b4 \u003d $l3 cmp 0L\n  if ($b4 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  $r31 \u003d InputStream in\u003e\n  $i23 \u003d $r31.read()\n  if ($i23 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  r0.trackReadBytes(1L)\n}",
      "B11 {\n  $r3 \u003d InputStream in\u003e\n  $r2 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $i24 \u003d IOUtils.readFully($r3, $r2)\n  $l5 \u003d (long) $i24\n  r0.trackReadBytes($l5)\n  if ($i24 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  return\n}",
      "B13 {\n  $r4 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $i6 \u003d lengthof $r4\n  if ($i24 \u003e\u003d $i6) goto B14 else B15\n}",
      "B14 {\n  $r59 \u003d IOException\n  new IOException(\"Truncated ar archive\")\n  throw $r59\n}",
      "B15 {\n  r52 \u003d ArchiveUtils.toAsciiBytes(\"`\\n\")\n  $r5 \u003d InputStream in\u003e\n  $i7 \u003d lengthof r52\n  r53 \u003d IOUtils.readRange($r5, $i7)\n  i36 \u003d lengthof r53\n  $l8 \u003d (long) i36\n  r0.trackReadBytes($l8)\n  $i9 \u003d lengthof r52\n  if (i36 \u003d\u003d $i9) goto B16 else B17\n}",
      "B16 {\n  $r61 \u003d IOException\n  $r60 \u003d StringBuilder\n  new StringBuilder()\n  $r27 \u003d $r60.append(\"Failed to read entry trailer. Occurred at byte: \")\n  $l22 \u003d r0.getBytesRead()\n  $r28 \u003d $r27.append($l22)\n  $r29 \u003d $r28.toString()\n  new IOException($r29)\n  throw $r61\n}",
      "B17 {\n  $z0 \u003d Arrays.equals(r52, r53)\n  if ($z0 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  $r63 \u003d IOException\n  $r62 \u003d StringBuilder\n  new StringBuilder()\n  $r22 \u003d $r62.append(\"Invalid entry trailer. not read the content? Occurred at byte: \")\n  $l21 \u003d r0.getBytesRead()\n  $r23 \u003d $r22.append($l21)\n  $r24 \u003d $r23.toString()\n  new IOException($r24)\n  throw $r63\n}",
      "B19 {\n  $l10 \u003d ArArchiveInputStream: long offset\u003e\n  ArArchiveInputStream: long entryOffset\u003e \u003d $l10\n  $r6 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $r7 \u003d ArchiveUtils.toAsciiString($r6, 0, 16)\n  r54 \u003d $r7.trim()\n  $z1 \u003d ArArchiveInputStream.isGNUStringTable(r54)\n  if ($z1 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r17 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $r18 \u003d r0.readGNUStringTable($r17, 48, 10)\n  ArArchiveEntry currentEntry\u003e \u003d $r18\n  $r19 \u003d r0.getNextArEntry()\n  return\n}",
      "B21 {\n  $r8 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  l37 \u003d r0.asLong($r8, 48, 10)\n  goto B23\n}",
      "B22 {\n  $r48 :\u003d @caughtexception\n  $r64 \u003d IOException\n  new IOException(\"Broken archive, unable to parse ar_size field as a number\", $r48)\n  throw $r64\n}",
      "B23 {\n  $z2 \u003d r54.endsWith(\"/\")\n  if ($z2 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $i19 \u003d r54.length()\n  $i20 \u003d $i19 - 1\n  r54 \u003d r54.substring(0, $i20)\n  goto B29\n}",
      "B25 {\n  $z3 \u003d r0.isGNULongName(r54)\n  if ($z3 \u003d\u003d false) goto B26 else B27\n}",
      "B26 {\n  $r16 \u003d r54.substring(1)\n  i38 \u003d ParsingUtils.parseIntValue($r16)\n  r54 \u003d r0.getExtendedName(i38)\n  goto B29\n}",
      "B27 {\n  $z4 \u003d ArArchiveInputStream.isBSDLongName(r54)\n  if ($z4 \u003d\u003d false) goto B28 else B29\n}",
      "B28 {\n  r54 \u003d r0.getBSDLongName(r54)\n  i39 \u003d r54.length()\n  $l15 \u003d (long) i39\n  l37 \u003d l37 - $l15\n  $l17 \u003d ArArchiveInputStream: long entryOffset\u003e\n  $l16 \u003d (long) i39\n  $l18 \u003d $l17 + $l16\n  ArArchiveInputStream: long entryOffset\u003e \u003d $l18\n}",
      "B29 {\n  $b40 \u003d l37 cmp 0L\n  $i41 \u003d (int) $b40\n  if ($i41 \u003e\u003d 0) goto B30 else B31\n}",
      "B30 {\n  $r65 \u003d IOException\n  new IOException(\"broken archive, entry with negative size\")\n  throw $r65\n}",
      "B31 {\n  $r66 \u003d ArArchiveEntry\n  $r10 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $i14 \u003d r0.asInt($r10, 28, 6, 1)\n  $r11 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $i13 \u003d r0.asInt($r11, 34, 6, 1)\n  $r12 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $i12 \u003d r0.asInt($r12, 40, 8, 8)\n  $r13 \u003d ArArchiveInputStream: byte[] metaData\u003e\n  $l11 \u003d r0.asLong($r13, 16, 12)\n  new ArArchiveEntry(r54, l37, $i14, $i13, $i12, $l11)\n  ArArchiveEntry currentEntry\u003e \u003d $r66\n  $r14 \u003d ArArchiveEntry currentEntry\u003e\n  return\n}",
      "B32 {\n  $r46 :\u003d @caughtexception\n  $r67 \u003d IOException\n  new IOException(\"Broken archive, unable to parse entry metadata fields as numbers\", $r46)\n  throw $r67\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B29",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B29",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveInputStream#isGNULongName(...1)",
        "body": "{\r\n    return name !\u003d null \u0026\u0026 GNU_LONGNAME_PATTERN.matcher(name).matches();\r\n}"
      },
      {
        "name": "ArArchiveInputStream#getBytesRead(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ArArchiveInputStream#asInt(...4)",
        "body": "{\r\n    return asInt(byteArray, offset, len, 10, treatBlankAsZero);\r\n}"
      },
      {
        "name": "ArArchiveInputStream#getBSDLongName(...1)",
        "body": "{\r\n    final int nameLen \u003d ParsingUtils.parseIntValue(bsdLongName.substring(BSD_LONGNAME_PREFIX_LEN));\r\n    final byte[] name \u003d IOUtils.readRange(in, nameLen);\r\n    final int read \u003d name.length;\r\n    trackReadBytes(read);\r\n    if (read !\u003d nameLen) {\r\n        throw new EOFException(bsdLongName);\r\n    }\r\n    return ArchiveUtils.toAsciiString(name);\r\n}"
      },
      {
        "name": "ArArchiveInputStream#isBSDLongName(...1)",
        "body": "{\r\n    return name !\u003d null \u0026\u0026 BSD_LONGNAME_PATTERN.matcher(name).matches();\r\n}"
      },
      {
        "name": "ArArchiveInputStream#isGNUStringTable(...1)",
        "body": "{\r\n    return GNU_STRING_TABLE_NAME.equals(name);\r\n}"
      },
      {
        "name": "ArArchiveInputStream#getExtendedName(...1)",
        "body": "{\r\n    if (namebuffer \u003d\u003d null) {\r\n        throw new IOException(\"Cannot process GNU long file name as no // record was found\");\r\n    }\r\n    for (int i \u003d offset; i \u003c namebuffer.length; i++) {\r\n        if (namebuffer[i] \u003d\u003d \u0027\\012\u0027 || namebuffer[i] \u003d\u003d 0) {\r\n            // Avoid array errors\r\n            if (i \u003d\u003d 0) {\r\n                break;\r\n            }\r\n            if (namebuffer[i - 1] \u003d\u003d \u0027/\u0027) {\r\n                // drop trailing /\r\n                i--;\r\n            }\r\n            // Check there is a something to return, otherwise break out of the loop\r\n            if (i - offset \u003e 0) {\r\n                return ArchiveUtils.toAsciiString(namebuffer, offset, i - offset);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    throw new IOException(\"Failed to read entry: \" + offset);\r\n}"
      },
      {
        "name": "ArArchiveInputStream#asLong(...3)",
        "body": "{\r\n    return ParsingUtils.parseLongValue(ArchiveUtils.toAsciiString(byteArray, offset, len).trim());\r\n}"
      },
      {
        "name": "ArArchiveInputStream#readGNUStringTable(...3)",
        "body": "{\r\n    final int bufflen;\r\n    try {\r\n        // Assume length will fit in an int\r\n        bufflen \u003d asInt(length, offset, len);\r\n    } catch (final NumberFormatException ex) {\r\n        throw new IOException(\"Broken archive, unable to parse GNU string table length field as a number\", ex);\r\n    }\r\n    namebuffer \u003d IOUtils.readRange(in, bufflen);\r\n    final int read \u003d namebuffer.length;\r\n    trackReadBytes(read);\r\n    if (read !\u003d bufflen) {\r\n        throw new IOException(\"Failed to read complete // record: expected\u003d\" + bufflen + \" read\u003d\" + read);\r\n    }\r\n    return new ArArchiveEntry(GNU_STRING_TABLE_NAME, bufflen);\r\n}"
      },
      {
        "name": "ArArchiveInputStream#trackReadBytes(...1)",
        "body": "{\r\n    count(read);\r\n    if (read \u003e 0) {\r\n        offset +\u003d read;\r\n    }\r\n}"
      },
      {
        "name": "ArArchiveInputStream#getNextArEntry(...0)",
        "body": "{\r\n    if (currentEntry !\u003d null) {\r\n        final long entryEnd \u003d entryOffset + currentEntry.getLength();\r\n        final long skipped \u003d org.apache.commons.io.IOUtils.skip(in, entryEnd - offset);\r\n        trackReadBytes(skipped);\r\n        currentEntry \u003d null;\r\n    }\r\n    if (offset \u003d\u003d 0) {\r\n        final byte[] expected \u003d ArchiveUtils.toAsciiBytes(ArArchiveEntry.HEADER);\r\n        final byte[] realized \u003d IOUtils.readRange(in, expected.length);\r\n        final int read \u003d realized.length;\r\n        trackReadBytes(read);\r\n        if (read !\u003d expected.length) {\r\n            throw new IOException(\"Failed to read header. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        if (!Arrays.equals(expected, realized)) {\r\n            throw new IOException(\"Invalid header \" + ArchiveUtils.toAsciiString(realized));\r\n        }\r\n    }\r\n    if (offset % 2 !\u003d 0) {\r\n        if (in.read() \u003c 0) {\r\n            // hit eof\r\n            return null;\r\n        }\r\n        trackReadBytes(1);\r\n    }\r\n    {\r\n        final int read \u003d IOUtils.readFully(in, metaData);\r\n        trackReadBytes(read);\r\n        if (read \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n        if (read \u003c metaData.length) {\r\n            throw new IOException(\"Truncated ar archive\");\r\n        }\r\n    }\r\n    {\r\n        final byte[] expected \u003d ArchiveUtils.toAsciiBytes(ArArchiveEntry.TRAILER);\r\n        final byte[] realized \u003d IOUtils.readRange(in, expected.length);\r\n        final int read \u003d realized.length;\r\n        trackReadBytes(read);\r\n        if (read !\u003d expected.length) {\r\n            throw new IOException(\"Failed to read entry trailer. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        if (!Arrays.equals(expected, realized)) {\r\n            throw new IOException(\"Invalid entry trailer. not read the content? Occurred at byte: \" + getBytesRead());\r\n        }\r\n    }\r\n    entryOffset \u003d offset;\r\n    // GNU ar uses a \u0027/\u0027 to mark the end of the file name; this allows for the use of spaces without the use of an extended file name.\r\n    // entry name is stored as ASCII string\r\n    String temp \u003d ArchiveUtils.toAsciiString(metaData, NAME_OFFSET, NAME_LEN).trim();\r\n    if (isGNUStringTable(temp)) {\r\n        // GNU extended file names entry\r\n        currentEntry \u003d readGNUStringTable(metaData, LENGTH_OFFSET, LENGTH_LEN);\r\n        return getNextArEntry();\r\n    }\r\n    long len;\r\n    try {\r\n        len \u003d asLong(metaData, LENGTH_OFFSET, LENGTH_LEN);\r\n    } catch (final NumberFormatException ex) {\r\n        throw new IOException(\"Broken archive, unable to parse ar_size field as a number\", ex);\r\n    }\r\n    if (temp.endsWith(\"/\")) {\r\n        // GNU terminator\r\n        temp \u003d temp.substring(0, temp.length() - 1);\r\n    } else if (isGNULongName(temp)) {\r\n        // get the offset\r\n        final int off \u003d ParsingUtils.parseIntValue(temp.substring(1));\r\n        // convert to the long name\r\n        temp \u003d getExtendedName(off);\r\n    } else if (isBSDLongName(temp)) {\r\n        temp \u003d getBSDLongName(temp);\r\n        // entry length contained the length of the file name in\r\n        // addition to the real length of the entry.\r\n        // assume file name was ASCII, there is no \"standard\" otherwise\r\n        final int nameLen \u003d temp.length();\r\n        len -\u003d nameLen;\r\n        entryOffset +\u003d nameLen;\r\n    }\r\n    if (len \u003c 0) {\r\n        throw new IOException(\"broken archive, entry with negative size\");\r\n    }\r\n    try {\r\n        currentEntry \u003d new ArArchiveEntry(temp, len, asInt(metaData, USER_ID_OFFSET, USER_ID_LEN, true), asInt(metaData, GROUP_ID_OFFSET, GROUP_ID_LEN, true), asInt(metaData, FILE_MODE_OFFSET, FILE_MODE_LEN, 8), asLong(metaData, LAST_MODIFIED_OFFSET, LAST_MODIFIED_LEN));\r\n        return currentEntry;\r\n    } catch (final NumberFormatException ex) {\r\n        throw new IOException(\"Broken archive, unable to parse entry metadata fields as numbers\", ex);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (currentEntry \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current ar entry\");\r\n    }\r\n    final long entryEnd \u003d entryOffset + currentEntry.getLength();\r\n    if (len \u003c 0 || offset \u003e\u003d entryEnd) {\r\n        return -1;\r\n    }\r\n    final int toRead \u003d (int) Math.min(len, entryEnd - offset);\r\n    final int ret \u003d this.in.read(b, off, toRead);\r\n    trackReadBytes(ret);\r\n    return ret;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B4 : If(i0 \u003c 0) → B5 | else → B6",
      "B5 : If($i14 \u003c 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ArArchiveInputStream\n  r3 :\u003d @parameter0: byte[]\n  i11 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d ArArchiveEntry currentEntry\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d IllegalStateException\n  new IllegalStateException(\"No current ar entry\")\n  throw $r6\n}",
      "B4 {\n  $l1 \u003d ArArchiveInputStream: long entryOffset\u003e\n  $r2 \u003d ArArchiveEntry currentEntry\u003e\n  $l2 \u003d $r2.getLength()\n  l3 \u003d $l1 + $l2\n  if (i0 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  $l4 \u003d ArArchiveInputStream: long offset\u003e\n  $b5 \u003d $l4 cmp l3\n  $i14 \u003d (int) $b5\n  if ($i14 \u003c 0) goto B6 else B7\n}",
      "B6 {\n  $i16 \u003d (int) -1\n  return\n}",
      "B7 {\n  $l8 \u003d (long) i0\n  $l6 \u003d ArArchiveInputStream: long offset\u003e\n  $l7 \u003d l3 - $l6\n  $l9 \u003d Math.min($l8, $l7)\n  i10 \u003d (int) $l9\n  $r4 \u003d InputStream in\u003e\n  i12 \u003d $r4.read(r3, i11, i10)\n  $l13 \u003d (long) i12\n  r0.trackReadBytes($l13)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveInputStream#trackReadBytes(...1)",
        "body": "{\r\n    count(read);\r\n    if (read \u003e 0) {\r\n        offset +\u003d read;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (!isFinished()) {\r\n            finish();\r\n        }\r\n    } finally {\r\n        prevEntry \u003d null;\r\n        super.close();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArArchiveOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.finish()\n}",
      "B2 {\n  ArArchiveEntry prevEntry\u003e \u003d null\n  r0.close()\n  goto B4\n}",
      "B3 {\n  $r1 :\u003d @caughtexception\n  ArArchiveEntry prevEntry\u003e \u003d null\n  r0.close()\n  throw $r1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveOutputStream#finish(...0)",
        "body": "{\r\n    if (prevEntryOpen) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    checkFinished();\r\n    super.finish();\r\n}"
      },
      {
        "name": "ArArchiveOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream",
    "methodName": "closeArchiveEntry",
    "signature": "void closeArchiveEntry()",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    if (prevEntry \u003d\u003d null || !prevEntryOpen) {\r\n        throw new IOException(\"No current entry to close\");\r\n    }\r\n    if ((headerPlus + entryOffset) % 2 !\u003d 0) {\r\n        // Pad byte\r\n        out.write(PAD);\r\n    }\r\n    prevEntryOpen \u003d false;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3",
      "B3 : If($b5 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ArArchiveOutputStream\n  r0.checkFinished()\n  $r1 \u003d ArArchiveEntry prevEntry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d ArArchiveOutputStream: boolean prevEntryOpen\u003e\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d IOException\n  new IOException(\"No current entry to close\")\n  throw $r2\n}",
      "B3 {\n  $i0 \u003d ArArchiveOutputStream: int headerPlus\u003e\n  $l2 \u003d (long) $i0\n  $l1 \u003d ArArchiveOutputStream: long entryOffset\u003e\n  $l3 \u003d $l2 + $l1\n  $l4 \u003d $l3 % 2L\n  $b5 \u003d $l4 cmp 0L\n  if ($b5 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d OutputStream out\u003e\n  $r3.write(10)\n}",
      "B5 {\n  ArArchiveOutputStream: boolean prevEntryOpen\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (prevEntryOpen) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    checkFinished();\r\n    super.finish();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArArchiveOutputStream\n  $z0 \u003d ArArchiveOutputStream: boolean prevEntryOpen\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IOException\n  new IOException(\"This archive contains unclosed entries.\")\n  throw $r1\n}",
      "B2 {\n  r0.checkFinished()\n  r0.finish()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ar.ArArchiveOutputStream",
    "methodName": "putArchiveEntry",
    "signature": "void putArchiveEntry(org.apache.commons.compress.archivers.ar.ArArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    if (prevEntry \u003d\u003d null) {\r\n        writeArchiveHeader();\r\n    } else {\r\n        if (prevEntry.getLength() !\u003d entryOffset) {\r\n            throw new IOException(\"Length does not match entry (\" + prevEntry.getLength() + \" !\u003d \" + entryOffset);\r\n        }\r\n        if (prevEntryOpen) {\r\n            closeArchiveEntry();\r\n        }\r\n    }\r\n    prevEntry \u003d entry;\r\n    headerPlus \u003d writeEntryHeader(entry);\r\n    entryOffset \u003d 0;\r\n    prevEntryOpen \u003d true;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($b2 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ArArchiveOutputStream\n  ArArchiveEntry\n  r0.checkFinished()\n  $r1 \u003d ArArchiveEntry prevEntry\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.writeArchiveHeader()\n  goto B6\n}",
      "B2 {\n  $r2 \u003d ArArchiveEntry prevEntry\u003e\n  $l1 \u003d $r2.getLength()\n  $l0 \u003d ArArchiveOutputStream: long entryOffset\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IOException\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r5.append(\"Length does not match entry (\")\n  $r6 \u003d ArArchiveEntry prevEntry\u003e\n  $l3 \u003d $r6.getLength()\n  $r8 \u003d $r7.append($l3)\n  $r9 \u003d $r8.append(\" !\u003d \")\n  $l4 \u003d ArArchiveOutputStream: long entryOffset\u003e\n  $r10 \u003d $r9.append($l4)\n  $r11 \u003d $r10.toString()\n  new IOException($r11)\n  throw $r4\n}",
      "B4 {\n  $z0 \u003d ArArchiveOutputStream: boolean prevEntryOpen\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r0.closeArchiveEntry()\n}",
      "B6 {\n  ArArchiveEntry prevEntry\u003e \u003d r3\n  $i5 \u003d r0.writeEntryHeader(r3)\n  ArArchiveOutputStream: int headerPlus\u003e \u003d $i5\n  ArArchiveOutputStream: long entryOffset\u003e \u003d 0L\n  ArArchiveOutputStream: boolean prevEntryOpen\u003e \u003d 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArArchiveOutputStream#writeArchiveHeader(...0)",
        "body": "{\r\n    return writeUsAscii(ArArchiveEntry.HEADER);\r\n}"
      },
      {
        "name": "ArArchiveOutputStream#closeArchiveEntry(...0)",
        "body": "{\r\n    checkFinished();\r\n    if (prevEntry \u003d\u003d null || !prevEntryOpen) {\r\n        throw new IOException(\"No current entry to close\");\r\n    }\r\n    if ((headerPlus + entryOffset) % 2 !\u003d 0) {\r\n        // Pad byte\r\n        out.write(PAD);\r\n    }\r\n    prevEntryOpen \u003d false;\r\n}"
      },
      {
        "name": "ArArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ArArchiveOutputStream#writeEntryHeader(...1)",
        "body": "{\r\n    int offset \u003d 0;\r\n    boolean appendName \u003d false;\r\n    final String eName \u003d entry.getName();\r\n    final int nLength \u003d eName.length();\r\n    if (LONGFILE_ERROR \u003d\u003d longFileMode \u0026\u0026 nLength \u003e 16) {\r\n        throw new IOException(\"File name too long, \u003e 16 chars: \" + eName);\r\n    }\r\n    if (LONGFILE_BSD \u003d\u003d longFileMode \u0026\u0026 (nLength \u003e 16 || eName.indexOf(SPACE) \u003e -1)) {\r\n        appendName \u003d true;\r\n        final String fileNameLen \u003d ArArchiveInputStream.BSD_LONGNAME_PREFIX + nLength;\r\n        if (fileNameLen.length() \u003e 16) {\r\n            throw new IOException(\"File length too long, \u003e 16 chars: \" + eName);\r\n        }\r\n        offset +\u003d write(fileNameLen);\r\n    } else {\r\n        offset +\u003d write(eName);\r\n    }\r\n    offset \u003d pad(offset, 16, SPACE);\r\n    // Last modified\r\n    offset +\u003d write(checkLength(String.valueOf(entry.getLastModified()), 12, \"Last modified\"));\r\n    offset \u003d pad(offset, 28, SPACE);\r\n    // User ID\r\n    offset +\u003d write(checkLength(String.valueOf(entry.getUserId()), 6, \"User ID\"));\r\n    offset \u003d pad(offset, 34, SPACE);\r\n    // Group ID\r\n    offset +\u003d write(checkLength(String.valueOf(entry.getGroupId()), 6, \"Group ID\"));\r\n    offset \u003d pad(offset, 40, SPACE);\r\n    // Mode\r\n    offset +\u003d write(checkLength(String.valueOf(Integer.toString(entry.getMode(), 8)), 8, \"File mode\"));\r\n    offset \u003d pad(offset, 48, SPACE);\r\n    // Size\r\n    // On overflow, the file size is incremented by the length of the name.\r\n    offset +\u003d write(checkLength(String.valueOf(entry.getLength() + (appendName ? nLength : 0)), 10, \"Size\"));\r\n    offset \u003d pad(offset, 58, SPACE);\r\n    offset +\u003d write(ArArchiveEntry.TRAILER);\r\n    // Name\r\n    if (appendName) {\r\n        offset +\u003d write(eName);\r\n    }\r\n    return offset;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ArchiveStreamFactory",
    "methodName": "detect",
    "signature": "java.lang.String detect(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    if (in \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature \u003d new byte[SIGNATURE_SIZE];\r\n    in.mark(signature.length);\r\n    int signatureLength \u003d -1;\r\n    try {\r\n        signatureLength \u003d IOUtils.readFully(in, signature);\r\n        in.reset();\r\n    } catch (final IOException e) {\r\n        throw new ArchiveException(\"Failure reading signature.\", (Throwable) e);\r\n    }\r\n    // For now JAR files are detected as ZIP files.\r\n    if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n        return ZIP;\r\n    }\r\n    // For now JAR files are detected as ZIP files.\r\n    if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n        return JAR;\r\n    }\r\n    if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n        return AR;\r\n    }\r\n    if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n        return CPIO;\r\n    }\r\n    if (ArjArchiveInputStream.matches(signature, signatureLength)) {\r\n        return ARJ;\r\n    }\r\n    if (SevenZFile.matches(signature, signatureLength)) {\r\n        return SEVEN_Z;\r\n    }\r\n    // Dump needs a bigger buffer to check the signature;\r\n    final byte[] dumpsig \u003d new byte[DUMP_SIGNATURE_SIZE];\r\n    in.mark(dumpsig.length);\r\n    try {\r\n        signatureLength \u003d IOUtils.readFully(in, dumpsig);\r\n        in.reset();\r\n    } catch (final IOException e) {\r\n        throw new ArchiveException(\"IOException while reading dump signature\", (Throwable) e);\r\n    }\r\n    if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n        return DUMP;\r\n    }\r\n    // Tar needs an even bigger buffer to check the signature; read the first block\r\n    final byte[] tarHeader \u003d new byte[TAR_HEADER_SIZE];\r\n    in.mark(tarHeader.length);\r\n    try {\r\n        signatureLength \u003d IOUtils.readFully(in, tarHeader);\r\n        in.reset();\r\n    } catch (final IOException e) {\r\n        throw new ArchiveException(\"IOException while reading tar signature\", (Throwable) e);\r\n    }\r\n    if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\r\n        return TAR;\r\n    }\r\n    // COMPRESS-117\r\n    if (signatureLength \u003e\u003d TAR_HEADER_SIZE) {\r\n        try (TarArchiveInputStream inputStream \u003d new TarArchiveInputStream(new ByteArrayInputStream(tarHeader))) {\r\n            // COMPRESS-191 - verify the header checksum\r\n            TarArchiveEntry entry \u003d inputStream.getNextEntry();\r\n            // try to find the first non-directory entry within the first 10 entries.\r\n            int count \u003d 0;\r\n            while (entry !\u003d null \u0026\u0026 entry.isDirectory() \u0026\u0026 entry.isCheckSumOK() \u0026\u0026 count++ \u003c TAR_TEST_ENTRY_COUNT) {\r\n                entry \u003d inputStream.getNextEntry();\r\n            }\r\n            if (entry !\u003d null \u0026\u0026 entry.isCheckSumOK() \u0026\u0026 !entry.isDirectory() \u0026\u0026 isName(entry.getGroupName()) \u0026\u0026 isName(entry.getName()) \u0026\u0026 isName(entry.getUserName()) || count \u003e 0) {\r\n                return TAR;\r\n            }\r\n        } catch (final Exception ignored) {\r\n            // can generate IllegalArgumentException as well as IOException auto-detection, simply not a TAR ignored\r\n        }\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}",
    "nodes": 48,
    "edges": 54,
    "cc": 8,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($z4 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($z5 \u003d\u003d false) → B15 | else → B16",
      "B16 : If($z6 \u003d\u003d false) → B17 | else → B18",
      "B20 : If($z7 \u003d\u003d false) → B21 | else → B22",
      "B24 : If($z8 \u003d\u003d false) → B25 | else → B26",
      "B26 : If(i6 \u003c 512) → B27 | else → B47",
      "B28 : If(r20 \u003d\u003d null) → B29 | else → B33",
      "B29 : If($z14 \u003d\u003d false) → B30 | else → B33",
      "B30 : If($z15 \u003d\u003d false) → B31 | else → B33",
      "B31 : If($i3 \u003e\u003d 10) → B32 | else → B33",
      "B33 : If(r20 \u003d\u003d null) → B34 | else → B39",
      "B34 : If($z9 \u003d\u003d false) → B35 | else → B39",
      "B35 : If($z10 !\u003d 0) → B36 | else → B39",
      "B36 : If($z11 \u003d\u003d false) → B37 | else → B39",
      "B37 : If($z12 \u003d\u003d false) → B38 | else → B39",
      "B38 : If($z13 !\u003d 0) → B39 | else → B40",
      "B39 : If(i7 \u003c\u003d 0) → B40 | else → B41"
    ],
    "blockList": [
      "B0 {\n  InputStream\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Stream must not be null.\")\n  throw $r8\n}",
      "B2 {\n  $z0 \u003d r0.markSupported()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Mark is not supported.\")\n  throw $r7\n}",
      "B4 {\n  r1 \u003d newarray (byte)[12]\n  $i0 \u003d lengthof r1\n  r0.mark($i0)\n  i4 \u003d IOUtils.readFully(r0, r1)\n  r0.reset()\n  goto B6\n}",
      "B5 {\n  $r16 :\u003d @caughtexception\n  $r17 \u003d ArchiveException\n  new ArchiveException(\"Failure reading signature.\", $r16)\n  throw $r17\n}",
      "B6 {\n  $z1 \u003d ZipArchiveInputStream.matches(r1, i4)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z2 \u003d JarArchiveInputStream.matches(r1, i4)\n  if ($z2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $z3 \u003d ArArchiveInputStream.matches(r1, i4)\n  if ($z3 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  $z4 \u003d CpioArchiveInputStream.matches(r1, i4)\n  if ($z4 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $z5 \u003d ArjArchiveInputStream.matches(r1, i4)\n  if ($z5 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $z6 \u003d SevenZFile.matches(r1, i4)\n  if ($z6 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  return\n}",
      "B18 {\n  r18 \u003d newarray (byte)[32]\n  $i1 \u003d lengthof r18\n  r0.mark($i1)\n  i5 \u003d IOUtils.readFully(r0, r18)\n  r0.reset()\n  goto B20\n}",
      "B19 {\n  $r14 :\u003d @caughtexception\n  $r15 \u003d ArchiveException\n  new ArchiveException(\"IOException while reading dump signature\", $r14)\n  throw $r15\n}",
      "B20 {\n  $z7 \u003d DumpArchiveInputStream.matches(r18, i5)\n  if ($z7 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  return\n}",
      "B22 {\n  r19 \u003d newarray (byte)[512]\n  $i2 \u003d lengthof r19\n  r0.mark($i2)\n  i6 \u003d IOUtils.readFully(r0, r19)\n  r0.reset()\n  goto B24\n}",
      "B23 {\n  $r12 :\u003d @caughtexception\n  $r13 \u003d ArchiveException\n  new ArchiveException(\"IOException while reading tar signature\", $r12)\n  throw $r13\n}",
      "B24 {\n  $z8 \u003d TarArchiveInputStream.matches(r19, i6)\n  if ($z8 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  return\n}",
      "B26 {\n  if (i6 \u003c 512) goto B27 else B47\n}",
      "B27 {\n  $r2 \u003d TarArchiveInputStream\n  $r3 \u003d ByteArrayInputStream\n  new ByteArrayInputStream(r19)\n  new TarArchiveInputStream($r3)\n  r20 \u003d $r2.getNextEntry()\n  i7 \u003d 0\n}",
      "B28 {\n  if (r20 \u003d\u003d null) goto B29 else B33\n}",
      "B29 {\n  $z14 \u003d r20.isDirectory()\n  if ($z14 \u003d\u003d false) goto B30 else B33\n}",
      "B30 {\n  $z15 \u003d r20.isCheckSumOK()\n  if ($z15 \u003d\u003d false) goto B31 else B33\n}",
      "B31 {\n  $i3 \u003d i7\n  i7 \u003d i7 + 1\n  if ($i3 \u003e\u003d 10) goto B32 else B33\n}",
      "B32 {\n  r20 \u003d $r2.getNextEntry()\n  goto B28\n}",
      "B33 {\n  if (r20 \u003d\u003d null) goto B34 else B39\n}",
      "B34 {\n  $z9 \u003d r20.isCheckSumOK()\n  if ($z9 \u003d\u003d false) goto B35 else B39\n}",
      "B35 {\n  $z10 \u003d r20.isDirectory()\n  if ($z10 !\u003d 0) goto B36 else B39\n}",
      "B36 {\n  $r4 \u003d r20.getGroupName()\n  $z11 \u003d ArchiveStreamFactory.isName($r4)\n  if ($z11 \u003d\u003d false) goto B37 else B39\n}",
      "B37 {\n  $r5 \u003d r20.getName()\n  $z12 \u003d ArchiveStreamFactory.isName($r5)\n  if ($z12 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r6 \u003d r20.getUserName()\n  $z13 \u003d ArchiveStreamFactory.isName($r6)\n  if ($z13 !\u003d 0) goto B39 else B40\n}",
      "B39 {\n  if (i7 \u003c\u003d 0) goto B40 else B41\n}",
      "B40 {\n  $r2.close()\n  return\n}",
      "B41 {\n  $r2.close()\n  goto B45\n}",
      "B42 {\n  $r11 :\u003d @caughtexception\n  $r2.close()\n  goto B44\n}",
      "B43 {\n  $r10 :\u003d @caughtexception\n  $r11.addSuppressed($r10)\n}",
      "B44 {\n  throw $r11\n}",
      "B45 {\n  goto B47\n}",
      "B46 {\n  $r9 :\u003d @caughtexception\n}",
      "B47 {\n  $r21 \u003d ArchiveException\n  new ArchiveException(\"No Archiver found for the stream signature\")\n  throw $r21\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B24",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B27",
      "B26 --\u003e B47",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B33",
      "B29 --\u003e B30",
      "B29 --\u003e B33",
      "B30 --\u003e B31",
      "B30 --\u003e B33",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B28",
      "B33 --\u003e B34",
      "B33 --\u003e B39",
      "B34 --\u003e B35",
      "B34 --\u003e B39",
      "B35 --\u003e B36",
      "B35 --\u003e B39",
      "B36 --\u003e B37",
      "B36 --\u003e B39",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e [EXIT]",
      "B41 --\u003e B45",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e [EXIT]",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArchiveStreamFactory#isName(...1)",
        "body": "{\r\n    // Expect ASCII https://www.mkssoftware.com/docs/man4/tar.4.asp\r\n    return value.isEmpty() || value.chars().allMatch(ch -\u003e ch \u003e 31 \u0026\u0026 ch \u003c 128);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ArchiveStreamFactory",
    "methodName": "createArchiveInputStream",
    "signature": "org.apache.commons.compress.archivers.ArchiveInputStream createArchiveInputStream(java.lang.String,java.io.InputStream,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (archiverName \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Archiver name must not be null.\");\r\n    }\r\n    if (in \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"InputStream must not be null.\");\r\n    }\r\n    if (AR.equalsIgnoreCase(archiverName)) {\r\n        return (I) new ArArchiveInputStream(in);\r\n    }\r\n    if (ARJ.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new ArjArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new ArjArchiveInputStream(in);\r\n    }\r\n    if (ZIP.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new ZipArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new ZipArchiveInputStream(in);\r\n    }\r\n    if (TAR.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new TarArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new TarArchiveInputStream(in);\r\n    }\r\n    if (JAR.equalsIgnoreCase(archiverName) || APK.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new JarArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new JarArchiveInputStream(in);\r\n    }\r\n    if (CPIO.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new CpioArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new CpioArchiveInputStream(in);\r\n    }\r\n    if (DUMP.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (I) new DumpArchiveInputStream(in, actualEncoding);\r\n        }\r\n        return (I) new DumpArchiveInputStream(in);\r\n    }\r\n    if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\r\n        throw new StreamingNotSupportedException(SEVEN_Z);\r\n    }\r\n    final ArchiveStreamProvider archiveStreamProvider \u003d getArchiveInputStreamProviders().get(toKey(archiverName));\r\n    if (archiveStreamProvider !\u003d null) {\r\n        return archiveStreamProvider.createArchiveInputStream(archiverName, in, actualEncoding);\r\n    }\r\n    throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\r\n}",
    "nodes": 36,
    "edges": 36,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B10",
      "B7 : If(r7 \u003d\u003d null) → B8 | else → B9",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B14",
      "B11 : If(r7 \u003d\u003d null) → B12 | else → B13",
      "B14 : If($z3 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(r7 \u003d\u003d null) → B16 | else → B17",
      "B18 : If($z4 !\u003d 0) → B19 | else → B20",
      "B19 : If($z5 \u003d\u003d false) → B20 | else → B23",
      "B20 : If(r7 \u003d\u003d null) → B21 | else → B22",
      "B23 : If($z6 \u003d\u003d false) → B24 | else → B27",
      "B24 : If(r7 \u003d\u003d null) → B25 | else → B26",
      "B27 : If($z7 \u003d\u003d false) → B28 | else → B31",
      "B28 : If(r7 \u003d\u003d null) → B29 | else → B30",
      "B31 : If($z8 \u003d\u003d false) → B32 | else → B33",
      "B33 : If(r18 \u003d\u003d null) → B34 | else → B35"
    ],
    "blockList": [
      "B0 {\n  ArchiveStreamFactory\n  String\n  InputStream\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r39 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Archiver name must not be null.\")\n  throw $r39\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r38 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"InputStream must not be null.\")\n  throw $r38\n}",
      "B4 {\n  $r2 \u003d \"ar\"\n  $z0 \u003d $r2.equalsIgnoreCase(r0)\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r37 \u003d ArArchiveInputStream\n  new ArArchiveInputStream(r1)\n  return\n}",
      "B6 {\n  $r3 \u003d \"arj\"\n  $z1 \u003d $r3.equalsIgnoreCase(r0)\n  if ($z1 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  if (r7 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r36 \u003d ArjArchiveInputStream\n  new ArjArchiveInputStream(r1, r7)\n  return\n}",
      "B9 {\n  $r35 \u003d ArjArchiveInputStream\n  new ArjArchiveInputStream(r1)\n  return\n}",
      "B10 {\n  $r4 \u003d \"zip\"\n  $z2 \u003d $r4.equalsIgnoreCase(r0)\n  if ($z2 \u003d\u003d false) goto B11 else B14\n}",
      "B11 {\n  if (r7 \u003d\u003d null) goto B12 else B13\n}",
      "B12 {\n  $r34 \u003d ZipArchiveInputStream\n  new ZipArchiveInputStream(r1, r7)\n  return\n}",
      "B13 {\n  $r33 \u003d ZipArchiveInputStream\n  new ZipArchiveInputStream(r1)\n  return\n}",
      "B14 {\n  $r5 \u003d \"tar\"\n  $z3 \u003d $r5.equalsIgnoreCase(r0)\n  if ($z3 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  if (r7 \u003d\u003d null) goto B16 else B17\n}",
      "B16 {\n  $r32 \u003d TarArchiveInputStream\n  new TarArchiveInputStream(r1, r7)\n  return\n}",
      "B17 {\n  $r31 \u003d TarArchiveInputStream\n  new TarArchiveInputStream(r1)\n  return\n}",
      "B18 {\n  $r6 \u003d \"jar\"\n  $z4 \u003d $r6.equalsIgnoreCase(r0)\n  if ($z4 !\u003d 0) goto B19 else B20\n}",
      "B19 {\n  $r10 \u003d \"apk\"\n  $z5 \u003d $r10.equalsIgnoreCase(r0)\n  if ($z5 \u003d\u003d false) goto B20 else B23\n}",
      "B20 {\n  if (r7 \u003d\u003d null) goto B21 else B22\n}",
      "B21 {\n  $r9 \u003d JarArchiveInputStream\n  new JarArchiveInputStream(r1, r7)\n  return\n}",
      "B22 {\n  $r8 \u003d JarArchiveInputStream\n  new JarArchiveInputStream(r1)\n  return\n}",
      "B23 {\n  $r11 \u003d \"cpio\"\n  $z6 \u003d $r11.equalsIgnoreCase(r0)\n  if ($z6 \u003d\u003d false) goto B24 else B27\n}",
      "B24 {\n  if (r7 \u003d\u003d null) goto B25 else B26\n}",
      "B25 {\n  $r30 \u003d CpioArchiveInputStream\n  new CpioArchiveInputStream(r1, r7)\n  return\n}",
      "B26 {\n  $r29 \u003d CpioArchiveInputStream\n  new CpioArchiveInputStream(r1)\n  return\n}",
      "B27 {\n  $r12 \u003d \"dump\"\n  $z7 \u003d $r12.equalsIgnoreCase(r0)\n  if ($z7 \u003d\u003d false) goto B28 else B31\n}",
      "B28 {\n  if (r7 \u003d\u003d null) goto B29 else B30\n}",
      "B29 {\n  $r28 \u003d DumpArchiveInputStream\n  new DumpArchiveInputStream(r1, r7)\n  return\n}",
      "B30 {\n  $r27 \u003d DumpArchiveInputStream\n  new DumpArchiveInputStream(r1)\n  return\n}",
      "B31 {\n  $r13 \u003d \"7z\"\n  $z8 \u003d $r13.equalsIgnoreCase(r0)\n  if ($z8 \u003d\u003d false) goto B32 else B33\n}",
      "B32 {\n  $r26 \u003d StreamingNotSupportedException\n  new StreamingNotSupportedException(\"7z\")\n  throw $r26\n}",
      "B33 {\n  $r16 \u003d r14.getArchiveInputStreamProviders()\n  $r15 \u003d ArchiveStreamFactory.toKey(r0)\n  $r17 \u003d $r16.get($r15)\n  r18 \u003d ArchiveStreamProvider) $r17\n  if (r18 \u003d\u003d null) goto B34 else B35\n}",
      "B34 {\n  $r25 \u003d r18.createArchiveInputStream(r0, r1, r7)\n  return\n}",
      "B35 {\n  $r19 \u003d ArchiveException\n  $r20 \u003d StringBuilder\n  new StringBuilder()\n  $r21 \u003d $r20.append(\"Archiver: \")\n  $r22 \u003d $r21.append(r0)\n  $r23 \u003d $r22.append(\" not found.\")\n  $r24 \u003d $r23.toString()\n  new ArchiveException($r24)\n  throw $r19\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B19 --\u003e B23",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B27",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B28",
      "B27 --\u003e B31",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e [EXIT]",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e [EXIT]",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArchiveStreamFactory#getArchiveInputStreamProviders(...0)",
        "body": "{\r\n    if (archiveInputStreamProviders \u003d\u003d null) {\r\n        archiveInputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableArchiveInputStreamProviders());\r\n    }\r\n    return archiveInputStreamProviders;\r\n}"
      },
      {
        "name": "ArchiveStreamFactory#toKey(...1)",
        "body": "{\r\n    return name.toUpperCase(Locale.ROOT);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ArchiveStreamFactory",
    "methodName": "createArchiveOutputStream",
    "signature": "org.apache.commons.compress.archivers.ArchiveOutputStream createArchiveOutputStream(java.lang.String,java.io.OutputStream,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (archiverName \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Archiver name must not be null.\");\r\n    }\r\n    if (out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"OutputStream must not be null.\");\r\n    }\r\n    if (AR.equalsIgnoreCase(archiverName)) {\r\n        return (O) new ArArchiveOutputStream(out);\r\n    }\r\n    if (ZIP.equalsIgnoreCase(archiverName)) {\r\n        final ZipArchiveOutputStream zip \u003d new ZipArchiveOutputStream(out);\r\n        if (actualEncoding !\u003d null) {\r\n            zip.setEncoding(actualEncoding);\r\n        }\r\n        return (O) zip;\r\n    }\r\n    if (TAR.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (O) new TarArchiveOutputStream(out, actualEncoding);\r\n        }\r\n        return (O) new TarArchiveOutputStream(out);\r\n    }\r\n    if (JAR.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (O) new JarArchiveOutputStream(out, actualEncoding);\r\n        }\r\n        return (O) new JarArchiveOutputStream(out);\r\n    }\r\n    if (CPIO.equalsIgnoreCase(archiverName)) {\r\n        if (actualEncoding !\u003d null) {\r\n            return (O) new CpioArchiveOutputStream(out, actualEncoding);\r\n        }\r\n        return (O) new CpioArchiveOutputStream(out);\r\n    }\r\n    if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\r\n        throw new StreamingNotSupportedException(SEVEN_Z);\r\n    }\r\n    final ArchiveStreamProvider archiveStreamProvider \u003d getArchiveOutputStreamProviders().get(toKey(archiverName));\r\n    if (archiveStreamProvider !\u003d null) {\r\n        return archiveStreamProvider.createArchiveOutputStream(archiverName, out, actualEncoding);\r\n    }\r\n    throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\r\n}",
    "nodes": 27,
    "edges": 27,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B10",
      "B7 : If(r18 \u003d\u003d null) → B8 | else → B9",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B14",
      "B11 : If(r18 \u003d\u003d null) → B12 | else → B13",
      "B14 : If($z3 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(r18 \u003d\u003d null) → B16 | else → B17",
      "B18 : If($z4 \u003d\u003d false) → B19 | else → B22",
      "B19 : If(r18 \u003d\u003d null) → B20 | else → B21",
      "B22 : If($z5 \u003d\u003d false) → B23 | else → B24",
      "B24 : If(r31 \u003d\u003d null) → B25 | else → B26"
    ],
    "blockList": [
      "B0 {\n  ArchiveStreamFactory\n  String\n  OutputStream\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r30 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Archiver name must not be null.\")\n  throw $r30\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r29 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"OutputStream must not be null.\")\n  throw $r29\n}",
      "B4 {\n  $r2 \u003d \"ar\"\n  $z0 \u003d $r2.equalsIgnoreCase(r0)\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r28 \u003d ArArchiveOutputStream\n  new ArArchiveOutputStream(r1)\n  return\n}",
      "B6 {\n  $r3 \u003d \"zip\"\n  $z1 \u003d $r3.equalsIgnoreCase(r0)\n  if ($z1 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  $r27 \u003d ZipArchiveOutputStream\n  new ZipArchiveOutputStream(r1)\n  if (r18 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r27.setEncoding(r18)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r4 \u003d \"tar\"\n  $z2 \u003d $r4.equalsIgnoreCase(r0)\n  if ($z2 \u003d\u003d false) goto B11 else B14\n}",
      "B11 {\n  if (r18 \u003d\u003d null) goto B12 else B13\n}",
      "B12 {\n  $r26 \u003d TarArchiveOutputStream\n  new TarArchiveOutputStream(r1, r18)\n  return\n}",
      "B13 {\n  $r25 \u003d TarArchiveOutputStream\n  new TarArchiveOutputStream(r1)\n  return\n}",
      "B14 {\n  $r5 \u003d \"jar\"\n  $z3 \u003d $r5.equalsIgnoreCase(r0)\n  if ($z3 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  if (r18 \u003d\u003d null) goto B16 else B17\n}",
      "B16 {\n  $r24 \u003d JarArchiveOutputStream\n  new JarArchiveOutputStream(r1, r18)\n  return\n}",
      "B17 {\n  $r23 \u003d JarArchiveOutputStream\n  new JarArchiveOutputStream(r1)\n  return\n}",
      "B18 {\n  $r6 \u003d \"cpio\"\n  $z4 \u003d $r6.equalsIgnoreCase(r0)\n  if ($z4 \u003d\u003d false) goto B19 else B22\n}",
      "B19 {\n  if (r18 \u003d\u003d null) goto B20 else B21\n}",
      "B20 {\n  $r22 \u003d CpioArchiveOutputStream\n  new CpioArchiveOutputStream(r1, r18)\n  return\n}",
      "B21 {\n  $r21 \u003d CpioArchiveOutputStream\n  new CpioArchiveOutputStream(r1)\n  return\n}",
      "B22 {\n  $r7 \u003d \"7z\"\n  $z5 \u003d $r7.equalsIgnoreCase(r0)\n  if ($z5 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r20 \u003d StreamingNotSupportedException\n  new StreamingNotSupportedException(\"7z\")\n  throw $r20\n}",
      "B24 {\n  $r10 \u003d r8.getArchiveOutputStreamProviders()\n  $r9 \u003d ArchiveStreamFactory.toKey(r0)\n  $r11 \u003d $r10.get($r9)\n  r31 \u003d ArchiveStreamProvider) $r11\n  if (r31 \u003d\u003d null) goto B25 else B26\n}",
      "B25 {\n  $r19 \u003d r31.createArchiveOutputStream(r0, r1, r18)\n  return\n}",
      "B26 {\n  $r12 \u003d ArchiveException\n  $r13 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r13.append(\"Archiver: \")\n  $r15 \u003d $r14.append(r0)\n  $r16 \u003d $r15.append(\" not found.\")\n  $r17 \u003d $r16.toString()\n  new ArchiveException($r17)\n  throw $r12\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArchiveStreamFactory#getArchiveOutputStreamProviders(...0)",
        "body": "{\r\n    if (archiveOutputStreamProviders \u003d\u003d null) {\r\n        archiveOutputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableArchiveOutputStreamProviders());\r\n    }\r\n    return archiveOutputStreamProviders;\r\n}"
      },
      {
        "name": "ArchiveStreamFactory#toKey(...1)",
        "body": "{\r\n    return name.toUpperCase(Locale.ROOT);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ArchiveStreamFactory",
    "methodName": "getArchiveInputStreamProviders",
    "signature": "java.util.SortedMap getArchiveInputStreamProviders()",
    "visibility": "public",
    "body": "{\r\n    if (archiveInputStreamProviders \u003d\u003d null) {\r\n        archiveInputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableArchiveInputStreamProviders());\r\n    }\r\n    return archiveInputStreamProviders;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArchiveStreamFactory\n  $r1 \u003d SortedMap archiveInputStreamProviders\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ArchiveStreamFactory.findAvailableArchiveInputStreamProviders()\n  $r4 \u003d Collections.unmodifiableSortedMap($r3)\n  SortedMap archiveInputStreamProviders\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d SortedMap archiveInputStreamProviders\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArchiveStreamFactory#findAvailableArchiveInputStreamProviders(...0)",
        "body": "{\r\n    return AccessController.doPrivileged((PrivilegedAction\u003cSortedMap\u003cString, ArchiveStreamProvider\u003e\u003e) () -\u003e {\r\n        final TreeMap\u003cString, ArchiveStreamProvider\u003e map \u003d new TreeMap\u003c\u003e();\r\n        putAll(DEFAULT.getInputStreamArchiveNames(), DEFAULT, map);\r\n        archiveStreamProviderIterable().forEach(provider -\u003e putAll(provider.getInputStreamArchiveNames(), provider, map));\r\n        return map;\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.ArchiveStreamFactory",
    "methodName": "getArchiveOutputStreamProviders",
    "signature": "java.util.SortedMap getArchiveOutputStreamProviders()",
    "visibility": "public",
    "body": "{\r\n    if (archiveOutputStreamProviders \u003d\u003d null) {\r\n        archiveOutputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableArchiveOutputStreamProviders());\r\n    }\r\n    return archiveOutputStreamProviders;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArchiveStreamFactory\n  $r1 \u003d SortedMap archiveOutputStreamProviders\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ArchiveStreamFactory.findAvailableArchiveOutputStreamProviders()\n  $r4 \u003d Collections.unmodifiableSortedMap($r3)\n  SortedMap archiveOutputStreamProviders\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d SortedMap archiveOutputStreamProviders\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArchiveStreamFactory#findAvailableArchiveOutputStreamProviders(...0)",
        "body": "{\r\n    return AccessController.doPrivileged((PrivilegedAction\u003cSortedMap\u003cString, ArchiveStreamProvider\u003e\u003e) () -\u003e {\r\n        final TreeMap\u003cString, ArchiveStreamProvider\u003e map \u003d new TreeMap\u003c\u003e();\r\n        putAll(DEFAULT.getOutputStreamArchiveNames(), DEFAULT, map);\r\n        archiveStreamProviderIterable().forEach(provider -\u003e putAll(provider.getOutputStreamArchiveNames(), provider, map));\r\n        return map;\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ArjArchiveEntry other \u003d (ArjArchiveEntry) obj;\r\n    return localFileHeader.equals(other.localFileHeader);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d ArjArchiveEntry) r1\n  $r6 \u003d LocalFileHeader localFileHeader\u003e\n  $r5 \u003d LocalFileHeader localFileHeader\u003e\n  $z0 \u003d $r6.equals($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "getLastModifiedDate",
    "signature": "java.util.Date getLastModifiedDate()",
    "visibility": "public",
    "body": "{\r\n    final long ts \u003d isHostOsUnix() ? localFileHeader.dateTimeModified * 1000L : ZipUtil.dosToJavaTime(0xFFFFFFFFL \u0026 localFileHeader.dateTimeModified);\r\n    return new Date(ts);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  $z0 \u003d r0.isHostOsUnix()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d LocalFileHeader localFileHeader\u003e\n  $i3 \u003d LocalFileHeader: int dateTimeModified\u003e\n  $l4 \u003d (long) $i3\n  $l5 \u003d $l4 * 1000L\n  goto B3\n}",
      "B2 {\n  $r1 \u003d LocalFileHeader localFileHeader\u003e\n  $i0 \u003d LocalFileHeader: int dateTimeModified\u003e\n  $l1 \u003d (long) $i0\n  $l2 \u003d 4294967295L \u0026 $l1\n  $l5 \u003d ZipUtil.dosToJavaTime($l2)\n}",
      "B3 {\n  $r2 \u003d Date\n  new Date($l5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveEntry#isHostOsUnix(...0)",
        "body": "{\r\n    return getHostOs() \u003d\u003d HostOs.UNIX || getHostOs() \u003d\u003d HostOs.NEXT;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "getName",
    "signature": "java.lang.String getName()",
    "visibility": "public",
    "body": "{\r\n    if ((localFileHeader.arjFlags \u0026 LocalFileHeader.Flags.PATHSYM) !\u003d 0) {\r\n        return localFileHeader.name.replace(\"/\", File.separator);\r\n    }\r\n    return localFileHeader.name;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  $r1 \u003d LocalFileHeader localFileHeader\u003e\n  $i0 \u003d LocalFileHeader: int arjFlags\u003e\n  $i1 \u003d $i0 \u0026 16\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d LocalFileHeader localFileHeader\u003e\n  $r6 \u003d String name\u003e\n  $r5 \u003d String separator\u003e\n  $r7 \u003d $r6.replace(\"/\", $r5)\n  return\n}",
      "B2 {\n  $r2 \u003d LocalFileHeader localFileHeader\u003e\n  $r3 \u003d String name\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "getUnixMode",
    "signature": "int getUnixMode()",
    "visibility": "public",
    "body": "{\r\n    return isHostOsUnix() ? getMode() : 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  $z0 \u003d r0.isHostOsUnix()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d r0.getMode()\n  goto B3\n}",
      "B2 {\n  $i0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveEntry#isHostOsUnix(...0)",
        "body": "{\r\n    return getHostOs() \u003d\u003d HostOs.UNIX || getHostOs() \u003d\u003d HostOs.NEXT;\r\n}"
      },
      {
        "name": "ArjArchiveEntry#getMode(...0)",
        "body": "{\r\n    return localFileHeader.fileAccessMode;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final String name \u003d getName();\r\n    return name \u003d\u003d null ? 0 : name.hashCode();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  r1 \u003d r0.getName()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $i0 \u003d r1.hashCode()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveEntry#getName(...0)",
        "body": "{\r\n    if ((localFileHeader.arjFlags \u0026 LocalFileHeader.Flags.PATHSYM) !\u003d 0) {\r\n        return localFileHeader.name.replace(\"/\", File.separator);\r\n    }\r\n    return localFileHeader.name;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "isDirectory",
    "signature": "boolean isDirectory()",
    "visibility": "public",
    "body": "{\r\n    return localFileHeader.fileType \u003d\u003d LocalFileHeader.FileTypes.DIRECTORY;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  $r1 \u003d LocalFileHeader localFileHeader\u003e\n  $i0 \u003d LocalFileHeader: int fileType\u003e\n  if ($i0 !\u003d 3) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry",
    "methodName": "isHostOsUnix",
    "signature": "boolean isHostOsUnix()",
    "visibility": "public",
    "body": "{\r\n    return getHostOs() \u003d\u003d HostOs.UNIX || getHostOs() \u003d\u003d HostOs.NEXT;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 2) → B1 | else → B2",
      "B1 : If($i1 !\u003d 8) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveEntry\n  $i0 \u003d r0.getHostOs()\n  if ($i0 \u003d\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d r0.getHostOs()\n  if ($i1 !\u003d 8) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveEntry#getHostOs(...0)",
        "body": "{\r\n    return localFileHeader.hostOS;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return length \u003e\u003d 2 \u0026\u0026 (0xff \u0026 signature[0]) \u003d\u003d ARJ_MAGIC_1 \u0026\u0026 (0xff \u0026 signature[1]) \u003d\u003d ARJ_MAGIC_2;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003c 2) → B1 | else → B4",
      "B1 : If($i6 !\u003d 96) → B2 | else → B4",
      "B2 : If($i8 !\u003d 234) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c 2) goto B1 else B4\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $s5 \u003d (short) $b1\n  $s2 \u003d 255 \u0026 $s5\n  $i6 \u003d (int) $s2\n  if ($i6 !\u003d 96) goto B2 else B4\n}",
      "B2 {\n  $b3 \u003d r0[1]\n  $s7 \u003d (short) $b3\n  $s4 \u003d 255 \u0026 $s7\n  $i8 \u003d (int) $s4\n  if ($i8 !\u003d 234) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream",
    "methodName": "canReadEntryData",
    "signature": "boolean canReadEntryData(org.apache.commons.compress.archivers.ArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    return ae instanceof ArjArchiveEntry \u0026\u0026 ((ArjArchiveEntry) ae).getMethod() \u003d\u003d LocalFileHeader.Methods.STORED;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveInputStream\n  ArchiveEntry\n  $z0 \u003d ArjArchiveEntry\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r1 \u003d ArjArchiveEntry) r0\n  $i0 \u003d $r1.getMethod()\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream",
    "methodName": "getNextEntry",
    "signature": "org.apache.commons.compress.archivers.arj.ArjArchiveEntry getNextEntry()",
    "visibility": "public",
    "body": "{\r\n    if (currentInputStream !\u003d null) {\r\n        // return value ignored as IOUtils.skip ensures the stream is drained completely\r\n        final InputStream input \u003d currentInputStream;\r\n        org.apache.commons.io.IOUtils.skip(input, Long.MAX_VALUE);\r\n        currentInputStream.close();\r\n        currentLocalFileHeader \u003d null;\r\n        currentInputStream \u003d null;\r\n    }\r\n    currentLocalFileHeader \u003d readLocalFileHeader();\r\n    if (currentLocalFileHeader !\u003d null) {\r\n        // @formatter:off\r\n        currentInputStream \u003d BoundedInputStream.builder().setInputStream(dis).setMaxCount(currentLocalFileHeader.compressedSize).setPropagateClose(false).get();\r\n        // @formatter:on\r\n        if (currentLocalFileHeader.method \u003d\u003d LocalFileHeader.Methods.STORED) {\r\n            // @formatter:off\r\n            currentInputStream \u003d ChecksumInputStream.builder().setChecksum(new CRC32()).setInputStream(currentInputStream).setCountThreshold(currentLocalFileHeader.originalSize).setExpectedChecksumValue(currentLocalFileHeader.originalCrc32).get();\r\n            // @formatter:on\r\n        }\r\n        return new ArjArchiveEntry(currentLocalFileHeader);\r\n    }\r\n    currentInputStream \u003d null;\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d null) → B3 | else → B6",
      "B3 : If($i1 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveInputStream\n  $r1 \u003d InputStream currentInputStream\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r28 \u003d InputStream currentInputStream\u003e\n  IOUtils.skip(r28, 9223372036854775807L)\n  $r29 \u003d InputStream currentInputStream\u003e\n  $r29.close()\n  LocalFileHeader currentLocalFileHeader\u003e \u003d null\n  InputStream currentInputStream\u003e \u003d null\n}",
      "B2 {\n  $r2 \u003d r0.readLocalFileHeader()\n  LocalFileHeader currentLocalFileHeader\u003e \u003d $r2\n  $r3 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  if ($r3 \u003d\u003d null) goto B3 else B6\n}",
      "B3 {\n  $r5 \u003d BoundedInputStream.builder()\n  $r4 \u003d DataInputStream dis\u003e\n  $r6 \u003d $r5.setInputStream($r4)\n  $r8 \u003d BoundedInputStream$Builder) $r6\n  $r7 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $l0 \u003d LocalFileHeader: long compressedSize\u003e\n  $r9 \u003d $r8.setMaxCount($l0)\n  $r10 \u003d BoundedInputStream$Builder) $r9\n  $r11 \u003d $r10.setPropagateClose(0)\n  $r12 \u003d BoundedInputStream$Builder) $r11\n  $r13 \u003d $r12.get()\n  InputStream currentInputStream\u003e \u003d $r13\n  $r14 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $i1 \u003d LocalFileHeader: int method\u003e\n  if ($i1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r18 \u003d ChecksumInputStream.builder()\n  $r17 \u003d CRC32\n  new CRC32()\n  $r20 \u003d $r18.setChecksum($r17)\n  $r19 \u003d InputStream currentInputStream\u003e\n  $r21 \u003d $r20.setInputStream($r19)\n  $r23 \u003d ChecksumInputStream$Builder) $r21\n  $r22 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $l2 \u003d LocalFileHeader: long originalSize\u003e\n  $r25 \u003d $r23.setCountThreshold($l2)\n  $r24 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $l3 \u003d LocalFileHeader: long originalCrc32\u003e\n  $r26 \u003d $r25.setExpectedChecksumValue($l3)\n  $r27 \u003d $r26.get()\n  InputStream currentInputStream\u003e \u003d $r27\n}",
      "B5 {\n  $r15 \u003d ArjArchiveEntry\n  $r16 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  new ArjArchiveEntry($r16)\n  return\n}",
      "B6 {\n  InputStream currentInputStream\u003e \u003d null\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ArjArchiveInputStream#readLocalFileHeader(...0)",
        "body": "{\r\n    final byte[] basicHeaderBytes \u003d readHeader();\r\n    if (basicHeaderBytes \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    try (DataInputStream basicHeader \u003d new DataInputStream(new ByteArrayInputStream(basicHeaderBytes))) {\r\n        final int firstHeaderSize \u003d basicHeader.readUnsignedByte();\r\n        final byte[] firstHeaderBytes \u003d readRange(basicHeader, firstHeaderSize - 1);\r\n        pushedBackBytes(firstHeaderBytes.length);\r\n        try (DataInputStream firstHeader \u003d new DataInputStream(new ByteArrayInputStream(firstHeaderBytes))) {\r\n            final LocalFileHeader localFileHeader \u003d new LocalFileHeader();\r\n            localFileHeader.archiverVersionNumber \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.minVersionToExtract \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.hostOS \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.arjFlags \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.method \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.fileType \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.reserved \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.dateTimeModified \u003d read32(firstHeader);\r\n            localFileHeader.compressedSize \u003d 0xffffFFFFL \u0026 read32(firstHeader);\r\n            localFileHeader.originalSize \u003d 0xffffFFFFL \u0026 read32(firstHeader);\r\n            localFileHeader.originalCrc32 \u003d 0xffffFFFFL \u0026 read32(firstHeader);\r\n            localFileHeader.fileSpecPosition \u003d read16(firstHeader);\r\n            localFileHeader.fileAccessMode \u003d read16(firstHeader);\r\n            pushedBackBytes(20);\r\n            localFileHeader.firstChapter \u003d firstHeader.readUnsignedByte();\r\n            localFileHeader.lastChapter \u003d firstHeader.readUnsignedByte();\r\n            readExtraData(firstHeaderSize, firstHeader, localFileHeader);\r\n            localFileHeader.name \u003d readString(basicHeader);\r\n            localFileHeader.comment \u003d readString(basicHeader);\r\n            final ArrayList\u003cbyte[]\u003e extendedHeaders \u003d new ArrayList\u003c\u003e();\r\n            int extendedHeaderSize;\r\n            while ((extendedHeaderSize \u003d read16(dis)) \u003e 0) {\r\n                final byte[] extendedHeaderBytes \u003d readRange(dis, extendedHeaderSize);\r\n                final long extendedHeaderCrc32 \u003d 0xffffFFFFL \u0026 read32(dis);\r\n                final CRC32 crc32 \u003d new CRC32();\r\n                crc32.update(extendedHeaderBytes);\r\n                if (extendedHeaderCrc32 !\u003d crc32.getValue()) {\r\n                    throw new IOException(\"Extended header CRC32 verification failure\");\r\n                }\r\n                extendedHeaders.add(extendedHeaderBytes);\r\n            }\r\n            localFileHeader.extendedHeaders \u003d extendedHeaders.toArray(new byte[0][]);\r\n            return localFileHeader;\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.arj.ArjArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (currentLocalFileHeader \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current arj entry\");\r\n    }\r\n    if (currentLocalFileHeader.method !\u003d LocalFileHeader.Methods.STORED) {\r\n        throw new IOException(\"Unsupported compression method \" + currentLocalFileHeader.method);\r\n    }\r\n    return currentInputStream.read(b, off, len);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B4 : If($i1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ArjArchiveInputStream\n  r3 :\u003d @parameter0: byte[]\n  i2 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r11 \u003d IllegalStateException\n  new IllegalStateException(\"No current arj entry\")\n  throw $r11\n}",
      "B4 {\n  $r2 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $i1 \u003d LocalFileHeader: int method\u003e\n  if ($i1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r5 \u003d IOException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r6.append(\"Unsupported compression method \")\n  $r7 \u003d LocalFileHeader currentLocalFileHeader\u003e\n  $i4 \u003d LocalFileHeader: int method\u003e\n  $r9 \u003d $r8.append($i4)\n  $r10 \u003d $r9.toString()\n  new IOException($r10)\n  throw $r5\n}",
      "B6 {\n  $r4 \u003d InputStream currentInputStream\u003e\n  $i3 \u003d $r4.read(r3, i2, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CpioArchiveEntry other \u003d (CpioArchiveEntry) obj;\r\n    return Objects.equals(name, other.name);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CpioArchiveEntry) r1\n  $r6 \u003d String name\u003e\n  $r5 \u003d String name\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "getDataPadCount",
    "signature": "int getDataPadCount()",
    "visibility": "public",
    "body": "{\r\n    if (this.alignmentBoundary \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final long size \u003d this.fileSize;\r\n    final int remain \u003d (int) (size % this.alignmentBoundary);\r\n    if (remain \u003e 0) {\r\n        return this.alignmentBoundary - remain;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i5 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $i0 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  l1 \u003d CpioArchiveEntry: long fileSize\u003e\n  $i2 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  $l3 \u003d (long) $i2\n  $l4 \u003d l1 % $l3\n  i5 \u003d (int) $l4\n  if (i5 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $i6 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  $i7 \u003d $i6 - i5\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "getHeaderPadCount",
    "signature": "int getHeaderPadCount(java.nio.charset.Charset)",
    "visibility": "public",
    "body": "{\r\n    if (name \u003d\u003d null) {\r\n        return 0;\r\n    }\r\n    if (charset \u003d\u003d null) {\r\n        return getHeaderPadCount(name.length());\r\n    }\r\n    return getHeaderPadCount(name.getBytes(charset).length);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If(r2 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  Charset\n  $r1 \u003d String name\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d String name\u003e\n  $i3 \u003d $r5.length()\n  $l4 \u003d (long) $i3\n  $i5 \u003d r0.getHeaderPadCount($l4)\n  return\n}",
      "B4 {\n  $r3 \u003d String name\u003e\n  $r4 \u003d $r3.getBytes(r2)\n  $i0 \u003d lengthof $r4\n  $l1 \u003d (long) $i0\n  $i2 \u003d r0.getHeaderPadCount($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveEntry#getHeaderPadCount(...1)",
        "body": "{\r\n    if (name \u003d\u003d null) {\r\n        return 0;\r\n    }\r\n    if (charset \u003d\u003d null) {\r\n        return getHeaderPadCount(name.length());\r\n    }\r\n    return getHeaderPadCount(name.getBytes(charset).length);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "getHeaderPadCount",
    "signature": "int getHeaderPadCount(long)",
    "visibility": "public",
    "body": "{\r\n    if (this.alignmentBoundary \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    // Name has terminating null\r\n    int size \u003d this.headerSize + 1;\r\n    if (name !\u003d null) {\r\n        size \u003d ExactMath.add(size, nameSize);\r\n    }\r\n    final int remain \u003d size % this.alignmentBoundary;\r\n    if (remain \u003e 0) {\r\n        return this.alignmentBoundary - remain;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i6 \u003c\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  l5 :\u003d @parameter0: long\n  $i0 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d CpioArchiveEntry: int headerSize\u003e\n  i7 \u003d $i1 + 1\n  $r1 \u003d String name\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  i7 \u003d ExactMath.add(i7, l5)\n}",
      "B4 {\n  $i2 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  $i6 \u003d i7 % $i2\n  if ($i6 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i3 \u003d CpioArchiveEntry: int alignmentBoundary\u003e\n  $i4 \u003d $i3 - $i6\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "getMode",
    "signature": "long getMode()",
    "visibility": "public",
    "body": "{\r\n    return mode \u003d\u003d 0 \u0026\u0026 !CPIO_TRAILER.equals(name) ? C_ISREG : mode;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B3",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $b1 \u003d $l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d \"TRAILER!!!\"\n  $r1 \u003d String name\u003e\n  $z0 \u003d $r2.equals($r1)\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $l2 \u003d 32768L\n  goto B4\n}",
      "B3 {\n  $l2 \u003d CpioArchiveEntry: long mode\u003e\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "getNumberOfLinks",
    "signature": "long getNumberOfLinks()",
    "visibility": "public",
    "body": "{\r\n    return nlink \u003d\u003d 0 ? isDirectory() ? 2 : 1 : nlink;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long nlink\u003e\n  $b1 \u003d $l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $l2 \u003d 2L\n  goto B5\n}",
      "B3 {\n  $l2 \u003d 1L\n  goto B5\n}",
      "B4 {\n  $l2 \u003d CpioArchiveEntry: long nlink\u003e\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveEntry#isDirectory(...0)",
        "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISDIR;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isBlockDevice",
    "signature": "boolean isBlockDevice()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISBLK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 24576L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isCharacterDevice",
    "signature": "boolean isCharacterDevice()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISCHR;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 8192L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isDirectory",
    "signature": "boolean isDirectory()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISDIR;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 16384L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isNetwork",
    "signature": "boolean isNetwork()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISNWK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 36864L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isPipe",
    "signature": "boolean isPipe()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISFIFO;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 4096L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isRegularFile",
    "signature": "boolean isRegularFile()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISREG;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 32768L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isSocket",
    "signature": "boolean isSocket()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISSOCK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 49152L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "isSymbolicLink",
    "signature": "boolean isSymbolicLink()",
    "visibility": "public",
    "body": "{\r\n    return CpioUtil.fileType(mode) \u003d\u003d C_ISLNK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  $l0 \u003d CpioArchiveEntry: long mode\u003e\n  $l1 \u003d CpioUtil.fileType($l0)\n  $b2 \u003d $l1 cmp 40960L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "setMode",
    "signature": "void setMode(long)",
    "visibility": "public",
    "body": "{\r\n    final long maskedMode \u003d mode \u0026 S_IFMT;\r\n    switch((int) maskedMode) {\r\n        case C_ISDIR:\r\n        case C_ISLNK:\r\n        case C_ISREG:\r\n        case C_ISFIFO:\r\n        case C_ISCHR:\r\n        case C_ISBLK:\r\n        case C_ISSOCK:\r\n        case C_ISNWK:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown mode. \" + \"Full: \" + Long.toHexString(mode) + \" Masked: \" + Long.toHexString(maskedMode));\r\n    }\r\n    this.mode \u003d mode;\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  l0 :\u003d @parameter0: long\n  l1 \u003d l0 \u0026 61440L\n  $i2 \u003d (int) l1\n  IllegalArgumentException; }\n}",
      "B1 {\n  goto B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r2.append(\"Unknown mode. Full: \")\n  $r3 \u003d Long.toHexString(l0)\n  $r5 \u003d $r4.append($r3)\n  $r7 \u003d $r5.append(\" Masked: \")\n  $r6 \u003d Long.toHexString(l1)\n  $r8 \u003d $r7.append($r6)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r1\n}",
      "B3 {\n  CpioArchiveEntry: long mode\u003e \u003d l0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry",
    "methodName": "setSize",
    "signature": "void setSize(long)",
    "visibility": "public",
    "body": "{\r\n    if (size \u003c 0 || size \u003e 0xFFFFFFFFL) {\r\n        throw new IllegalArgumentException(\"Invalid entry size \u003c\" + size + \"\u003e\");\r\n    }\r\n    this.fileSize \u003d size;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i3 \u003c 0) → B1 | else → B2",
      "B1 : If($i4 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveEntry\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i3 \u003d (int) $b1\n  if ($i3 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $b2 \u003d l0 cmp 4294967295L\n  $i4 \u003d (int) $b2\n  if ($i4 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d IllegalArgumentException\n  $r7 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r7.append(\"Invalid entry size \u003c\")\n  $r3 \u003d $r2.append(l0)\n  $r4 \u003d $r3.append(\"\u003e\")\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r8\n}",
      "B3 {\n  CpioArchiveEntry: long fileSize\u003e \u003d l0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c 6) {\r\n        return false;\r\n    }\r\n    // Check binary values\r\n    if (signature[0] \u003d\u003d 0x71 \u0026\u0026 (signature[1] \u0026 0xFF) \u003d\u003d 0xc7 || signature[1] \u003d\u003d 0x71 \u0026\u0026 (signature[0] \u0026 0xFF) \u003d\u003d 0xc7) {\r\n        return true;\r\n    }\r\n    // Check Ascii (String) values\r\n    // 3037 3037 30nn\r\n    if (signature[0] !\u003d 0x30) {\r\n        return false;\r\n    }\r\n    if (signature[1] !\u003d 0x37) {\r\n        return false;\r\n    }\r\n    if (signature[2] !\u003d 0x30) {\r\n        return false;\r\n    }\r\n    if (signature[3] !\u003d 0x37) {\r\n        return false;\r\n    }\r\n    if (signature[4] !\u003d 0x30) {\r\n        return false;\r\n    }\r\n    // Check last byte\r\n    if (signature[5] \u003d\u003d 0x31) {\r\n        return true;\r\n    }\r\n    if (signature[5] \u003d\u003d 0x32) {\r\n        return true;\r\n    }\r\n    if (signature[5] \u003d\u003d 0x37) {\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "nodes": 24,
    "edges": 26,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 6) → B1 | else → B2",
      "B2 : If($i15 !\u003d 113) → B3 | else → B4",
      "B3 : If($i17 \u003d\u003d 199) → B4 | else → B6",
      "B4 : If($i18 !\u003d 113) → B5 | else → B7",
      "B5 : If($i20 !\u003d 199) → B6 | else → B7",
      "B7 : If($i21 \u003d\u003d 48) → B8 | else → B9",
      "B9 : If($i22 \u003d\u003d 55) → B10 | else → B11",
      "B11 : If($i23 \u003d\u003d 48) → B12 | else → B13",
      "B13 : If($i24 \u003d\u003d 55) → B14 | else → B15",
      "B15 : If($i25 \u003d\u003d 48) → B16 | else → B17",
      "B17 : If($i26 !\u003d 49) → B18 | else → B19",
      "B19 : If($i27 !\u003d 50) → B20 | else → B21",
      "B21 : If($i28 !\u003d 55) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003e\u003d 6) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $b1 \u003d r0[0]\n  $i15 \u003d (int) $b1\n  if ($i15 !\u003d 113) goto B3 else B4\n}",
      "B3 {\n  $b13 \u003d r0[1]\n  $s16 \u003d (short) $b13\n  $s14 \u003d $s16 \u0026 255\n  $i17 \u003d (int) $s14\n  if ($i17 \u003d\u003d 199) goto B4 else B6\n}",
      "B4 {\n  $b2 \u003d r0[1]\n  $i18 \u003d (int) $b2\n  if ($i18 !\u003d 113) goto B5 else B7\n}",
      "B5 {\n  $b11 \u003d r0[0]\n  $s19 \u003d (short) $b11\n  $s12 \u003d $s19 \u0026 255\n  $i20 \u003d (int) $s12\n  if ($i20 !\u003d 199) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  $b3 \u003d r0[0]\n  $i21 \u003d (int) $b3\n  if ($i21 \u003d\u003d 48) goto B8 else B9\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $b4 \u003d r0[1]\n  $i22 \u003d (int) $b4\n  if ($i22 \u003d\u003d 55) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $b5 \u003d r0[2]\n  $i23 \u003d (int) $b5\n  if ($i23 \u003d\u003d 48) goto B12 else B13\n}",
      "B12 {\n  return\n}",
      "B13 {\n  $b6 \u003d r0[3]\n  $i24 \u003d (int) $b6\n  if ($i24 \u003d\u003d 55) goto B14 else B15\n}",
      "B14 {\n  return\n}",
      "B15 {\n  $b7 \u003d r0[4]\n  $i25 \u003d (int) $b7\n  if ($i25 \u003d\u003d 48) goto B16 else B17\n}",
      "B16 {\n  return\n}",
      "B17 {\n  $b8 \u003d r0[5]\n  $i26 \u003d (int) $b8\n  if ($i26 !\u003d 49) goto B18 else B19\n}",
      "B18 {\n  return\n}",
      "B19 {\n  $b9 \u003d r0[5]\n  $i27 \u003d (int) $b9\n  if ($i27 !\u003d 50) goto B20 else B21\n}",
      "B20 {\n  return\n}",
      "B21 {\n  $b10 \u003d r0[5]\n  $i28 \u003d (int) $b10\n  if ($i28 !\u003d 55) goto B22 else B23\n}",
      "B22 {\n  return\n}",
      "B23 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "available",
    "signature": "int available()",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    if (this.entryEOF) {\r\n        return 0;\r\n    }\r\n    return 1;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveInputStream\n  r0.ensureOpen()\n  $z0 \u003d CpioArchiveInputStream: boolean entryEOF\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveInputStream#ensureOpen(...0)",
        "body": "{\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!this.closed) {\r\n        in.close();\r\n        this.closed \u003d true;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveInputStream\n  $z0 \u003d CpioArchiveInputStream: boolean closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d InputStream in\u003e\n  $r1.close()\n  CpioArchiveInputStream: boolean closed\u003e \u003d 1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "getNextCPIOEntry",
    "signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveEntry getNextCPIOEntry()",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    if (this.entry !\u003d null) {\r\n        closeEntry();\r\n    }\r\n    readFully(buffer2, 0, buffer2.length);\r\n    if (CpioUtil.byteArray2long(buffer2, false) \u003d\u003d MAGIC_OLD_BINARY) {\r\n        this.entry \u003d readOldBinaryEntry(false);\r\n    } else if (CpioUtil.byteArray2long(buffer2, true) \u003d\u003d MAGIC_OLD_BINARY) {\r\n        this.entry \u003d readOldBinaryEntry(true);\r\n    } else {\r\n        System.arraycopy(buffer2, 0, buffer6, 0, buffer2.length);\r\n        readFully(buffer6, buffer2.length, buffer4.length);\r\n        final String magicString \u003d ArchiveUtils.toAsciiString(buffer6);\r\n        switch(magicString) {\r\n            case MAGIC_NEW:\r\n                this.entry \u003d readNewEntry(false);\r\n                break;\r\n            case MAGIC_NEW_CRC:\r\n                this.entry \u003d readNewEntry(true);\r\n                break;\r\n            case MAGIC_OLD_ASCII:\r\n                this.entry \u003d readOldAsciiEntry();\r\n                break;\r\n            default:\r\n                throw new IOException(\"Unknown magic [\" + magicString + \"]. Occurred at byte: \" + getBytesRead());\r\n        }\r\n    }\r\n    this.entryBytesRead \u003d 0;\r\n    this.entryEOF \u003d false;\r\n    this.crc \u003d 0;\r\n    if (this.entry.getName().equals(CPIO_TRAILER)) {\r\n        this.entryEOF \u003d true;\r\n        skipRemainderOfLastBlock();\r\n        return null;\r\n    }\r\n    return this.entry;\r\n}",
    "nodes": 21,
    "edges": 31,
    "cc": 12,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($b2 !\u003d 0) → B3 | else → B4",
      "B4 : If($b4 !\u003d 0) → B5 | else → B6",
      "B6 : If(switch-on $i8) → B7 | else → B9",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B13",
      "B9 : If($z1 \u003d\u003d false) → B10 | else → B13",
      "B11 : If($z0 \u003d\u003d false) → B12 | else → B13",
      "B13 : If(switch-on b10) → B14 | else → B15",
      "B18 : If($z3 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveInputStream\n  r0.ensureOpen()\n  $r1 \u003d CpioArchiveEntry entry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.closeEntry()\n}",
      "B2 {\n  $r3 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $r2 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $i0 \u003d lengthof $r2\n  r0.readFully($r3, 0, $i0)\n  $r4 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $l1 \u003d CpioUtil.byteArray2long($r4, 0)\n  $b2 \u003d $l1 cmp 29127L\n  if ($b2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r26 \u003d r0.readOldBinaryEntry(0)\n  CpioArchiveEntry entry\u003e \u003d $r26\n  goto B18\n}",
      "B4 {\n  $r5 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $l3 \u003d CpioUtil.byteArray2long($r5, 1)\n  $b4 \u003d $l3 cmp 29127L\n  if ($b4 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r25 \u003d r0.readOldBinaryEntry(1)\n  CpioArchiveEntry entry\u003e \u003d $r25\n  goto B18\n}",
      "B6 {\n  $r8 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $r7 \u003d CpioArchiveInputStream: byte[] buffer6\u003e\n  $r6 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $i5 \u003d lengthof $r6\n  System.arraycopy($r8, 0, $r7, 0, $i5)\n  $r11 \u003d CpioArchiveInputStream: byte[] buffer6\u003e\n  $r9 \u003d CpioArchiveInputStream: byte[] buffer2\u003e\n  $i7 \u003d lengthof $r9\n  $r10 \u003d CpioArchiveInputStream: byte[] buffer4\u003e\n  $i6 \u003d lengthof $r10\n  r0.readFully($r11, $i7, $i6)\n  $r12 \u003d CpioArchiveInputStream: byte[] buffer6\u003e\n  r13 \u003d ArchiveUtils.toAsciiString($r12)\n  b10 \u003d -1\n  $i8 \u003d r13.hashCode()\n  IOException; }; }\n}",
      "B7 {\n  $z2 \u003d r13.equals(\"070701\")\n  if ($z2 \u003d\u003d false) goto B8 else B13\n}",
      "B8 {\n  b10 \u003d 0\n  goto B13\n}",
      "B9 {\n  $z1 \u003d r13.equals(\"070702\")\n  if ($z1 \u003d\u003d false) goto B10 else B13\n}",
      "B10 {\n  b10 \u003d 1\n  goto B13\n}",
      "B11 {\n  $z0 \u003d r13.equals(\"070707\")\n  if ($z0 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  b10 \u003d 2\n}",
      "B13 {\n  IOException; }\n}",
      "B14 {\n  $r17 \u003d r0.readNewEntry(0)\n  CpioArchiveEntry entry\u003e \u003d $r17\n  goto B18\n}",
      "B15 {\n  $r16 \u003d r0.readNewEntry(1)\n  CpioArchiveEntry entry\u003e \u003d $r16\n  goto B18\n}",
      "B16 {\n  $r14 \u003d r0.readOldAsciiEntry()\n  CpioArchiveEntry entry\u003e \u003d $r14\n  goto B18\n}",
      "B17 {\n  $r18 \u003d IOException\n  $r19 \u003d StringBuilder\n  new StringBuilder()\n  $r20 \u003d $r19.append(\"Unknown magic \")\n  $r21 \u003d $r20.append(r13)\n  $r22 \u003d $r21.append(\". Occurred at byte: \")\n  $l9 \u003d r0.getBytesRead()\n  $r23 \u003d $r22.append($l9)\n  $r24 \u003d $r23.toString()\n  new IOException($r24)\n  throw $r18\n}",
      "B18 {\n  CpioArchiveInputStream: long entryBytesRead\u003e \u003d 0L\n  CpioArchiveInputStream: boolean entryEOF\u003e \u003d 0\n  CpioArchiveInputStream: long crc\u003e \u003d 0L\n  $r27 \u003d CpioArchiveEntry entry\u003e\n  $r28 \u003d $r27.getName()\n  $z3 \u003d $r28.equals(\"TRAILER!!!\")\n  if ($z3 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  CpioArchiveInputStream: boolean entryEOF\u003e \u003d 1\n  r0.skipRemainderOfLastBlock()\n  return\n}",
      "B20 {\n  $r15 \u003d CpioArchiveEntry entry\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B18",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B18",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B6 --\u003e B11",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B13",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B13 --\u003e B16",
      "B13 --\u003e B17",
      "B14 --\u003e B18",
      "B15 --\u003e B18",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveInputStream#getBytesRead(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveInputStream#skipRemainderOfLastBlock(...0)",
        "body": "{\r\n    final long readFromLastBlock \u003d getBytesRead() % blockSize;\r\n    long remainingBytes \u003d readFromLastBlock \u003d\u003d 0 ? 0 : blockSize - readFromLastBlock;\r\n    while (remainingBytes \u003e 0) {\r\n        final long skipped \u003d skip(blockSize - readFromLastBlock);\r\n        if (skipped \u003c\u003d 0) {\r\n            break;\r\n        }\r\n        remainingBytes -\u003d skipped;\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#ensureOpen(...0)",
        "body": "{\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#readNewEntry(...1)",
        "body": "{\r\n    final CpioArchiveEntry newEntry;\r\n    if (hasCrc) {\r\n        newEntry \u003d new CpioArchiveEntry(FORMAT_NEW_CRC);\r\n    } else {\r\n        newEntry \u003d new CpioArchiveEntry(FORMAT_NEW);\r\n    }\r\n    newEntry.setInode(readAsciiLong(8, 16));\r\n    final long mode \u003d readAsciiLong(8, 16);\r\n    if (CpioUtil.fileType(mode) !\u003d 0) {\r\n        // mode is initialized to 0\r\n        newEntry.setMode(mode);\r\n    }\r\n    newEntry.setUID(readAsciiLong(8, 16));\r\n    newEntry.setGID(readAsciiLong(8, 16));\r\n    newEntry.setNumberOfLinks(readAsciiLong(8, 16));\r\n    newEntry.setTime(readAsciiLong(8, 16));\r\n    newEntry.setSize(readAsciiLong(8, 16));\r\n    if (newEntry.getSize() \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative length\");\r\n    }\r\n    newEntry.setDeviceMaj(readAsciiLong(8, 16));\r\n    newEntry.setDeviceMin(readAsciiLong(8, 16));\r\n    newEntry.setRemoteDeviceMaj(readAsciiLong(8, 16));\r\n    newEntry.setRemoteDeviceMin(readAsciiLong(8, 16));\r\n    final long namesize \u003d readAsciiLong(8, 16);\r\n    if (namesize \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative name length\");\r\n    }\r\n    newEntry.setChksum(readAsciiLong(8, 16));\r\n    final String name \u003d readCString((int) namesize);\r\n    newEntry.setName(name);\r\n    if (CpioUtil.fileType(mode) \u003d\u003d 0 \u0026\u0026 !name.equals(CPIO_TRAILER)) {\r\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \" + ArchiveUtils.sanitize(name) + \" Occurred at byte: \" + getBytesRead());\r\n    }\r\n    final int headerPadCount \u003d newEntry.getHeaderPadCount(namesize - 1);\r\n    if (skip(headerPadCount) !\u003d headerPadCount) {\r\n        throw new IOException(\"Header pad count mismatch.\");\r\n    }\r\n    return newEntry;\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#readOldAsciiEntry(...0)",
        "body": "{\r\n    final CpioArchiveEntry ret \u003d new CpioArchiveEntry(FORMAT_OLD_ASCII);\r\n    ret.setDevice(readAsciiLong(6, 8));\r\n    ret.setInode(readAsciiLong(6, 8));\r\n    final long mode \u003d readAsciiLong(6, 8);\r\n    if (CpioUtil.fileType(mode) !\u003d 0) {\r\n        ret.setMode(mode);\r\n    }\r\n    ret.setUID(readAsciiLong(6, 8));\r\n    ret.setGID(readAsciiLong(6, 8));\r\n    ret.setNumberOfLinks(readAsciiLong(6, 8));\r\n    ret.setRemoteDevice(readAsciiLong(6, 8));\r\n    ret.setTime(readAsciiLong(11, 8));\r\n    final long namesize \u003d readAsciiLong(6, 8);\r\n    if (namesize \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative name length\");\r\n    }\r\n    ret.setSize(readAsciiLong(11, 8));\r\n    if (ret.getSize() \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative length\");\r\n    }\r\n    final String name \u003d readCString((int) namesize);\r\n    ret.setName(name);\r\n    if (CpioUtil.fileType(mode) \u003d\u003d 0 \u0026\u0026 !name.equals(CPIO_TRAILER)) {\r\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(name) + \" Occurred at byte: \" + getBytesRead());\r\n    }\r\n    return ret;\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#readFully(...3)",
        "body": "{\r\n    final int count \u003d IOUtils.readFully(in, b, off, len);\r\n    count(count);\r\n    if (count \u003c len) {\r\n        throw new EOFException();\r\n    }\r\n    return count;\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#readOldBinaryEntry(...1)",
        "body": "{\r\n    final CpioArchiveEntry oldEntry \u003d new CpioArchiveEntry(FORMAT_OLD_BINARY);\r\n    oldEntry.setDevice(readBinaryLong(2, swapHalfWord));\r\n    oldEntry.setInode(readBinaryLong(2, swapHalfWord));\r\n    final long mode \u003d readBinaryLong(2, swapHalfWord);\r\n    if (CpioUtil.fileType(mode) !\u003d 0) {\r\n        oldEntry.setMode(mode);\r\n    }\r\n    oldEntry.setUID(readBinaryLong(2, swapHalfWord));\r\n    oldEntry.setGID(readBinaryLong(2, swapHalfWord));\r\n    oldEntry.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\r\n    oldEntry.setRemoteDevice(readBinaryLong(2, swapHalfWord));\r\n    oldEntry.setTime(readBinaryLong(4, swapHalfWord));\r\n    final long namesize \u003d readBinaryLong(2, swapHalfWord);\r\n    if (namesize \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative name length\");\r\n    }\r\n    oldEntry.setSize(readBinaryLong(4, swapHalfWord));\r\n    if (oldEntry.getSize() \u003c 0) {\r\n        throw new IOException(\"Found illegal entry with negative length\");\r\n    }\r\n    final String name \u003d readCString((int) namesize);\r\n    oldEntry.setName(name);\r\n    if (CpioUtil.fileType(mode) \u003d\u003d 0 \u0026\u0026 !name.equals(CPIO_TRAILER)) {\r\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + ArchiveUtils.sanitize(name) + \"Occurred at byte: \" + getBytesRead());\r\n    }\r\n    final int headerPadCount \u003d oldEntry.getHeaderPadCount(namesize - 1);\r\n    if (skip(headerPadCount) !\u003d headerPadCount) {\r\n        throw new IOException(\"Header pad count mismatch.\");\r\n    }\r\n    return oldEntry;\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#closeEntry(...0)",
        "body": "{\r\n    // the skip implementation of this class will not skip more\r\n    // than Integer.MAX_VALUE bytes\r\n    while (skip((long) Integer.MAX_VALUE) \u003d\u003d Integer.MAX_VALUE) {\r\n        // NOPMD NOSONAR\r\n        // do nothing\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    if (off \u003c 0 || len \u003c 0 || off \u003e b.length - len) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (this.entry \u003d\u003d null || this.entryEOF) {\r\n        return -1;\r\n    }\r\n    if (this.entryBytesRead \u003d\u003d this.entry.getSize()) {\r\n        final int dataPadCount \u003d entry.getDataPadCount();\r\n        if (skip(dataPadCount) !\u003d dataPadCount) {\r\n            throw new IOException(\"Data pad count missmatch.\");\r\n        }\r\n        this.entryEOF \u003d true;\r\n        if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC \u0026\u0026 this.crc !\u003d this.entry.getChksum()) {\r\n            throw new IOException(\"CRC Error. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        // EOF for this entry\r\n        return -1;\r\n    }\r\n    final int tmplength \u003d (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);\r\n    if (tmplength \u003c 0) {\r\n        return -1;\r\n    }\r\n    final int tmpread \u003d readFully(b, off, tmplength);\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC) {\r\n        for (int pos \u003d 0; pos \u003c tmpread; pos++) {\r\n            this.crc +\u003d b[pos] \u0026 0xFF;\r\n            this.crc \u0026\u003d 0xFFFFFFFFL;\r\n        }\r\n    }\r\n    if (tmpread \u003e 0) {\r\n        this.entryBytesRead +\u003d tmpread;\r\n    }\r\n    return tmpread;\r\n}",
    "nodes": 25,
    "edges": 31,
    "cc": 8,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B3",
      "B1 : If(i1 \u003c 0) → B2 | else → B3",
      "B2 : If(i0 \u003c\u003d $i3) → B3 | else → B4",
      "B4 : If(i1 !\u003d 0) → B5 | else → B6",
      "B6 : If($r2 \u003d\u003d null) → B7 | else → B8",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($b6 !\u003d 0) → B10 | else → B16",
      "B10 : If($i24 \u003d\u003d i30) → B11 | else → B12",
      "B12 : If($i35 !\u003d 2) → B13 | else → B15",
      "B13 : If($b28 \u003d\u003d false) → B14 | else → B15",
      "B16 : If(i31 \u003e\u003d 0) → B17 | else → B18",
      "B18 : If($i40 !\u003d 2) → B19 | else → B22",
      "B20 : If(i32 \u003e\u003d i12) → B21 | else → B22",
      "B22 : If(i12 \u003c\u003d 0) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveInputStream\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0.ensureOpen()\n  if (i0 \u003c 0) goto B1 else B3\n}",
      "B1 {\n  if (i1 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d lengthof r1\n  $i3 \u003d $i2 - i1\n  if (i0 \u003c\u003d $i3) goto B3 else B4\n}",
      "B3 {\n  $r16 \u003d IndexOutOfBoundsException\n  new IndexOutOfBoundsException()\n  throw $r16\n}",
      "B4 {\n  if (i1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r2 \u003d CpioArchiveEntry entry\u003e\n  if ($r2 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $z0 \u003d CpioArchiveInputStream: boolean entryEOF\u003e\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $i34 \u003d (int) -1\n  return\n}",
      "B9 {\n  $l4 \u003d CpioArchiveInputStream: long entryBytesRead\u003e\n  $r3 \u003d CpioArchiveEntry entry\u003e\n  $l5 \u003d $r3.getSize()\n  $b6 \u003d $l4 cmp $l5\n  if ($b6 !\u003d 0) goto B10 else B16\n}",
      "B10 {\n  $r6 \u003d CpioArchiveEntry entry\u003e\n  i30 \u003d $r6.getDataPadCount()\n  $i24 \u003d r0.skip(i30)\n  if ($i24 \u003d\u003d i30) goto B11 else B12\n}",
      "B11 {\n  $r17 \u003d IOException\n  new IOException(\"Data pad count missmatch.\")\n  throw $r17\n}",
      "B12 {\n  CpioArchiveInputStream: boolean entryEOF\u003e \u003d 1\n  $r7 \u003d CpioArchiveEntry entry\u003e\n  $s25 \u003d $r7.getFormat()\n  $i35 \u003d (int) $s25\n  if ($i35 !\u003d 2) goto B13 else B15\n}",
      "B13 {\n  $l26 \u003d CpioArchiveInputStream: long crc\u003e\n  $r8 \u003d CpioArchiveEntry entry\u003e\n  $l27 \u003d $r8.getChksum()\n  $b28 \u003d $l26 cmp $l27\n  if ($b28 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r19 \u003d IOException\n  $r18 \u003d StringBuilder\n  new StringBuilder()\n  $r11 \u003d $r18.append(\"CRC Error. Occurred at byte: \")\n  $l29 \u003d r0.getBytesRead()\n  $r12 \u003d $r11.append($l29)\n  $r13 \u003d $r12.toString()\n  new IOException($r13)\n  throw $r19\n}",
      "B15 {\n  $i37 \u003d (int) -1\n  return\n}",
      "B16 {\n  $l10 \u003d (long) i1\n  $r4 \u003d CpioArchiveEntry entry\u003e\n  $l8 \u003d $r4.getSize()\n  $l7 \u003d CpioArchiveInputStream: long entryBytesRead\u003e\n  $l9 \u003d $l8 - $l7\n  $l11 \u003d Math.min($l10, $l9)\n  i31 \u003d (int) $l11\n  if (i31 \u003e\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $i39 \u003d (int) -1\n  return\n}",
      "B18 {\n  i12 \u003d r0.readFully(r1, i0, i31)\n  $r5 \u003d CpioArchiveEntry entry\u003e\n  $s13 \u003d $r5.getFormat()\n  $i40 \u003d (int) $s13\n  if ($i40 !\u003d 2) goto B19 else B22\n}",
      "B19 {\n  i32 \u003d 0\n}",
      "B20 {\n  if (i32 \u003e\u003d i12) goto B21 else B22\n}",
      "B21 {\n  $l20 \u003d CpioArchiveInputStream: long crc\u003e\n  $b17 \u003d r1[i32]\n  $s41 \u003d (short) $b17\n  $s18 \u003d $s41 \u0026 255\n  $l19 \u003d (long) $s18\n  $l21 \u003d $l20 + $l19\n  CpioArchiveInputStream: long crc\u003e \u003d $l21\n  $l22 \u003d CpioArchiveInputStream: long crc\u003e\n  $l23 \u003d $l22 \u0026 4294967295L\n  CpioArchiveInputStream: long crc\u003e \u003d $l23\n  i32 \u003d i32 + 1\n  goto B20\n}",
      "B22 {\n  if (i12 \u003c\u003d 0) goto B23 else B24\n}",
      "B23 {\n  $l15 \u003d CpioArchiveInputStream: long entryBytesRead\u003e\n  $l14 \u003d (long) i12\n  $l16 \u003d $l15 + $l14\n  CpioArchiveInputStream: long entryBytesRead\u003e \u003d $l16\n}",
      "B24 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B16",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B20",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveInputStream#getBytesRead(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveInputStream#skip(...1)",
        "body": "{\r\n    // bytes cannot be more than 3 bytes\r\n    return length \u003e 0 ? readFully(buffer4, 0, length) : 0;\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#ensureOpen(...0)",
        "body": "{\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#readFully(...3)",
        "body": "{\r\n    final int count \u003d IOUtils.readFully(in, b, off, len);\r\n    count(count);\r\n    if (count \u003c len) {\r\n        throw new EOFException();\r\n    }\r\n    return count;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream",
    "methodName": "skip",
    "signature": "long skip(long)",
    "visibility": "public",
    "body": "{\r\n    if (n \u003c 0) {\r\n        throw new IllegalArgumentException(\"Negative skip length\");\r\n    }\r\n    ensureOpen();\r\n    final int max \u003d (int) Math.min(n, Integer.MAX_VALUE);\r\n    int total \u003d 0;\r\n    while (total \u003c max) {\r\n        int len \u003d max - total;\r\n        if (len \u003e this.tmpBuf.length) {\r\n            len \u003d this.tmpBuf.length;\r\n        }\r\n        len \u003d read(this.tmpBuf, 0, len);\r\n        if (len \u003d\u003d -1) {\r\n            this.entryEOF \u003d true;\r\n            break;\r\n        }\r\n        total +\u003d len;\r\n    }\r\n    return total;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i9 \u003e\u003d 0) → B1 | else → B2",
      "B3 : If(i7 \u003e\u003d i3) → B4 | else → B9",
      "B4 : If(i8 \u003c\u003d $i5) → B5 | else → B6",
      "B6 : If($i6 !\u003d $i11) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveInputStream\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i9 \u003d (int) $b1\n  if ($i9 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Negative skip length\")\n  throw $r5\n}",
      "B2 {\n  r0.ensureOpen()\n  $l2 \u003d Math.min(l0, 2147483647L)\n  i3 \u003d (int) $l2\n  i7 \u003d 0\n}",
      "B3 {\n  if (i7 \u003e\u003d i3) goto B4 else B9\n}",
      "B4 {\n  i8 \u003d i3 - i7\n  $r1 \u003d CpioArchiveInputStream: byte[] tmpBuf\u003e\n  $i5 \u003d lengthof $r1\n  if (i8 \u003c\u003d $i5) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d CpioArchiveInputStream: byte[] tmpBuf\u003e\n  i8 \u003d lengthof $r3\n}",
      "B6 {\n  $r2 \u003d CpioArchiveInputStream: byte[] tmpBuf\u003e\n  $i6 \u003d r0.read($r2, 0, i8)\n  $i11 \u003d (int) -1\n  if ($i6 !\u003d $i11) goto B7 else B8\n}",
      "B7 {\n  CpioArchiveInputStream: boolean entryEOF\u003e \u003d 1\n  goto B9\n}",
      "B8 {\n  i7 \u003d i7 + $i6\n  goto B3\n}",
      "B9 {\n  $l4 \u003d (long) i7\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveInputStream#ensureOpen(...0)",
        "body": "{\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveInputStream#read(...3)",
        "body": "{\r\n    ensureOpen();\r\n    if (off \u003c 0 || len \u003c 0 || off \u003e b.length - len) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (this.entry \u003d\u003d null || this.entryEOF) {\r\n        return -1;\r\n    }\r\n    if (this.entryBytesRead \u003d\u003d this.entry.getSize()) {\r\n        final int dataPadCount \u003d entry.getDataPadCount();\r\n        if (skip(dataPadCount) !\u003d dataPadCount) {\r\n            throw new IOException(\"Data pad count missmatch.\");\r\n        }\r\n        this.entryEOF \u003d true;\r\n        if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC \u0026\u0026 this.crc !\u003d this.entry.getChksum()) {\r\n            throw new IOException(\"CRC Error. Occurred at byte: \" + getBytesRead());\r\n        }\r\n        // EOF for this entry\r\n        return -1;\r\n    }\r\n    final int tmplength \u003d (int) Math.min(len, this.entry.getSize() - this.entryBytesRead);\r\n    if (tmplength \u003c 0) {\r\n        return -1;\r\n    }\r\n    final int tmpread \u003d readFully(b, off, tmplength);\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC) {\r\n        for (int pos \u003d 0; pos \u003c tmpread; pos++) {\r\n            this.crc +\u003d b[pos] \u0026 0xFF;\r\n            this.crc \u0026\u003d 0xFFFFFFFFL;\r\n        }\r\n    }\r\n    if (tmpread \u003e 0) {\r\n        this.entryBytesRead +\u003d tmpread;\r\n    }\r\n    return tmpread;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (!isFinished()) {\r\n            finish();\r\n        }\r\n    } finally {\r\n        super.close();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.finish()\n}",
      "B2 {\n  r0.close()\n  goto B4\n}",
      "B3 {\n  $r1 :\u003d @caughtexception\n  r0.close()\n  throw $r1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveOutputStream#finish(...0)",
        "body": "{\r\n    checkOpen();\r\n    checkFinished();\r\n    if (this.entry !\u003d null) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    this.entry \u003d new CpioArchiveEntry(this.entryFormat);\r\n    this.entry.setName(CPIO_TRAILER);\r\n    this.entry.setNumberOfLinks(1);\r\n    writeHeader(this.entry);\r\n    closeArchiveEntry();\r\n    final int lengthOfLastBlock \u003d (int) (getBytesWritten() % blockSize);\r\n    if (lengthOfLastBlock !\u003d 0) {\r\n        pad(blockSize - lengthOfLastBlock);\r\n    }\r\n    super.finish();\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream",
    "methodName": "closeArchiveEntry",
    "signature": "void closeArchiveEntry()",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    checkOpen();\r\n    if (entry \u003d\u003d null) {\r\n        throw new IOException(\"Trying to close non-existent entry\");\r\n    }\r\n    if (this.entry.getSize() !\u003d this.written) {\r\n        throw new IOException(\"Invalid entry size (expected \" + this.entry.getSize() + \" but got \" + this.written + \" bytes)\");\r\n    }\r\n    pad(this.entry.getDataPadCount());\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC \u0026\u0026 this.crc !\u003d this.entry.getChksum()) {\r\n        throw new IOException(\"CRC Error\");\r\n    }\r\n    this.entry \u003d null;\r\n    this.crc \u003d 0;\r\n    this.written \u003d 0;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($b2 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i10 !\u003d 2) → B5 | else → B7",
      "B5 : If($b7 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveOutputStream\n  r0.checkFinished()\n  r0.checkOpen()\n  $r1 \u003d CpioArchiveEntry entry\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r17 \u003d IOException\n  new IOException(\"Trying to close non-existent entry\")\n  throw $r17\n}",
      "B2 {\n  $r2 \u003d CpioArchiveEntry entry\u003e\n  $l1 \u003d $r2.getSize()\n  $l0 \u003d CpioArchiveOutputStream: long written\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r19 \u003d IOException\n  $r18 \u003d StringBuilder\n  new StringBuilder()\n  $r10 \u003d $r18.append(\"Invalid entry size (expected \")\n  $r9 \u003d CpioArchiveEntry entry\u003e\n  $l8 \u003d $r9.getSize()\n  $r11 \u003d $r10.append($l8)\n  $r12 \u003d $r11.append(\" but got \")\n  $l9 \u003d CpioArchiveOutputStream: long written\u003e\n  $r13 \u003d $r12.append($l9)\n  $r14 \u003d $r13.append(\" bytes)\")\n  $r15 \u003d $r14.toString()\n  new IOException($r15)\n  throw $r19\n}",
      "B4 {\n  $r3 \u003d CpioArchiveEntry entry\u003e\n  $i3 \u003d $r3.getDataPadCount()\n  r0.pad($i3)\n  $r4 \u003d CpioArchiveEntry entry\u003e\n  $s4 \u003d $r4.getFormat()\n  $i10 \u003d (int) $s4\n  if ($i10 !\u003d 2) goto B5 else B7\n}",
      "B5 {\n  $l5 \u003d CpioArchiveOutputStream: long crc\u003e\n  $r5 \u003d CpioArchiveEntry entry\u003e\n  $l6 \u003d $r5.getChksum()\n  $b7 \u003d $l5 cmp $l6\n  if ($b7 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r20 \u003d IOException\n  new IOException(\"CRC Error\")\n  throw $r20\n}",
      "B7 {\n  CpioArchiveEntry entry\u003e \u003d null\n  CpioArchiveOutputStream: long crc\u003e \u003d 0L\n  CpioArchiveOutputStream: long written\u003e \u003d 0L\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveOutputStream#pad(...1)",
        "body": "{\r\n    if (count \u003e 0) {\r\n        out.write(new byte[count]);\r\n        count(count);\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    checkOpen();\r\n    checkFinished();\r\n    if (this.entry !\u003d null) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    this.entry \u003d new CpioArchiveEntry(this.entryFormat);\r\n    this.entry.setName(CPIO_TRAILER);\r\n    this.entry.setNumberOfLinks(1);\r\n    writeHeader(this.entry);\r\n    closeArchiveEntry();\r\n    final int lengthOfLastBlock \u003d (int) (getBytesWritten() % blockSize);\r\n    if (lengthOfLastBlock !\u003d 0) {\r\n        pad(blockSize - lengthOfLastBlock);\r\n    }\r\n    super.finish();\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(i5 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveOutputStream\n  r0.checkOpen()\n  r0.checkFinished()\n  $r1 \u003d CpioArchiveEntry entry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IOException\n  new IOException(\"This archive contains unclosed entries.\")\n  throw $r6\n}",
      "B2 {\n  $r2 \u003d CpioArchiveEntry\n  $s0 \u003d CpioArchiveOutputStream: short entryFormat\u003e\n  new CpioArchiveEntry($s0)\n  CpioArchiveEntry entry\u003e \u003d $r2\n  $r3 \u003d CpioArchiveEntry entry\u003e\n  $r3.setName(\"TRAILER!!!\")\n  $r4 \u003d CpioArchiveEntry entry\u003e\n  $r4.setNumberOfLinks(1L)\n  $r5 \u003d CpioArchiveEntry entry\u003e\n  r0.writeHeader($r5)\n  r0.closeArchiveEntry()\n  $l3 \u003d r0.getBytesWritten()\n  $i1 \u003d CpioArchiveOutputStream: int blockSize\u003e\n  $l2 \u003d (long) $i1\n  $l4 \u003d $l3 % $l2\n  i5 \u003d (int) $l4\n  if (i5 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i6 \u003d CpioArchiveOutputStream: int blockSize\u003e\n  $i7 \u003d $i6 - i5\n  r0.pad($i7)\n}",
      "B4 {\n  r0.finish()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveOutputStream#writeHeader(...1)",
        "body": "{\r\n    switch(e.getFormat()) {\r\n        case FORMAT_NEW:\r\n            writeUsAsciiRaw(MAGIC_NEW);\r\n            count(6);\r\n            writeNewEntry(e);\r\n            break;\r\n        case FORMAT_NEW_CRC:\r\n            writeUsAsciiRaw(MAGIC_NEW_CRC);\r\n            count(6);\r\n            writeNewEntry(e);\r\n            break;\r\n        case FORMAT_OLD_ASCII:\r\n            writeUsAsciiRaw(MAGIC_OLD_ASCII);\r\n            count(6);\r\n            writeOldAsciiEntry(e);\r\n            break;\r\n        case FORMAT_OLD_BINARY:\r\n            final boolean swapHalfWord \u003d true;\r\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\r\n            writeOldBinaryEntry(e, swapHalfWord);\r\n            break;\r\n        default:\r\n            throw new IOException(\"Unknown format \" + e.getFormat());\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#getBytesWritten(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveOutputStream#closeArchiveEntry(...0)",
        "body": "{\r\n    checkFinished();\r\n    checkOpen();\r\n    if (entry \u003d\u003d null) {\r\n        throw new IOException(\"Trying to close non-existent entry\");\r\n    }\r\n    if (this.entry.getSize() !\u003d this.written) {\r\n        throw new IOException(\"Invalid entry size (expected \" + this.entry.getSize() + \" but got \" + this.written + \" bytes)\");\r\n    }\r\n    pad(this.entry.getDataPadCount());\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC \u0026\u0026 this.crc !\u003d this.entry.getChksum()) {\r\n        throw new IOException(\"CRC Error\");\r\n    }\r\n    this.entry \u003d null;\r\n    this.crc \u003d 0;\r\n    this.written \u003d 0;\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#pad(...1)",
        "body": "{\r\n    if (count \u003e 0) {\r\n        out.write(new byte[count]);\r\n        count(count);\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream",
    "methodName": "putArchiveEntry",
    "signature": "void putArchiveEntry(org.apache.commons.compress.archivers.cpio.CpioArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    checkOpen();\r\n    if (this.entry !\u003d null) {\r\n        // close previous entry\r\n        closeArchiveEntry();\r\n    }\r\n    if (entry.getTime() \u003d\u003d -1) {\r\n        entry.setTime(System.currentTimeMillis() / 1000);\r\n    }\r\n    final short format \u003d entry.getFormat();\r\n    if (format !\u003d this.entryFormat) {\r\n        throw new IOException(\"Header format: \" + format + \" does not match existing format: \" + this.entryFormat);\r\n    }\r\n    if (this.names.put(entry.getName(), entry) !\u003d null) {\r\n        throw new IOException(\"Duplicate entry: \" + entry.getName());\r\n    }\r\n    writeHeader(entry);\r\n    this.entry \u003d entry;\r\n    this.written \u003d 0;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($b1 !\u003d 0) → B3 | else → B4",
      "B4 : If($i7 \u003d\u003d $i8) → B5 | else → B6",
      "B6 : If($r5 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveOutputStream\n  CpioArchiveEntry\n  r0.checkFinished()\n  r0.checkOpen()\n  $r1 \u003d CpioArchiveEntry entry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.closeArchiveEntry()\n}",
      "B2 {\n  $l0 \u003d r2.getTime()\n  $b1 \u003d $l0 cmp -1L\n  if ($b1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $l4 \u003d System.currentTimeMillis()\n  $l5 \u003d $l4 / 1000L\n  r2.setTime($l5)\n}",
      "B4 {\n  $s6 \u003d r2.getFormat()\n  $s2 \u003d CpioArchiveOutputStream: short entryFormat\u003e\n  $i7 \u003d (int) $s6\n  $i8 \u003d (int) $s2\n  if ($i7 \u003d\u003d $i8) goto B5 else B6\n}",
      "B5 {\n  $r20 \u003d IOException\n  $r19 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r19.append(\"Header format: \")\n  $i9 \u003d (int) $s6\n  $r15 \u003d $r14.append($i9)\n  $r16 \u003d $r15.append(\" does not match existing format: \")\n  $s3 \u003d CpioArchiveOutputStream: short entryFormat\u003e\n  $i10 \u003d (int) $s3\n  $r17 \u003d $r16.append($i10)\n  $r18 \u003d $r17.toString()\n  new IOException($r18)\n  throw $r20\n}",
      "B6 {\n  $r3 \u003d HashMap names\u003e\n  $r4 \u003d r2.getName()\n  $r5 \u003d $r3.put($r4, r2)\n  if ($r5 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r22 \u003d IOException\n  $r21 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r21.append(\"Duplicate entry: \")\n  $r8 \u003d r2.getName()\n  $r10 \u003d $r9.append($r8)\n  $r11 \u003d $r10.toString()\n  new IOException($r11)\n  throw $r22\n}",
      "B8 {\n  r0.writeHeader(r2)\n  CpioArchiveEntry entry\u003e \u003d r2\n  CpioArchiveOutputStream: long written\u003e \u003d 0L\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveOutputStream#writeHeader(...1)",
        "body": "{\r\n    switch(e.getFormat()) {\r\n        case FORMAT_NEW:\r\n            writeUsAsciiRaw(MAGIC_NEW);\r\n            count(6);\r\n            writeNewEntry(e);\r\n            break;\r\n        case FORMAT_NEW_CRC:\r\n            writeUsAsciiRaw(MAGIC_NEW_CRC);\r\n            count(6);\r\n            writeNewEntry(e);\r\n            break;\r\n        case FORMAT_OLD_ASCII:\r\n            writeUsAsciiRaw(MAGIC_OLD_ASCII);\r\n            count(6);\r\n            writeOldAsciiEntry(e);\r\n            break;\r\n        case FORMAT_OLD_BINARY:\r\n            final boolean swapHalfWord \u003d true;\r\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\r\n            writeOldBinaryEntry(e, swapHalfWord);\r\n            break;\r\n        default:\r\n            throw new IOException(\"Unknown format \" + e.getFormat());\r\n    }\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveOutputStream#closeArchiveEntry(...0)",
        "body": "{\r\n    checkFinished();\r\n    checkOpen();\r\n    if (entry \u003d\u003d null) {\r\n        throw new IOException(\"Trying to close non-existent entry\");\r\n    }\r\n    if (this.entry.getSize() !\u003d this.written) {\r\n        throw new IOException(\"Invalid entry size (expected \" + this.entry.getSize() + \" but got \" + this.written + \" bytes)\");\r\n    }\r\n    pad(this.entry.getDataPadCount());\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC \u0026\u0026 this.crc !\u003d this.entry.getChksum()) {\r\n        throw new IOException(\"CRC Error\");\r\n    }\r\n    this.entry \u003d null;\r\n    this.crc \u003d 0;\r\n    this.written \u003d 0;\r\n}"
      },
      {
        "name": "CpioArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    checkOpen();\r\n    if (off \u003c 0 || len \u003c 0 || off \u003e b.length - len) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len \u003d\u003d 0) {\r\n        return;\r\n    }\r\n    if (this.entry \u003d\u003d null) {\r\n        throw new IOException(\"No current CPIO entry\");\r\n    }\r\n    if (this.written + len \u003e this.entry.getSize()) {\r\n        throw new IOException(\"Attempt to write past end of STORED entry\");\r\n    }\r\n    out.write(b, off, len);\r\n    this.written +\u003d len;\r\n    if (this.entry.getFormat() \u003d\u003d FORMAT_NEW_CRC) {\r\n        for (int pos \u003d 0; pos \u003c len; pos++) {\r\n            this.crc +\u003d b[pos] \u0026 0xFF;\r\n            this.crc \u0026\u003d 0xFFFFFFFFL;\r\n        }\r\n    }\r\n    count(len);\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B3",
      "B1 : If(i1 \u003c 0) → B2 | else → B3",
      "B2 : If(i0 \u003c\u003d $i3) → B3 | else → B4",
      "B4 : If(i1 !\u003d 0) → B5 | else → B6",
      "B6 : If($r2 !\u003d null) → B7 | else → B8",
      "B8 : If($i21 \u003c\u003d 0) → B9 | else → B10",
      "B10 : If($i22 !\u003d 2) → B11 | else → B14",
      "B12 : If(i20 \u003e\u003d i1) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  CpioArchiveOutputStream\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0.checkOpen()\n  if (i0 \u003c 0) goto B1 else B3\n}",
      "B1 {\n  if (i1 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d lengthof r1\n  $i3 \u003d $i2 - i1\n  if (i0 \u003c\u003d $i3) goto B3 else B4\n}",
      "B3 {\n  $r9 \u003d IndexOutOfBoundsException\n  new IndexOutOfBoundsException()\n  throw $r9\n}",
      "B4 {\n  if (i1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r2 \u003d CpioArchiveEntry entry\u003e\n  if ($r2 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d IOException\n  new IOException(\"No current CPIO entry\")\n  throw $r10\n}",
      "B8 {\n  $l5 \u003d CpioArchiveOutputStream: long written\u003e\n  $l4 \u003d (long) i1\n  $l7 \u003d $l5 + $l4\n  $r3 \u003d CpioArchiveEntry entry\u003e\n  $l6 \u003d $r3.getSize()\n  $b8 \u003d $l7 cmp $l6\n  $i21 \u003d (int) $b8\n  if ($i21 \u003c\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $r11 \u003d IOException\n  new IOException(\"Attempt to write past end of STORED entry\")\n  throw $r11\n}",
      "B10 {\n  $r4 \u003d OutputStream out\u003e\n  $r4.write(r1, i0, i1)\n  $l10 \u003d CpioArchiveOutputStream: long written\u003e\n  $l9 \u003d (long) i1\n  $l11 \u003d $l10 + $l9\n  CpioArchiveOutputStream: long written\u003e \u003d $l11\n  $r5 \u003d CpioArchiveEntry entry\u003e\n  $s12 \u003d $r5.getFormat()\n  $i22 \u003d (int) $s12\n  if ($i22 !\u003d 2) goto B11 else B14\n}",
      "B11 {\n  i20 \u003d 0\n}",
      "B12 {\n  if (i20 \u003e\u003d i1) goto B13 else B14\n}",
      "B13 {\n  $l16 \u003d CpioArchiveOutputStream: long crc\u003e\n  $b13 \u003d r1[i20]\n  $s23 \u003d (short) $b13\n  $s14 \u003d $s23 \u0026 255\n  $l15 \u003d (long) $s14\n  $l17 \u003d $l16 + $l15\n  CpioArchiveOutputStream: long crc\u003e \u003d $l17\n  $l18 \u003d CpioArchiveOutputStream: long crc\u003e\n  $l19 \u003d $l18 \u0026 4294967295L\n  CpioArchiveOutputStream: long crc\u003e \u003d $l19\n  i20 \u003d i20 + 1\n  goto B12\n}",
      "B14 {\n  r0.count(i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B12",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpioArchiveOutputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "CpioArchiveOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o \u003d\u003d this) {\r\n        return true;\r\n    }\r\n    if (o \u003d\u003d null || !o.getClass().equals(getClass())) {\r\n        return false;\r\n    }\r\n    final DumpArchiveEntry rhs \u003d (DumpArchiveEntry) o;\r\n    if (ino !\u003d rhs.ino) {\r\n        return false;\r\n    }\r\n    // summary is always null right now, but this may change some day\r\n    if (// NOSONAR\r\n    summary \u003d\u003d null \u0026\u0026 rhs.summary !\u003d null || summary !\u003d null \u0026\u0026 !summary.equals(rhs.summary)) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($z0 !\u003d 0) → B4 | else → B5",
      "B5 : If($i1 \u003d\u003d $i0) → B6 | else → B7",
      "B7 : If($r5 !\u003d null) → B8 | else → B9",
      "B8 : If($r9 !\u003d null) → B9 | else → B11",
      "B9 : If($r6 \u003d\u003d null) → B10 | else → B12",
      "B10 : If($z1 !\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  $z0 \u003d $r3.equals($r2)\n  if ($z0 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d DumpArchiveEntry) r0\n  $i1 \u003d DumpArchiveEntry: int ino\u003e\n  $i0 \u003d DumpArchiveEntry: int ino\u003e\n  if ($i1 \u003d\u003d $i0) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  $r5 \u003d DumpArchiveSummary summary\u003e\n  if ($r5 !\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d DumpArchiveSummary summary\u003e\n  if ($r9 !\u003d null) goto B9 else B11\n}",
      "B9 {\n  $r6 \u003d DumpArchiveSummary summary\u003e\n  if ($r6 \u003d\u003d null) goto B10 else B12\n}",
      "B10 {\n  $r8 \u003d DumpArchiveSummary summary\u003e\n  $r7 \u003d DumpArchiveSummary summary\u003e\n  $z1 \u003d $r8.equals($r7)\n  if ($z1 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DumpArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "getSize",
    "signature": "long getSize()",
    "visibility": "public",
    "body": "{\r\n    return isDirectory() ? SIZE_UNKNOWN : size;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $l0 \u003d -1L\n  goto B3\n}",
      "B2 {\n  $l0 \u003d DumpArchiveEntry: long size\u003e\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DumpArchiveEntry#isDirectory(...0)",
        "body": "{\r\n    return type \u003d\u003d TYPE.DIRECTORY;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isBlkDev",
    "signature": "boolean isBlkDev()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.BLKDEV;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE BLKDEV\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isChrDev",
    "signature": "boolean isChrDev()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.CHRDEV;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE CHRDEV\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isDirectory",
    "signature": "boolean isDirectory()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.DIRECTORY;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE DIRECTORY\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isFifo",
    "signature": "boolean isFifo()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.FIFO;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE FIFO\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isFile",
    "signature": "boolean isFile()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.FILE;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE FILE\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isSocket",
    "signature": "boolean isSocket()",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d TYPE.SOCKET;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  $r2 \u003d DumpArchiveEntry$TYPE type\u003e\n  $r1 \u003d DumpArchiveEntry$TYPE SOCKET\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "isSparseRecord",
    "signature": "boolean isSparseRecord(int)",
    "visibility": "public",
    "body": "{\r\n    return (header.getCdata(idx) \u0026 0x01) \u003d\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  i0 :\u003d @parameter0: int\n  $r1 \u003d DumpArchiveEntry$TapeSegmentHeader header\u003e\n  $i1 \u003d $r1.getCdata(i0)\n  $i2 \u003d $i1 \u0026 1\n  if ($i2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry",
    "methodName": "setName",
    "signature": "void setName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    this.originalName \u003d name;\r\n    if (name !\u003d null) {\r\n        if (isDirectory() \u0026\u0026 !name.endsWith(\"/\")) {\r\n            name +\u003d \"/\";\r\n        }\r\n        if (name.startsWith(\"./\")) {\r\n            name \u003d name.substring(2);\r\n        }\r\n    }\r\n    this.name \u003d name;\r\n}",
    "nodes": 7,
    "edges": 10,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r4 \u003d\u003d null) → B1 | else → B6",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveEntry\n  String\n  String originalName\u003e \u003d r4\n  if (r4 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $z1 \u003d r4.endsWith(\"/\")\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r1.append(r4)\n  $r3 \u003d $r2.append(\"/\")\n  r4 \u003d $r3.toString()\n}",
      "B4 {\n  $z2 \u003d r4.startsWith(\"./\")\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r4 \u003d r4.substring(2)\n}",
      "B6 {\n  String name\u003e \u003d r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DumpArchiveEntry#isDirectory(...0)",
        "body": "{\r\n    return type \u003d\u003d TYPE.DIRECTORY;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    // do we have enough of the header?\r\n    if (length \u003c 32) {\r\n        return false;\r\n    }\r\n    // this is the best test\r\n    if (length \u003e\u003d DumpArchiveConstants.TP_SIZE) {\r\n        return DumpArchiveUtil.verify(buffer);\r\n    }\r\n    // this will work in a pinch.\r\n    return DumpArchiveConstants.NFS_MAGIC \u003d\u003d DumpArchiveUtil.convert32(buffer, 24);\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 32) → B1 | else → B2",
      "B2 : If(i0 \u003c 1024) → B3 | else → B4",
      "B4 : If($i3 !\u003d $i1) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003e\u003d 32) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (i0 \u003c 1024) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d DumpArchiveUtil.verify(r0)\n  return\n}",
      "B4 {\n  $i1 \u003d DumpArchiveUtil.convert32(r0, 24)\n  $i3 \u003d (int) 60012\n  if ($i3 !\u003d $i1) goto B5 else B6\n}",
      "B5 {\n  $z1 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z1 \u003d 0\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!isClosed) {\r\n        isClosed \u003d true;\r\n        raw.close();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveInputStream\n  $z0 \u003d DumpArchiveInputStream: boolean isClosed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  DumpArchiveInputStream: boolean isClosed\u003e \u003d 1\n  $r1 \u003d TapeInputStream raw\u003e\n  $r1.close()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream",
    "methodName": "getNextEntry",
    "signature": "org.apache.commons.compress.archivers.dump.DumpArchiveEntry getNextEntry()",
    "visibility": "public",
    "body": "{\r\n    DumpArchiveEntry entry \u003d null;\r\n    String path \u003d null;\r\n    // is there anything in the queue?\r\n    if (!queue.isEmpty()) {\r\n        return queue.remove();\r\n    }\r\n    while (entry \u003d\u003d null) {\r\n        if (hasHitEOF) {\r\n            return null;\r\n        }\r\n        // skip any remaining records in this segment for prior file.\r\n        // we might still have holes... easiest to do it\r\n        // block by block. We may want to revisit this if\r\n        // the unnecessary decompression time adds up.\r\n        while (readIdx \u003c active.getHeaderCount()) {\r\n            if (!active.isSparseRecord(readIdx++) \u0026\u0026 raw.skip(DumpArchiveConstants.TP_SIZE) \u003d\u003d -1) {\r\n                throw new EOFException();\r\n            }\r\n        }\r\n        readIdx \u003d 0;\r\n        filepos \u003d raw.getBytesRead();\r\n        byte[] headerBytes \u003d raw.readRecord();\r\n        if (!DumpArchiveUtil.verify(headerBytes)) {\r\n            throw new InvalidFormatException();\r\n        }\r\n        active \u003d DumpArchiveEntry.parse(headerBytes);\r\n        // skip any remaining segments for prior file.\r\n        while (DumpArchiveConstants.SEGMENT_TYPE.ADDR \u003d\u003d active.getHeaderType()) {\r\n            if (raw.skip((long) DumpArchiveConstants.TP_SIZE * (active.getHeaderCount() - active.getHeaderHoles())) \u003d\u003d -1) {\r\n                throw new EOFException();\r\n            }\r\n            filepos \u003d raw.getBytesRead();\r\n            headerBytes \u003d raw.readRecord();\r\n            if (!DumpArchiveUtil.verify(headerBytes)) {\r\n                throw new InvalidFormatException();\r\n            }\r\n            active \u003d DumpArchiveEntry.parse(headerBytes);\r\n        }\r\n        // check if this is an end-of-volume marker.\r\n        if (DumpArchiveConstants.SEGMENT_TYPE.END \u003d\u003d active.getHeaderType()) {\r\n            hasHitEOF \u003d true;\r\n            return null;\r\n        }\r\n        entry \u003d active;\r\n        if (entry.isDirectory()) {\r\n            readDirectoryEntry(active);\r\n            // now we create an empty InputStream.\r\n            entryOffset \u003d 0;\r\n            entrySize \u003d 0;\r\n            readIdx \u003d active.getHeaderCount();\r\n        } else {\r\n            entryOffset \u003d 0;\r\n            entrySize \u003d active.getEntrySize();\r\n            readIdx \u003d 0;\r\n        }\r\n        recordOffset \u003d readBuf.length;\r\n        path \u003d getPath(entry);\r\n        if (path \u003d\u003d null) {\r\n            entry \u003d null;\r\n        }\r\n    }\r\n    entry.setName(path);\r\n    entry.setSimpleName(names.get(entry.getIno()).getName());\r\n    entry.setOffset(filepos);\r\n    return entry;\r\n}",
    "nodes": 27,
    "edges": 32,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(r36 !\u003d null) → B3 | else → B26",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($i18 \u003e\u003d $i19) → B6 | else → B9",
      "B6 : If($z5 !\u003d 0) → B7 | else → B5",
      "B7 : If($b17 !\u003d 0) → B8 | else → B5",
      "B9 : If($z2 !\u003d 0) → B10 | else → B11",
      "B12 : If($r11 !\u003d $r12) → B13 | else → B18",
      "B13 : If($b12 !\u003d 0) → B14 | else → B15",
      "B15 : If($z4 !\u003d 0) → B16 | else → B17",
      "B18 : If($r14 !\u003d $r15) → B19 | else → B20",
      "B20 : If($z3 \u003d\u003d false) → B21 | else → B22",
      "B23 : If($r20 !\u003d null) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveInputStream\n  r36 \u003d null\n  r37 \u003d null\n  $r1 \u003d Queue queue\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r33 \u003d Queue queue\u003e\n  $r34 \u003d $r33.remove()\n  $r35 \u003d DumpArchiveEntry) $r34\n  return\n}",
      "B2 {\n  if (r36 !\u003d null) goto B3 else B26\n}",
      "B3 {\n  $z1 \u003d DumpArchiveInputStream: boolean hasHitEOF\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i18 \u003d DumpArchiveInputStream: int readIdx\u003e\n  $r38 \u003d DumpArchiveEntry active\u003e\n  $i19 \u003d $r38.getHeaderCount()\n  if ($i18 \u003e\u003d $i19) goto B6 else B9\n}",
      "B6 {\n  $r30 \u003d DumpArchiveEntry active\u003e\n  $i14 \u003d DumpArchiveInputStream: int readIdx\u003e\n  $i15 \u003d $i14 + 1\n  DumpArchiveInputStream: int readIdx\u003e \u003d $i15\n  $z5 \u003d $r30.isSparseRecord($i14)\n  if ($z5 !\u003d 0) goto B7 else B5\n}",
      "B7 {\n  $r31 \u003d TapeInputStream raw\u003e\n  $l16 \u003d $r31.skip(1024L)\n  $b17 \u003d $l16 cmp -1L\n  if ($b17 !\u003d 0) goto B8 else B5\n}",
      "B8 {\n  $r32 \u003d EOFException\n  new EOFException()\n  throw $r32\n}",
      "B9 {\n  DumpArchiveInputStream: int readIdx\u003e \u003d 0\n  $r7 \u003d TapeInputStream raw\u003e\n  $l2 \u003d $r7.getBytesRead()\n  DumpArchiveInputStream: long filepos\u003e \u003d $l2\n  $r8 \u003d TapeInputStream raw\u003e\n  r39 \u003d $r8.readRecord()\n  $z2 \u003d DumpArchiveUtil.verify(r39)\n  if ($z2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $r29 \u003d InvalidFormatException\n  new InvalidFormatException()\n  throw $r29\n}",
      "B11 {\n  $r9 \u003d DumpArchiveEntry.parse(r39)\n  DumpArchiveEntry active\u003e \u003d $r9\n}",
      "B12 {\n  $r11 \u003d DumpArchiveConstants$SEGMENT_TYPE ADDR\u003e\n  $r10 \u003d DumpArchiveEntry active\u003e\n  $r12 \u003d $r10.getHeaderType()\n  if ($r11 !\u003d $r12) goto B13 else B18\n}",
      "B13 {\n  $r22 \u003d TapeInputStream raw\u003e\n  $r21 \u003d DumpArchiveEntry active\u003e\n  $i7 \u003d $r21.getHeaderCount()\n  $r23 \u003d DumpArchiveEntry active\u003e\n  $i6 \u003d $r23.getHeaderHoles()\n  $i8 \u003d $i7 - $i6\n  $l9 \u003d (long) $i8\n  $l10 \u003d 1024L * $l9\n  $l11 \u003d $r22.skip($l10)\n  $b12 \u003d $l11 cmp -1L\n  if ($b12 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r28 \u003d EOFException\n  new EOFException()\n  throw $r28\n}",
      "B15 {\n  $r24 \u003d TapeInputStream raw\u003e\n  $l13 \u003d $r24.getBytesRead()\n  DumpArchiveInputStream: long filepos\u003e \u003d $l13\n  $r25 \u003d TapeInputStream raw\u003e\n  r40 \u003d $r25.readRecord()\n  $z4 \u003d DumpArchiveUtil.verify(r40)\n  if ($z4 !\u003d 0) goto B16 else B17\n}",
      "B16 {\n  $r27 \u003d InvalidFormatException\n  new InvalidFormatException()\n  throw $r27\n}",
      "B17 {\n  $r26 \u003d DumpArchiveEntry.parse(r40)\n  DumpArchiveEntry active\u003e \u003d $r26\n  goto B12\n}",
      "B18 {\n  $r14 \u003d DumpArchiveConstants$SEGMENT_TYPE END\u003e\n  $r13 \u003d DumpArchiveEntry active\u003e\n  $r15 \u003d $r13.getHeaderType()\n  if ($r14 !\u003d $r15) goto B19 else B20\n}",
      "B19 {\n  DumpArchiveInputStream: boolean hasHitEOF\u003e \u003d 1\n  return\n}",
      "B20 {\n  r36 \u003d DumpArchiveEntry active\u003e\n  $z3 \u003d r36.isDirectory()\n  if ($z3 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  $r18 \u003d DumpArchiveEntry active\u003e\n  r0.readDirectoryEntry($r18)\n  DumpArchiveInputStream: long entryOffset\u003e \u003d 0L\n  DumpArchiveInputStream: long entrySize\u003e \u003d 0L\n  $r19 \u003d DumpArchiveEntry active\u003e\n  $i5 \u003d $r19.getHeaderCount()\n  DumpArchiveInputStream: int readIdx\u003e \u003d $i5\n  goto B23\n}",
      "B22 {\n  DumpArchiveInputStream: long entryOffset\u003e \u003d 0L\n  $r16 \u003d DumpArchiveEntry active\u003e\n  $l3 \u003d $r16.getEntrySize()\n  DumpArchiveInputStream: long entrySize\u003e \u003d $l3\n  DumpArchiveInputStream: int readIdx\u003e \u003d 0\n}",
      "B23 {\n  $r17 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i4 \u003d lengthof $r17\n  DumpArchiveInputStream: int recordOffset\u003e \u003d $i4\n  $r20 \u003d r0.getPath(r36)\n  r37 \u003d $r20\n  if ($r20 !\u003d null) goto B24 else B25\n}",
      "B24 {\n  r36 \u003d null\n}",
      "B25 {\n  goto B2\n}",
      "B26 {\n  r36.setName(r37)\n  $r2 \u003d Map names\u003e\n  $i0 \u003d r36.getIno()\n  $r3 \u003d Integer.valueOf($i0)\n  $r4 \u003d $r2.get($r3)\n  $r5 \u003d Dirent) $r4\n  $r6 \u003d $r5.getName()\n  r36.setSimpleName($r6)\n  $l1 \u003d DumpArchiveInputStream: long filepos\u003e\n  r36.setOffset($l1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B26",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B8",
      "B7 --\u003e B5",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B18",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B12",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B2",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DumpArchiveInputStream#getPath(...1)",
        "body": "{\r\n    // build the stack of elements. It\u0027s possible that we\u0027re\r\n    // still missing an intermediate value and if so we\r\n    final Stack\u003cString\u003e elements \u003d new Stack\u003c\u003e();\r\n    final BitSet visited \u003d new BitSet();\r\n    Dirent dirent \u003d null;\r\n    for (int i \u003d entry.getIno(); ; i \u003d dirent.getParentIno()) {\r\n        if (!names.containsKey(i)) {\r\n            elements.clear();\r\n            break;\r\n        }\r\n        if (visited.get(i)) {\r\n            throw new DumpArchiveException(\"Duplicate node \" + i);\r\n        }\r\n        dirent \u003d names.get(i);\r\n        visited.set(i);\r\n        elements.push(dirent.getName());\r\n        if (dirent.getIno() \u003d\u003d dirent.getParentIno()) {\r\n            break;\r\n        }\r\n    }\r\n    // if an element is missing defer the work and read next entry.\r\n    if (elements.isEmpty()) {\r\n        pending.put(entry.getIno(), entry);\r\n        return null;\r\n    }\r\n    // generate full path from stack of elements.\r\n    final StringBuilder sb \u003d new StringBuilder(elements.pop());\r\n    while (!elements.isEmpty()) {\r\n        sb.append(\u0027/\u0027);\r\n        sb.append(elements.pop());\r\n    }\r\n    return sb.toString();\r\n}"
      },
      {
        "name": "DumpArchiveInputStream#readDirectoryEntry(...1)",
        "body": "{\r\n    long size \u003d entry.getEntrySize();\r\n    boolean first \u003d true;\r\n    while (first || DumpArchiveConstants.SEGMENT_TYPE.ADDR \u003d\u003d entry.getHeaderType()) {\r\n        // read the header that we just peeked at.\r\n        if (!first) {\r\n            raw.readRecord();\r\n        }\r\n        if (!names.containsKey(entry.getIno()) \u0026\u0026 DumpArchiveConstants.SEGMENT_TYPE.INODE \u003d\u003d entry.getHeaderType()) {\r\n            pending.put(entry.getIno(), entry);\r\n        }\r\n        final int datalen \u003d DumpArchiveConstants.TP_SIZE * entry.getHeaderCount();\r\n        if (blockBuffer.length \u003c datalen) {\r\n            blockBuffer \u003d IOUtils.readRange(raw, datalen);\r\n            if (blockBuffer.length !\u003d datalen) {\r\n                throw new EOFException();\r\n            }\r\n        } else if (raw.read(blockBuffer, 0, datalen) !\u003d datalen) {\r\n            throw new EOFException();\r\n        }\r\n        int reclen \u003d 0;\r\n        for (int i \u003d 0; i \u003c datalen - 8 \u0026\u0026 i \u003c size - 8; i +\u003d reclen) {\r\n            final int ino \u003d DumpArchiveUtil.convert32(blockBuffer, i);\r\n            reclen \u003d DumpArchiveUtil.convert16(blockBuffer, i + 4);\r\n            if (reclen \u003d\u003d 0) {\r\n                throw new DumpArchiveException(\"reclen cannot be 0\");\r\n            }\r\n            final byte type \u003d blockBuffer[i + 6];\r\n            final String name \u003d DumpArchiveUtil.decode(zipEncoding, blockBuffer, i + 8, blockBuffer[i + 7]);\r\n            if (CURRENT_PATH_SEGMENT.equals(name) || PARENT_PATH_SEGMENT.equals(name)) {\r\n                // do nothing...\r\n                continue;\r\n            }\r\n            final Dirent d \u003d new Dirent(ino, entry.getIno(), type, name);\r\n            /*\r\n                 * if ((type \u003d\u003d 4) \u0026\u0026 names.containsKey(ino)) { System.out.println(\"we already have ino: \" + names.get(ino)); }\r\n                 */\r\n            names.put(ino, d);\r\n            // check whether this allows us to fill anything in the pending list.\r\n            for (final Map.Entry\u003cInteger, DumpArchiveEntry\u003e mapEntry : pending.entrySet()) {\r\n                final DumpArchiveEntry v \u003d mapEntry.getValue();\r\n                final String path \u003d getPath(v);\r\n                if (path !\u003d null) {\r\n                    v.setName(path);\r\n                    v.setSimpleName(names.get(mapEntry.getKey()).getName());\r\n                    queue.add(v);\r\n                }\r\n            }\r\n            // remove anything that we found. (We can\u0027t do it earlier\r\n            // because of concurrent modification exceptions.)\r\n            queue.forEach(e -\u003e pending.remove(e.getIno()));\r\n        }\r\n        final byte[] peekBytes \u003d raw.peek();\r\n        if (!DumpArchiveUtil.verify(peekBytes)) {\r\n            throw new InvalidFormatException();\r\n        }\r\n        entry \u003d DumpArchiveEntry.parse(peekBytes);\r\n        first \u003d false;\r\n        size -\u003d DumpArchiveConstants.TP_SIZE;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    int totalRead \u003d 0;\r\n    if (hasHitEOF || isClosed || entryOffset \u003e\u003d entrySize) {\r\n        return -1;\r\n    }\r\n    if (active \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current dump entry\");\r\n    }\r\n    if (len + entryOffset \u003e entrySize) {\r\n        len \u003d (int) (entrySize - entryOffset);\r\n    }\r\n    while (len \u003e 0) {\r\n        final int sz \u003d Math.min(len, readBuf.length - recordOffset);\r\n        // copy any data we have\r\n        if (recordOffset + sz \u003c\u003d readBuf.length) {\r\n            System.arraycopy(readBuf, recordOffset, buf, off, sz);\r\n            totalRead +\u003d sz;\r\n            recordOffset +\u003d sz;\r\n            len -\u003d sz;\r\n            off +\u003d sz;\r\n        }\r\n        // load next block if necessary.\r\n        if (len \u003e 0) {\r\n            if (readIdx \u003e\u003d 512) {\r\n                final byte[] headerBytes \u003d raw.readRecord();\r\n                if (!DumpArchiveUtil.verify(headerBytes)) {\r\n                    throw new InvalidFormatException();\r\n                }\r\n                active \u003d DumpArchiveEntry.parse(headerBytes);\r\n                readIdx \u003d 0;\r\n            }\r\n            if (!active.isSparseRecord(readIdx++)) {\r\n                final int r \u003d raw.read(readBuf, 0, readBuf.length);\r\n                if (r !\u003d readBuf.length) {\r\n                    throw new EOFException();\r\n                }\r\n            } else {\r\n                Arrays.fill(readBuf, (byte) 0);\r\n            }\r\n            recordOffset \u003d 0;\r\n        }\r\n    }\r\n    entryOffset +\u003d totalRead;\r\n    return totalRead;\r\n}",
    "nodes": 26,
    "edges": 33,
    "cc": 9,
    "flowSummary": [
      "B0 : If(i30 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B5",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B4 : If($i33 \u003c 0) → B5 | else → B6",
      "B6 : If($r1 !\u003d null) → B7 | else → B8",
      "B8 : If($i36 \u003c\u003d 0) → B9 | else → B10",
      "B10 : If(i30 \u003c\u003d 0) → B11 | else → B25",
      "B11 : If($i17 \u003e $i16) → B12 | else → B13",
      "B13 : If(i30 \u003c\u003d 0) → B14 | else → B24",
      "B14 : If($i18 \u003c 512) → B15 | else → B18",
      "B15 : If($z3 !\u003d 0) → B16 | else → B17",
      "B18 : If($z2 !\u003d 0) → B19 | else → B22",
      "B19 : If(i32 \u003d\u003d $i22) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveInputStream\n  r14 :\u003d @parameter0: byte[]\n  i29 :\u003d @parameter1: int\n  i30 :\u003d @parameter2: int\n  if (i30 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i31 \u003d 0\n  $z0 \u003d DumpArchiveInputStream: boolean hasHitEOF\u003e\n  if ($z0 !\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $z1 \u003d DumpArchiveInputStream: boolean isClosed\u003e\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $l1 \u003d DumpArchiveInputStream: long entryOffset\u003e\n  $l0 \u003d DumpArchiveInputStream: long entrySize\u003e\n  $b2 \u003d $l1 cmp $l0\n  $i33 \u003d (int) $b2\n  if ($i33 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  $i35 \u003d (int) -1\n  return\n}",
      "B6 {\n  $r1 \u003d DumpArchiveEntry active\u003e\n  if ($r1 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r18 \u003d IllegalStateException\n  new IllegalStateException(\"No current dump entry\")\n  throw $r18\n}",
      "B8 {\n  $l4 \u003d (long) i30\n  $l3 \u003d DumpArchiveInputStream: long entryOffset\u003e\n  $l6 \u003d $l4 + $l3\n  $l5 \u003d DumpArchiveInputStream: long entrySize\u003e\n  $b7 \u003d $l6 cmp $l5\n  $i36 \u003d (int) $b7\n  if ($i36 \u003c\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $l27 \u003d DumpArchiveInputStream: long entrySize\u003e\n  $l26 \u003d DumpArchiveInputStream: long entryOffset\u003e\n  $l28 \u003d $l27 - $l26\n  i30 \u003d (int) $l28\n}",
      "B10 {\n  if (i30 \u003c\u003d 0) goto B11 else B25\n}",
      "B11 {\n  $r2 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i12 \u003d lengthof $r2\n  $i11 \u003d DumpArchiveInputStream: int recordOffset\u003e\n  $i13 \u003d $i12 - $i11\n  i14 \u003d Math.min(i30, $i13)\n  $i15 \u003d DumpArchiveInputStream: int recordOffset\u003e\n  $i17 \u003d $i15 + i14\n  $r3 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i16 \u003d lengthof $r3\n  if ($i17 \u003e $i16) goto B12 else B13\n}",
      "B12 {\n  $r15 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i23 \u003d DumpArchiveInputStream: int recordOffset\u003e\n  System.arraycopy($r15, $i23, r14, i29, i14)\n  i31 \u003d i31 + i14\n  $i24 \u003d DumpArchiveInputStream: int recordOffset\u003e\n  $i25 \u003d $i24 + i14\n  DumpArchiveInputStream: int recordOffset\u003e \u003d $i25\n  i30 \u003d i30 - i14\n  i29 \u003d i29 + i14\n}",
      "B13 {\n  if (i30 \u003c\u003d 0) goto B14 else B24\n}",
      "B14 {\n  $i18 \u003d DumpArchiveInputStream: int readIdx\u003e\n  if ($i18 \u003c 512) goto B15 else B18\n}",
      "B15 {\n  $r11 \u003d TapeInputStream raw\u003e\n  r17 \u003d $r11.readRecord()\n  $z3 \u003d DumpArchiveUtil.verify(r17)\n  if ($z3 !\u003d 0) goto B16 else B17\n}",
      "B16 {\n  $r19 \u003d InvalidFormatException\n  new InvalidFormatException()\n  throw $r19\n}",
      "B17 {\n  $r12 \u003d DumpArchiveEntry.parse(r17)\n  DumpArchiveEntry active\u003e \u003d $r12\n  DumpArchiveInputStream: int readIdx\u003e \u003d 0\n}",
      "B18 {\n  $r4 \u003d DumpArchiveEntry active\u003e\n  $i19 \u003d DumpArchiveInputStream: int readIdx\u003e\n  $i20 \u003d $i19 + 1\n  DumpArchiveInputStream: int readIdx\u003e \u003d $i20\n  $z2 \u003d $r4.isSparseRecord($i19)\n  if ($z2 !\u003d 0) goto B19 else B22\n}",
      "B19 {\n  $r8 \u003d TapeInputStream raw\u003e\n  $r7 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $r6 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i21 \u003d lengthof $r6\n  i32 \u003d $r8.read($r7, 0, $i21)\n  $r9 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  $i22 \u003d lengthof $r9\n  if (i32 \u003d\u003d $i22) goto B20 else B21\n}",
      "B20 {\n  $r20 \u003d EOFException\n  new EOFException()\n  throw $r20\n}",
      "B21 {\n  goto B23\n}",
      "B22 {\n  $r5 \u003d DumpArchiveInputStream: byte[] readBuf\u003e\n  Arrays.fill($r5, 0)\n}",
      "B23 {\n  DumpArchiveInputStream: int recordOffset\u003e \u003d 0\n}",
      "B24 {\n  goto B10\n}",
      "B25 {\n  $l9 \u003d DumpArchiveInputStream: long entryOffset\u003e\n  $l8 \u003d (long) i31\n  $l10 \u003d $l9 + $l8\n  DumpArchiveInputStream: long entryOffset\u003e \u003d $l10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B25",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B24",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B24 --\u003e B10",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final DumpArchiveSummary other \u003d (DumpArchiveSummary) obj;\r\n    return Objects.equals(devname, other.devname) \u0026\u0026 dumpDate \u003d\u003d other.dumpDate \u0026\u0026 Objects.equals(hostname, other.hostname);\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B9",
      "B6 : If($b2 !\u003d 0) → B7 | else → B9",
      "B7 : If($z1 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d DumpArchiveSummary) r1\n  $r6 \u003d String devname\u003e\n  $r5 \u003d String devname\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B9\n}",
      "B6 {\n  $l1 \u003d DumpArchiveSummary: long dumpDate\u003e\n  $l0 \u003d DumpArchiveSummary: long dumpDate\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B7 else B9\n}",
      "B7 {\n  $r8 \u003d String hostname\u003e\n  $r7 \u003d String hostname\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $z2 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z2 \u003d 0\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DumpArchiveSummary#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "isCompressed",
    "signature": "boolean isCompressed()",
    "visibility": "public",
    "body": "{\r\n    return (flags \u0026 0x0080) \u003d\u003d 0x0080;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 128) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  $i0 \u003d DumpArchiveSummary: int flags\u003e\n  $i1 \u003d $i0 \u0026 128\n  if ($i1 !\u003d 128) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "isExtendedAttributes",
    "signature": "boolean isExtendedAttributes()",
    "visibility": "public",
    "body": "{\r\n    return (flags \u0026 0x8000) \u003d\u003d 0x8000;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  $i0 \u003d DumpArchiveSummary: int flags\u003e\n  $i3 \u003d (int) 32768\n  $i1 \u003d $i0 \u0026 $i3\n  $i5 \u003d (int) 32768\n  if ($i1 !\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "isMetaDataOnly",
    "signature": "boolean isMetaDataOnly()",
    "visibility": "public",
    "body": "{\r\n    return (flags \u0026 0x0100) \u003d\u003d 0x0100;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 256) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  $i0 \u003d DumpArchiveSummary: int flags\u003e\n  $i1 \u003d $i0 \u0026 256\n  if ($i1 !\u003d 256) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "isNewHeader",
    "signature": "boolean isNewHeader()",
    "visibility": "public",
    "body": "{\r\n    return (flags \u0026 0x0001) \u003d\u003d 0x0001;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  $i0 \u003d DumpArchiveSummary: int flags\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.dump.DumpArchiveSummary",
    "methodName": "isNewInode",
    "signature": "boolean isNewInode()",
    "visibility": "public",
    "body": "{\r\n    return (flags \u0026 0x0002) \u003d\u003d 0x0002;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DumpArchiveSummary\n  $i0 \u003d DumpArchiveSummary: int flags\u003e\n  $i1 \u003d $i0 \u0026 2\n  if ($i1 !\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.examples.Archiver",
    "methodName": "create",
    "signature": "void create(java.lang.String,java.nio.file.Path,java.nio.file.Path)",
    "visibility": "public",
    "body": "{\r\n    if (prefersSeekableByteChannel(format)) {\r\n        try (SeekableByteChannel channel \u003d FileChannel.open(target, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n            create(format, channel, directory);\r\n            return;\r\n        }\r\n    }\r\n    try (// ArchiveOutputStream wraps newOutputStream result\r\n    @SuppressWarnings(\"resource\") ArchiveOutputStream\u003c?\u003e outputStream \u003d ArchiveStreamFactory.DEFAULT.createArchiveOutputStream(format, Files.newOutputStream(target))) {\r\n        create(outputStream, directory, EMPTY_FileVisitOption);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 16,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B1 : If(r17 \u003d\u003d null) → B2 | else → B3",
      "B4 : If(r17 \u003d\u003d null) → B5 | else → B7",
      "B8 : If(r18 \u003d\u003d null) → B9 | else → B14",
      "B10 : If(r18 \u003d\u003d null) → B11 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Archiver\n  String\n  Path\n  Path\n  $z0 \u003d r0.prefersSeekableByteChannel(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  $r9 \u003d OpenOption)[3]\n  $r10 \u003d StandardOpenOption WRITE\u003e\n  $r9[0] \u003d $r10\n  $r11 \u003d StandardOpenOption CREATE\u003e\n  $r9[1] \u003d $r11\n  $r12 \u003d StandardOpenOption TRUNCATE_EXISTING\u003e\n  $r9[2] \u003d $r12\n  r17 \u003d FileChannel.open(r2, $r9)\n  r0.create(r1, r17, r6)\n  if (r17 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  r17.close()\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r16 :\u003d @caughtexception\n  if (r17 \u003d\u003d null) goto B5 else B7\n}",
      "B5 {\n  r17.close()\n  goto B7\n}",
      "B6 {\n  $r15 :\u003d @caughtexception\n  $r16.addSuppressed($r15)\n}",
      "B7 {\n  throw $r16\n}",
      "B8 {\n  $r4 \u003d ArchiveStreamFactory DEFAULT\u003e\n  $r3 \u003d OpenOption)[0]\n  $r5 \u003d Files.newOutputStream(r2, $r3)\n  r18 \u003d $r4.createArchiveOutputStream(r1, $r5)\n  $r8 \u003d EnumSet EMPTY_FileVisitOption\u003e\n  $r7 \u003d LinkOption)[0]\n  r0.create(r18, r6, $r8, $r7)\n  if (r18 \u003d\u003d null) goto B9 else B14\n}",
      "B9 {\n  r18.close()\n  goto B14\n}",
      "B10 {\n  $r14 :\u003d @caughtexception\n  if (r18 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  r18.close()\n  goto B13\n}",
      "B12 {\n  $r13 :\u003d @caughtexception\n  $r14.addSuppressed($r13)\n}",
      "B13 {\n  throw $r14\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Archiver#create(...3)",
        "body": "{\r\n    create(format, target.toPath(), directory.toPath());\r\n}"
      },
      {
        "name": "Archiver#prefersSeekableByteChannel(...1)",
        "body": "{\r\n    return ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.examples.Archiver",
    "methodName": "create",
    "signature": "void create(java.lang.String,java.nio.channels.SeekableByteChannel,java.io.File,org.apache.commons.compress.archivers.examples.CloseableConsumer)",
    "visibility": "public",
    "body": "{\r\n    try (CloseableConsumerAdapter c \u003d new CloseableConsumerAdapter(closeableConsumer)) {\r\n        if (!prefersSeekableByteChannel(format)) {\r\n            create(format, c.track(Channels.newOutputStream(target)), directory);\r\n        } else if (ArchiveStreamFactory.ZIP.equalsIgnoreCase(format)) {\r\n            create(c.track(new ZipArchiveOutputStream(target)), directory);\r\n        } else if (ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format)) {\r\n            create(c.track(new SevenZOutputFile(target)), directory);\r\n        } else {\r\n            // never reached as prefersSeekableByteChannel only returns true for ZIP and 7z\r\n            throw new ArchiveException(\"Don\u0027t know how to handle format \" + format);\r\n        }\r\n    }\r\n}",
    "nodes": 12,
    "edges": 12,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Archiver\n  String\n  SeekableByteChannel\n  File\n  CloseableConsumer\n  $r0 \u003d CloseableConsumerAdapter\n  new CloseableConsumerAdapter(r1)\n  $z0 \u003d r2.prefersSeekableByteChannel(r3)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r19 \u003d Channels.newOutputStream(r12)\n  $r20 \u003d $r0.track($r19)\n  $r21 \u003d OutputStream) $r20\n  r2.create(r3, $r21, r14)\n  goto B7\n}",
      "B2 {\n  $r4 \u003d \"zip\"\n  $z1 \u003d $r4.equalsIgnoreCase(r3)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r16 \u003d ZipArchiveOutputStream\n  new ZipArchiveOutputStream(r12)\n  $r17 \u003d $r0.track($r16)\n  $r18 \u003d ArchiveOutputStream) $r17\n  r2.create($r18, r14)\n  goto B7\n}",
      "B4 {\n  $r5 \u003d \"7z\"\n  $z2 \u003d $r5.equalsIgnoreCase(r3)\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r11 \u003d SevenZOutputFile\n  new SevenZOutputFile(r12)\n  $r13 \u003d $r0.track($r11)\n  $r15 \u003d SevenZOutputFile) $r13\n  r2.create($r15, r14)\n  goto B7\n}",
      "B6 {\n  $r6 \u003d ArchiveException\n  $r7 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r7.append(\"Don\\\u0027t know how to handle format \")\n  $r9 \u003d $r8.append(r3)\n  $r10 \u003d $r9.toString()\n  new ArchiveException($r10)\n  throw $r6\n}",
      "B7 {\n  $r0.close()\n  goto B11\n}",
      "B8 {\n  $r23 :\u003d @caughtexception\n  $r0.close()\n  goto B10\n}",
      "B9 {\n  $r22 :\u003d @caughtexception\n  $r23.addSuppressed($r22)\n}",
      "B10 {\n  throw $r23\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B11",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Archiver#create(...3)",
        "body": "{\r\n    create(format, target.toPath(), directory.toPath());\r\n}"
      },
      {
        "name": "Archiver#create(...2)",
        "body": "{\r\n    create(target, directory.toPath(), EMPTY_FileVisitOption);\r\n}"
      },
      {
        "name": "Archiver#prefersSeekableByteChannel(...1)",
        "body": "{\r\n    return ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.examples.Expander",
    "methodName": "expand",
    "signature": "void expand(java.lang.String,java.nio.file.Path,java.nio.file.Path)",
    "visibility": "public",
    "body": "{\r\n    if (prefersSeekableByteChannel(format)) {\r\n        try (SeekableByteChannel channel \u003d FileChannel.open(archive, StandardOpenOption.READ)) {\r\n            expand(format, channel, targetDirectory, CloseableConsumer.CLOSING_CONSUMER);\r\n        }\r\n        return;\r\n    }\r\n    try (InputStream inputStream \u003d new BufferedInputStream(Files.newInputStream(archive))) {\r\n        expand(format, inputStream, targetDirectory, CloseableConsumer.CLOSING_CONSUMER);\r\n    }\r\n}",
    "nodes": 13,
    "edges": 12,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B1 : If(r15 \u003d\u003d null) → B2 | else → B7",
      "B3 : If(r15 \u003d\u003d null) → B4 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Expander\n  String\n  Path\n  Path\n  $z0 \u003d r0.prefersSeekableByteChannel(r1)\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  $r8 \u003d OpenOption)[1]\n  $r9 \u003d StandardOpenOption READ\u003e\n  $r8[0] \u003d $r9\n  r15 \u003d FileChannel.open(r3, $r8)\n  $r10 \u003d CloseableConsumer CLOSING_CONSUMER\u003e\n  r0.expand(r1, r15, r6, $r10)\n  if (r15 \u003d\u003d null) goto B2 else B7\n}",
      "B2 {\n  r15.close()\n  goto B7\n}",
      "B3 {\n  $r14 :\u003d @caughtexception\n  if (r15 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  r15.close()\n  goto B6\n}",
      "B5 {\n  $r13 :\u003d @caughtexception\n  $r14.addSuppressed($r13)\n}",
      "B6 {\n  throw $r14\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r2 \u003d BufferedInputStream\n  $r4 \u003d OpenOption)[0]\n  $r5 \u003d Files.newInputStream(r3, $r4)\n  new BufferedInputStream($r5)\n  $r7 \u003d CloseableConsumer CLOSING_CONSUMER\u003e\n  r0.expand(r1, $r2, r6, $r7)\n  $r2.close()\n  goto B12\n}",
      "B9 {\n  $r12 :\u003d @caughtexception\n  $r2.close()\n  goto B11\n}",
      "B10 {\n  $r11 :\u003d @caughtexception\n  $r12.addSuppressed($r11)\n}",
      "B11 {\n  throw $r12\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B12",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Expander#expand(...4)",
        "body": "{\r\n    expand(format, archive, toPath(targetDirectory), closeableConsumer);\r\n}"
      },
      {
        "name": "Expander#prefersSeekableByteChannel(...1)",
        "body": "{\r\n    return ArchiveStreamFactory.TAR.equalsIgnoreCase(format) || ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.examples.Expander",
    "methodName": "expand",
    "signature": "void expand(java.lang.String,java.nio.channels.SeekableByteChannel,java.nio.file.Path,org.apache.commons.compress.archivers.examples.CloseableConsumer)",
    "visibility": "public",
    "body": "{\r\n    try (CloseableConsumerAdapter c \u003d new CloseableConsumerAdapter(closeableConsumer)) {\r\n        if (!prefersSeekableByteChannel(format)) {\r\n            expand(format, c.track(Channels.newInputStream(archive)), targetDirectory, CloseableConsumer.NULL_CONSUMER);\r\n        } else if (ArchiveStreamFactory.TAR.equalsIgnoreCase(format)) {\r\n            expand(c.track(new TarFile(archive)), targetDirectory);\r\n        } else if (ArchiveStreamFactory.ZIP.equalsIgnoreCase(format)) {\r\n            expand(c.track(ZipFile.builder().setSeekableByteChannel(archive).get()), targetDirectory);\r\n        } else if (ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format)) {\r\n            expand(c.track(SevenZFile.builder().setSeekableByteChannel(archive).get()), targetDirectory);\r\n        } else {\r\n            // never reached as prefersSeekableByteChannel only returns true for TAR, ZIP and 7z\r\n            throw new ArchiveException(\"Don\u0027t know how to handle format \" + format);\r\n        }\r\n    }\r\n}",
    "nodes": 14,
    "edges": 15,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z3 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  Expander\n  String\n  SeekableByteChannel\n  Path\n  CloseableConsumer\n  $r0 \u003d CloseableConsumerAdapter\n  new CloseableConsumerAdapter(r1)\n  $z0 \u003d r2.prefersSeekableByteChannel(r3)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r27 \u003d Channels.newInputStream(r12)\n  $r28 \u003d $r0.track($r27)\n  $r30 \u003d InputStream) $r28\n  $r29 \u003d CloseableConsumer NULL_CONSUMER\u003e\n  r2.expand(r3, $r30, r17, $r29)\n  goto B9\n}",
      "B2 {\n  $r4 \u003d \"tar\"\n  $z1 \u003d $r4.equalsIgnoreCase(r3)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r24 \u003d TarFile\n  new TarFile(r12)\n  $r25 \u003d $r0.track($r24)\n  $r26 \u003d TarFile) $r25\n  r2.expand($r26, r17)\n  goto B9\n}",
      "B4 {\n  $r5 \u003d \"zip\"\n  $z2 \u003d $r5.equalsIgnoreCase(r3)\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r19 \u003d ZipFile.builder()\n  $r20 \u003d $r19.setSeekableByteChannel(r12)\n  $r21 \u003d $r20.get()\n  $r22 \u003d $r0.track($r21)\n  $r23 \u003d ZipFile) $r22\n  r2.expand($r23, r17)\n  goto B9\n}",
      "B6 {\n  $r6 \u003d \"7z\"\n  $z3 \u003d $r6.equalsIgnoreCase(r3)\n  if ($z3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r13 \u003d SevenZFile.builder()\n  $r14 \u003d $r13.setSeekableByteChannel(r12)\n  $r15 \u003d $r14.get()\n  $r16 \u003d $r0.track($r15)\n  $r18 \u003d SevenZFile) $r16\n  r2.expand($r18, r17)\n  goto B9\n}",
      "B8 {\n  $r7 \u003d ArchiveException\n  $r8 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r8.append(\"Don\\\u0027t know how to handle format \")\n  $r10 \u003d $r9.append(r3)\n  $r11 \u003d $r10.toString()\n  new ArchiveException($r11)\n  throw $r7\n}",
      "B9 {\n  $r0.close()\n  goto B13\n}",
      "B10 {\n  $r32 :\u003d @caughtexception\n  $r0.close()\n  goto B12\n}",
      "B11 {\n  $r31 :\u003d @caughtexception\n  $r32.addSuppressed($r31)\n}",
      "B12 {\n  throw $r32\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B13",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Expander#expand(...4)",
        "body": "{\r\n    expand(format, archive, toPath(targetDirectory), closeableConsumer);\r\n}"
      },
      {
        "name": "Expander#expand(...2)",
        "body": "{\r\n    expand(archive, toPath(targetDirectory));\r\n}"
      },
      {
        "name": "Expander#prefersSeekableByteChannel(...1)",
        "body": "{\r\n    return ArchiveStreamFactory.TAR.equalsIgnoreCase(format) || ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream",
    "methodName": "getNextJarEntry",
    "signature": "org.apache.commons.compress.archivers.jar.JarArchiveEntry getNextJarEntry()",
    "visibility": "public",
    "body": "{\r\n    final ZipArchiveEntry entry \u003d getNextZipEntry();\r\n    return entry \u003d\u003d null ? null : new JarArchiveEntry(entry);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JarArchiveInputStream\n  r1 \u003d r0.getNextZipEntry()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d JarArchiveEntry\n  new JarArchiveEntry(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JarArchiveInputStream#getNextZipEntry(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStream",
    "methodName": "putArchiveEntry",
    "signature": "void putArchiveEntry(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    if (!jarMarkerAdded) {\r\n        entry.addAsFirstExtraField(JarMarker.getInstance());\r\n        jarMarkerAdded \u003d true;\r\n    }\r\n    super.putArchiveEntry(entry);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JarArchiveOutputStream\n  ZipArchiveEntry\n  $z0 \u003d JarArchiveOutputStream: boolean jarMarkerAdded\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JarMarker.getInstance()\n  r1.addAsFirstExtraField($r2)\n  JarArchiveOutputStream: boolean jarMarkerAdded\u003e \u003d 1\n}",
      "B2 {\n  r0.putArchiveEntry(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.Lister",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    if (ArrayUtils.isEmpty(args)) {\r\n        usage();\r\n        return;\r\n    }\r\n    new Lister(false, args).go();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $z0 \u003d ArrayUtils.isEmpty(r0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  Lister.usage()\n  return\n}",
      "B2 {\n  $r1 \u003d Lister\n  new Lister(0, r0)\n  $r1.go()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Lister#usage(...0)",
        "body": "{\r\n    System.err.println(\"Parameters: archive-name [archive-type]\\n\");\r\n    System.err.println(\"The magic archive-type \u0027zipfile\u0027 prefers ZipFile over ZipArchiveInputStream\");\r\n    System.err.println(\"The magic archive-type \u0027tarfile\u0027 prefers TarFile over TarArchiveInputStream\");\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.CLI",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    if (ArrayUtils.isEmpty(args)) {\r\n        usage();\r\n        return;\r\n    }\r\n    final Mode mode \u003d grabMode(args);\r\n    System.out.println(mode.getMessage() + \" \" + args[0]);\r\n    final File file \u003d new File(args[0]);\r\n    if (!file.isFile()) {\r\n        System.err.println(file + \" doesn\u0027t exist or is a directory\");\r\n    }\r\n    try (SevenZFile archive \u003d SevenZFile.builder().setFile(file).get()) {\r\n        SevenZArchiveEntry ae;\r\n        while ((ae \u003d archive.getNextEntry()) !\u003d null) {\r\n            mode.takeAction(archive, ae);\r\n        }\r\n    }\r\n}",
    "nodes": 14,
    "edges": 16,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4",
      "B5 : If($r23 \u003d\u003d null) → B6 | else → B7",
      "B7 : If($r20 \u003d\u003d null) → B8 | else → B13",
      "B9 : If($r20 \u003d\u003d null) → B10 | else → B12"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $z0 \u003d ArrayUtils.isEmpty(r0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  CLI.usage()\n  return\n}",
      "B2 {\n  r1 \u003d CLI.grabMode(r0)\n  $r3 \u003d PrintStream out\u003e\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d r1.getMessage()\n  $r5 \u003d $r2.append($r4)\n  $r7 \u003d $r5.append(\" \")\n  $r6 \u003d r0[0]\n  $r8 \u003d $r7.append($r6)\n  $r9 \u003d $r8.toString()\n  $r3.println($r9)\n  $r10 \u003d File\n  $r11 \u003d r0[0]\n  new File($r11)\n  $z1 \u003d $r10.isFile()\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r16 \u003d PrintStream err\u003e\n  $r15 \u003d StringBuilder\n  new StringBuilder()\n  $r17 \u003d $r15.append($r10)\n  $r18 \u003d $r17.append(\" doesn\\\u0027t exist or is a directory\")\n  $r19 \u003d $r18.toString()\n  $r16.println($r19)\n}",
      "B4 {\n  $r12 \u003d SevenZFile.builder()\n  $r13 \u003d $r12.setFile($r10)\n  $r14 \u003d SevenZFile$Builder) $r13\n  $r20 \u003d $r14.get()\n}",
      "B5 {\n  $r23 \u003d $r20.getNextEntry()\n  if ($r23 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  r1.takeAction($r20, $r23)\n  goto B5\n}",
      "B7 {\n  if ($r20 \u003d\u003d null) goto B8 else B13\n}",
      "B8 {\n  $r20.close()\n  goto B13\n}",
      "B9 {\n  $r22 :\u003d @caughtexception\n  if ($r20 \u003d\u003d null) goto B10 else B12\n}",
      "B10 {\n  $r20.close()\n  goto B12\n}",
      "B11 {\n  $r21 :\u003d @caughtexception\n  $r22.addSuppressed($r21)\n}",
      "B12 {\n  throw $r22\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B8",
      "B7 --\u003e B13",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CLI#grabMode(...1)",
        "body": "{\r\n    if (args.length \u003c 2) {\r\n        return Mode.LIST;\r\n    }\r\n    return Enum.valueOf(Mode.class, args[1].toUpperCase(Locale.ROOT));\r\n}"
      },
      {
        "name": "CLI#usage(...0)",
        "body": "{\r\n    System.out.println(\"Parameters: archive-name [list]\");\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final SevenZArchiveEntry other \u003d (SevenZArchiveEntry) obj;\r\n    return Objects.equals(name, other.name) \u0026\u0026 hasStream \u003d\u003d other.hasStream \u0026\u0026 isDirectory \u003d\u003d other.isDirectory \u0026\u0026 isAntiItem \u003d\u003d other.isAntiItem \u0026\u0026 hasCreationDate \u003d\u003d other.hasCreationDate \u0026\u0026 hasLastModifiedDate \u003d\u003d other.hasLastModifiedDate \u0026\u0026 hasAccessDate \u003d\u003d other.hasAccessDate \u0026\u0026 Objects.equals(creationDate, other.creationDate) \u0026\u0026 Objects.equals(lastModifiedDate, other.lastModifiedDate) \u0026\u0026 Objects.equals(accessDate, other.accessDate) \u0026\u0026 hasWindowsAttributes \u003d\u003d other.hasWindowsAttributes \u0026\u0026 windowsAttributes \u003d\u003d other.windowsAttributes \u0026\u0026 hasCrc \u003d\u003d other.hasCrc \u0026\u0026 crc \u003d\u003d other.crc \u0026\u0026 compressedCrc \u003d\u003d other.compressedCrc \u0026\u0026 size \u003d\u003d other.size \u0026\u0026 compressedSize \u003d\u003d other.compressedSize \u0026\u0026 equalSevenZMethods(contentMethods, other.contentMethods);\r\n}",
    "nodes": 26,
    "edges": 44,
    "cc": 20,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B24",
      "B6 : If($z2 !\u003d $z1) → B7 | else → B24",
      "B7 : If($z4 !\u003d $z3) → B8 | else → B24",
      "B8 : If($z6 !\u003d $z5) → B9 | else → B24",
      "B9 : If($z8 !\u003d $z7) → B10 | else → B24",
      "B10 : If($z10 !\u003d $z9) → B11 | else → B24",
      "B11 : If($z12 !\u003d $z11) → B12 | else → B24",
      "B12 : If($z13 \u003d\u003d false) → B13 | else → B24",
      "B13 : If($z14 \u003d\u003d false) → B14 | else → B24",
      "B14 : If($z15 \u003d\u003d false) → B15 | else → B24",
      "B15 : If($z17 !\u003d $z16) → B16 | else → B24",
      "B16 : If($i1 !\u003d $i0) → B17 | else → B24",
      "B17 : If($z19 !\u003d $z18) → B18 | else → B24",
      "B18 : If($b4 !\u003d 0) → B19 | else → B24",
      "B19 : If($b7 !\u003d 0) → B20 | else → B24",
      "B20 : If($b10 !\u003d 0) → B21 | else → B24",
      "B21 : If($b13 !\u003d 0) → B22 | else → B24",
      "B22 : If($z20 \u003d\u003d false) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d SevenZArchiveEntry) r1\n  $r6 \u003d String name\u003e\n  $r5 \u003d String name\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B24\n}",
      "B6 {\n  $z2 \u003d SevenZArchiveEntry: boolean hasStream\u003e\n  $z1 \u003d SevenZArchiveEntry: boolean hasStream\u003e\n  if ($z2 !\u003d $z1) goto B7 else B24\n}",
      "B7 {\n  $z4 \u003d SevenZArchiveEntry: boolean isDirectory\u003e\n  $z3 \u003d SevenZArchiveEntry: boolean isDirectory\u003e\n  if ($z4 !\u003d $z3) goto B8 else B24\n}",
      "B8 {\n  $z6 \u003d SevenZArchiveEntry: boolean isAntiItem\u003e\n  $z5 \u003d SevenZArchiveEntry: boolean isAntiItem\u003e\n  if ($z6 !\u003d $z5) goto B9 else B24\n}",
      "B9 {\n  $z8 \u003d SevenZArchiveEntry: boolean hasCreationDate\u003e\n  $z7 \u003d SevenZArchiveEntry: boolean hasCreationDate\u003e\n  if ($z8 !\u003d $z7) goto B10 else B24\n}",
      "B10 {\n  $z10 \u003d SevenZArchiveEntry: boolean hasLastModifiedDate\u003e\n  $z9 \u003d SevenZArchiveEntry: boolean hasLastModifiedDate\u003e\n  if ($z10 !\u003d $z9) goto B11 else B24\n}",
      "B11 {\n  $z12 \u003d SevenZArchiveEntry: boolean hasAccessDate\u003e\n  $z11 \u003d SevenZArchiveEntry: boolean hasAccessDate\u003e\n  if ($z12 !\u003d $z11) goto B12 else B24\n}",
      "B12 {\n  $r8 \u003d FileTime creationDate\u003e\n  $r7 \u003d FileTime creationDate\u003e\n  $z13 \u003d Objects.equals($r8, $r7)\n  if ($z13 \u003d\u003d false) goto B13 else B24\n}",
      "B13 {\n  $r10 \u003d FileTime lastModifiedDate\u003e\n  $r9 \u003d FileTime lastModifiedDate\u003e\n  $z14 \u003d Objects.equals($r10, $r9)\n  if ($z14 \u003d\u003d false) goto B14 else B24\n}",
      "B14 {\n  $r12 \u003d FileTime accessDate\u003e\n  $r11 \u003d FileTime accessDate\u003e\n  $z15 \u003d Objects.equals($r12, $r11)\n  if ($z15 \u003d\u003d false) goto B15 else B24\n}",
      "B15 {\n  $z17 \u003d SevenZArchiveEntry: boolean hasWindowsAttributes\u003e\n  $z16 \u003d SevenZArchiveEntry: boolean hasWindowsAttributes\u003e\n  if ($z17 !\u003d $z16) goto B16 else B24\n}",
      "B16 {\n  $i1 \u003d SevenZArchiveEntry: int windowsAttributes\u003e\n  $i0 \u003d SevenZArchiveEntry: int windowsAttributes\u003e\n  if ($i1 !\u003d $i0) goto B17 else B24\n}",
      "B17 {\n  $z19 \u003d SevenZArchiveEntry: boolean hasCrc\u003e\n  $z18 \u003d SevenZArchiveEntry: boolean hasCrc\u003e\n  if ($z19 !\u003d $z18) goto B18 else B24\n}",
      "B18 {\n  $l3 \u003d SevenZArchiveEntry: long crc\u003e\n  $l2 \u003d SevenZArchiveEntry: long crc\u003e\n  $b4 \u003d $l3 cmp $l2\n  if ($b4 !\u003d 0) goto B19 else B24\n}",
      "B19 {\n  $l6 \u003d SevenZArchiveEntry: long compressedCrc\u003e\n  $l5 \u003d SevenZArchiveEntry: long compressedCrc\u003e\n  $b7 \u003d $l6 cmp $l5\n  if ($b7 !\u003d 0) goto B20 else B24\n}",
      "B20 {\n  $l9 \u003d SevenZArchiveEntry: long size\u003e\n  $l8 \u003d SevenZArchiveEntry: long size\u003e\n  $b10 \u003d $l9 cmp $l8\n  if ($b10 !\u003d 0) goto B21 else B24\n}",
      "B21 {\n  $l12 \u003d SevenZArchiveEntry: long compressedSize\u003e\n  $l11 \u003d SevenZArchiveEntry: long compressedSize\u003e\n  $b13 \u003d $l12 cmp $l11\n  if ($b13 !\u003d 0) goto B22 else B24\n}",
      "B22 {\n  $r14 \u003d Iterable contentMethods\u003e\n  $r13 \u003d Iterable contentMethods\u003e\n  $z20 \u003d r0.equalSevenZMethods($r14, $r13)\n  if ($z20 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $z21 \u003d 1\n  goto B25\n}",
      "B24 {\n  $z21 \u003d 0\n}",
      "B25 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B24",
      "B6 --\u003e B7",
      "B6 --\u003e B24",
      "B7 --\u003e B8",
      "B7 --\u003e B24",
      "B8 --\u003e B9",
      "B8 --\u003e B24",
      "B9 --\u003e B10",
      "B9 --\u003e B24",
      "B10 --\u003e B11",
      "B10 --\u003e B24",
      "B11 --\u003e B12",
      "B11 --\u003e B24",
      "B12 --\u003e B13",
      "B12 --\u003e B24",
      "B13 --\u003e B14",
      "B13 --\u003e B24",
      "B14 --\u003e B15",
      "B14 --\u003e B24",
      "B15 --\u003e B16",
      "B15 --\u003e B24",
      "B16 --\u003e B17",
      "B16 --\u003e B24",
      "B17 --\u003e B18",
      "B17 --\u003e B24",
      "B18 --\u003e B19",
      "B18 --\u003e B24",
      "B19 --\u003e B20",
      "B19 --\u003e B24",
      "B20 --\u003e B21",
      "B20 --\u003e B24",
      "B21 --\u003e B22",
      "B21 --\u003e B24",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      },
      {
        "name": "SevenZArchiveEntry#equalSevenZMethods(...2)",
        "body": "{\r\n    if (c1 \u003d\u003d null) {\r\n        return c2 \u003d\u003d null;\r\n    }\r\n    if (c2 \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    final Iterator\u003c? extends SevenZMethodConfiguration\u003e i2 \u003d c2.iterator();\r\n    for (final SevenZMethodConfiguration element : c1) {\r\n        if (!i2.hasNext() || !element.equals(i2.next())) {\r\n            return false;\r\n        }\r\n    }\r\n    return !i2.hasNext();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "getAccessTime",
    "signature": "java.nio.file.attribute.FileTime getAccessTime()",
    "visibility": "public",
    "body": "{\r\n    if (hasAccessDate) {\r\n        return accessDate;\r\n    }\r\n    throw new UnsupportedOperationException(\"The entry doesn\u0027t have this timestamp\");\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  $z0 \u003d SevenZArchiveEntry: boolean hasAccessDate\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d FileTime accessDate\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"The entry doesn\\\u0027t have this timestamp\")\n  throw $r1\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "getCreationTime",
    "signature": "java.nio.file.attribute.FileTime getCreationTime()",
    "visibility": "public",
    "body": "{\r\n    if (hasCreationDate) {\r\n        return creationDate;\r\n    }\r\n    throw new UnsupportedOperationException(\"The entry doesn\u0027t have this timestamp\");\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  $z0 \u003d SevenZArchiveEntry: boolean hasCreationDate\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d FileTime creationDate\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"The entry doesn\\\u0027t have this timestamp\")\n  throw $r1\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "getLastModifiedTime",
    "signature": "java.nio.file.attribute.FileTime getLastModifiedTime()",
    "visibility": "public",
    "body": "{\r\n    if (hasLastModifiedDate) {\r\n        return lastModifiedDate;\r\n    }\r\n    throw new UnsupportedOperationException(\"The entry doesn\u0027t have this timestamp\");\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  $z0 \u003d SevenZArchiveEntry: boolean hasLastModifiedDate\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d FileTime lastModifiedDate\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"The entry doesn\\\u0027t have this timestamp\")\n  throw $r1\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final String n \u003d getName();\r\n    return n \u003d\u003d null ? 0 : n.hashCode();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  r1 \u003d r0.getName()\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $i0 \u003d r1.hashCode()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZArchiveEntry#getName(...0)",
        "body": "{\r\n    return name;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "isEmptyStream",
    "signature": "boolean isEmptyStream()",
    "visibility": "public",
    "body": "{\r\n    return !hasStream;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  $z0 \u003d SevenZArchiveEntry: boolean hasStream\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "setAccessTime",
    "signature": "void setAccessTime(java.nio.file.attribute.FileTime)",
    "visibility": "public",
    "body": "{\r\n    hasAccessDate \u003d time !\u003d null;\r\n    if (hasAccessDate) {\r\n        this.accessDate \u003d time;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  FileTime\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  SevenZArchiveEntry: boolean hasAccessDate\u003e \u003d $z1\n  $z0 \u003d SevenZArchiveEntry: boolean hasAccessDate\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  FileTime accessDate\u003e \u003d r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "setContentMethods",
    "signature": "void setContentMethods(java.lang.Iterable)",
    "visibility": "public",
    "body": "{\r\n    if (methods !\u003d null) {\r\n        final LinkedList\u003cSevenZMethodConfiguration\u003e l \u003d new LinkedList\u003c\u003e();\r\n        methods.forEach(l::addLast);\r\n        contentMethods \u003d Collections.unmodifiableList(l);\r\n    } else {\r\n        contentMethods \u003d null;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  Iterable\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d LinkedList\n  new LinkedList()\n  Objects.requireNonNull($r2)\n  $r3 \u003d SevenZArchiveEntry$addLast__11.bootstrap$($r2)\n  r0.forEach($r3)\n  $r4 \u003d Collections.unmodifiableList($r2)\n  Iterable contentMethods\u003e \u003d $r4\n  goto B3\n}",
      "B2 {\n  Iterable contentMethods\u003e \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "setCreationTime",
    "signature": "void setCreationTime(java.nio.file.attribute.FileTime)",
    "visibility": "public",
    "body": "{\r\n    hasCreationDate \u003d time !\u003d null;\r\n    if (hasCreationDate) {\r\n        this.creationDate \u003d time;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  FileTime\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  SevenZArchiveEntry: boolean hasCreationDate\u003e \u003d $z1\n  $z0 \u003d SevenZArchiveEntry: boolean hasCreationDate\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  FileTime creationDate\u003e \u003d r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry",
    "methodName": "setLastModifiedTime",
    "signature": "void setLastModifiedTime(java.nio.file.attribute.FileTime)",
    "visibility": "public",
    "body": "{\r\n    hasLastModifiedDate \u003d time !\u003d null;\r\n    if (hasLastModifiedDate) {\r\n        this.lastModifiedDate \u003d time;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SevenZArchiveEntry\n  FileTime\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  SevenZArchiveEntry: boolean hasLastModifiedDate\u003e \u003d $z1\n  $z0 \u003d SevenZArchiveEntry: boolean hasLastModifiedDate\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  FileTime lastModifiedDate\u003e \u003d r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c sevenZSignature.length) {\r\n        return false;\r\n    }\r\n    for (int i \u003d 0; i \u003c sevenZSignature.length; i++) {\r\n        if (signature[i] !\u003d sevenZSignature[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i6 \u003d\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i5 \u003d 0\n}",
      "B3 {\n  $r1 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $i2 \u003d lengthof $r1\n  if (i5 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b4 \u003d r2[i5]\n  $r3 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $b3 \u003d $r3[i5]\n  $i6 \u003d (int) $b4\n  $i7 \u003d (int) $b3\n  if ($i6 \u003d\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (channel !\u003d null) {\r\n        try {\r\n            channel.close();\r\n        } finally {\r\n            channel \u003d null;\r\n            if (password !\u003d null) {\r\n                Arrays.fill(password, (byte) 0);\r\n            }\r\n            password \u003d null;\r\n        }\r\n    }\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B3",
      "B4 : If($r6 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  $r1 \u003d SeekableByteChannel channel\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $r2 \u003d SeekableByteChannel channel\u003e\n  $r2.close()\n  SeekableByteChannel channel\u003e \u003d null\n  $r3 \u003d SevenZFile: byte[] password\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d SevenZFile: byte[] password\u003e\n  Arrays.fill($r4, 0)\n}",
      "B3 {\n  SevenZFile: byte[] password\u003e \u003d null\n  goto B7\n}",
      "B4 {\n  $r5 :\u003d @caughtexception\n  SeekableByteChannel channel\u003e \u003d null\n  $r6 \u003d SevenZFile: byte[] password\u003e\n  if ($r6 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d SevenZFile: byte[] password\u003e\n  Arrays.fill($r7, 0)\n}",
      "B6 {\n  SevenZFile: byte[] password\u003e \u003d null\n  throw $r5\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "getDefaultName",
    "signature": "java.lang.String getDefaultName()",
    "visibility": "public",
    "body": "{\r\n    if (DEFAULT_FILE_NAME.equals(fileName) || fileName \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    final String lastSegment \u003d new File(fileName).getName();\r\n    final int dotPos \u003d lastSegment.lastIndexOf(\".\");\r\n    if (dotPos \u003e 0) {\r\n        // if the file starts with a dot then this is not an extension\r\n        return lastSegment.substring(0, dotPos);\r\n    }\r\n    return lastSegment + \"~\";\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($r3 !\u003d null) → B2 | else → B3",
      "B3 : If(i0 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  $r2 \u003d \"unknown archive\"\n  $r1 \u003d String fileName\u003e\n  $z0 \u003d $r2.equals($r1)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d String fileName\u003e\n  if ($r3 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r4 \u003d File\n  $r5 \u003d String fileName\u003e\n  new File($r5)\n  r6 \u003d $r4.getName()\n  i0 \u003d r6.lastIndexOf(\".\")\n  if (i0 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r11 \u003d r6.substring(0, i0)\n  return\n}",
      "B5 {\n  $r7 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r7.append(r6)\n  $r9 \u003d $r8.append(\"~\")\n  $r10 \u003d $r9.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "getInputStream",
    "signature": "java.io.InputStream getInputStream(org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    int entryIndex \u003d -1;\r\n    for (int i \u003d 0; i \u003c archive.files.length; i++) {\r\n        if (entry \u003d\u003d archive.files[i]) {\r\n            entryIndex \u003d i;\r\n            break;\r\n        }\r\n    }\r\n    if (entryIndex \u003c 0) {\r\n        throw new IllegalArgumentException(\"Can not find \" + entry.getName() + \" in \" + fileName);\r\n    }\r\n    buildDecodingStream(entryIndex, true);\r\n    currentEntryIndex \u003d entryIndex;\r\n    currentFolderIndex \u003d archive.streamMap.fileFolderIndex[entryIndex];\r\n    return getCurrentStream();\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d $i0) → B2 | else → B5",
      "B2 : If(r9 !\u003d $r19) → B3 | else → B4",
      "B5 : If(i2 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  SevenZArchiveEntry\n  $i5 \u003d (int) -1\n  i2 \u003d $i5\n  i3 \u003d 0\n}",
      "B1 {\n  $r1 \u003d Archive archive\u003e\n  $r2 \u003d SevenZArchiveEntry[] files\u003e\n  $i0 \u003d lengthof $r2\n  if (i3 \u003e\u003d $i0) goto B2 else B5\n}",
      "B2 {\n  $r17 \u003d Archive archive\u003e\n  $r18 \u003d SevenZArchiveEntry[] files\u003e\n  $r19 \u003d $r18[i3]\n  if (r9 !\u003d $r19) goto B3 else B4\n}",
      "B3 {\n  i2 \u003d i3\n  goto B5\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  if (i2 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r21 \u003d IllegalArgumentException\n  $r20 \u003d StringBuilder\n  new StringBuilder()\n  $r11 \u003d $r20.append(\"Can not find \")\n  $r10 \u003d r9.getName()\n  $r12 \u003d $r11.append($r10)\n  $r14 \u003d $r12.append(\" in \")\n  $r13 \u003d String fileName\u003e\n  $r15 \u003d $r14.append($r13)\n  $r16 \u003d $r15.toString()\n  new IllegalArgumentException($r16)\n  throw $r21\n}",
      "B7 {\n  r0.buildDecodingStream(i2, 1)\n  SevenZFile: int currentEntryIndex\u003e \u003d i2\n  $r3 \u003d Archive archive\u003e\n  $r4 \u003d StreamMap streamMap\u003e\n  $r5 \u003d StreamMap: int[] fileFolderIndex\u003e\n  $i1 \u003d $r5[i2]\n  SevenZFile: int currentFolderIndex\u003e \u003d $i1\n  $r6 \u003d r0.getCurrentStream()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZFile#buildDecodingStream(...2)",
        "body": "{\r\n    if (archive.streamMap \u003d\u003d null) {\r\n        throw new IOException(\"Archive doesn\u0027t contain stream information to read entries\");\r\n    }\r\n    final int folderIndex \u003d archive.streamMap.fileFolderIndex[entryIndex];\r\n    if (folderIndex \u003c 0) {\r\n        deferredBlockStreams.clear();\r\n        // TODO: previously it\u0027d return an empty stream?\r\n        // new BoundedInputStream(new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY), 0);\r\n        return;\r\n    }\r\n    final SevenZArchiveEntry file \u003d archive.files[entryIndex];\r\n    boolean isInSameFolder \u003d false;\r\n    if (currentFolderIndex \u003d\u003d folderIndex) {\r\n        // (COMPRESS-320).\r\n        // The current entry is within the same (potentially opened) folder. The\r\n        // previous stream has to be fully decoded before we can start reading\r\n        // but don\u0027t do it eagerly -- if the user skips over the entire folder nothing\r\n        // is effectively decompressed.\r\n        if (entryIndex \u003e 0) {\r\n            file.setContentMethods(archive.files[entryIndex - 1].getContentMethods());\r\n        }\r\n        // if this is called in a random access, then the content methods of previous entry may be null\r\n        // the content methods should be set to methods of the first entry as it must not be null,\r\n        // and the content methods would only be set if the content methods was not set\r\n        if (isRandomAccess \u0026\u0026 file.getContentMethods() \u003d\u003d null) {\r\n            final int folderFirstFileIndex \u003d archive.streamMap.folderFirstFileIndex[folderIndex];\r\n            final SevenZArchiveEntry folderFirstFile \u003d archive.files[folderFirstFileIndex];\r\n            file.setContentMethods(folderFirstFile.getContentMethods());\r\n        }\r\n        isInSameFolder \u003d true;\r\n    } else {\r\n        currentFolderIndex \u003d folderIndex;\r\n        // We\u0027re opening a new folder. Discard any queued streams/ folder stream.\r\n        reopenFolderInputStream(folderIndex, file);\r\n    }\r\n    boolean haveSkippedEntries \u003d false;\r\n    if (isRandomAccess) {\r\n        // entries will only need to be skipped if it\u0027s a random access\r\n        haveSkippedEntries \u003d skipEntriesWhenNeeded(entryIndex, isInSameFolder, folderIndex);\r\n    }\r\n    if (isRandomAccess \u0026\u0026 currentEntryIndex \u003d\u003d entryIndex \u0026\u0026 !haveSkippedEntries) {\r\n        // we don\u0027t need to add another entry to the deferredBlockStreams when :\r\n        // 1. If this method is called in a random access and the entry index\r\n        // to be read equals to the current entry index, the input stream\r\n        // has already been put in the deferredBlockStreams\r\n        // 2. If this entry has not been read(which means no entries are skipped)\r\n        return;\r\n    }\r\n    InputStream fileStream \u003d BoundedInputStream.builder().setInputStream(currentFolderInputStream).setMaxCount(file.getSize()).setPropagateClose(false).get();\r\n    if (file.getHasCrc()) {\r\n        // @formatter:off\r\n        fileStream \u003d ChecksumInputStream.builder().setChecksum(new CRC32()).setInputStream(fileStream).setExpectedChecksumValue(file.getCrcValue()).get();\r\n        // @formatter:on\r\n    }\r\n    deferredBlockStreams.add(fileStream);\r\n}"
      },
      {
        "name": "SevenZFile#getCurrentStream(...0)",
        "body": "{\r\n    if (archive.files[currentEntryIndex].getSize() \u003d\u003d 0) {\r\n        return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\r\n    }\r\n    if (deferredBlockStreams.isEmpty()) {\r\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\r\n    }\r\n    while (deferredBlockStreams.size() \u003e 1) {\r\n        // In solid compression mode we need to decompress all leading folder\u0027\r\n        // streams to get access to an entry. We defer this until really needed\r\n        // so that entire blocks can be skipped without wasting time for decompression.\r\n        try (InputStream stream \u003d deferredBlockStreams.remove(0)) {\r\n            org.apache.commons.io.IOUtils.skip(stream, Long.MAX_VALUE, org.apache.commons.io.IOUtils::byteArray);\r\n        }\r\n        compressedBytesReadFromCurrentEntry \u003d 0;\r\n    }\r\n    return deferredBlockStreams.get(0);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "getNextEntry",
    "signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry getNextEntry()",
    "visibility": "public",
    "body": "{\r\n    if (currentEntryIndex \u003e\u003d archive.files.length - 1) {\r\n        return null;\r\n    }\r\n    ++currentEntryIndex;\r\n    final SevenZArchiveEntry entry \u003d archive.files[currentEntryIndex];\r\n    if (entry.getName() \u003d\u003d null \u0026\u0026 useDefaultNameForUnnamedEntries) {\r\n        entry.setName(getDefaultName());\r\n    }\r\n    buildDecodingStream(currentEntryIndex, false);\r\n    uncompressedBytesReadFromCurrentEntry \u003d compressedBytesReadFromCurrentEntry \u003d 0;\r\n    return entry;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If($r6 !\u003d null) → B3 | else → B5",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  $i2 \u003d SevenZFile: int currentEntryIndex\u003e\n  $r1 \u003d Archive archive\u003e\n  $r2 \u003d SevenZArchiveEntry[] files\u003e\n  $i0 \u003d lengthof $r2\n  $i1 \u003d $i0 - 1\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i3 \u003d SevenZFile: int currentEntryIndex\u003e\n  $i4 \u003d $i3 + 1\n  SevenZFile: int currentEntryIndex\u003e \u003d $i4\n  $r3 \u003d Archive archive\u003e\n  $r4 \u003d SevenZArchiveEntry[] files\u003e\n  $i5 \u003d SevenZFile: int currentEntryIndex\u003e\n  r5 \u003d $r4[$i5]\n  $r6 \u003d r5.getName()\n  if ($r6 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  $z0 \u003d SevenZFile: boolean useDefaultNameForUnnamedEntries\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r7 \u003d r0.getDefaultName()\n  r5.setName($r7)\n}",
      "B5 {\n  $i6 \u003d SevenZFile: int currentEntryIndex\u003e\n  r0.buildDecodingStream($i6, 0)\n  SevenZFile: long compressedBytesReadFromCurrentEntry\u003e \u003d 0L\n  SevenZFile: long uncompressedBytesReadFromCurrentEntry\u003e \u003d 0L\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZFile#buildDecodingStream(...2)",
        "body": "{\r\n    if (archive.streamMap \u003d\u003d null) {\r\n        throw new IOException(\"Archive doesn\u0027t contain stream information to read entries\");\r\n    }\r\n    final int folderIndex \u003d archive.streamMap.fileFolderIndex[entryIndex];\r\n    if (folderIndex \u003c 0) {\r\n        deferredBlockStreams.clear();\r\n        // TODO: previously it\u0027d return an empty stream?\r\n        // new BoundedInputStream(new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY), 0);\r\n        return;\r\n    }\r\n    final SevenZArchiveEntry file \u003d archive.files[entryIndex];\r\n    boolean isInSameFolder \u003d false;\r\n    if (currentFolderIndex \u003d\u003d folderIndex) {\r\n        // (COMPRESS-320).\r\n        // The current entry is within the same (potentially opened) folder. The\r\n        // previous stream has to be fully decoded before we can start reading\r\n        // but don\u0027t do it eagerly -- if the user skips over the entire folder nothing\r\n        // is effectively decompressed.\r\n        if (entryIndex \u003e 0) {\r\n            file.setContentMethods(archive.files[entryIndex - 1].getContentMethods());\r\n        }\r\n        // if this is called in a random access, then the content methods of previous entry may be null\r\n        // the content methods should be set to methods of the first entry as it must not be null,\r\n        // and the content methods would only be set if the content methods was not set\r\n        if (isRandomAccess \u0026\u0026 file.getContentMethods() \u003d\u003d null) {\r\n            final int folderFirstFileIndex \u003d archive.streamMap.folderFirstFileIndex[folderIndex];\r\n            final SevenZArchiveEntry folderFirstFile \u003d archive.files[folderFirstFileIndex];\r\n            file.setContentMethods(folderFirstFile.getContentMethods());\r\n        }\r\n        isInSameFolder \u003d true;\r\n    } else {\r\n        currentFolderIndex \u003d folderIndex;\r\n        // We\u0027re opening a new folder. Discard any queued streams/ folder stream.\r\n        reopenFolderInputStream(folderIndex, file);\r\n    }\r\n    boolean haveSkippedEntries \u003d false;\r\n    if (isRandomAccess) {\r\n        // entries will only need to be skipped if it\u0027s a random access\r\n        haveSkippedEntries \u003d skipEntriesWhenNeeded(entryIndex, isInSameFolder, folderIndex);\r\n    }\r\n    if (isRandomAccess \u0026\u0026 currentEntryIndex \u003d\u003d entryIndex \u0026\u0026 !haveSkippedEntries) {\r\n        // we don\u0027t need to add another entry to the deferredBlockStreams when :\r\n        // 1. If this method is called in a random access and the entry index\r\n        // to be read equals to the current entry index, the input stream\r\n        // has already been put in the deferredBlockStreams\r\n        // 2. If this entry has not been read(which means no entries are skipped)\r\n        return;\r\n    }\r\n    InputStream fileStream \u003d BoundedInputStream.builder().setInputStream(currentFolderInputStream).setMaxCount(file.getSize()).setPropagateClose(false).get();\r\n    if (file.getHasCrc()) {\r\n        // @formatter:off\r\n        fileStream \u003d ChecksumInputStream.builder().setChecksum(new CRC32()).setInputStream(fileStream).setExpectedChecksumValue(file.getCrcValue()).get();\r\n        // @formatter:on\r\n    }\r\n    deferredBlockStreams.add(fileStream);\r\n}"
      },
      {
        "name": "SevenZFile#getDefaultName(...0)",
        "body": "{\r\n    if (DEFAULT_FILE_NAME.equals(fileName) || fileName \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    final String lastSegment \u003d new File(fileName).getName();\r\n    final int dotPos \u003d lastSegment.lastIndexOf(\".\");\r\n    if (dotPos \u003e 0) {\r\n        // if the file starts with a dot then this is not an extension\r\n        return lastSegment.substring(0, dotPos);\r\n    }\r\n    return lastSegment + \"~\";\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    // does not allocate\r\n    @SuppressWarnings(\"resource\")\r\n    final int b \u003d getCurrentStream().read();\r\n    if (b \u003e\u003d 0) {\r\n        uncompressedBytesReadFromCurrentEntry++;\r\n    }\r\n    return b;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  $r1 \u003d r0.getCurrentStream()\n  i0 \u003d $r1.read()\n  if (i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $l1 \u003d SevenZFile: long uncompressedBytesReadFromCurrentEntry\u003e\n  $l2 \u003d $l1 + 1L\n  SevenZFile: long uncompressedBytesReadFromCurrentEntry\u003e \u003d $l2\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZFile#getCurrentStream(...0)",
        "body": "{\r\n    if (archive.files[currentEntryIndex].getSize() \u003d\u003d 0) {\r\n        return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\r\n    }\r\n    if (deferredBlockStreams.isEmpty()) {\r\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\r\n    }\r\n    while (deferredBlockStreams.size() \u003e 1) {\r\n        // In solid compression mode we need to decompress all leading folder\u0027\r\n        // streams to get access to an entry. We defer this until really needed\r\n        // so that entire blocks can be skipped without wasting time for decompression.\r\n        try (InputStream stream \u003d deferredBlockStreams.remove(0)) {\r\n            org.apache.commons.io.IOUtils.skip(stream, Long.MAX_VALUE, org.apache.commons.io.IOUtils::byteArray);\r\n        }\r\n        compressedBytesReadFromCurrentEntry \u003d 0;\r\n    }\r\n    return deferredBlockStreams.get(0);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZFile",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    // does not allocate\r\n    @SuppressWarnings(\"resource\")\r\n    final int current \u003d getCurrentStream().read(b, off, len);\r\n    if (current \u003e 0) {\r\n        uncompressedBytesReadFromCurrentEntry +\u003d current;\r\n    }\r\n    return current;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i2 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SevenZFile\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getCurrentStream()\n  i2 \u003d $r2.read(r1, i1, i0)\n  if (i2 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $l4 \u003d SevenZFile: long uncompressedBytesReadFromCurrentEntry\u003e\n  $l3 \u003d (long) i2\n  $l5 \u003d $l4 + $l3\n  SevenZFile: long uncompressedBytesReadFromCurrentEntry\u003e \u003d $l5\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZFile#getCurrentStream(...0)",
        "body": "{\r\n    if (archive.files[currentEntryIndex].getSize() \u003d\u003d 0) {\r\n        return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY);\r\n    }\r\n    if (deferredBlockStreams.isEmpty()) {\r\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\r\n    }\r\n    while (deferredBlockStreams.size() \u003e 1) {\r\n        // In solid compression mode we need to decompress all leading folder\u0027\r\n        // streams to get access to an entry. We defer this until really needed\r\n        // so that entire blocks can be skipped without wasting time for decompression.\r\n        try (InputStream stream \u003d deferredBlockStreams.remove(0)) {\r\n            org.apache.commons.io.IOUtils.skip(stream, Long.MAX_VALUE, org.apache.commons.io.IOUtils::byteArray);\r\n        }\r\n        compressedBytesReadFromCurrentEntry \u003d 0;\r\n    }\r\n    return deferredBlockStreams.get(0);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final SevenZMethodConfiguration other \u003d (SevenZMethodConfiguration) obj;\r\n    return Objects.equals(method, other.method) \u0026\u0026 Objects.equals(options, other.options);\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  SevenZMethodConfiguration\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d SevenZMethodConfiguration) r1\n  $r6 \u003d SevenZMethod method\u003e\n  $r5 \u003d SevenZMethod method\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d Object options\u003e\n  $r7 \u003d Object options\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZMethodConfiguration#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZMethodConfiguration",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    return method \u003d\u003d null ? 0 : method.hashCode();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZMethodConfiguration\n  $r1 \u003d SevenZMethod method\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d SevenZMethod method\u003e\n  $i0 \u003d $r2.hashCode()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (!finished) {\r\n            finish();\r\n        }\r\n    } finally {\r\n        channel.close();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  $z0 \u003d SevenZOutputFile: boolean finished\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.finish()\n}",
      "B2 {\n  $r1 \u003d SeekableByteChannel channel\u003e\n  $r1.close()\n  goto B4\n}",
      "B3 {\n  $r2 :\u003d @caughtexception\n  $r3 \u003d SeekableByteChannel channel\u003e\n  $r3.close()\n  throw $r2\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZOutputFile#finish(...0)",
        "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"This archive has already been finished\");\r\n    }\r\n    finished \u003d true;\r\n    final long headerPosition \u003d channel.position();\r\n    final ByteArrayOutputStream headerBaos \u003d new ByteArrayOutputStream();\r\n    final DataOutputStream header \u003d new DataOutputStream(headerBaos);\r\n    writeHeader(header);\r\n    header.flush();\r\n    final byte[] headerBytes \u003d headerBaos.toByteArray();\r\n    channel.write(ByteBuffer.wrap(headerBytes));\r\n    final CRC32 crc32 \u003d new CRC32();\r\n    crc32.update(headerBytes);\r\n    final ByteBuffer bb \u003d ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2 + /* version */\r\n    4 + /* start header CRC */\r\n    8 + /* next header position */\r\n    8 + /* next header length */\r\n    4).order(ByteOrder.LITTLE_ENDIAN);\r\n    // signature header\r\n    channel.position(0);\r\n    bb.put(SevenZFile.sevenZSignature);\r\n    // version\r\n    bb.put((byte) 0).put((byte) 2);\r\n    // placeholder for start header CRC\r\n    bb.putInt(0);\r\n    // start header\r\n    bb.putLong(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE).putLong(0xffffFFFFL \u0026 headerBytes.length).putInt((int) crc32.getValue());\r\n    crc32.reset();\r\n    crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);\r\n    bb.putInt(SevenZFile.sevenZSignature.length + 2, (int) crc32.getValue());\r\n    bb.flip();\r\n    channel.write(bb);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "closeArchiveEntry",
    "signature": "void closeArchiveEntry()",
    "visibility": "public",
    "body": "{\r\n    if (currentOutputStream !\u003d null) {\r\n        currentOutputStream.flush();\r\n        currentOutputStream.close();\r\n    }\r\n    final SevenZArchiveEntry entry \u003d files.get(files.size() - 1);\r\n    if (fileBytesWritten \u003e 0) {\r\n        // this implies currentOutputStream !\u003d null\r\n        entry.setHasStream(true);\r\n        ++numNonEmptyStreams;\r\n        // NOSONAR\r\n        entry.setSize(currentOutputStream.getByteCount());\r\n        entry.setCompressedSize(fileBytesWritten);\r\n        entry.setCrcValue(crc32.getValue());\r\n        entry.setCompressedCrcValue(compressedCrc32.getValue());\r\n        entry.setHasCrc(true);\r\n        if (additionalCountingStreams !\u003d null) {\r\n            final long[] sizes \u003d new long[additionalCountingStreams.length];\r\n            Arrays.setAll(sizes, i -\u003e additionalCountingStreams[i].getByteCount());\r\n            additionalSizes.put(entry, sizes);\r\n        }\r\n    } else {\r\n        entry.setHasStream(false);\r\n        entry.setSize(0);\r\n        entry.setCompressedSize(0);\r\n        entry.setHasCrc(false);\r\n    }\r\n    currentOutputStream \u003d null;\r\n    additionalCountingStreams \u003d null;\r\n    crc32.reset();\r\n    compressedCrc32.reset();\r\n    fileBytesWritten \u003d 0;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i11 \u003c\u003d 0) → B3 | else → B5",
      "B3 : If($r8 \u003d\u003d null) → B4 | else → B6"
    ],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  $r1 \u003d CountingOutputStream currentOutputStream\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d CountingOutputStream currentOutputStream\u003e\n  $r13.flush()\n  $r14 \u003d CountingOutputStream currentOutputStream\u003e\n  $r14.close()\n}",
      "B2 {\n  $r3 \u003d List files\u003e\n  $r2 \u003d List files\u003e\n  $i0 \u003d $r2.size()\n  $i1 \u003d $i0 - 1\n  $r4 \u003d $r3.get($i1)\n  $r15 \u003d SevenZArchiveEntry) $r4\n  $l2 \u003d SevenZOutputFile: long fileBytesWritten\u003e\n  $b3 \u003d $l2 cmp 0L\n  $i11 \u003d (int) $b3\n  if ($i11 \u003c\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $r15.setHasStream(1)\n  $i4 \u003d SevenZOutputFile: int numNonEmptyStreams\u003e\n  $i5 \u003d $i4 + 1\n  SevenZOutputFile: int numNonEmptyStreams\u003e \u003d $i5\n  $r5 \u003d CountingOutputStream currentOutputStream\u003e\n  $l6 \u003d $r5.getByteCount()\n  $r15.setSize($l6)\n  $l7 \u003d SevenZOutputFile: long fileBytesWritten\u003e\n  $r15.setCompressedSize($l7)\n  $r6 \u003d CRC32 crc32\u003e\n  $l8 \u003d $r6.getValue()\n  $r15.setCrcValue($l8)\n  $r7 \u003d CRC32 compressedCrc32\u003e\n  $l9 \u003d $r7.getValue()\n  $r15.setCompressedCrcValue($l9)\n  $r15.setHasCrc(1)\n  $r8 \u003d CountingOutputStream[] additionalCountingStreams\u003e\n  if ($r8 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  $r9 \u003d CountingOutputStream[] additionalCountingStreams\u003e\n  $i10 \u003d lengthof $r9\n  r10 \u003d newarray (long)[$i10]\n  $r11 \u003d SevenZOutputFile$lambda_closeArchiveEntry_0__12.bootstrap$(r0)\n  Arrays.setAll(r10, $r11)\n  $r12 \u003d Map additionalSizes\u003e\n  $r12.put($r15, r10)\n  goto B6\n}",
      "B5 {\n  $r15.setHasStream(0)\n  $r15.setSize(0L)\n  $r15.setCompressedSize(0L)\n  $r15.setHasCrc(0)\n}",
      "B6 {\n  CountingOutputStream currentOutputStream\u003e \u003d null\n  CountingOutputStream[] additionalCountingStreams\u003e \u003d null\n  $r16 \u003d CRC32 crc32\u003e\n  $r16.reset()\n  $r17 \u003d CRC32 compressedCrc32\u003e\n  $r17.reset()\n  SevenZOutputFile: long fileBytesWritten\u003e \u003d 0L\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "createArchiveEntry",
    "signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry createArchiveEntry(java.io.File,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final SevenZArchiveEntry entry \u003d new SevenZArchiveEntry();\r\n    entry.setDirectory(inputFile.isDirectory());\r\n    entry.setName(entryName);\r\n    try {\r\n        fillDates(inputFile.toPath(), entry);\r\n    } catch (final IOException e) {\r\n        // NOSONAR\r\n        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\r\n    }\r\n    return entry;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  File\n  String\n  $r0 \u003d SevenZArchiveEntry\n  new SevenZArchiveEntry()\n  $z0 \u003d r1.isDirectory()\n  $r0.setDirectory($z0)\n  $r0.setName(r2)\n  $r5 \u003d r1.toPath()\n  $r4 \u003d LinkOption)[0]\n  r3.fillDates($r5, $r0, $r4)\n  goto B2\n}",
      "B1 {\n  $r6 :\u003d @caughtexception\n  $r7 \u003d Date\n  $l0 \u003d r1.lastModified()\n  new Date($l0)\n  $r0.setLastModifiedDate($r7)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZOutputFile#fillDates(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"This archive has already been finished\");\r\n    }\r\n    finished \u003d true;\r\n    final long headerPosition \u003d channel.position();\r\n    final ByteArrayOutputStream headerBaos \u003d new ByteArrayOutputStream();\r\n    final DataOutputStream header \u003d new DataOutputStream(headerBaos);\r\n    writeHeader(header);\r\n    header.flush();\r\n    final byte[] headerBytes \u003d headerBaos.toByteArray();\r\n    channel.write(ByteBuffer.wrap(headerBytes));\r\n    final CRC32 crc32 \u003d new CRC32();\r\n    crc32.update(headerBytes);\r\n    final ByteBuffer bb \u003d ByteBuffer.allocate(SevenZFile.sevenZSignature.length + 2 + /* version */\r\n    4 + /* start header CRC */\r\n    8 + /* next header position */\r\n    8 + /* next header length */\r\n    4).order(ByteOrder.LITTLE_ENDIAN);\r\n    // signature header\r\n    channel.position(0);\r\n    bb.put(SevenZFile.sevenZSignature);\r\n    // version\r\n    bb.put((byte) 0).put((byte) 2);\r\n    // placeholder for start header CRC\r\n    bb.putInt(0);\r\n    // start header\r\n    bb.putLong(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE).putLong(0xffffFFFFL \u0026 headerBytes.length).putInt((int) crc32.getValue());\r\n    crc32.reset();\r\n    crc32.update(bb.array(), SevenZFile.sevenZSignature.length + 6, 20);\r\n    bb.putInt(SevenZFile.sevenZSignature.length + 2, (int) crc32.getValue());\r\n    bb.flip();\r\n    channel.write(bb);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  $z0 \u003d SevenZOutputFile: boolean finished\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r21 \u003d IOException\n  new IOException(\"This archive has already been finished\")\n  throw $r21\n}",
      "B2 {\n  SevenZOutputFile: boolean finished\u003e \u003d 1\n  $r1 \u003d SeekableByteChannel channel\u003e\n  l0 \u003d $r1.position()\n  $r2 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n  $r3 \u003d DataOutputStream\n  new DataOutputStream($r2)\n  r0.writeHeader($r3)\n  $r3.flush()\n  r4 \u003d $r2.toByteArray()\n  $r5 \u003d SeekableByteChannel channel\u003e\n  $r6 \u003d ByteBuffer.wrap(r4)\n  $r5.write($r6)\n  $r7 \u003d CRC32\n  new CRC32()\n  $r7.update(r4)\n  $r8 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $i1 \u003d lengthof $r8\n  $i2 \u003d $i1 + 2\n  $i3 \u003d $i2 + 4\n  $i4 \u003d $i3 + 8\n  $i5 \u003d $i4 + 8\n  $i6 \u003d $i5 + 4\n  $r10 \u003d ByteBuffer.allocate($i6)\n  $r9 \u003d ByteOrder LITTLE_ENDIAN\u003e\n  r11 \u003d $r10.order($r9)\n  $r12 \u003d SeekableByteChannel channel\u003e\n  $r12.position(0L)\n  $r13 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  r11.put($r13)\n  $r14 \u003d r11.put(0)\n  $r14.put(2)\n  r11.putInt(0)\n  $l7 \u003d l0 - 32L\n  $r15 \u003d r11.putLong($l7)\n  $i8 \u003d lengthof r4\n  $l9 \u003d (long) $i8\n  $l10 \u003d 4294967295L \u0026 $l9\n  $r16 \u003d $r15.putLong($l10)\n  $l11 \u003d $r7.getValue()\n  $i12 \u003d (int) $l11\n  $r16.putInt($i12)\n  $r7.reset()\n  $r18 \u003d r11.array()\n  $r17 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $i13 \u003d lengthof $r17\n  $i14 \u003d $i13 + 6\n  $r7.update($r18, $i14, 20)\n  $r19 \u003d SevenZFile: byte[] sevenZSignature\u003e\n  $i15 \u003d lengthof $r19\n  $i18 \u003d $i15 + 2\n  $l16 \u003d $r7.getValue()\n  $i17 \u003d (int) $l16\n  r11.putInt($i18, $i17)\n  r11.flip()\n  $r20 \u003d SeekableByteChannel channel\u003e\n  $r20.write(r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZOutputFile#writeHeader(...1)",
        "body": "{\r\n    header.write(NID.kHeader);\r\n    header.write(NID.kMainStreamsInfo);\r\n    writeStreamsInfo(header);\r\n    writeFilesInfo(header);\r\n    header.write(NID.kEnd);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003e 0) {\r\n        getCurrentOutputStream().write(b, off, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getCurrentOutputStream()\n  $r2.write(r1, i1, i0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZOutputFile#getCurrentOutputStream(...0)",
        "body": "{\r\n    if (currentOutputStream \u003d\u003d null) {\r\n        currentOutputStream \u003d setupFileOutputStream();\r\n    }\r\n    return currentOutputStream;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile",
    "methodName": "write",
    "signature": "void write(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final byte[] buffer \u003d new byte[8024];\r\n    int n \u003d 0;\r\n    while (-1 !\u003d (n \u003d inputStream.read(buffer))) {\r\n        write(buffer, 0, n);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($i2 \u003d\u003d $i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  SevenZOutputFile\n  InputStream\n  r0 \u003d newarray (byte)[8024]\n}",
      "B1 {\n  $i0 \u003d r1.read(r0)\n  $i2 \u003d (int) -1\n  if ($i2 \u003d\u003d $i0) goto B2 else B3\n}",
      "B2 {\n  r2.write(r0, 0, $i0)\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SevenZOutputFile#write(...3)",
        "body": "{\r\n    if (len \u003e 0) {\r\n        getCurrentOutputStream().write(b, off, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (it \u003d\u003d null || getClass() !\u003d it.getClass()) {\r\n        return false;\r\n    }\r\n    return equals((TarArchiveEntry) it);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($r3 \u003d\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  Object\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.getClass()\n  $r2 \u003d r0.getClass()\n  if ($r3 \u003d\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r4 \u003d TarArchiveEntry) r0\n  $z0 \u003d r1.equals($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#equals(...1)",
        "body": "{\r\n    if (it \u003d\u003d null || getClass() !\u003d it.getClass()) {\r\n        return false;\r\n    }\r\n    return equals((TarArchiveEntry) it);\r\n}"
      },
      {
        "name": "TarArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(org.apache.commons.compress.archivers.tar.TarArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    return it !\u003d null \u0026\u0026 getName().equals(it.getName());\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  TarArchiveEntry\n  if (r0 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d r1.getName()\n  $r2 \u003d r0.getName()\n  $z0 \u003d $r3.equals($r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#getName(...0)",
        "body": "{\r\n    return name;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "getDirectoryEntries",
    "signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry[] getDirectoryEntries()",
    "visibility": "public",
    "body": "{\r\n    if (file \u003d\u003d null || !isDirectory()) {\r\n        return EMPTY_TAR_ARCHIVE_ENTRY_ARRAY;\r\n    }\r\n    final List\u003cTarArchiveEntry\u003e entries \u003d new ArrayList\u003c\u003e();\r\n    try (DirectoryStream\u003cPath\u003e dirStream \u003d Files.newDirectoryStream(file)) {\r\n        for (final Path p : dirStream) {\r\n            entries.add(new TarArchiveEntry(p));\r\n        }\r\n    } catch (final IOException e) {\r\n        return EMPTY_TAR_ARCHIVE_ENTRY_ARRAY;\r\n    }\r\n    return entries.toArray(EMPTY_TAR_ARCHIVE_ENTRY_ARRAY);\r\n}",
    "nodes": 15,
    "edges": 16,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If(r14 \u003d\u003d null) → B7 | else → B12",
      "B8 : If(r14 \u003d\u003d null) → B9 | else → B11"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $r1 \u003d Path file\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d r0.isDirectory()\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRY_ARRAY\u003e\n  return\n}",
      "B3 {\n  $r3 \u003d ArrayList\n  new ArrayList()\n  $r4 \u003d Path file\u003e\n  r14 \u003d Files.newDirectoryStream($r4)\n  r15 \u003d r14.iterator()\n}",
      "B4 {\n  $z1 \u003d r15.hasNext()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r8 \u003d r15.next()\n  r16 \u003d Path) $r8\n  $r9 \u003d TarArchiveEntry\n  new TarArchiveEntry(r16)\n  $r3.add($r9)\n  goto B4\n}",
      "B6 {\n  if (r14 \u003d\u003d null) goto B7 else B12\n}",
      "B7 {\n  r14.close()\n  goto B12\n}",
      "B8 {\n  $r13 :\u003d @caughtexception\n  if (r14 \u003d\u003d null) goto B9 else B11\n}",
      "B9 {\n  r14.close()\n  goto B11\n}",
      "B10 {\n  $r12 :\u003d @caughtexception\n  $r13.addSuppressed($r12)\n}",
      "B11 {\n  throw $r13\n}",
      "B12 {\n  goto B14\n}",
      "B13 {\n  $r10 :\u003d @caughtexception\n  $r11 \u003d TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRY_ARRAY\u003e\n  return\n}",
      "B14 {\n  $r5 \u003d TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRY_ARRAY\u003e\n  $r6 \u003d $r3.toArray($r5)\n  $r7 \u003d TarArchiveEntry[]) $r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e B7",
      "B6 --\u003e B12",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#isDirectory(...0)",
        "body": "{\r\n    if (file !\u003d null) {\r\n        return Files.isDirectory(file, linkOptions);\r\n    }\r\n    if (linkFlag \u003d\u003d LF_DIR) {\r\n        return true;\r\n    }\r\n    return !isPaxHeader() \u0026\u0026 !isGlobalPaxHeader() \u0026\u0026 getName().endsWith(\"/\");\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "getFile",
    "signature": "java.io.File getFile()",
    "visibility": "public",
    "body": "{\r\n    return file !\u003d null ? file.toFile() : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $r1 \u003d Path file\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Path file\u003e\n  $r3 \u003d $r2.toFile()\n  goto B3\n}",
      "B2 {\n  $r3 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "getOrderedSparseHeaders",
    "signature": "java.util.List getOrderedSparseHeaders()",
    "visibility": "public",
    "body": "{\r\n    if (sparseHeaders \u003d\u003d null || sparseHeaders.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    final List\u003cTarArchiveStructSparse\u003e orderedAndFiltered \u003d sparseHeaders.stream().filter(s -\u003e s.getOffset() \u003e 0 || s.getNumbytes() \u003e 0).sorted(Comparator.comparingLong(TarArchiveStructSparse::getOffset)).collect(Collectors.toList());\r\n    final int numberOfHeaders \u003d orderedAndFiltered.size();\r\n    for (int i \u003d 0; i \u003c numberOfHeaders; i++) {\r\n        final TarArchiveStructSparse str \u003d orderedAndFiltered.get(i);\r\n        if (i + 1 \u003c numberOfHeaders \u0026\u0026 str.getOffset() + str.getNumbytes() \u003e orderedAndFiltered.get(i + 1).getOffset()) {\r\n            throw new IOException(\"Corrupted TAR archive. Sparse blocks for \" + getName() + \" overlap each other.\");\r\n        }\r\n        if (str.getOffset() + str.getNumbytes() \u003c 0) {\r\n            // integer overflow?\r\n            throw new IOException(\"Unreadable TAR archive. Offset and numbytes for sparse block in \" + getName() + \" too large.\");\r\n        }\r\n    }\r\n    if (!orderedAndFiltered.isEmpty()) {\r\n        final TarArchiveStructSparse last \u003d orderedAndFiltered.get(numberOfHeaders - 1);\r\n        if (last.getOffset() + last.getNumbytes() \u003e getRealSize()) {\r\n            throw new IOException(\"Corrupted TAR archive. Sparse block extends beyond real size of the entry\");\r\n        }\r\n    }\r\n    return orderedAndFiltered;\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(i18 \u003e\u003d i0) → B5 | else → B11",
      "B5 : If($i7 \u003e\u003d i0) → B6 | else → B8",
      "B6 : If($i19 \u003c\u003d 0) → B7 | else → B8",
      "B8 : If($i20 \u003e\u003d 0) → B9 | else → B10",
      "B11 : If($z1 !\u003d 0) → B12 | else → B14",
      "B12 : If($i21 \u003c\u003d 0) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $r1 \u003d List sparseHeaders\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d List sparseHeaders\u003e\n  $z0 \u003d $r3.isEmpty()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d Collections.emptyList()\n  return\n}",
      "B3 {\n  $r4 \u003d List sparseHeaders\u003e\n  $r6 \u003d $r4.stream()\n  $r5 \u003d TarArchiveEntry$lambda_getOrderedSparseHeaders_0__13.bootstrap$()\n  $r9 \u003d $r6.filter($r5)\n  $r7 \u003d TarArchiveEntry$getOffset__14.bootstrap$()\n  $r8 \u003d Comparator.comparingLong($r7)\n  $r11 \u003d $r9.sorted($r8)\n  $r10 \u003d Collectors.toList()\n  $r12 \u003d $r11.collect($r10)\n  r13 \u003d List) $r12\n  i0 \u003d r13.size()\n  i18 \u003d 0\n}",
      "B4 {\n  if (i18 \u003e\u003d i0) goto B5 else B11\n}",
      "B5 {\n  $r16 \u003d r13.get(i18)\n  r17 \u003d TarArchiveStructSparse) $r16\n  $i7 \u003d i18 + 1\n  if ($i7 \u003e\u003d i0) goto B6 else B8\n}",
      "B6 {\n  $l13 \u003d r17.getOffset()\n  $l12 \u003d r17.getNumbytes()\n  $l16 \u003d $l13 + $l12\n  $i14 \u003d i18 + 1\n  $r25 \u003d r13.get($i14)\n  $r26 \u003d TarArchiveStructSparse) $r25\n  $l15 \u003d $r26.getOffset()\n  $b17 \u003d $l16 cmp $l15\n  $i19 \u003d (int) $b17\n  if ($i19 \u003c\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $r36 \u003d IOException\n  $r35 \u003d StringBuilder\n  new StringBuilder()\n  $r30 \u003d $r35.append(\"Corrupted TAR archive. Sparse blocks for \")\n  $r29 \u003d r0.getName()\n  $r31 \u003d $r30.append($r29)\n  $r32 \u003d $r31.append(\" overlap each other.\")\n  $r33 \u003d $r32.toString()\n  new IOException($r33)\n  throw $r36\n}",
      "B8 {\n  $l9 \u003d r17.getOffset()\n  $l8 \u003d r17.getNumbytes()\n  $l10 \u003d $l9 + $l8\n  $b11 \u003d $l10 cmp 0L\n  $i20 \u003d (int) $b11\n  if ($i20 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $r38 \u003d IOException\n  $r37 \u003d StringBuilder\n  new StringBuilder()\n  $r21 \u003d $r37.append(\"Unreadable TAR archive. Offset and numbytes for sparse block in \")\n  $r20 \u003d r0.getName()\n  $r22 \u003d $r21.append($r20)\n  $r23 \u003d $r22.append(\" too large.\")\n  $r24 \u003d $r23.toString()\n  new IOException($r24)\n  throw $r38\n}",
      "B10 {\n  i18 \u003d i18 + 1\n  goto B4\n}",
      "B11 {\n  $z1 \u003d r13.isEmpty()\n  if ($z1 !\u003d 0) goto B12 else B14\n}",
      "B12 {\n  $i1 \u003d i0 - 1\n  $r14 \u003d r13.get($i1)\n  r34 \u003d TarArchiveStructSparse) $r14\n  $l3 \u003d r34.getOffset()\n  $l2 \u003d r34.getNumbytes()\n  $l5 \u003d $l3 + $l2\n  $l4 \u003d r0.getRealSize()\n  $b6 \u003d $l5 cmp $l4\n  $i21 \u003d (int) $b6\n  if ($i21 \u003c\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $r39 \u003d IOException\n  new IOException(\"Corrupted TAR archive. Sparse block extends beyond real size of the entry\")\n  throw $r39\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B11",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B4",
      "B11 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#getRealSize(...0)",
        "body": "{\r\n    if (!isSparse()) {\r\n        return getSize();\r\n    }\r\n    return realSize;\r\n}"
      },
      {
        "name": "TarArchiveEntry#getName(...0)",
        "body": "{\r\n    return name;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "getRealSize",
    "signature": "long getRealSize()",
    "visibility": "public",
    "body": "{\r\n    if (!isSparse()) {\r\n        return getSize();\r\n    }\r\n    return realSize;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $z0 \u003d r0.isSparse()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $l1 \u003d r0.getSize()\n  return\n}",
      "B2 {\n  $l0 \u003d TarArchiveEntry: long realSize\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#getSize(...0)",
        "body": "{\r\n    return size;\r\n}"
      },
      {
        "name": "TarArchiveEntry#isSparse(...0)",
        "body": "{\r\n    return isGNUSparse() || isStarSparse();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isBlockDevice",
    "signature": "boolean isBlockDevice()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_BLK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 52) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 52) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isCharacterDevice",
    "signature": "boolean isCharacterDevice()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_CHR;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 51) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 51) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isDirectory",
    "signature": "boolean isDirectory()",
    "visibility": "public",
    "body": "{\r\n    if (file !\u003d null) {\r\n        return Files.isDirectory(file, linkOptions);\r\n    }\r\n    if (linkFlag \u003d\u003d LF_DIR) {\r\n        return true;\r\n    }\r\n    return !isPaxHeader() \u0026\u0026 !isGlobalPaxHeader() \u0026\u0026 getName().endsWith(\"/\");\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i1 !\u003d 53) → B3 | else → B4",
      "B4 : If($z0 !\u003d 0) → B5 | else → B8",
      "B5 : If($z1 !\u003d 0) → B6 | else → B8",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $r1 \u003d Path file\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Path file\u003e\n  $r3 \u003d LinkOption[] linkOptions\u003e\n  $z3 \u003d Files.isDirectory($r4, $r3)\n  return\n}",
      "B2 {\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 53) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z0 \u003d r0.isPaxHeader()\n  if ($z0 !\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $z1 \u003d r0.isGlobalPaxHeader()\n  if ($z1 !\u003d 0) goto B6 else B8\n}",
      "B6 {\n  $r2 \u003d r0.getName()\n  $z2 \u003d $r2.endsWith(\"/\")\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z4 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z4 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#isPaxHeader(...0)",
        "body": "{\r\n    return linkFlag \u003d\u003d LF_PAX_EXTENDED_HEADER_LC || linkFlag \u003d\u003d LF_PAX_EXTENDED_HEADER_UC;\r\n}"
      },
      {
        "name": "TarArchiveEntry#getName(...0)",
        "body": "{\r\n    return name;\r\n}"
      },
      {
        "name": "TarArchiveEntry#isGlobalPaxHeader(...0)",
        "body": "{\r\n    return linkFlag \u003d\u003d LF_PAX_GLOBAL_EXTENDED_HEADER;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isFIFO",
    "signature": "boolean isFIFO()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_FIFO;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 54) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 54) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isFile",
    "signature": "boolean isFile()",
    "visibility": "public",
    "body": "{\r\n    if (file !\u003d null) {\r\n        return Files.isRegularFile(file, linkOptions);\r\n    }\r\n    if (linkFlag \u003d\u003d LF_OLDNORM || linkFlag \u003d\u003d LF_NORMAL) {\r\n        return true;\r\n    }\r\n    return linkFlag !\u003d LF_DIR \u0026\u0026 !getName().endsWith(\"/\");\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($b0 \u003d\u003d false) → B3 | else → B4",
      "B3 : If($i3 !\u003d 48) → B4 | else → B5",
      "B5 : If($i4 \u003d\u003d 53) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $r1 \u003d Path file\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d Path file\u003e\n  $r3 \u003d LinkOption[] linkOptions\u003e\n  $z1 \u003d Files.isRegularFile($r4, $r3)\n  return\n}",
      "B2 {\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  if ($b0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $b1 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i3 \u003d (int) $b1\n  if ($i3 !\u003d 48) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $b2 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i4 \u003d (int) $b2\n  if ($i4 \u003d\u003d 53) goto B6 else B8\n}",
      "B6 {\n  $r2 \u003d r0.getName()\n  $z0 \u003d $r2.endsWith(\"/\")\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#getName(...0)",
        "body": "{\r\n    return name;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isGlobalPaxHeader",
    "signature": "boolean isGlobalPaxHeader()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_PAX_GLOBAL_EXTENDED_HEADER;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 103) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 103) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isGNULongLinkEntry",
    "signature": "boolean isGNULongLinkEntry()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_GNUTYPE_LONGLINK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 75) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 75) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isGNULongNameEntry",
    "signature": "boolean isGNULongNameEntry()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_GNUTYPE_LONGNAME;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 76) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 76) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isGNUSparse",
    "signature": "boolean isGNUSparse()",
    "visibility": "public",
    "body": "{\r\n    return isOldGNUSparse() || isPaxGNUSparse();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $z0 \u003d r0.isOldGNUSparse()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d r0.isPaxGNUSparse()\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#isPaxGNUSparse(...0)",
        "body": "{\r\n    return paxGNUSparse;\r\n}"
      },
      {
        "name": "TarArchiveEntry#isOldGNUSparse(...0)",
        "body": "{\r\n    return linkFlag \u003d\u003d LF_GNUTYPE_SPARSE;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isLink",
    "signature": "boolean isLink()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_LINK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 49) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 49) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isOldGNUSparse",
    "signature": "boolean isOldGNUSparse()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_GNUTYPE_SPARSE;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 83) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 83) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isPaxHeader",
    "signature": "boolean isPaxHeader()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_PAX_EXTENDED_HEADER_LC || linkFlag \u003d\u003d LF_PAX_EXTENDED_HEADER_UC;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d 120) → B1 | else → B2",
      "B1 : If($i3 !\u003d 88) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i2 \u003d (int) $b0\n  if ($i2 \u003d\u003d 120) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i3 \u003d (int) $b1\n  if ($i3 !\u003d 88) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isSparse",
    "signature": "boolean isSparse()",
    "visibility": "public",
    "body": "{\r\n    return isGNUSparse() || isStarSparse();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $z0 \u003d r0.isGNUSparse()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d r0.isStarSparse()\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#isGNUSparse(...0)",
        "body": "{\r\n    return isOldGNUSparse() || isPaxGNUSparse();\r\n}"
      },
      {
        "name": "TarArchiveEntry#isStarSparse(...0)",
        "body": "{\r\n    return starSparse;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "isSymbolicLink",
    "signature": "boolean isSymbolicLink()",
    "visibility": "public",
    "body": "{\r\n    return linkFlag \u003d\u003d LF_SYMLINK;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 50) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  $b0 \u003d TarArchiveEntry: byte linkFlag\u003e\n  $i1 \u003d (int) $b0\n  if ($i1 !\u003d 50) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "setDataOffset",
    "signature": "void setDataOffset(long)",
    "visibility": "public",
    "body": "{\r\n    if (dataOffset \u003c 0) {\r\n        throw new IllegalArgumentException(\"The offset cannot be smaller than 0\");\r\n    }\r\n    this.dataOffset \u003d dataOffset;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The offset cannot be smaller than 0\")\n  throw $r2\n}",
      "B2 {\n  TarArchiveEntry: long dataOffset\u003e \u003d l0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "setDevMajor",
    "signature": "void setDevMajor(int)",
    "visibility": "public",
    "body": "{\r\n    if (devNo \u003c 0) {\r\n        throw new IllegalArgumentException(\"Major device number is out of \" + \"range: \" + devNo);\r\n    }\r\n    this.devMajor \u003d devNo;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r2.append(\"Major device number is out of range: \")\n  $r4 \u003d $r3.append(i0)\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r1\n}",
      "B2 {\n  TarArchiveEntry: int devMajor\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "setDevMinor",
    "signature": "void setDevMinor(int)",
    "visibility": "public",
    "body": "{\r\n    if (devNo \u003c 0) {\r\n        throw new IllegalArgumentException(\"Minor device number is out of \" + \"range: \" + devNo);\r\n    }\r\n    this.devMinor \u003d devNo;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r2.append(\"Minor device number is out of range: \")\n  $r4 \u003d $r3.append(i0)\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r1\n}",
      "B2 {\n  TarArchiveEntry: int devMinor\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "setSize",
    "signature": "void setSize(long)",
    "visibility": "public",
    "body": "{\r\n    if (size \u003c 0) {\r\n        throw new IllegalArgumentException(\"Size is out of range: \" + size);\r\n    }\r\n    this.size \u003d size;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r6.append(\"Size is out of range: \")\n  $r4 \u003d $r3.append(l0)\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r7\n}",
      "B2 {\n  TarArchiveEntry: long size\u003e \u003d l0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveEntry",
    "methodName": "writeEntryHeader",
    "signature": "void writeEntryHeader(byte[],org.apache.commons.compress.archivers.zip.ZipEncoding,boolean)",
    "visibility": "public",
    "body": "{\r\n    int offset \u003d 0;\r\n    offset \u003d TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN, encoding);\r\n    offset \u003d writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\r\n    offset \u003d writeEntryHeaderField(userId, outbuf, offset, UIDLEN, starMode);\r\n    offset \u003d writeEntryHeaderField(groupId, outbuf, offset, GIDLEN, starMode);\r\n    offset \u003d writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\r\n    offset \u003d writeEntryHeaderField(TimeUtils.toUnixTime(mTime), outbuf, offset, MODTIMELEN, starMode);\r\n    final int csOffset \u003d offset;\r\n    offset \u003d fill((byte) \u0027 \u0027, offset, outbuf, CHKSUMLEN);\r\n    outbuf[offset++] \u003d linkFlag;\r\n    offset \u003d TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN, encoding);\r\n    offset \u003d TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\r\n    offset \u003d TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\r\n    offset \u003d TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN, encoding);\r\n    offset \u003d TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN, encoding);\r\n    offset \u003d writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN, starMode);\r\n    offset \u003d writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN, starMode);\r\n    if (starMode) {\r\n        // skip prefix\r\n        offset \u003d fill(0, offset, outbuf, PREFIXLEN_XSTAR);\r\n        offset \u003d writeEntryHeaderOptionalTimeField(aTime, offset, outbuf, ATIMELEN_XSTAR);\r\n        offset \u003d writeEntryHeaderOptionalTimeField(cTime, offset, outbuf, CTIMELEN_XSTAR);\r\n        // 8-byte fill\r\n        offset \u003d fill(0, offset, outbuf, 8);\r\n        // Do not write MAGIC_XSTAR because it causes issues with some TAR tools\r\n        // This makes it effectively XUSTAR, which guarantees compatibility with USTAR\r\n        offset \u003d fill(0, offset, outbuf, XSTAR_MAGIC_LEN);\r\n    }\r\n    // NOSONAR - assignment as documentation\r\n    offset \u003d fill(0, offset, outbuf, outbuf.length - offset);\r\n    final long chk \u003d TarUtils.computeCheckSum(outbuf);\r\n    TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveEntry\n  r1 :\u003d @parameter0: byte[]\n  ZipEncoding\n  z0 :\u003d @parameter2: boolean\n  $r3 \u003d String name\u003e\n  i14 \u003d TarUtils.formatNameBytes($r3, r1, 0, 100, r2)\n  $i0 \u003d TarArchiveEntry: int mode\u003e\n  $l1 \u003d (long) $i0\n  i15 \u003d r0.writeEntryHeaderField($l1, r1, i14, 8, z0)\n  $l2 \u003d TarArchiveEntry: long userId\u003e\n  i16 \u003d r0.writeEntryHeaderField($l2, r1, i15, 8, z0)\n  $l3 \u003d TarArchiveEntry: long groupId\u003e\n  i17 \u003d r0.writeEntryHeaderField($l3, r1, i16, 8, z0)\n  $l4 \u003d TarArchiveEntry: long size\u003e\n  i18 \u003d r0.writeEntryHeaderField($l4, r1, i17, 12, z0)\n  $r4 \u003d FileTime mTime\u003e\n  $l5 \u003d TimeUtils.toUnixTime($r4)\n  i19 \u003d r0.writeEntryHeaderField($l5, r1, i18, 12, z0)\n  i20 \u003d r0.fill(32, i19, r1, 8)\n  i21 \u003d i20 + 1\n  $b6 \u003d TarArchiveEntry: byte linkFlag\u003e\n  r1[i20] \u003d $b6\n  $r5 \u003d String linkName\u003e\n  i22 \u003d TarUtils.formatNameBytes($r5, r1, i21, 100, r2)\n  $r6 \u003d String magic\u003e\n  i23 \u003d TarUtils.formatNameBytes($r6, r1, i22, 6)\n  $r7 \u003d String version\u003e\n  i24 \u003d TarUtils.formatNameBytes($r7, r1, i23, 2)\n  $r8 \u003d String userName\u003e\n  i25 \u003d TarUtils.formatNameBytes($r8, r1, i24, 32, r2)\n  $r9 \u003d String groupName\u003e\n  i26 \u003d TarUtils.formatNameBytes($r9, r1, i25, 32, r2)\n  $i7 \u003d TarArchiveEntry: int devMajor\u003e\n  $l8 \u003d (long) $i7\n  i27 \u003d r0.writeEntryHeaderField($l8, r1, i26, 8, z0)\n  $i9 \u003d TarArchiveEntry: int devMinor\u003e\n  $l10 \u003d (long) $i9\n  i28 \u003d r0.writeEntryHeaderField($l10, r1, i27, 8, z0)\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  i29 \u003d r0.fill(0, i28, r1, 131)\n  $r10 \u003d FileTime aTime\u003e\n  i30 \u003d r0.writeEntryHeaderOptionalTimeField($r10, i29, r1, 12)\n  $r11 \u003d FileTime cTime\u003e\n  i31 \u003d r0.writeEntryHeaderOptionalTimeField($r11, i30, r1, 12)\n  i32 \u003d r0.fill(0, i31, r1, 8)\n  i28 \u003d r0.fill(0, i32, r1, 4)\n}",
      "B2 {\n  $i11 \u003d lengthof r1\n  $i12 \u003d $i11 - i28\n  r0.fill(0, i28, r1, $i12)\n  $l13 \u003d TarUtils.computeCheckSum(r1)\n  TarUtils.formatCheckSumOctalBytes($l13, r1, i19, 8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveEntry#writeEntryHeaderOptionalTimeField(...4)",
        "body": "{\r\n    if (time !\u003d null) {\r\n        offset \u003d writeEntryHeaderField(TimeUtils.toUnixTime(time), outbuf, offset, fieldLength, true);\r\n    } else {\r\n        offset \u003d fill(0, offset, outbuf, fieldLength);\r\n    }\r\n    return offset;\r\n}"
      },
      {
        "name": "TarArchiveEntry#writeEntryHeaderField(...5)",
        "body": "{\r\n    if (!starMode \u0026\u0026 (value \u003c 0 || value \u003e\u003d 1L \u003c\u003c 3 * (length - 1))) {\r\n        // value doesn\u0027t fit into field when written as octal\r\n        // number, will be written to PAX header or causes an\r\n        // error\r\n        return TarUtils.formatLongOctalBytes(0, outbuf, offset, length);\r\n    }\r\n    return TarUtils.formatLongOctalOrBinaryBytes(value, outbuf, offset, length);\r\n}"
      },
      {
        "name": "TarArchiveEntry#fill(...4)",
        "body": "{\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        outbuf[offset + i] \u003d value;\r\n    }\r\n    return offset + length;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    final int versionOffset \u003d TarConstants.VERSION_OFFSET;\r\n    final int versionLen \u003d TarConstants.VERSIONLEN;\r\n    if (length \u003c versionOffset + versionLen) {\r\n        return false;\r\n    }\r\n    final int magicOffset \u003d TarConstants.MAGIC_OFFSET;\r\n    final int magicLen \u003d TarConstants.MAGICLEN;\r\n    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, magicOffset, magicLen) \u0026\u0026 ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX, signature, versionOffset, versionLen)) {\r\n        return true;\r\n    }\r\n    // IBM AIX tar.h https://www.ibm.com/docs/sv/aix/7.2.0?topic\u003dfiles-tarh-file : \"This field is terminated with a space only.\"\r\n    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, magicOffset, magicLen) \u0026\u0026 ArchiveUtils.matchAsciiBuffer(VERSION_AIX, signature, versionOffset, versionLen)) {\r\n        return true;\r\n    }\r\n    if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU, signature, magicOffset, magicLen) \u0026\u0026 (ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE, signature, versionOffset, versionLen) || ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO, signature, versionOffset, versionLen))) {\r\n        return true;\r\n    }\r\n    // COMPRESS-107 - recognize Ant tar files\r\n    return ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT, signature, magicOffset, magicLen) \u0026\u0026 ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT, signature, versionOffset, versionLen);\r\n}",
    "nodes": 17,
    "edges": 22,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 265) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z8 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z7 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B12",
      "B9 : If($z5 !\u003d 0) → B10 | else → B11",
      "B10 : If($z6 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($z3 \u003d\u003d false) → B13 | else → B15",
      "B13 : If($z4 \u003d\u003d false) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003e\u003d 265) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", r0, 257, 6)\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $z8 \u003d ArchiveUtils.matchAsciiBuffer(\"00\", r0, 263, 2)\n  if ($z8 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z1 \u003d ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", r0, 257, 6)\n  if ($z1 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $z7 \u003d ArchiveUtils.matchAsciiBuffer(\"0 \", r0, 263, 2)\n  if ($z7 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $z2 \u003d ArchiveUtils.matchAsciiBuffer(\"ustar \", r0, 257, 6)\n  if ($z2 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  $z5 \u003d ArchiveUtils.matchAsciiBuffer(\" \\u0000\", r0, 263, 2)\n  if ($z5 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $z6 \u003d ArchiveUtils.matchAsciiBuffer(\"0\\u0000\", r0, 263, 2)\n  if ($z6 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  $z3 \u003d ArchiveUtils.matchAsciiBuffer(\"ustar\\u0000\", r0, 257, 6)\n  if ($z3 \u003d\u003d false) goto B13 else B15\n}",
      "B13 {\n  $z4 \u003d ArchiveUtils.matchAsciiBuffer(\"\\u0000\\u0000\", r0, 263, 2)\n  if ($z4 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $z9 \u003d 1\n  goto B16\n}",
      "B15 {\n  $z9 \u003d 0\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "available",
    "signature": "int available()",
    "visibility": "public",
    "body": "{\r\n    if (isDirectory()) {\r\n        return 0;\r\n    }\r\n    final long available \u003d currEntry.getRealSize() - entryOffset;\r\n    if (available \u003e Integer.MAX_VALUE) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return (int) available;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i5 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TarArchiveInputStream\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d TarArchiveEntry currEntry\u003e\n  $l1 \u003d $r1.getRealSize()\n  $l0 \u003d TarArchiveInputStream: long entryOffset\u003e\n  l2 \u003d $l1 - $l0\n  $b3 \u003d l2 cmp 2147483647L\n  $i5 \u003d (int) $b3\n  if ($i5 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $i4 \u003d (int) l2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveInputStream#isDirectory(...0)",
        "body": "{\r\n    return currEntry !\u003d null \u0026\u0026 currEntry.isDirectory();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    // Close all the input streams in sparseInputStreams\r\n    if (sparseInputStreams !\u003d null) {\r\n        for (final InputStream inputStream : sparseInputStreams) {\r\n            inputStream.close();\r\n        }\r\n    }\r\n    in.close();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TarArchiveInputStream\n  $r1 \u003d List sparseInputStreams\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d List sparseInputStreams\u003e\n  r4 \u003d $r3.iterator()\n}",
      "B2 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d r4.next()\n  r6 \u003d InputStream) $r5\n  r6.close()\n  goto B2\n}",
      "B4 {\n  $r2 \u003d InputStream in\u003e\n  $r2.close()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "getNextTarEntry",
    "signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry getNextTarEntry()",
    "visibility": "public",
    "body": "{\r\n    if (isAtEOF()) {\r\n        return null;\r\n    }\r\n    if (currEntry !\u003d null) {\r\n        /* Skip will only go to the end of the current entry */\r\n        IOUtils.skip(this, Long.MAX_VALUE);\r\n        /* skip to the end of the last record */\r\n        skipRecordPadding();\r\n    }\r\n    final byte[] headerBuf \u003d getRecord();\r\n    if (headerBuf \u003d\u003d null) {\r\n        /* hit EOF */\r\n        currEntry \u003d null;\r\n        return null;\r\n    }\r\n    try {\r\n        currEntry \u003d new TarArchiveEntry(globalPaxHeaders, headerBuf, zipEncoding, lenient);\r\n    } catch (final IllegalArgumentException e) {\r\n        throw new IOException(\"Error detected parsing the header\", e);\r\n    }\r\n    entryOffset \u003d 0;\r\n    entrySize \u003d currEntry.getSize();\r\n    if (currEntry.isGNULongLinkEntry()) {\r\n        final byte[] longLinkData \u003d getLongNameData();\r\n        if (longLinkData \u003d\u003d null) {\r\n            // Bugzilla: 40334\r\n            // Malformed tar file - long link entry name not followed by entry\r\n            return null;\r\n        }\r\n        currEntry.setLinkName(zipEncoding.decode(longLinkData));\r\n    }\r\n    if (currEntry.isGNULongNameEntry()) {\r\n        final byte[] longNameData \u003d getLongNameData();\r\n        if (longNameData \u003d\u003d null) {\r\n            // Bugzilla: 40334\r\n            // Malformed tar file - long entry name not followed by entry\r\n            return null;\r\n        }\r\n        // COMPRESS-509 : the name of directories should end with \u0027/\u0027\r\n        final String name \u003d zipEncoding.decode(longNameData);\r\n        currEntry.setName(name);\r\n        if (currEntry.isDirectory() \u0026\u0026 !name.endsWith(\"/\")) {\r\n            currEntry.setName(name + \"/\");\r\n        }\r\n    }\r\n    if (currEntry.isGlobalPaxHeader()) {\r\n        // Process Global Pax headers\r\n        readGlobalPaxHeaders();\r\n    }\r\n    try {\r\n        if (currEntry.isPaxHeader()) {\r\n            // Process Pax headers\r\n            paxHeaders();\r\n        } else if (!globalPaxHeaders.isEmpty()) {\r\n            applyPaxHeadersToCurrentEntry(globalPaxHeaders, globalSparseHeaders);\r\n        }\r\n    } catch (final NumberFormatException e) {\r\n        throw new IOException(\"Error detected parsing the pax header\", e);\r\n    }\r\n    if (currEntry.isOldGNUSparse()) {\r\n        // Process sparse files\r\n        readOldGNUSparse();\r\n    }\r\n    // If the size of the next element in the archive has changed\r\n    // due to a new size being reported in the POSIX header\r\n    // information, we update entrySize here so that it contains\r\n    // the correct value.\r\n    entrySize \u003d currEntry.getSize();\r\n    return currEntry;\r\n}",
    "nodes": 29,
    "edges": 35,
    "cc": 8,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r27 !\u003d null) → B5 | else → B6",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B12",
      "B9 : If(r32 !\u003d null) → B10 | else → B11",
      "B12 : If($z3 \u003d\u003d false) → B13 | else → B18",
      "B13 : If(r33 !\u003d null) → B14 | else → B15",
      "B15 : If($z7 \u003d\u003d false) → B16 | else → B18",
      "B16 : If($z8 !\u003d 0) → B17 | else → B18",
      "B18 : If($z9 \u003d\u003d false) → B19 | else → B20",
      "B20 : If($z4 \u003d\u003d false) → B21 | else → B22",
      "B22 : If($z5 !\u003d 0) → B23 | else → B24",
      "B26 : If($z6 \u003d\u003d false) → B27 | else → B28"
    ],
    "blockList": [
      "B0 {\n  TarArchiveInputStream\n  $z0 \u003d r0.isAtEOF()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d TarArchiveEntry currEntry\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  IOUtils.skip(r0, 9223372036854775807L)\n  r0.skipRecordPadding()\n}",
      "B4 {\n  $r27 \u003d r0.getRecord()\n  if ($r27 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  TarArchiveEntry currEntry\u003e \u003d null\n  return\n}",
      "B6 {\n  $r2 \u003d TarArchiveEntry\n  $r4 \u003d Map globalPaxHeaders\u003e\n  $r3 \u003d ZipEncoding zipEncoding\u003e\n  $z1 \u003d TarArchiveInputStream: boolean lenient\u003e\n  new TarArchiveEntry($r4, $r27, $r3, $z1)\n  TarArchiveEntry currEntry\u003e \u003d $r2\n  goto B8\n}",
      "B7 {\n  $r30 :\u003d @caughtexception\n  $r31 \u003d IOException\n  new IOException(\"Error detected parsing the header\", $r30)\n  throw $r31\n}",
      "B8 {\n  TarArchiveInputStream: long entryOffset\u003e \u003d 0L\n  $r5 \u003d TarArchiveEntry currEntry\u003e\n  $l0 \u003d $r5.getSize()\n  TarArchiveInputStream: long entrySize\u003e \u003d $l0\n  $r6 \u003d TarArchiveEntry currEntry\u003e\n  $z2 \u003d $r6.isGNULongLinkEntry()\n  if ($z2 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  r32 \u003d r0.getLongNameData()\n  if (r32 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $r25 \u003d TarArchiveEntry currEntry\u003e\n  $r24 \u003d ZipEncoding zipEncoding\u003e\n  $r26 \u003d $r24.decode(r32)\n  $r25.setLinkName($r26)\n}",
      "B12 {\n  $r7 \u003d TarArchiveEntry currEntry\u003e\n  $z3 \u003d $r7.isGNULongNameEntry()\n  if ($z3 \u003d\u003d false) goto B13 else B18\n}",
      "B13 {\n  r33 \u003d r0.getLongNameData()\n  if (r33 !\u003d null) goto B14 else B15\n}",
      "B14 {\n  return\n}",
      "B15 {\n  $r15 \u003d ZipEncoding zipEncoding\u003e\n  r16 \u003d $r15.decode(r33)\n  $r17 \u003d TarArchiveEntry currEntry\u003e\n  $r17.setName(r16)\n  $r18 \u003d TarArchiveEntry currEntry\u003e\n  $z7 \u003d $r18.isDirectory()\n  if ($z7 \u003d\u003d false) goto B16 else B18\n}",
      "B16 {\n  $z8 \u003d r16.endsWith(\"/\")\n  if ($z8 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r20 \u003d TarArchiveEntry currEntry\u003e\n  $r19 \u003d StringBuilder\n  new StringBuilder()\n  $r21 \u003d $r19.append(r16)\n  $r22 \u003d $r21.append(\"/\")\n  $r23 \u003d $r22.toString()\n  $r20.setName($r23)\n}",
      "B18 {\n  $r34 \u003d TarArchiveEntry currEntry\u003e\n  $z9 \u003d $r34.isGlobalPaxHeader()\n  if ($z9 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  r0.readGlobalPaxHeaders()\n}",
      "B20 {\n  $r8 \u003d TarArchiveEntry currEntry\u003e\n  $z4 \u003d $r8.isPaxHeader()\n  if ($z4 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  r0.paxHeaders()\n  goto B24\n}",
      "B22 {\n  $r9 \u003d Map globalPaxHeaders\u003e\n  $z5 \u003d $r9.isEmpty()\n  if ($z5 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  $r14 \u003d Map globalPaxHeaders\u003e\n  $r13 \u003d List globalSparseHeaders\u003e\n  r0.applyPaxHeadersToCurrentEntry($r14, $r13)\n}",
      "B24 {\n  goto B26\n}",
      "B25 {\n  $r28 :\u003d @caughtexception\n  $r29 \u003d IOException\n  new IOException(\"Error detected parsing the pax header\", $r28)\n  throw $r29\n}",
      "B26 {\n  $r10 \u003d TarArchiveEntry currEntry\u003e\n  $z6 \u003d $r10.isOldGNUSparse()\n  if ($z6 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  r0.readOldGNUSparse()\n}",
      "B28 {\n  $r11 \u003d TarArchiveEntry currEntry\u003e\n  $l1 \u003d $r11.getSize()\n  TarArchiveInputStream: long entrySize\u003e \u003d $l1\n  $r12 \u003d TarArchiveEntry currEntry\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B18",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B24",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveInputStream#readGlobalPaxHeaders(...0)",
        "body": "{\r\n    globalPaxHeaders \u003d TarUtils.parsePaxHeaders(this, globalSparseHeaders, globalPaxHeaders, entrySize);\r\n    // Get the actual file entry\r\n    getNextEntry();\r\n    if (currEntry \u003d\u003d null) {\r\n        throw new IOException(\"Error detected parsing the pax header\");\r\n    }\r\n}"
      },
      {
        "name": "TarArchiveInputStream#isAtEOF(...0)",
        "body": "{\r\n    return atEof;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#skipRecordPadding(...0)",
        "body": "{\r\n    if (!isDirectory() \u0026\u0026 this.entrySize \u003e 0 \u0026\u0026 this.entrySize % getRecordSize() !\u003d 0) {\r\n        final long available \u003d in.available();\r\n        final long numRecords \u003d this.entrySize / getRecordSize() + 1;\r\n        final long padding \u003d numRecords * getRecordSize() - this.entrySize;\r\n        long skipped \u003d IOUtils.skip(in, padding);\r\n        skipped \u003d getActuallySkipped(available, skipped, padding);\r\n        count(skipped);\r\n    }\r\n}"
      },
      {
        "name": "TarArchiveInputStream#paxHeaders(...0)",
        "body": "{\r\n    List\u003cTarArchiveStructSparse\u003e sparseHeaders \u003d new ArrayList\u003c\u003e();\r\n    final Map\u003cString, String\u003e headers \u003d TarUtils.parsePaxHeaders(this, sparseHeaders, globalPaxHeaders, entrySize);\r\n    // for 0.1 PAX Headers\r\n    if (headers.containsKey(TarGnuSparseKeys.MAP)) {\r\n        sparseHeaders \u003d new ArrayList\u003c\u003e(TarUtils.parseFromPAX01SparseHeaders(headers.get(TarGnuSparseKeys.MAP)));\r\n    }\r\n    // Get the actual file entry\r\n    getNextEntry();\r\n    if (currEntry \u003d\u003d null) {\r\n        throw new IOException(\"premature end of tar archive. Didn\u0027t find any entry after PAX header.\");\r\n    }\r\n    applyPaxHeadersToCurrentEntry(headers, sparseHeaders);\r\n    // for 1.0 PAX Format, the sparse map is stored in the file data block\r\n    if (currEntry.isPaxGNU1XSparse()) {\r\n        sparseHeaders \u003d TarUtils.parsePAX1XSparseHeaders(in, getRecordSize());\r\n        currEntry.setSparseHeaders(sparseHeaders);\r\n    }\r\n    // sparse headers are all done reading, we need to build\r\n    // sparse input streams using these sparse headers\r\n    buildSparseInputStreams();\r\n}"
      },
      {
        "name": "TarArchiveInputStream#applyPaxHeadersToCurrentEntry(...2)",
        "body": "{\r\n    currEntry.updateEntryFromPaxHeaders(headers);\r\n    currEntry.setSparseHeaders(sparseHeaders);\r\n}"
      },
      {
        "name": "TarArchiveInputStream#getLongNameData(...0)",
        "body": "{\r\n    // read in the name\r\n    final ByteArrayOutputStream longName \u003d new ByteArrayOutputStream();\r\n    int length \u003d 0;\r\n    while ((length \u003d read(smallBuf)) \u003e\u003d 0) {\r\n        longName.write(smallBuf, 0, length);\r\n    }\r\n    getNextEntry();\r\n    if (currEntry \u003d\u003d null) {\r\n        // Bugzilla: 40334\r\n        // Malformed tar file - long entry name not followed by entry\r\n        return null;\r\n    }\r\n    byte[] longNameData \u003d longName.toByteArray();\r\n    // remove trailing null terminator(s)\r\n    length \u003d longNameData.length;\r\n    while (length \u003e 0 \u0026\u0026 longNameData[length - 1] \u003d\u003d 0) {\r\n        --length;\r\n    }\r\n    if (length !\u003d longNameData.length) {\r\n        longNameData \u003d Arrays.copyOf(longNameData, length);\r\n    }\r\n    return longNameData;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#getRecord(...0)",
        "body": "{\r\n    byte[] headerBuf \u003d readRecord();\r\n    setAtEOF(isEOFRecord(headerBuf));\r\n    if (isAtEOF() \u0026\u0026 headerBuf !\u003d null) {\r\n        tryToConsumeSecondEOFRecord();\r\n        consumeRemainderOfLastBlock();\r\n        headerBuf \u003d null;\r\n    }\r\n    return headerBuf;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#readOldGNUSparse(...0)",
        "body": "{\r\n    if (currEntry.isExtended()) {\r\n        TarArchiveSparseEntry entry;\r\n        do {\r\n            final byte[] headerBuf \u003d getRecord();\r\n            if (headerBuf \u003d\u003d null) {\r\n                throw new IOException(\"premature end of tar archive. Didn\u0027t find extended_header after header with extended flag.\");\r\n            }\r\n            entry \u003d new TarArchiveSparseEntry(headerBuf);\r\n            currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());\r\n        } while (entry.isExtended());\r\n    }\r\n    // sparse headers are all done reading, we need to build\r\n    // sparse input streams using these sparse headers\r\n    buildSparseInputStreams();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (numToRead \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    int totalRead \u003d 0;\r\n    if (isAtEOF() || isDirectory()) {\r\n        return -1;\r\n    }\r\n    if (currEntry \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current tar entry\");\r\n    }\r\n    if (entryOffset \u003e\u003d currEntry.getRealSize()) {\r\n        return -1;\r\n    }\r\n    numToRead \u003d Math.min(numToRead, available());\r\n    if (currEntry.isSparse()) {\r\n        // for sparse entries, we need to read them in another way\r\n        totalRead \u003d readSparse(buf, offset, numToRead);\r\n    } else {\r\n        totalRead \u003d in.read(buf, offset, numToRead);\r\n    }\r\n    if (totalRead \u003d\u003d -1) {\r\n        if (numToRead \u003e 0) {\r\n            throw new IOException(\"Truncated TAR archive\");\r\n        }\r\n        setAtEOF(true);\r\n    } else {\r\n        count(totalRead);\r\n        entryOffset +\u003d totalRead;\r\n    }\r\n    return totalRead;\r\n}",
    "nodes": 18,
    "edges": 20,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i8 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($r1 !\u003d null) → B6 | else → B7",
      "B7 : If($i13 \u003c 0) → B8 | else → B9",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11",
      "B12 : If(i10 !\u003d $i17) → B13 | else → B16",
      "B13 : If(i9 \u003c\u003d 0) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  TarArchiveInputStream\n  r4 :\u003d @parameter0: byte[]\n  i4 :\u003d @parameter1: int\n  i8 :\u003d @parameter2: int\n  if (i8 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r0.isAtEOF()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z1 \u003d r0.isDirectory()\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $i12 \u003d (int) -1\n  return\n}",
      "B5 {\n  $r1 \u003d TarArchiveEntry currEntry\u003e\n  if ($r1 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r8 \u003d IllegalStateException\n  new IllegalStateException(\"No current tar entry\")\n  throw $r8\n}",
      "B7 {\n  $l0 \u003d TarArchiveInputStream: long entryOffset\u003e\n  $r2 \u003d TarArchiveEntry currEntry\u003e\n  $l1 \u003d $r2.getRealSize()\n  $b2 \u003d $l0 cmp $l1\n  $i13 \u003d (int) $b2\n  if ($i13 \u003c 0) goto B8 else B9\n}",
      "B8 {\n  $i15 \u003d (int) -1\n  return\n}",
      "B9 {\n  $i3 \u003d r0.available()\n  i9 \u003d Math.min(i8, $i3)\n  $r3 \u003d TarArchiveEntry currEntry\u003e\n  $z2 \u003d $r3.isSparse()\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  i10 \u003d r0.readSparse(r4, i4, i9)\n  goto B12\n}",
      "B11 {\n  $r5 \u003d InputStream in\u003e\n  i10 \u003d $r5.read(r4, i4, i9)\n}",
      "B12 {\n  $i17 \u003d (int) -1\n  if (i10 !\u003d $i17) goto B13 else B16\n}",
      "B13 {\n  if (i9 \u003c\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r9 \u003d IOException\n  new IOException(\"Truncated TAR archive\")\n  throw $r9\n}",
      "B15 {\n  r0.setAtEOF(1)\n  goto B17\n}",
      "B16 {\n  r0.count(i10)\n  $l6 \u003d TarArchiveInputStream: long entryOffset\u003e\n  $l5 \u003d (long) i10\n  $l7 \u003d $l6 + $l5\n  TarArchiveInputStream: long entryOffset\u003e \u003d $l7\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveInputStream#isDirectory(...0)",
        "body": "{\r\n    return currEntry !\u003d null \u0026\u0026 currEntry.isDirectory();\r\n}"
      },
      {
        "name": "TarArchiveInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TarArchiveInputStream#isAtEOF(...0)",
        "body": "{\r\n    return atEof;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#available(...0)",
        "body": "{\r\n    if (isDirectory()) {\r\n        return 0;\r\n    }\r\n    final long available \u003d currEntry.getRealSize() - entryOffset;\r\n    if (available \u003e Integer.MAX_VALUE) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n    return (int) available;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#readSparse(...3)",
        "body": "{\r\n    // if there are no actual input streams, just read from the original input stream\r\n    if (sparseInputStreams \u003d\u003d null || sparseInputStreams.isEmpty()) {\r\n        return in.read(buf, offset, numToRead);\r\n    }\r\n    if (currentSparseInputStreamIndex \u003e\u003d sparseInputStreams.size()) {\r\n        return -1;\r\n    }\r\n    final InputStream currentInputStream \u003d sparseInputStreams.get(currentSparseInputStreamIndex);\r\n    final int readLen \u003d currentInputStream.read(buf, offset, numToRead);\r\n    // if the current input stream is the last input stream,\r\n    // just return the number of bytes read from current input stream\r\n    if (currentSparseInputStreamIndex \u003d\u003d sparseInputStreams.size() - 1) {\r\n        return readLen;\r\n    }\r\n    // if EOF of current input stream is meet, open a new input stream and recursively call read\r\n    if (readLen \u003d\u003d -1) {\r\n        currentSparseInputStreamIndex++;\r\n        return readSparse(buf, offset, numToRead);\r\n    }\r\n    // if the rest data of current input stream is not long enough, open a new input stream\r\n    // and recursively call read\r\n    if (readLen \u003c numToRead) {\r\n        currentSparseInputStreamIndex++;\r\n        final int readLenOfNext \u003d readSparse(buf, offset + readLen, numToRead - readLen);\r\n        if (readLenOfNext \u003d\u003d -1) {\r\n            return readLen;\r\n        }\r\n        return readLen + readLenOfNext;\r\n    }\r\n    // if the rest data of current input stream is enough(which means readLen \u003d\u003d len), just return readLen\r\n    return readLen;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#setAtEOF(...1)",
        "body": "{\r\n    this.atEof \u003d atEof;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
    "methodName": "skip",
    "signature": "long skip(long)",
    "visibility": "public",
    "body": "{\r\n    if (n \u003c\u003d 0 || isDirectory()) {\r\n        return 0;\r\n    }\r\n    final long availableOfInputStream \u003d in.available();\r\n    final long available \u003d currEntry.getRealSize() - entryOffset;\r\n    final long numToSkip \u003d Math.min(n, available);\r\n    long skipped;\r\n    if (!currEntry.isSparse()) {\r\n        skipped \u003d IOUtils.skip(in, numToSkip);\r\n        // for non-sparse entry, we should get the bytes actually skipped bytes along with\r\n        // inputStream.available() if inputStream is instance of FileInputStream\r\n        skipped \u003d getActuallySkipped(availableOfInputStream, skipped, numToSkip);\r\n    } else {\r\n        skipped \u003d skipSparse(numToSkip);\r\n    }\r\n    count(skipped);\r\n    entryOffset +\u003d skipped;\r\n    return skipped;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i12 \u003c\u003d 0) → B1 | else → B2",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  TarArchiveInputStream\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i12 \u003d (int) $b1\n  if ($i12 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d InputStream in\u003e\n  $i2 \u003d $r1.available()\n  l3 \u003d (long) $i2\n  $r2 \u003d TarArchiveEntry currEntry\u003e\n  $l5 \u003d $r2.getRealSize()\n  $l4 \u003d TarArchiveInputStream: long entryOffset\u003e\n  l6 \u003d $l5 - $l4\n  l7 \u003d Math.min(l0, l6)\n  $r3 \u003d TarArchiveEntry currEntry\u003e\n  $z1 \u003d $r3.isSparse()\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d InputStream in\u003e\n  l10 \u003d IOUtils.skip($r4, l7)\n  l11 \u003d r0.getActuallySkipped(l3, l10, l7)\n  goto B6\n}",
      "B5 {\n  l11 \u003d r0.skipSparse(l7)\n}",
      "B6 {\n  r0.count(l11)\n  $l8 \u003d TarArchiveInputStream: long entryOffset\u003e\n  $l9 \u003d $l8 + l11\n  TarArchiveInputStream: long entryOffset\u003e \u003d $l9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveInputStream#isDirectory(...0)",
        "body": "{\r\n    return currEntry !\u003d null \u0026\u0026 currEntry.isDirectory();\r\n}"
      },
      {
        "name": "TarArchiveInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TarArchiveInputStream#getActuallySkipped(...3)",
        "body": "{\r\n    long actuallySkipped \u003d skipped;\r\n    if (in instanceof FileInputStream) {\r\n        actuallySkipped \u003d Math.min(skipped, available);\r\n    }\r\n    if (actuallySkipped !\u003d expected) {\r\n        throw new IOException(\"Truncated TAR archive\");\r\n    }\r\n    return actuallySkipped;\r\n}"
      },
      {
        "name": "TarArchiveInputStream#skipSparse(...1)",
        "body": "{\r\n    if (sparseInputStreams \u003d\u003d null || sparseInputStreams.isEmpty()) {\r\n        return in.skip(n);\r\n    }\r\n    long bytesSkipped \u003d 0;\r\n    while (bytesSkipped \u003c n \u0026\u0026 currentSparseInputStreamIndex \u003c sparseInputStreams.size()) {\r\n        final InputStream currentInputStream \u003d sparseInputStreams.get(currentSparseInputStreamIndex);\r\n        bytesSkipped +\u003d currentInputStream.skip(n - bytesSkipped);\r\n        if (bytesSkipped \u003c n) {\r\n            currentSparseInputStreamIndex++;\r\n        }\r\n    }\r\n    return bytesSkipped;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (!isFinished()) {\r\n            finish();\r\n        }\r\n    } finally {\r\n        super.close();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.finish()\n}",
      "B2 {\n  r0.close()\n  goto B4\n}",
      "B3 {\n  $r1 :\u003d @caughtexception\n  r0.close()\n  throw $r1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveOutputStream#finish(...0)",
        "body": "{\r\n    checkFinished();\r\n    if (haveUnclosedEntry) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    writeEOFRecord();\r\n    writeEOFRecord();\r\n    padAsNeeded();\r\n    out.flush();\r\n    super.finish();\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
    "methodName": "closeArchiveEntry",
    "signature": "void closeArchiveEntry()",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    if (!haveUnclosedEntry) {\r\n        throw new IOException(\"No current entry to close\");\r\n    }\r\n    ((FixedLengthBlockOutputStream) out).flushBlock();\r\n    if (currBytes \u003c currSize) {\r\n        throw new IOException(\"Entry \u0027\" + currName + \"\u0027 closed at \u0027\" + currBytes + \"\u0027 before the \u0027\" + currSize + \"\u0027 bytes specified in the header were written\");\r\n    }\r\n    recordsWritten +\u003d currSize / RECORD_SIZE;\r\n    if (0 !\u003d currSize % RECORD_SIZE) {\r\n        recordsWritten++;\r\n    }\r\n    haveUnclosedEntry \u003d false;\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i14 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If($b9 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TarArchiveOutputStream\n  r0.checkFinished()\n  $z0 \u003d TarArchiveOutputStream: boolean haveUnclosedEntry\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d IOException\n  new IOException(\"No current entry to close\")\n  throw $r15\n}",
      "B2 {\n  $r1 \u003d OutputStream out\u003e\n  $r2 \u003d FixedLengthBlockOutputStream) $r1\n  $r2.flushBlock()\n  $l1 \u003d TarArchiveOutputStream: long currBytes\u003e\n  $l0 \u003d TarArchiveOutputStream: long currSize\u003e\n  $b2 \u003d $l1 cmp $l0\n  $i14 \u003d (int) $b2\n  if ($i14 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r17 \u003d IOException\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r16.append(\"Entry \\\u0027\")\n  $r5 \u003d String currName\u003e\n  $r7 \u003d $r6.append($r5)\n  $r8 \u003d $r7.append(\"\\\u0027 closed at \\\u0027\")\n  $l12 \u003d TarArchiveOutputStream: long currBytes\u003e\n  $r9 \u003d $r8.append($l12)\n  $r10 \u003d $r9.append(\"\\\u0027 before the \\\u0027\")\n  $l13 \u003d TarArchiveOutputStream: long currSize\u003e\n  $r11 \u003d $r10.append($l13)\n  $r12 \u003d $r11.append(\"\\\u0027 bytes specified in the header were written\")\n  $r13 \u003d $r12.toString()\n  new IOException($r13)\n  throw $r17\n}",
      "B4 {\n  $l5 \u003d TarArchiveOutputStream: long recordsWritten\u003e\n  $l3 \u003d TarArchiveOutputStream: long currSize\u003e\n  $l4 \u003d $l3 / 512L\n  $l6 \u003d $l5 + $l4\n  TarArchiveOutputStream: long recordsWritten\u003e \u003d $l6\n  $l7 \u003d TarArchiveOutputStream: long currSize\u003e\n  $l8 \u003d $l7 % 512L\n  $b9 \u003d 0L cmp $l8\n  if ($b9 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $l10 \u003d TarArchiveOutputStream: long recordsWritten\u003e\n  $l11 \u003d $l10 + 1L\n  TarArchiveOutputStream: long recordsWritten\u003e \u003d $l11\n}",
      "B6 {\n  TarArchiveOutputStream: boolean haveUnclosedEntry\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    if (haveUnclosedEntry) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    writeEOFRecord();\r\n    writeEOFRecord();\r\n    padAsNeeded();\r\n    out.flush();\r\n    super.finish();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TarArchiveOutputStream\n  r0.checkFinished()\n  $z0 \u003d TarArchiveOutputStream: boolean haveUnclosedEntry\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOException\n  new IOException(\"This archive contains unclosed entries.\")\n  throw $r2\n}",
      "B2 {\n  r0.writeEOFRecord()\n  r0.writeEOFRecord()\n  r0.padAsNeeded()\n  $r1 \u003d OutputStream out\u003e\n  $r1.flush()\n  r0.finish()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveOutputStream#padAsNeeded(...0)",
        "body": "{\r\n    final int start \u003d Math.toIntExact(recordsWritten % recordsPerBlock);\r\n    if (start !\u003d 0) {\r\n        for (int i \u003d start; i \u003c recordsPerBlock; i++) {\r\n            writeEOFRecord();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#writeEOFRecord(...0)",
        "body": "{\r\n    writeRecord(ArrayFill.fill(recordBuf, (byte) 0));\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
    "methodName": "putArchiveEntry",
    "signature": "void putArchiveEntry(org.apache.commons.compress.archivers.tar.TarArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    checkFinished();\r\n    if (archiveEntry.isGlobalPaxHeader()) {\r\n        final byte[] data \u003d encodeExtendedPaxHeadersContents(archiveEntry.getExtraPaxHeaders());\r\n        archiveEntry.setSize(data.length);\r\n        archiveEntry.writeEntryHeader(recordBuf, zipEncoding, bigNumberMode \u003d\u003d BIGNUMBER_STAR);\r\n        writeRecord(recordBuf);\r\n        currSize \u003d archiveEntry.getSize();\r\n        currBytes \u003d 0;\r\n        this.haveUnclosedEntry \u003d true;\r\n        write(data);\r\n        closeArchiveEntry();\r\n    } else {\r\n        final Map\u003cString, String\u003e paxHeaders \u003d new HashMap\u003c\u003e();\r\n        final String entryName \u003d archiveEntry.getName();\r\n        final boolean paxHeaderContainsPath \u003d handleLongName(archiveEntry, entryName, paxHeaders, \"path\", TarConstants.LF_GNUTYPE_LONGNAME, \"file name\");\r\n        final String linkName \u003d archiveEntry.getLinkName();\r\n        final boolean paxHeaderContainsLinkPath \u003d linkName !\u003d null \u0026\u0026 !linkName.isEmpty() \u0026\u0026 handleLongName(archiveEntry, linkName, paxHeaders, \"linkpath\", TarConstants.LF_GNUTYPE_LONGLINK, \"link name\");\r\n        if (bigNumberMode \u003d\u003d BIGNUMBER_POSIX) {\r\n            addPaxHeadersForBigNumbers(paxHeaders, archiveEntry);\r\n        } else if (bigNumberMode !\u003d BIGNUMBER_STAR) {\r\n            failForBigNumbers(archiveEntry);\r\n        }\r\n        if (addPaxHeadersForNonAsciiNames \u0026\u0026 !paxHeaderContainsPath \u0026\u0026 !ASCII.canEncode(entryName)) {\r\n            paxHeaders.put(\"path\", entryName);\r\n        }\r\n        if (addPaxHeadersForNonAsciiNames \u0026\u0026 !paxHeaderContainsLinkPath \u0026\u0026 (archiveEntry.isLink() || archiveEntry.isSymbolicLink()) \u0026\u0026 !ASCII.canEncode(linkName)) {\r\n            paxHeaders.put(\"linkpath\", linkName);\r\n        }\r\n        paxHeaders.putAll(archiveEntry.getExtraPaxHeaders());\r\n        if (!paxHeaders.isEmpty()) {\r\n            writePaxHeaders(archiveEntry, entryName, paxHeaders);\r\n        }\r\n        archiveEntry.writeEntryHeader(recordBuf, zipEncoding, bigNumberMode \u003d\u003d BIGNUMBER_STAR);\r\n        writeRecord(recordBuf);\r\n        currBytes \u003d 0;\r\n        if (archiveEntry.isDirectory()) {\r\n            currSize \u003d 0;\r\n        } else {\r\n            currSize \u003d archiveEntry.getSize();\r\n        }\r\n        currName \u003d entryName;\r\n        haveUnclosedEntry \u003d true;\r\n    }\r\n}",
    "nodes": 34,
    "edges": 51,
    "cc": 19,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B5",
      "B1 : If($i5 !\u003d 1) → B2 | else → B3",
      "B5 : If(r4 \u003d\u003d null) → B6 | else → B9",
      "B6 : If($z8 !\u003d 0) → B7 | else → B9",
      "B7 : If($z9 \u003d\u003d false) → B8 | else → B9",
      "B10 : If($i7 !\u003d 2) → B11 | else → B12",
      "B12 : If($i0 \u003d\u003d 1) → B13 | else → B14",
      "B14 : If($z12 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(z1 !\u003d 0) → B16 | else → B18",
      "B16 : If($z7 !\u003d 0) → B17 | else → B18",
      "B18 : If($z13 \u003d\u003d false) → B19 | else → B24",
      "B19 : If(z2 !\u003d 0) → B20 | else → B24",
      "B20 : If($z4 !\u003d 0) → B21 | else → B22",
      "B21 : If($z6 \u003d\u003d false) → B22 | else → B24",
      "B22 : If($z5 !\u003d 0) → B23 | else → B24",
      "B24 : If($z14 !\u003d 0) → B25 | else → B26",
      "B26 : If($i1 !\u003d 1) → B27 | else → B28",
      "B29 : If($z3 \u003d\u003d false) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  TarArchiveOutputStream\n  TarArchiveEntry\n  r0.checkFinished()\n  $z0 \u003d r1.isGlobalPaxHeader()\n  if ($z0 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  $r10 \u003d r1.getExtraPaxHeaders()\n  r14 \u003d r0.encodeExtendedPaxHeadersContents($r10)\n  $i3 \u003d lengthof r14\n  $l4 \u003d (long) $i3\n  r1.setSize($l4)\n  $r12 \u003d TarArchiveOutputStream: byte[] recordBuf\u003e\n  $r11 \u003d ZipEncoding zipEncoding\u003e\n  $i5 \u003d TarArchiveOutputStream: int bigNumberMode\u003e\n  if ($i5 !\u003d 1) goto B2 else B3\n}",
      "B2 {\n  $z10 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z10 \u003d 0\n}",
      "B4 {\n  r1.writeEntryHeader($r12, $r11, $z10)\n  $r13 \u003d TarArchiveOutputStream: byte[] recordBuf\u003e\n  r0.writeRecord($r13)\n  $l6 \u003d r1.getSize()\n  TarArchiveOutputStream: long currSize\u003e \u003d $l6\n  TarArchiveOutputStream: long currBytes\u003e \u003d 0L\n  TarArchiveOutputStream: boolean haveUnclosedEntry\u003e \u003d 1\n  r0.write(r14)\n  r0.closeArchiveEntry()\n  goto B33\n}",
      "B5 {\n  $r2 \u003d HashMap\n  new HashMap()\n  r3 \u003d r1.getName()\n  z1 \u003d r0.handleLongName(r1, r3, $r2, \"path\", 76, \"file name\")\n  r4 \u003d r1.getLinkName()\n  if (r4 \u003d\u003d null) goto B6 else B9\n}",
      "B6 {\n  $z8 \u003d r4.isEmpty()\n  if ($z8 !\u003d 0) goto B7 else B9\n}",
      "B7 {\n  $z9 \u003d r0.handleLongName(r1, r4, $r2, \"linkpath\", 75, \"link name\")\n  if ($z9 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $z11 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z11 \u003d 0\n}",
      "B10 {\n  z2 \u003d $z11\n  $i7 \u003d TarArchiveOutputStream: int bigNumberMode\u003e\n  if ($i7 !\u003d 2) goto B11 else B12\n}",
      "B11 {\n  r0.addPaxHeadersForBigNumbers($r2, r1)\n  goto B14\n}",
      "B12 {\n  $i0 \u003d TarArchiveOutputStream: int bigNumberMode\u003e\n  if ($i0 \u003d\u003d 1) goto B13 else B14\n}",
      "B13 {\n  r0.failForBigNumbers(r1)\n}",
      "B14 {\n  $z12 \u003d TarArchiveOutputStream: boolean addPaxHeadersForNonAsciiNames\u003e\n  if ($z12 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  if (z1 !\u003d 0) goto B16 else B18\n}",
      "B16 {\n  $r9 \u003d ZipEncoding ASCII\u003e\n  $z7 \u003d $r9.canEncode(r3)\n  if ($z7 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r2.put(\"path\", r3)\n}",
      "B18 {\n  $z13 \u003d TarArchiveOutputStream: boolean addPaxHeadersForNonAsciiNames\u003e\n  if ($z13 \u003d\u003d false) goto B19 else B24\n}",
      "B19 {\n  if (z2 !\u003d 0) goto B20 else B24\n}",
      "B20 {\n  $z4 \u003d r1.isLink()\n  if ($z4 !\u003d 0) goto B21 else B22\n}",
      "B21 {\n  $z6 \u003d r1.isSymbolicLink()\n  if ($z6 \u003d\u003d false) goto B22 else B24\n}",
      "B22 {\n  $r8 \u003d ZipEncoding ASCII\u003e\n  $z5 \u003d $r8.canEncode(r4)\n  if ($z5 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  $r2.put(\"linkpath\", r4)\n}",
      "B24 {\n  $r15 \u003d r1.getExtraPaxHeaders()\n  $r2.putAll($r15)\n  $z14 \u003d $r2.isEmpty()\n  if ($z14 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  r0.writePaxHeaders(r1, r3, $r2)\n}",
      "B26 {\n  $r6 \u003d TarArchiveOutputStream: byte[] recordBuf\u003e\n  $r5 \u003d ZipEncoding zipEncoding\u003e\n  $i1 \u003d TarArchiveOutputStream: int bigNumberMode\u003e\n  if ($i1 !\u003d 1) goto B27 else B28\n}",
      "B27 {\n  $z15 \u003d 1\n  goto B29\n}",
      "B28 {\n  $z15 \u003d 0\n}",
      "B29 {\n  r1.writeEntryHeader($r6, $r5, $z15)\n  $r7 \u003d TarArchiveOutputStream: byte[] recordBuf\u003e\n  r0.writeRecord($r7)\n  TarArchiveOutputStream: long currBytes\u003e \u003d 0L\n  $z3 \u003d r1.isDirectory()\n  if ($z3 \u003d\u003d false) goto B30 else B31\n}",
      "B30 {\n  TarArchiveOutputStream: long currSize\u003e \u003d 0L\n  goto B32\n}",
      "B31 {\n  $l2 \u003d r1.getSize()\n  TarArchiveOutputStream: long currSize\u003e \u003d $l2\n}",
      "B32 {\n  String currName\u003e \u003d r3\n  TarArchiveOutputStream: boolean haveUnclosedEntry\u003e \u003d 1\n}",
      "B33 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B33",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B24",
      "B19 --\u003e B20",
      "B19 --\u003e B24",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B21 --\u003e B24",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B33 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveOutputStream#writeRecord(...1)",
        "body": "{\r\n    if (record.length !\u003d RECORD_SIZE) {\r\n        throw new IOException(\"Record to write has length \u0027\" + record.length + \"\u0027 which is not the record size of \u0027\" + RECORD_SIZE + \"\u0027\");\r\n    }\r\n    out.write(record);\r\n    recordsWritten++;\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#encodeExtendedPaxHeadersContents(...1)",
        "body": "{\r\n    final StringWriter w \u003d new StringWriter();\r\n    headers.forEach((k, v) -\u003e {\r\n        int len \u003d k.length() + v.length() + 3 + /* blank, equals and newline */\r\n        2;\r\n        String line \u003d len + \" \" + k + \"\u003d\" + v + \"\\n\";\r\n        int actualLength \u003d line.getBytes(UTF_8).length;\r\n        while (len !\u003d actualLength) {\r\n            // Adjust for cases where length \u003c 10 or \u003e 100\r\n            // or where UTF-8 encoding isn\u0027t a single octet\r\n            // per character.\r\n            // Must be in loop as size may go from 99 to 100 in\r\n            // first pass, so we\u0027d need a second.\r\n            len \u003d actualLength;\r\n            line \u003d len + \" \" + k + \"\u003d\" + v + \"\\n\";\r\n            actualLength \u003d line.getBytes(UTF_8).length;\r\n        }\r\n        w.write(line);\r\n    });\r\n    return w.toString().getBytes(UTF_8);\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#handleLongName(...6)",
        "body": "{\r\n    final ByteBuffer encodedName \u003d zipEncoding.encode(name);\r\n    final int len \u003d encodedName.limit() - encodedName.position();\r\n    if (len \u003e\u003d TarConstants.NAMELEN) {\r\n        if (longFileMode \u003d\u003d LONGFILE_POSIX) {\r\n            paxHeaders.put(paxHeaderName, name);\r\n            return true;\r\n        }\r\n        if (longFileMode \u003d\u003d LONGFILE_GNU) {\r\n            // create a TarEntry for the LongLink, the contents\r\n            // of which are the link\u0027s name\r\n            final TarArchiveEntry longLinkEntry \u003d new TarArchiveEntry(TarConstants.GNU_LONGLINK, linkType);\r\n            // +1 for NUL\r\n            longLinkEntry.setSize(len + 1L);\r\n            transferModTime(entry, longLinkEntry);\r\n            putArchiveEntry(longLinkEntry);\r\n            write(encodedName.array(), encodedName.arrayOffset(), len);\r\n            // NUL terminator\r\n            write(0);\r\n            closeArchiveEntry();\r\n        } else if (longFileMode !\u003d LONGFILE_TRUNCATE) {\r\n            throw new IllegalArgumentException(// NOSONAR\r\n            fieldName + \" \u0027\" + name + \"\u0027 is too long ( \u003e \" + TarConstants.NAMELEN + \" bytes)\");\r\n        }\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#failForBigNumbers(...1)",
        "body": "{\r\n    failForBigNumber(\"entry size\", entry.getSize(), TarConstants.MAXSIZE);\r\n    failForBigNumberWithPosixMessage(\"group id\", entry.getLongGroupId(), TarConstants.MAXID);\r\n    failForBigNumber(\"last modification time\", TimeUtils.toUnixTime(entry.getLastModifiedTime()), TarConstants.MAXSIZE);\r\n    failForBigNumber(\"user id\", entry.getLongUserId(), TarConstants.MAXID);\r\n    failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\r\n    failForBigNumber(\"major device number\", entry.getDevMajor(), TarConstants.MAXID);\r\n    failForBigNumber(\"minor device number\", entry.getDevMinor(), TarConstants.MAXID);\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#writePaxHeaders(...3)",
        "body": "{\r\n    String name \u003d \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\r\n    if (name.length() \u003e\u003d TarConstants.NAMELEN) {\r\n        name \u003d name.substring(0, TarConstants.NAMELEN - 1);\r\n    }\r\n    final TarArchiveEntry pex \u003d new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);\r\n    transferModTime(entry, pex);\r\n    final byte[] data \u003d encodeExtendedPaxHeadersContents(headers);\r\n    pex.setSize(data.length);\r\n    putArchiveEntry(pex);\r\n    write(data);\r\n    closeArchiveEntry();\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#closeArchiveEntry(...0)",
        "body": "{\r\n    checkFinished();\r\n    if (!haveUnclosedEntry) {\r\n        throw new IOException(\"No current entry to close\");\r\n    }\r\n    ((FixedLengthBlockOutputStream) out).flushBlock();\r\n    if (currBytes \u003c currSize) {\r\n        throw new IOException(\"Entry \u0027\" + currName + \"\u0027 closed at \u0027\" + currBytes + \"\u0027 before the \u0027\" + currSize + \"\u0027 bytes specified in the header were written\");\r\n    }\r\n    recordsWritten +\u003d currSize / RECORD_SIZE;\r\n    if (0 !\u003d currSize % RECORD_SIZE) {\r\n        recordsWritten++;\r\n    }\r\n    haveUnclosedEntry \u003d false;\r\n}"
      },
      {
        "name": "TarArchiveOutputStream#write(...1)",
        "body": "(source not found)"
      },
      {
        "name": "TarArchiveOutputStream#checkFinished(...0)",
        "body": "(source not found)"
      },
      {
        "name": "TarArchiveOutputStream#addPaxHeadersForBigNumbers(...2)",
        "body": "{\r\n    addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(), TarConstants.MAXSIZE);\r\n    addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getLongGroupId(), TarConstants.MAXID);\r\n    addFileTimePaxHeaderForBigNumber(paxHeaders, \"mtime\", entry.getLastModifiedTime(), TarConstants.MAXSIZE);\r\n    addFileTimePaxHeader(paxHeaders, \"atime\", entry.getLastAccessTime());\r\n    if (entry.getStatusChangeTime() !\u003d null) {\r\n        addFileTimePaxHeader(paxHeaders, \"ctime\", entry.getStatusChangeTime());\r\n    } else {\r\n        // ctime is usually set from creation time on platforms where the real ctime is not available\r\n        addFileTimePaxHeader(paxHeaders, \"ctime\", entry.getCreationTime());\r\n    }\r\n    addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getLongUserId(), TarConstants.MAXID);\r\n    // libarchive extensions\r\n    addFileTimePaxHeader(paxHeaders, \"LIBARCHIVE.creationtime\", entry.getCreationTime());\r\n    // star extensions by Jorg Schilling\r\n    addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\", entry.getDevMajor(), TarConstants.MAXID);\r\n    addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\", entry.getDevMinor(), TarConstants.MAXID);\r\n    // there is no PAX header for file mode\r\n    failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (!haveUnclosedEntry) {\r\n        throw new IllegalStateException(\"No current tar entry\");\r\n    }\r\n    if (currBytes + numToWrite \u003e currSize) {\r\n        throw new IOException(\"Request to write \u0027\" + numToWrite + \"\u0027 bytes exceeds size in header of \u0027\" + currSize + \"\u0027 bytes for entry \u0027\" + currName + \"\u0027\");\r\n    }\r\n    out.write(wBuf, wOffset, numToWrite);\r\n    currBytes +\u003d numToWrite;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i11 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TarArchiveOutputStream\n  r1 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  $z0 \u003d TarArchiveOutputStream: boolean haveUnclosedEntry\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d IllegalStateException\n  new IllegalStateException(\"No current tar entry\")\n  throw $r15\n}",
      "B2 {\n  $l2 \u003d TarArchiveOutputStream: long currBytes\u003e\n  $l1 \u003d (long) i0\n  $l4 \u003d $l2 + $l1\n  $l3 \u003d TarArchiveOutputStream: long currSize\u003e\n  $b5 \u003d $l4 cmp $l3\n  $i11 \u003d (int) $b5\n  if ($i11 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r17 \u003d IOException\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r5 \u003d $r16.append(\"Request to write \\\u0027\")\n  $r6 \u003d $r5.append(i0)\n  $r7 \u003d $r6.append(\"\\\u0027 bytes exceeds size in header of \\\u0027\")\n  $l10 \u003d TarArchiveOutputStream: long currSize\u003e\n  $r8 \u003d $r7.append($l10)\n  $r10 \u003d $r8.append(\"\\\u0027 bytes for entry \\\u0027\")\n  $r9 \u003d String currName\u003e\n  $r11 \u003d $r10.append($r9)\n  $r12 \u003d $r11.append(\"\\\u0027\")\n  $r13 \u003d $r12.toString()\n  new IOException($r13)\n  throw $r17\n}",
      "B4 {\n  $r2 \u003d OutputStream out\u003e\n  $r2.write(r1, i6, i0)\n  $l8 \u003d TarArchiveOutputStream: long currBytes\u003e\n  $l7 \u003d (long) i0\n  $l9 \u003d $l8 + $l7\n  TarArchiveOutputStream: long currBytes\u003e \u003d $l9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarArchiveStructSparse",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d o) {\r\n        return true;\r\n    }\r\n    if (o \u003d\u003d null || getClass() !\u003d o.getClass()) {\r\n        return false;\r\n    }\r\n    final TarArchiveStructSparse that \u003d (TarArchiveStructSparse) o;\r\n    return offset \u003d\u003d that.offset \u0026\u0026 numbytes \u003d\u003d that.numbytes;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($b2 !\u003d 0) → B6 | else → B8",
      "B6 : If($b5 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  TarArchiveStructSparse\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d TarArchiveStructSparse) r1\n  $l1 \u003d TarArchiveStructSparse: long offset\u003e\n  $l0 \u003d TarArchiveStructSparse: long offset\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B6 else B8\n}",
      "B6 {\n  $l4 \u003d TarArchiveStructSparse: long numbytes\u003e\n  $l3 \u003d TarArchiveStructSparse: long numbytes\u003e\n  $b5 \u003d $l4 cmp $l3\n  if ($b5 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $z0 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z0 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarArchiveStructSparse#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "computeCheckSum",
    "signature": "long computeCheckSum(byte[])",
    "visibility": "public",
    "body": "{\r\n    long sum \u003d 0;\r\n    for (final byte element : buf) {\r\n        sum +\u003d BYTE_MASK \u0026 element;\r\n    }\r\n    return sum;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  l4 \u003d 0L\n  i0 \u003d lengthof r0\n  i5 \u003d 0\n}",
      "B1 {\n  if (i5 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  b1 \u003d r0[i5]\n  $s6 \u003d (short) b1\n  $s2 \u003d 255 \u0026 $s6\n  $l3 \u003d (long) $s2\n  l4 \u003d l4 + $l3\n  i5 \u003d i5 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "formatLongOctalOrBinaryBytes",
    "signature": "int formatLongOctalOrBinaryBytes(long,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // Check whether we are dealing with UID/GID or SIZE field\r\n    final long maxAsOctalChar \u003d length \u003d\u003d TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\r\n    final boolean negative \u003d value \u003c 0;\r\n    if (!negative \u0026\u0026 value \u003c\u003d maxAsOctalChar) {\r\n        // OK to store as octal chars\r\n        return formatLongOctalBytes(value, buf, offset, length);\r\n    }\r\n    if (length \u003c 9) {\r\n        formatLongBinary(value, buf, offset, length, negative);\r\n    } else {\r\n        formatBigIntegerBinary(value, buf, offset, length, negative);\r\n    }\r\n    buf[offset] \u003d (byte) (negative ? 0xff : 0x80);\r\n    return offset + length;\r\n}",
    "nodes": 16,
    "edges": 20,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i0 !\u003d 8) → B1 | else → B2",
      "B3 : If($i11 \u003e\u003d 0) → B4 | else → B5",
      "B6 : If($z3 !\u003d 0) → B7 | else → B9",
      "B7 : If($i12 \u003e 0) → B8 | else → B9",
      "B9 : If(i0 \u003e\u003d 9) → B10 | else → B11",
      "B12 : If(z0 \u003d\u003d false) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  l2 :\u003d @parameter0: long\n  r0 :\u003d @parameter1: byte[]\n  i4 :\u003d @parameter2: int\n  i0 :\u003d @parameter3: int\n  if (i0 !\u003d 8) goto B1 else B2\n}",
      "B1 {\n  $l9 \u003d 2097151L\n  goto B3\n}",
      "B2 {\n  $l9 \u003d 8589934591L\n}",
      "B3 {\n  l1 \u003d $l9\n  $b3 \u003d l2 cmp 0L\n  $i11 \u003d (int) $b3\n  if ($i11 \u003e\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $z3 \u003d 1\n  $z2 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z3 \u003d 0\n  $z2 \u003d 0\n}",
      "B6 {\n  z0 \u003d $z2\n  if ($z3 !\u003d 0) goto B7 else B9\n}",
      "B7 {\n  $b7 \u003d l2 cmp l1\n  $i12 \u003d (int) $b7\n  if ($i12 \u003e 0) goto B8 else B9\n}",
      "B8 {\n  $i8 \u003d TarUtils.formatLongOctalBytes(l2, r0, i4, i0)\n  return\n}",
      "B9 {\n  if (i0 \u003e\u003d 9) goto B10 else B11\n}",
      "B10 {\n  TarUtils.formatLongBinary(l2, r0, i4, i0, z0)\n  goto B12\n}",
      "B11 {\n  TarUtils.formatBigIntegerBinary(l2, r0, i4, i0, z0)\n}",
      "B12 {\n  if (z0 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $s10 \u003d 255\n  goto B15\n}",
      "B14 {\n  $s10 \u003d 128\n}",
      "B15 {\n  $b5 \u003d (byte) $s10\n  r0[i4] \u003d $b5\n  $i6 \u003d i4 + i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarUtils#formatLongOctalBytes(...4)",
        "body": "{\r\n    // For space\r\n    final int idx \u003d length - 1;\r\n    formatUnsignedOctalString(value, buf, offset, idx);\r\n    // Trailing space\r\n    buf[offset + idx] \u003d (byte) \u0027 \u0027;\r\n    return offset + length;\r\n}"
      },
      {
        "name": "TarUtils#formatBigIntegerBinary(...5)",
        "body": "{\r\n    final BigInteger val \u003d BigInteger.valueOf(value);\r\n    final byte[] b \u003d val.toByteArray();\r\n    final int len \u003d b.length;\r\n    if (len \u003e length - 1) {\r\n        throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\r\n    }\r\n    final int off \u003d offset + length - len;\r\n    System.arraycopy(b, 0, buf, off, len);\r\n    Arrays.fill(buf, offset + 1, off, (byte) (negative ? 0xff : 0));\r\n}"
      },
      {
        "name": "TarUtils#formatLongBinary(...5)",
        "body": "{\r\n    final int bits \u003d (length - 1) * 8;\r\n    final long max \u003d 1L \u003c\u003c bits;\r\n    // Long.MIN_VALUE stays Long.MIN_VALUE\r\n    long val \u003d Math.abs(value);\r\n    if (val \u003c 0 || val \u003e\u003d max) {\r\n        throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\r\n    }\r\n    if (negative) {\r\n        val ^\u003d max - 1;\r\n        val++;\r\n        val |\u003d 0xffL \u003c\u003c bits;\r\n    }\r\n    for (int i \u003d offset + length - 1; i \u003e\u003d offset; i--) {\r\n        buf[i] \u003d (byte) val;\r\n        val \u003e\u003e\u003d 8;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "formatNameBytes",
    "signature": "int formatNameBytes(java.lang.String,byte[],int,int,org.apache.commons.compress.archivers.zip.ZipEncoding)",
    "visibility": "public",
    "body": "{\r\n    int len \u003d name.length();\r\n    ByteBuffer b \u003d encoding.encode(name);\r\n    while (b.limit() \u003e length \u0026\u0026 len \u003e 0) {\r\n        b \u003d encoding.encode(name.substring(0, --len));\r\n    }\r\n    final int limit \u003d b.limit() - b.position();\r\n    System.arraycopy(b.array(), b.arrayOffset(), buf, offset, limit);\r\n    // Pad any remaining output bytes with NUL\r\n    Arrays.fill(buf, offset + limit, offset + length, (byte) 0);\r\n    return offset + length;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B1 : If($i1 \u003c\u003d i0) → B2 | else → B4",
      "B2 : If(i10 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  String\n  r2 :\u003d @parameter1: byte[]\n  i4 :\u003d @parameter2: int\n  i0 :\u003d @parameter3: int\n  ZipEncoding\n  i10 \u003d r0.length()\n  r5 \u003d r1.encode(r0)\n}",
      "B1 {\n  $i1 \u003d r5.limit()\n  if ($i1 \u003c\u003d i0) goto B2 else B4\n}",
      "B2 {\n  if (i10 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $i12 \u003d (int) -1\n  i10 \u003d i10 + $i12\n  $r4 \u003d r0.substring(0, i10)\n  r5 \u003d r1.encode($r4)\n  goto B1\n}",
      "B4 {\n  $i3 \u003d r5.limit()\n  $i2 \u003d r5.position()\n  $i9 \u003d $i3 - $i2\n  $r3 \u003d r5.array()\n  $i5 \u003d r5.arrayOffset()\n  System.arraycopy($r3, $i5, r2, i4, $i9)\n  $i7 \u003d i4 + $i9\n  $i6 \u003d i4 + i0\n  Arrays.fill(r2, $i7, $i6, 0)\n  $i8 \u003d i4 + i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B1",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "formatUnsignedOctalString",
    "signature": "void formatUnsignedOctalString(long,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    int remaining \u003d length;\r\n    remaining--;\r\n    if (value \u003d\u003d 0) {\r\n        buffer[offset + remaining--] \u003d (byte) \u00270\u0027;\r\n    } else {\r\n        long val \u003d value;\r\n        for (; remaining \u003e\u003d 0 \u0026\u0026 val !\u003d 0; --remaining) {\r\n            // CheckStyle:MagicNumber OFF\r\n            buffer[offset + remaining] \u003d (byte) ((byte) \u00270\u0027 + (byte) (val \u0026 7));\r\n            val \u003d val \u003e\u003e\u003e 3;\r\n            // CheckStyle:MagicNumber ON\r\n        }\r\n        if (val !\u003d 0) {\r\n            throw new IllegalArgumentException(value + \"\u003d\" + Long.toOctalString(value) + \" will not fit in octal number buffer of length \" + length);\r\n        }\r\n    }\r\n    for (; remaining \u003e\u003d 0; --remaining) {\r\n        // leading zeros\r\n        buffer[offset + remaining] \u003d (byte) \u00270\u0027;\r\n    }\r\n    Arrays.fill(buffer, offset, offset + remaining + 1, (byte) \u00270\u0027);\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If($b2 !\u003d 0) → B1 | else → B2",
      "B3 : If(i17 \u003c 0) → B4 | else → B6",
      "B4 : If($b8 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($b3 \u003d\u003d false) → B7 | else → B8",
      "B8 : If(i17 \u003c 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  l1 :\u003d @parameter0: long\n  r0 :\u003d @parameter1: byte[]\n  i4 :\u003d @parameter2: int\n  i0 :\u003d @parameter3: int\n  $i20 \u003d (int) -1\n  i17 \u003d i0 + $i20\n  $b2 \u003d l1 cmp 0L\n  if ($b2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i15 \u003d i17\n  $i22 \u003d (int) -1\n  i17 \u003d i17 + $i22\n  $i16 \u003d i4 + $i15\n  r0[$i16] \u003d 48\n  goto B8\n}",
      "B2 {\n  l18 \u003d l1\n}",
      "B3 {\n  if (i17 \u003c 0) goto B4 else B6\n}",
      "B4 {\n  $b8 \u003d l18 cmp 0L\n  if ($b8 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $i14 \u003d i4 + i17\n  $l9 \u003d l18 \u0026 7L\n  $i10 \u003d (int) $l9\n  $b11 \u003d (byte) $i10\n  $i23 \u003d (int) $b11\n  $i12 \u003d 48 + $i23\n  $b13 \u003d (byte) $i12\n  r0[$i14] \u003d $b13\n  l18 \u003d l18 \u003e\u003e\u003e 3\n  $i25 \u003d (int) -1\n  i17 \u003d i17 + $i25\n  goto B3\n}",
      "B6 {\n  $b3 \u003d l18 cmp 0L\n  if ($b3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d IllegalArgumentException\n  $r10 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r10.append(l1)\n  $r5 \u003d $r3.append(\"\u003d\")\n  $r4 \u003d Long.toOctalString(l1)\n  $r6 \u003d $r5.append($r4)\n  $r7 \u003d $r6.append(\" will not fit in octal number buffer of length \")\n  $r8 \u003d $r7.append(i0)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r11\n}",
      "B8 {\n  if (i17 \u003c 0) goto B9 else B10\n}",
      "B9 {\n  $i7 \u003d i4 + i17\n  r0[$i7] \u003d 48\n  $i27 \u003d (int) -1\n  i17 \u003d i17 + $i27\n  goto B8\n}",
      "B10 {\n  $i5 \u003d i4 + i17\n  $i6 \u003d $i5 + 1\n  Arrays.fill(r0, i4, $i6, 48)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B8",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "parseBoolean",
    "signature": "boolean parseBoolean(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return buffer[offset] \u003d\u003d 1;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $b1 \u003d r0[i0]\n  if ($b1 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "parseName",
    "signature": "java.lang.String parseName(byte[],int,int,org.apache.commons.compress.archivers.zip.ZipEncoding)",
    "visibility": "public",
    "body": "{\r\n    int len \u003d 0;\r\n    for (int i \u003d offset; len \u003c length \u0026\u0026 buffer[i] !\u003d 0; i++) {\r\n        len++;\r\n    }\r\n    if (len \u003e 0) {\r\n        final byte[] b \u003d new byte[len];\r\n        System.arraycopy(buffer, offset, b, 0, len);\r\n        return encoding.decode(b);\r\n    }\r\n    return \"\";\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i1) → B2 | else → B4",
      "B2 : If($b2 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(i3 \u003c\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  ZipEncoding\n  i3 \u003d 0\n  i4 \u003d i0\n}",
      "B1 {\n  if (i3 \u003e\u003d i1) goto B2 else B4\n}",
      "B2 {\n  $b2 \u003d r0[i4]\n  if ($b2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i3 \u003d i3 + 1\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B4 {\n  if (i3 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r3 \u003d newarray (byte)[i3]\n  System.arraycopy(r0, i0, r3, 0, i3)\n  $r2 \u003d r1.decode(r3)\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B1",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "parseOctal",
    "signature": "long parseOctal(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    long result \u003d 0;\r\n    int end \u003d offset + length;\r\n    int start \u003d offset;\r\n    if (length \u003c 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    if (buffer[start] \u003d\u003d 0) {\r\n        return 0L;\r\n    }\r\n    // Skip leading spaces\r\n    while (start \u003c end) {\r\n        if (buffer[start] !\u003d \u0027 \u0027) {\r\n            break;\r\n        }\r\n        start++;\r\n    }\r\n    // Trim all trailing NULs and spaces.\r\n    // The ustar and POSIX tar specs require a trailing NUL or\r\n    // space but some implementations use the extra digit for big\r\n    // sizes/uids/gids ...\r\n    byte trailer \u003d buffer[end - 1];\r\n    while (start \u003c end \u0026\u0026 (trailer \u003d\u003d 0 || trailer \u003d\u003d \u0027 \u0027)) {\r\n        end--;\r\n        trailer \u003d buffer[end - 1];\r\n    }\r\n    for (; start \u003c end; start++) {\r\n        final byte currentByte \u003d buffer[start];\r\n        // CheckStyle:MagicNumber OFF\r\n        if (currentByte \u003c \u00270\u0027 || currentByte \u003e \u00277\u0027) {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        // convert from ASCII\r\n        result \u003d (result \u003c\u003c 3) + (currentByte - \u00270\u0027);\r\n        // CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}",
    "nodes": 19,
    "edges": 25,
    "cc": 8,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d 2) → B1 | else → B2",
      "B2 : If($b2 !\u003d 0) → B3 | else → B4",
      "B4 : If(i12 \u003e\u003d i11) → B5 | else → B8",
      "B5 : If($i14 \u003d\u003d 32) → B6 | else → B7",
      "B9 : If(i12 \u003e\u003d i11) → B10 | else → B13",
      "B10 : If(b13 \u003d\u003d false) → B11 | else → B12",
      "B11 : If($i15 !\u003d 32) → B12 | else → B13",
      "B13 : If(i12 \u003e\u003d i11) → B14 | else → B18",
      "B14 : If($i18 \u003c 48) → B15 | else → B16",
      "B15 : If($i19 \u003c\u003d 55) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  l10 \u003d 0L\n  i11 \u003d i0 + i1\n  i12 \u003d i0\n  if (i1 \u003e\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d IllegalArgumentException\n  $r9 \u003d StringBuilder\n  new StringBuilder()\n  $r5 \u003d $r9.append(\"Length \")\n  $r6 \u003d $r5.append(i1)\n  $r7 \u003d $r6.append(\" must be at least 2\")\n  $r8 \u003d $r7.toString()\n  new IllegalArgumentException($r8)\n  throw $r10\n}",
      "B2 {\n  $b2 \u003d r0[i0]\n  if ($b2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  if (i12 \u003e\u003d i11) goto B5 else B8\n}",
      "B5 {\n  $b9 \u003d r0[i12]\n  $i14 \u003d (int) $b9\n  if ($i14 \u003d\u003d 32) goto B6 else B7\n}",
      "B6 {\n  goto B8\n}",
      "B7 {\n  i12 \u003d i12 + 1\n  goto B4\n}",
      "B8 {\n  $i3 \u003d i11 - 1\n  b13 \u003d r0[$i3]\n}",
      "B9 {\n  if (i12 \u003e\u003d i11) goto B10 else B13\n}",
      "B10 {\n  if (b13 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $i15 \u003d (int) b13\n  if ($i15 !\u003d 32) goto B12 else B13\n}",
      "B12 {\n  $i17 \u003d (int) -1\n  i11 \u003d i11 + $i17\n  $i8 \u003d i11 - 1\n  b13 \u003d r0[$i8]\n  goto B9\n}",
      "B13 {\n  if (i12 \u003e\u003d i11) goto B14 else B18\n}",
      "B14 {\n  b4 \u003d r0[i12]\n  $i18 \u003d (int) b4\n  if ($i18 \u003c 48) goto B15 else B16\n}",
      "B15 {\n  $i19 \u003d (int) b4\n  if ($i19 \u003c\u003d 55) goto B16 else B17\n}",
      "B16 {\n  $r11 \u003d IllegalArgumentException\n  $r2 \u003d TarUtils.exceptionMessage(r0, i0, i1, i12, b4)\n  new IllegalArgumentException($r2)\n  throw $r11\n}",
      "B17 {\n  $l7 \u003d l10 \u003c\u003c 3\n  $i20 \u003d (int) b4\n  $i5 \u003d $i20 - 48\n  $l6 \u003d (long) $i5\n  l10 \u003d $l7 + $l6\n  i12 \u003d i12 + 1\n  goto B13\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B4",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B9",
      "B13 --\u003e B14",
      "B13 --\u003e B18",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B13",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarUtils#exceptionMessage(...5)",
        "body": "{\r\n    // default charset is good enough for an exception message,\r\n    //\r\n    // the alternative was to modify parseOctal and\r\n    // parseOctalOrBinary to receive the ZipEncoding of the\r\n    // archive (deprecating the existing public methods, of\r\n    // course) and dealing with the fact that ZipEncoding#decode\r\n    // can throw an IOException which parseOctal* doesn\u0027t declare\r\n    String string \u003d new String(buffer, offset, length, Charset.defaultCharset());\r\n    // Replace NULs to allow string to be printed\r\n    string \u003d string.replace(\"\\0\", \"{NUL}\");\r\n    return \"Invalid byte \" + currentByte + \" at offset \" + (current - offset) + \" in \u0027\" + string + \"\u0027 len\u003d\" + length;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "parseOctalOrBinary",
    "signature": "long parseOctalOrBinary(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if ((buffer[offset] \u0026 0x80) \u003d\u003d 0) {\r\n        return parseOctal(buffer, offset, length);\r\n    }\r\n    final boolean negative \u003d buffer[offset] \u003d\u003d (byte) 0xff;\r\n    if (length \u003c 9) {\r\n        return parseBinaryLong(buffer, offset, length, negative);\r\n    }\r\n    return parseBinaryBigInteger(buffer, offset, length, negative);\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($s2 !\u003d 0) → B1 | else → B2",
      "B2 : If($i9 !\u003d $i11) → B3 | else → B4",
      "B5 : If(i4 \u003e\u003d 9) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i4 :\u003d @parameter2: int\n  $b1 \u003d r0[i0]\n  $s8 \u003d (short) $b1\n  $s2 \u003d $s8 \u0026 128\n  if ($s2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $l7 \u003d TarUtils.parseOctal(r0, i0, i4)\n  return\n}",
      "B2 {\n  $b3 \u003d r0[i0]\n  $i9 \u003d (int) $b3\n  $i11 \u003d (int) -1\n  if ($i9 !\u003d $i11) goto B3 else B4\n}",
      "B3 {\n  $z2 \u003d 1\n  $z1 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z2 \u003d 0\n  $z1 \u003d 0\n}",
      "B5 {\n  if (i4 \u003e\u003d 9) goto B6 else B7\n}",
      "B6 {\n  $l6 \u003d TarUtils.parseBinaryLong(r0, i0, i4, $z2)\n  return\n}",
      "B7 {\n  $l5 \u003d TarUtils.parseBinaryBigInteger(r0, i0, i4, $z1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarUtils#parseBinaryBigInteger(...4)",
        "body": "{\r\n    final byte[] remainder \u003d new byte[length - 1];\r\n    System.arraycopy(buffer, offset + 1, remainder, 0, length - 1);\r\n    BigInteger val \u003d new BigInteger(remainder);\r\n    if (negative) {\r\n        // 2\u0027s complement\r\n        val \u003d val.add(NEG_1_BIG_INT).not();\r\n    }\r\n    if (val.bitLength() \u003e 63) {\r\n        throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\r\n    }\r\n    return negative ? -val.longValue() : val.longValue();\r\n}"
      },
      {
        "name": "TarUtils#parseBinaryLong(...4)",
        "body": "{\r\n    if (length \u003e\u003d 9) {\r\n        throw new IllegalArgumentException(\"At offset \" + offset + \", \" + length + \" byte binary number exceeds maximum signed long value\");\r\n    }\r\n    long val \u003d 0;\r\n    for (int i \u003d 1; i \u003c length; i++) {\r\n        val \u003d (val \u003c\u003c 8) + (buffer[offset + i] \u0026 0xff);\r\n    }\r\n    if (negative) {\r\n        // 2\u0027s complement\r\n        val--;\r\n        val ^\u003d (long) Math.pow(2.0, (length - 1) * 8.0) - 1;\r\n    }\r\n    return negative ? -val : val;\r\n}"
      },
      {
        "name": "TarUtils#parseOctal(...3)",
        "body": "{\r\n    long result \u003d 0;\r\n    int end \u003d offset + length;\r\n    int start \u003d offset;\r\n    if (length \u003c 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    if (buffer[start] \u003d\u003d 0) {\r\n        return 0L;\r\n    }\r\n    // Skip leading spaces\r\n    while (start \u003c end) {\r\n        if (buffer[start] !\u003d \u0027 \u0027) {\r\n            break;\r\n        }\r\n        start++;\r\n    }\r\n    // Trim all trailing NULs and spaces.\r\n    // The ustar and POSIX tar specs require a trailing NUL or\r\n    // space but some implementations use the extra digit for big\r\n    // sizes/uids/gids ...\r\n    byte trailer \u003d buffer[end - 1];\r\n    while (start \u003c end \u0026\u0026 (trailer \u003d\u003d 0 || trailer \u003d\u003d \u0027 \u0027)) {\r\n        end--;\r\n        trailer \u003d buffer[end - 1];\r\n    }\r\n    for (; start \u003c end; start++) {\r\n        final byte currentByte \u003d buffer[start];\r\n        // CheckStyle:MagicNumber OFF\r\n        if (currentByte \u003c \u00270\u0027 || currentByte \u003e \u00277\u0027) {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        // convert from ASCII\r\n        result \u003d (result \u003c\u003c 3) + (currentByte - \u00270\u0027);\r\n        // CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.tar.TarUtils",
    "methodName": "verifyCheckSum",
    "signature": "boolean verifyCheckSum(byte[])",
    "visibility": "public",
    "body": "{\r\n    final long storedSum \u003d parseOctal(header, TarConstants.CHKSUM_OFFSET, TarConstants.CHKSUMLEN);\r\n    long unsignedSum \u003d 0;\r\n    long signedSum \u003d 0;\r\n    for (int i \u003d 0; i \u003c header.length; i++) {\r\n        byte b \u003d header[i];\r\n        if (TarConstants.CHKSUM_OFFSET \u003c\u003d i \u0026\u0026 i \u003c TarConstants.CHKSUM_OFFSET + TarConstants.CHKSUMLEN) {\r\n            b \u003d \u0027 \u0027;\r\n        }\r\n        unsignedSum +\u003d 0xff \u0026 b;\r\n        signedSum +\u003d b;\r\n    }\r\n    return storedSum \u003d\u003d unsignedSum || storedSum \u003d\u003d signedSum;\r\n}",
    "nodes": 11,
    "edges": 15,
    "cc": 6,
    "flowSummary": [
      "B1 : If(i6 \u003e\u003d $i1) → B2 | else → B6",
      "B2 : If(148 \u003e i6) → B3 | else → B5",
      "B3 : If(i6 \u003e\u003d 156) → B4 | else → B5",
      "B6 : If($b2 \u003d\u003d false) → B7 | else → B8",
      "B7 : If($b3 !\u003d 0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  l0 \u003d TarUtils.parseOctal(r0, 148, 8)\n  l4 \u003d 0L\n  l5 \u003d 0L\n  i6 \u003d 0\n}",
      "B1 {\n  $i1 \u003d lengthof r0\n  if (i6 \u003e\u003d $i1) goto B2 else B6\n}",
      "B2 {\n  b7 \u003d r0[i6]\n  if (148 \u003e i6) goto B3 else B5\n}",
      "B3 {\n  if (i6 \u003e\u003d 156) goto B4 else B5\n}",
      "B4 {\n  b7 \u003d 32\n}",
      "B5 {\n  $s8 \u003d 255 \u0026 b7\n  $l9 \u003d (long) $s8\n  l4 \u003d l4 + $l9\n  $l10 \u003d (long) b7\n  l5 \u003d l5 + $l10\n  i6 \u003d i6 + 1\n  goto B1\n}",
      "B6 {\n  $b2 \u003d l0 cmp l4\n  if ($b2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $b3 \u003d l0 cmp l5\n  if ($b3 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $z0 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z0 \u003d 0\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TarUtils#parseOctal(...3)",
        "body": "{\r\n    long result \u003d 0;\r\n    int end \u003d offset + length;\r\n    int start \u003d offset;\r\n    if (length \u003c 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    if (buffer[start] \u003d\u003d 0) {\r\n        return 0L;\r\n    }\r\n    // Skip leading spaces\r\n    while (start \u003c end) {\r\n        if (buffer[start] !\u003d \u0027 \u0027) {\r\n            break;\r\n        }\r\n        start++;\r\n    }\r\n    // Trim all trailing NULs and spaces.\r\n    // The ustar and POSIX tar specs require a trailing NUL or\r\n    // space but some implementations use the extra digit for big\r\n    // sizes/uids/gids ...\r\n    byte trailer \u003d buffer[end - 1];\r\n    while (start \u003c end \u0026\u0026 (trailer \u003d\u003d 0 || trailer \u003d\u003d \u0027 \u0027)) {\r\n        end--;\r\n        trailer \u003d buffer[end - 1];\r\n    }\r\n    for (; start \u003c end; start++) {\r\n        final byte currentByte \u003d buffer[start];\r\n        // CheckStyle:MagicNumber OFF\r\n        if (currentByte \u003c \u00270\u0027 || currentByte \u003e \u00277\u0027) {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        // convert from ASCII\r\n        result \u003d (result \u003c\u003c 3) + (currentByte - \u00270\u0027);\r\n        // CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.AsiExtraField",
    "methodName": "isDirectory",
    "signature": "boolean isDirectory()",
    "visibility": "public",
    "body": "{\r\n    return dirFlag \u0026\u0026 !isLink();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  AsiExtraField\n  $z0 \u003d AsiExtraField: boolean dirFlag\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d r0.isLink()\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AsiExtraField#isLink(...0)",
        "body": "{\r\n    return !getLinkedFile().isEmpty();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.AsiExtraField",
    "methodName": "isLink",
    "signature": "boolean isLink()",
    "visibility": "public",
    "body": "{\r\n    return !getLinkedFile().isEmpty();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  AsiExtraField\n  $r1 \u003d r0.getLinkedFile()\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AsiExtraField#getLinkedFile(...0)",
        "body": "{\r\n    return link;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.AsiExtraField",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c MIN_SIZE) {\r\n        throw new ZipException(\"The length is too short, only \" + length + \" bytes, expected at least \" + MIN_SIZE);\r\n    }\r\n    final long givenChecksum \u003d ZipLong.getValue(data, offset);\r\n    final byte[] tmp \u003d new byte[length - WORD];\r\n    System.arraycopy(data, offset + WORD, tmp, 0, length - WORD);\r\n    crc.reset();\r\n    crc.update(tmp);\r\n    final long realChecksum \u003d crc.getValue();\r\n    if (givenChecksum !\u003d realChecksum) {\r\n        throw new ZipException(\"Bad CRC checksum, expected \" + Long.toHexString(givenChecksum) + \" instead of \" + Long.toHexString(realChecksum));\r\n    }\r\n    final int newMode \u003d ZipShort.getValue(tmp, 0);\r\n    // CheckStyle:MagicNumber OFF\r\n    final int linkArrayLength \u003d (int) ZipLong.getValue(tmp, 2);\r\n    if (linkArrayLength \u003c 0 || linkArrayLength \u003e tmp.length - 10) {\r\n        throw new ZipException(\"Bad symbolic link name length \" + linkArrayLength + \" in ASI extra field\");\r\n    }\r\n    uid \u003d ZipShort.getValue(tmp, 6);\r\n    gid \u003d ZipShort.getValue(tmp, 8);\r\n    if (linkArrayLength \u003d\u003d 0) {\r\n        link \u003d \"\";\r\n    } else {\r\n        final byte[] linkArray \u003d new byte[linkArrayLength];\r\n        System.arraycopy(tmp, 10, linkArray, 0, linkArrayLength);\r\n        // Uses default charset - see class Javadoc\r\n        link \u003d new String(linkArray, Charset.defaultCharset());\r\n    }\r\n    // CheckStyle:MagicNumber ON\r\n    setDirectory((newMode \u0026 DIR_FLAG) !\u003d 0);\r\n    setMode(newMode);\r\n}",
    "nodes": 14,
    "edges": 16,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 14) → B1 | else → B2",
      "B2 : If($b7 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(i10 \u003c 0) → B5 | else → B6",
      "B5 : If(i10 \u003c\u003d $i12) → B6 | else → B7",
      "B7 : If(i10 !\u003d 0) → B8 | else → B9",
      "B10 : If($i15 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  AsiExtraField\n  r0 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 \u003e\u003d 14) goto B1 else B2\n}",
      "B1 {\n  $r24 \u003d ZipException\n  $r25 \u003d StringBuilder\n  new StringBuilder()\n  $r26 \u003d $r25.append(\"The length is too short, only \")\n  $r27 \u003d $r26.append(i0)\n  $r28 \u003d $r27.append(\" bytes, expected at least \")\n  $r29 \u003d $r28.append(14)\n  $r30 \u003d $r29.toString()\n  new ZipException($r30)\n  throw $r24\n}",
      "B2 {\n  l2 \u003d ZipLong.getValue(r0, i1)\n  $i3 \u003d i0 - 4\n  r1 \u003d newarray (byte)[$i3]\n  $i5 \u003d i1 + 4\n  $i4 \u003d i0 - 4\n  System.arraycopy(r0, $i5, r1, 0, $i4)\n  $r3 \u003d CRC32 crc\u003e\n  $r3.reset()\n  $r4 \u003d CRC32 crc\u003e\n  $r4.update(r1)\n  $r5 \u003d CRC32 crc\u003e\n  l6 \u003d $r5.getValue()\n  $b7 \u003d l2 cmp l6\n  if ($b7 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r15 \u003d ZipException\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r18 \u003d $r16.append(\"Bad CRC checksum, expected \")\n  $r17 \u003d Long.toHexString(l2)\n  $r19 \u003d $r18.append($r17)\n  $r21 \u003d $r19.append(\" instead of \")\n  $r20 \u003d Long.toHexString(l6)\n  $r22 \u003d $r21.append($r20)\n  $r23 \u003d $r22.toString()\n  new ZipException($r23)\n  throw $r15\n}",
      "B4 {\n  i8 \u003d ZipShort.getValue(r1, 0)\n  $l9 \u003d ZipLong.getValue(r1, 2)\n  i10 \u003d (int) $l9\n  if (i10 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  $i11 \u003d lengthof r1\n  $i12 \u003d $i11 - 10\n  if (i10 \u003c\u003d $i12) goto B6 else B7\n}",
      "B6 {\n  $r6 \u003d ZipException\n  $r7 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r7.append(\"Bad symbolic link name length \")\n  $r9 \u003d $r8.append(i10)\n  $r10 \u003d $r9.append(\" in ASI extra field\")\n  $r11 \u003d $r10.toString()\n  new ZipException($r11)\n  throw $r6\n}",
      "B7 {\n  $i13 \u003d ZipShort.getValue(r1, 6)\n  AsiExtraField: int uid\u003e \u003d $i13\n  $i14 \u003d ZipShort.getValue(r1, 8)\n  AsiExtraField: int gid\u003e \u003d $i14\n  if (i10 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  String link\u003e \u003d \"\"\n  goto B10\n}",
      "B9 {\n  r12 \u003d newarray (byte)[i10]\n  System.arraycopy(r1, 10, r12, 0, i10)\n  $r13 \u003d String\n  $r14 \u003d Charset.defaultCharset()\n  new String(r12, $r14)\n  String link\u003e \u003d $r13\n}",
      "B10 {\n  $i15 \u003d i8 \u0026 16384\n  if ($i15 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $z0 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z0 \u003d 0\n}",
      "B13 {\n  r2.setDirectory($z0)\n  r2.setMode(i8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AsiExtraField#setMode(...1)",
        "body": "{\r\n    this.mode \u003d getMode(mode);\r\n}"
      },
      {
        "name": "AsiExtraField#setDirectory(...1)",
        "body": "{\r\n    this.dirFlag \u003d dirFlag;\r\n    mode \u003d getMode(mode);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.DefaultBackingStoreSupplier",
    "methodName": "get",
    "signature": "org.apache.commons.compress.parallel.ScatterGatherBackingStore get()",
    "visibility": "public",
    "body": "{\r\n    final String suffix \u003d \"n\" + storeNum.incrementAndGet();\r\n    final Path tempFile \u003d dir \u003d\u003d null ? Files.createTempFile(PREFIX, suffix) : Files.createTempFile(dir, PREFIX, suffix);\r\n    return new FileBasedScatterGatherBackingStore(tempFile);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r6 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultBackingStoreSupplier\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r0.append(\"n\")\n  $r2 \u003d AtomicInteger storeNum\u003e\n  $i0 \u003d $r2.incrementAndGet()\n  $r4 \u003d $r3.append($i0)\n  r5 \u003d $r4.toString()\n  $r6 \u003d Path dir\u003e\n  if ($r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d FileAttribute)[0]\n  $r11 \u003d Files.createTempFile(\"parallelscatter\", r5, $r10)\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Path dir\u003e\n  $r7 \u003d FileAttribute)[0]\n  $r11 \u003d Files.createTempFile($r8, \"parallelscatter\", r5, $r7)\n}",
      "B3 {\n  $r9 \u003d FileBasedScatterGatherBackingStore\n  new FileBasedScatterGatherBackingStore($r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "createExtraField",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField createExtraField(org.apache.commons.compress.archivers.zip.ZipShort)",
    "visibility": "public",
    "body": "{\r\n    final ZipExtraField field \u003d createExtraFieldNoDefault(headerId);\r\n    if (field !\u003d null) {\r\n        return field;\r\n    }\r\n    final UnrecognizedExtraField u \u003d new UnrecognizedExtraField();\r\n    u.setHeaderId(headerId);\r\n    return u;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipShort\n  r1 \u003d ExtraFieldUtils.createExtraFieldNoDefault(r0)\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d UnrecognizedExtraField\n  new UnrecognizedExtraField()\n  $r2.setHeaderId(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ExtraFieldUtils#createExtraFieldNoDefault(...1)",
        "body": "{\r\n    final Supplier\u003cZipExtraField\u003e provider \u003d IMPLEMENTATIONS.get(headerId);\r\n    return provider !\u003d null ? provider.get() : null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "createExtraFieldNoDefault",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField createExtraFieldNoDefault(org.apache.commons.compress.archivers.zip.ZipShort)",
    "visibility": "public",
    "body": "{\r\n    final Supplier\u003cZipExtraField\u003e provider \u003d IMPLEMENTATIONS.get(headerId);\r\n    return provider !\u003d null ? provider.get() : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipShort\n  $r1 \u003d ConcurrentMap IMPLEMENTATIONS\u003e\n  $r2 \u003d $r1.get(r0)\n  r3 \u003d Supplier) $r2\n  if (r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r3.get()\n  $r5 \u003d ZipExtraField) $r4\n  goto B3\n}",
      "B2 {\n  $r5 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "fillExtraField",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField fillExtraField(org.apache.commons.compress.archivers.zip.ZipExtraField,byte[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (local) {\r\n            ze.parseFromLocalFileData(data, off, len);\r\n        } else {\r\n            ze.parseFromCentralDirectoryData(data, off, len);\r\n        }\r\n        return ze;\r\n    } catch (final ArrayIndexOutOfBoundsException e) {\r\n        throw ZipUtil.newZipException(\"Failed to parse corrupt ZIP extra field of type \" + Integer.toHexString(ze.getHeaderId().getValue()), e);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipExtraField\n  r1 :\u003d @parameter1: byte[]\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  z0 :\u003d @parameter4: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.parseFromLocalFileData(r1, i0, i1)\n  goto B3\n}",
      "B2 {\n  r0.parseFromCentralDirectoryData(r1, i0, i1)\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 :\u003d @caughtexception\n  $r3 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r3.append(\"Failed to parse corrupt ZIP extra field of type \")\n  $r4 \u003d r0.getHeaderId()\n  $i2 \u003d $r4.getValue()\n  $r5 \u003d Integer.toHexString($i2)\n  $r7 \u003d $r6.append($r5)\n  $r8 \u003d $r7.toString()\n  $r9 \u003d ZipUtil.newZipException($r8, $r2)\n  throw $r9\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "mergeCentralDirectoryData",
    "signature": "byte[] mergeCentralDirectoryData(org.apache.commons.compress.archivers.zip.ZipExtraField[])",
    "visibility": "public",
    "body": "{\r\n    final int dataLength \u003d data.length;\r\n    final boolean lastIsUnparseableHolder \u003d dataLength \u003e 0 \u0026\u0026 data[dataLength - 1] instanceof UnparseableExtraFieldData;\r\n    final int regularExtraFieldCount \u003d lastIsUnparseableHolder ? dataLength - 1 : dataLength;\r\n    int sum \u003d WORD * regularExtraFieldCount;\r\n    for (final ZipExtraField element : data) {\r\n        sum +\u003d element.getCentralDirectoryLength().getValue();\r\n    }\r\n    final byte[] result \u003d new byte[sum];\r\n    int start \u003d 0;\r\n    for (int i \u003d 0; i \u003c regularExtraFieldCount; i++) {\r\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\r\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\r\n        start +\u003d WORD;\r\n        final byte[] central \u003d data[i].getCentralDirectoryData();\r\n        if (central !\u003d null) {\r\n            System.arraycopy(central, 0, result, start, central.length);\r\n            start +\u003d central.length;\r\n        }\r\n    }\r\n    if (lastIsUnparseableHolder) {\r\n        final byte[] central \u003d data[dataLength - 1].getCentralDirectoryData();\r\n        if (central !\u003d null) {\r\n            System.arraycopy(central, 0, result, start, central.length);\r\n        }\r\n    }\r\n    return result;\r\n}",
    "nodes": 19,
    "edges": 26,
    "cc": 9,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($z3 \u003d\u003d false) → B5 | else → B6",
      "B8 : If(i12 \u003e\u003d $i8) → B9 | else → B10",
      "B11 : If(i14 \u003e\u003d i1) → B12 | else → B15",
      "B12 : If(r13 \u003d\u003d null) → B13 | else → B14",
      "B15 : If(z0 \u003d\u003d false) → B16 | else → B18",
      "B16 : If(r14 \u003d\u003d null) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ZipExtraField[]\n  i0 \u003d lengthof r0\n  if (i0 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i9 \u003d i0 - 1\n  $r10 \u003d r0[$i9]\n  $z1 \u003d UnparseableExtraFieldData\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z4 \u003d 1\n  $z3 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z4 \u003d 0\n  $z3 \u003d 0\n}",
      "B4 {\n  z0 \u003d $z4\n  if ($z3 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $i10 \u003d i0 - 1\n  goto B7\n}",
      "B6 {\n  $i10 \u003d i0\n}",
      "B7 {\n  i1 \u003d $i10\n  i11 \u003d 4 * $i10\n  $i8 \u003d lengthof r0\n  i12 \u003d 0\n}",
      "B8 {\n  if (i12 \u003e\u003d $i8) goto B9 else B10\n}",
      "B9 {\n  r11 \u003d r0[i12]\n  $r9 \u003d r11.getCentralDirectoryLength()\n  $i7 \u003d $r9.getValue()\n  i11 \u003d i11 + $i7\n  i12 \u003d i12 + 1\n  goto B8\n}",
      "B10 {\n  r12 \u003d newarray (byte)[i11]\n  i13 \u003d 0\n  i14 \u003d 0\n}",
      "B11 {\n  if (i14 \u003e\u003d i1) goto B12 else B15\n}",
      "B12 {\n  $r2 \u003d r0[i14]\n  $r3 \u003d $r2.getHeaderId()\n  $r4 \u003d $r3.getBytes()\n  System.arraycopy($r4, 0, r12, i13, 2)\n  $r5 \u003d r0[i14]\n  $r6 \u003d $r5.getCentralDirectoryLength()\n  $r7 \u003d $r6.getBytes()\n  $i4 \u003d i13 + 2\n  System.arraycopy($r7, 0, r12, $i4, 2)\n  i13 \u003d i13 + 4\n  $r8 \u003d r0[i14]\n  r13 \u003d $r8.getCentralDirectoryData()\n  if (r13 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $i5 \u003d lengthof r13\n  System.arraycopy(r13, 0, r12, i13, $i5)\n  $i6 \u003d lengthof r13\n  i13 \u003d i13 + $i6\n}",
      "B14 {\n  i14 \u003d i14 + 1\n  goto B11\n}",
      "B15 {\n  if (z0 \u003d\u003d false) goto B16 else B18\n}",
      "B16 {\n  $i2 \u003d i0 - 1\n  $r1 \u003d r0[$i2]\n  r14 \u003d $r1.getCentralDirectoryData()\n  if (r14 \u003d\u003d null) goto B17 else B18\n}",
      "B17 {\n  $i3 \u003d lengthof r14\n  System.arraycopy(r14, 0, r12, i13, $i3)\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B8",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B11",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "mergeLocalFileDataData",
    "signature": "byte[] mergeLocalFileDataData(org.apache.commons.compress.archivers.zip.ZipExtraField[])",
    "visibility": "public",
    "body": "{\r\n    final int dataLength \u003d data.length;\r\n    final boolean lastIsUnparseableHolder \u003d dataLength \u003e 0 \u0026\u0026 data[dataLength - 1] instanceof UnparseableExtraFieldData;\r\n    final int regularExtraFieldCount \u003d lastIsUnparseableHolder ? dataLength - 1 : dataLength;\r\n    int sum \u003d WORD * regularExtraFieldCount;\r\n    for (final ZipExtraField element : data) {\r\n        sum +\u003d element.getLocalFileDataLength().getValue();\r\n    }\r\n    final byte[] result \u003d new byte[sum];\r\n    int start \u003d 0;\r\n    for (int i \u003d 0; i \u003c regularExtraFieldCount; i++) {\r\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\r\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\r\n        start +\u003d WORD;\r\n        final byte[] local \u003d data[i].getLocalFileDataData();\r\n        if (local !\u003d null) {\r\n            System.arraycopy(local, 0, result, start, local.length);\r\n            start +\u003d local.length;\r\n        }\r\n    }\r\n    if (lastIsUnparseableHolder) {\r\n        final byte[] local \u003d data[dataLength - 1].getLocalFileDataData();\r\n        if (local !\u003d null) {\r\n            System.arraycopy(local, 0, result, start, local.length);\r\n        }\r\n    }\r\n    return result;\r\n}",
    "nodes": 19,
    "edges": 26,
    "cc": 9,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($z4 \u003d\u003d false) → B5 | else → B6",
      "B8 : If(i12 \u003e\u003d $i8) → B9 | else → B10",
      "B11 : If(i14 \u003e\u003d i1) → B12 | else → B15",
      "B12 : If(r13 \u003d\u003d null) → B13 | else → B14",
      "B15 : If(z0 \u003d\u003d false) → B16 | else → B18",
      "B16 : If(r14 \u003d\u003d null) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ZipExtraField[]\n  i0 \u003d lengthof r0\n  if (i0 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $i9 \u003d i0 - 1\n  $r10 \u003d r0[$i9]\n  $z1 \u003d UnparseableExtraFieldData\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z4 \u003d 1\n  $z3 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z4 \u003d 0\n  $z3 \u003d 0\n}",
      "B4 {\n  z0 \u003d $z3\n  if ($z4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $i10 \u003d i0 - 1\n  goto B7\n}",
      "B6 {\n  $i10 \u003d i0\n}",
      "B7 {\n  i1 \u003d $i10\n  i11 \u003d 4 * $i10\n  $i8 \u003d lengthof r0\n  i12 \u003d 0\n}",
      "B8 {\n  if (i12 \u003e\u003d $i8) goto B9 else B10\n}",
      "B9 {\n  r11 \u003d r0[i12]\n  $r9 \u003d r11.getLocalFileDataLength()\n  $i7 \u003d $r9.getValue()\n  i11 \u003d i11 + $i7\n  i12 \u003d i12 + 1\n  goto B8\n}",
      "B10 {\n  r12 \u003d newarray (byte)[i11]\n  i13 \u003d 0\n  i14 \u003d 0\n}",
      "B11 {\n  if (i14 \u003e\u003d i1) goto B12 else B15\n}",
      "B12 {\n  $r2 \u003d r0[i14]\n  $r3 \u003d $r2.getHeaderId()\n  $r4 \u003d $r3.getBytes()\n  System.arraycopy($r4, 0, r12, i13, 2)\n  $r5 \u003d r0[i14]\n  $r6 \u003d $r5.getLocalFileDataLength()\n  $r7 \u003d $r6.getBytes()\n  $i4 \u003d i13 + 2\n  System.arraycopy($r7, 0, r12, $i4, 2)\n  i13 \u003d i13 + 4\n  $r8 \u003d r0[i14]\n  r13 \u003d $r8.getLocalFileDataData()\n  if (r13 \u003d\u003d null) goto B13 else B14\n}",
      "B13 {\n  $i5 \u003d lengthof r13\n  System.arraycopy(r13, 0, r12, i13, $i5)\n  $i6 \u003d lengthof r13\n  i13 \u003d i13 + $i6\n}",
      "B14 {\n  i14 \u003d i14 + 1\n  goto B11\n}",
      "B15 {\n  if (z0 \u003d\u003d false) goto B16 else B18\n}",
      "B16 {\n  $i2 \u003d i0 - 1\n  $r1 \u003d r0[$i2]\n  r14 \u003d $r1.getLocalFileDataData()\n  if (r14 \u003d\u003d null) goto B17 else B18\n}",
      "B17 {\n  $i3 \u003d lengthof r14\n  System.arraycopy(r14, 0, r12, i13, $i3)\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B8",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B11",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils",
    "methodName": "parse",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField[] parse(byte[],boolean,org.apache.commons.compress.archivers.zip.ExtraFieldParsingBehavior)",
    "visibility": "public",
    "body": "{\r\n    final List\u003cZipExtraField\u003e v \u003d new ArrayList\u003c\u003e();\r\n    int start \u003d 0;\r\n    final int dataLength \u003d data.length;\r\n    LOOP: while (start \u003c\u003d dataLength - WORD) {\r\n        final ZipShort headerId \u003d new ZipShort(data, start);\r\n        final int length \u003d new ZipShort(data, start + 2).getValue();\r\n        if (start + WORD + length \u003e dataLength) {\r\n            final ZipExtraField field \u003d parsingBehavior.onUnparseableExtraField(data, start, dataLength - start, local, length);\r\n            if (field !\u003d null) {\r\n                v.add(field);\r\n            }\r\n            // since we cannot parse the data we must assume\r\n            // the extra field consumes the whole rest of the\r\n            // available data\r\n            break LOOP;\r\n        }\r\n        try {\r\n            final ZipExtraField ze \u003d Objects.requireNonNull(parsingBehavior.createExtraField(headerId), \"createExtraField must not return null\");\r\n            v.add(Objects.requireNonNull(parsingBehavior.fill(ze, data, start + WORD, length, local), \"fill must not return null\"));\r\n            start +\u003d length + WORD;\r\n        } catch (final InstantiationException | IllegalAccessException e) {\r\n            throw ZipUtil.newZipException(e.getMessage(), e);\r\n        }\r\n    }\r\n    return v.toArray(EMPTY_ZIP_EXTRA_FIELD_ARRAY);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i9 \u003e $i1) → B2 | else → B8",
      "B2 : If($i5 \u003c\u003d i0) → B3 | else → B5",
      "B3 : If(r13 \u003d\u003d null) → B4 | else → B8"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: byte[]\n  z0 :\u003d @parameter1: boolean\n  ExtraFieldParsingBehavior\n  $r0 \u003d ArrayList\n  new ArrayList()\n  i9 \u003d 0\n  i0 \u003d lengthof r1\n}",
      "B1 {\n  $i1 \u003d i0 - 4\n  if (i9 \u003e $i1) goto B2 else B8\n}",
      "B2 {\n  $r2 \u003d ZipShort\n  new ZipShort(r1, i9)\n  $r3 \u003d ZipShort\n  $i2 \u003d i9 + 2\n  new ZipShort(r1, $i2)\n  i3 \u003d $r3.getValue()\n  $i4 \u003d i9 + 4\n  $i5 \u003d $i4 + i3\n  if ($i5 \u003c\u003d i0) goto B3 else B5\n}",
      "B3 {\n  $i8 \u003d i0 - i9\n  r13 \u003d r4.onUnparseableExtraField(r1, i9, $i8, z0, i3)\n  if (r13 \u003d\u003d null) goto B4 else B8\n}",
      "B4 {\n  $r0.add(r13)\n  goto B8\n}",
      "B5 {\n  $r5 \u003d r4.createExtraField($r2)\n  $r6 \u003d Objects.requireNonNull($r5, \"createExtraField must not return null\")\n  r14 \u003d ZipExtraField) $r6\n  $i6 \u003d i9 + 4\n  $r7 \u003d r4.fill(r14, r1, $i6, i3, z0)\n  $r8 \u003d Objects.requireNonNull($r7, \"fill must not return null\")\n  $r9 \u003d ZipExtraField) $r8\n  $r0.add($r9)\n  $i7 \u003d i3 + 4\n  i9 \u003d i9 + $i7\n  goto B7\n}",
      "B6 {\n  $r10 :\u003d @caughtexception\n  $r11 \u003d $r10.getMessage()\n  $r12 \u003d ZipUtil.newZipException($r11, $r10)\n  throw $r12\n}",
      "B7 {\n  goto B1\n}",
      "B8 {\n  $r15 \u003d ZipExtraField[] EMPTY_ZIP_EXTRA_FIELD_ARRAY\u003e\n  $r16 \u003d $r0.toArray($r15)\n  $r17 \u003d ZipExtraField[]) $r16\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B8",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B1",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "parse",
    "signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit parse(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    final int generalPurposeFlag \u003d ZipShort.getValue(data, offset);\r\n    final GeneralPurposeBit b \u003d new GeneralPurposeBit();\r\n    b.useDataDescriptor((generalPurposeFlag \u0026 DATA_DESCRIPTOR_FLAG) !\u003d 0);\r\n    b.useUTF8ForNames((generalPurposeFlag \u0026 UFT8_NAMES_FLAG) !\u003d 0);\r\n    b.useStrongEncryption((generalPurposeFlag \u0026 STRONG_ENCRYPTION_FLAG) !\u003d 0);\r\n    b.useEncryption((generalPurposeFlag \u0026 ENCRYPTION_FLAG) !\u003d 0);\r\n    b.slidingDictionarySize \u003d (generalPurposeFlag \u0026 SLIDING_DICTIONARY_SIZE_FLAG) !\u003d 0 ? 8192 : 4096;\r\n    b.numberOfShannonFanoTrees \u003d (generalPurposeFlag \u0026 NUMBER_OF_SHANNON_FANO_TREES_FLAG) !\u003d 0 ? 3 : 2;\r\n    return b;\r\n}",
    "nodes": 19,
    "edges": 24,
    "cc": 7,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($i3 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($i4 \u003d\u003d false) → B7 | else → B8",
      "B9 : If($i5 \u003d\u003d false) → B10 | else → B11",
      "B12 : If($i6 \u003d\u003d false) → B13 | else → B14",
      "B15 : If($i7 \u003d\u003d false) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 \u003d ZipShort.getValue(r0, i0)\n  $r1 \u003d GeneralPurposeBit\n  new GeneralPurposeBit()\n  $i2 \u003d i1 \u0026 8\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  $r1.useDataDescriptor($z0)\n  $i3 \u003d i1 \u0026 2048\n  if ($i3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z1 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z1 \u003d 0\n}",
      "B6 {\n  $r1.useUTF8ForNames($z1)\n  $i4 \u003d i1 \u0026 64\n  if ($i4 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  $r1.useStrongEncryption($z2)\n  $i5 \u003d i1 \u0026 1\n  if ($i5 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $z3 \u003d 1\n  goto B12\n}",
      "B11 {\n  $z3 \u003d 0\n}",
      "B12 {\n  $r1.useEncryption($z3)\n  $i6 \u003d i1 \u0026 2\n  if ($i6 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $s8 \u003d 8192\n  goto B15\n}",
      "B14 {\n  $s8 \u003d 4096\n}",
      "B15 {\n  GeneralPurposeBit: int slidingDictionarySize\u003e \u003d $s8\n  $i7 \u003d i1 \u0026 4\n  if ($i7 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $b9 \u003d 3\n  goto B18\n}",
      "B17 {\n  $b9 \u003d 2\n}",
      "B18 {\n  GeneralPurposeBit: int numberOfShannonFanoTrees\u003e \u003d $b9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "encode",
    "signature": "void encode(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    ZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0) | (languageEncodingFlag ? UFT8_NAMES_FLAG : 0) | (encryptionFlag ? ENCRYPTION_FLAG : 0) | (strongEncryptionFlag ? STRONG_ENCRYPTION_FLAG : 0), buf, offset);\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($z3 \u003d\u003d false) → B7 | else → B8",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  GeneralPurposeBit\n  r1 :\u003d @parameter0: byte[]\n  i2 :\u003d @parameter1: int\n  $z0 \u003d GeneralPurposeBit: boolean dataDescriptorFlag\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $b4 \u003d 8\n  goto B3\n}",
      "B2 {\n  $b4 \u003d 0\n}",
      "B3 {\n  $z1 \u003d GeneralPurposeBit: boolean languageEncodingFlag\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $s5 \u003d 2048\n  goto B6\n}",
      "B5 {\n  $s5 \u003d 0\n}",
      "B6 {\n  $s0 \u003d $b4 | $s5\n  $z3 \u003d GeneralPurposeBit: boolean encryptionFlag\u003e\n  if ($z3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z4 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z4 \u003d 0\n}",
      "B9 {\n  $s1 \u003d $s0 | $z4\n  $z2 \u003d GeneralPurposeBit: boolean strongEncryptionFlag\u003e\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $b6 \u003d 64\n  goto B12\n}",
      "B11 {\n  $b6 \u003d 0\n}",
      "B12 {\n  $s3 \u003d $s1 | $b6\n  ZipShort.putShort($s3, r1, i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (!(o instanceof GeneralPurposeBit)) {\r\n        return false;\r\n    }\r\n    final GeneralPurposeBit g \u003d (GeneralPurposeBit) o;\r\n    return g.encryptionFlag \u003d\u003d encryptionFlag \u0026\u0026 g.strongEncryptionFlag \u003d\u003d strongEncryptionFlag \u0026\u0026 g.languageEncodingFlag \u003d\u003d languageEncodingFlag \u0026\u0026 g.dataDescriptorFlag \u003d\u003d dataDescriptorFlag;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z2 !\u003d $z1) → B3 | else → B7",
      "B3 : If($z4 !\u003d $z3) → B4 | else → B7",
      "B4 : If($z6 !\u003d $z5) → B5 | else → B7",
      "B5 : If($z8 !\u003d $z7) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  GeneralPurposeBit\n  Object\n  $z0 \u003d GeneralPurposeBit\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r1 \u003d GeneralPurposeBit) r0\n  $z2 \u003d GeneralPurposeBit: boolean encryptionFlag\u003e\n  $z1 \u003d GeneralPurposeBit: boolean encryptionFlag\u003e\n  if ($z2 !\u003d $z1) goto B3 else B7\n}",
      "B3 {\n  $z4 \u003d GeneralPurposeBit: boolean strongEncryptionFlag\u003e\n  $z3 \u003d GeneralPurposeBit: boolean strongEncryptionFlag\u003e\n  if ($z4 !\u003d $z3) goto B4 else B7\n}",
      "B4 {\n  $z6 \u003d GeneralPurposeBit: boolean languageEncodingFlag\u003e\n  $z5 \u003d GeneralPurposeBit: boolean languageEncodingFlag\u003e\n  if ($z6 !\u003d $z5) goto B5 else B7\n}",
      "B5 {\n  $z8 \u003d GeneralPurposeBit: boolean dataDescriptorFlag\u003e\n  $z7 \u003d GeneralPurposeBit: boolean dataDescriptorFlag\u003e\n  if ($z8 !\u003d $z7) goto B6 else B7\n}",
      "B6 {\n  $z9 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z9 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    return 3 * (7 * (13 * (17 * (encryptionFlag ? 1 : 0) + (strongEncryptionFlag ? 1 : 0)) + (languageEncodingFlag ? 1 : 0)) + (dataDescriptorFlag ? 1 : 0));\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  GeneralPurposeBit\n  $z0 \u003d GeneralPurposeBit: boolean encryptionFlag\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z4 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z4 \u003d 0\n}",
      "B3 {\n  $i0 \u003d 17 * $z4\n  $z1 \u003d GeneralPurposeBit: boolean strongEncryptionFlag\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z5 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z5 \u003d 0\n}",
      "B6 {\n  $i1 \u003d $i0 + $z5\n  $i2 \u003d 13 * $i1\n  $z2 \u003d GeneralPurposeBit: boolean languageEncodingFlag\u003e\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z6 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z6 \u003d 0\n}",
      "B9 {\n  $i3 \u003d $i2 + $z6\n  $i4 \u003d 7 * $i3\n  $z3 \u003d GeneralPurposeBit: boolean dataDescriptorFlag\u003e\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $z7 \u003d 1\n  goto B12\n}",
      "B11 {\n  $z7 \u003d 0\n}",
      "B12 {\n  $i5 \u003d $i4 + $z7\n  $i6 \u003d 3 * $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "usesStrongEncryption",
    "signature": "boolean usesStrongEncryption()",
    "visibility": "public",
    "body": "{\r\n    return encryptionFlag \u0026\u0026 strongEncryptionFlag;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  GeneralPurposeBit\n  $z0 \u003d GeneralPurposeBit: boolean encryptionFlag\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $z1 \u003d GeneralPurposeBit: boolean strongEncryptionFlag\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit",
    "methodName": "useStrongEncryption",
    "signature": "void useStrongEncryption(boolean)",
    "visibility": "public",
    "body": "{\r\n    strongEncryptionFlag \u003d b;\r\n    if (b) {\r\n        useEncryption(true);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GeneralPurposeBit\n  z0 :\u003d @parameter0: boolean\n  GeneralPurposeBit: boolean strongEncryptionFlag\u003e \u003d z0\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.useEncryption(1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GeneralPurposeBit#useEncryption(...1)",
        "body": "{\r\n    encryptionFlag \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.JarMarker",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length !\u003d 0) {\r\n        throw new ZipException(\"JarMarker doesn\u0027t expect any data\");\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JarMarker\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d ZipException\n  new ZipException(\"JarMarker doesn\\\u0027t expect any data\")\n  throw $r0\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ParallelScatterZipCreator",
    "methodName": "createCallable",
    "signature": "java.util.concurrent.Callable createCallable(org.apache.commons.compress.archivers.zip.ZipArchiveEntry,org.apache.commons.compress.parallel.InputStreamSupplier)",
    "visibility": "public",
    "body": "{\r\n    final int method \u003d zipArchiveEntry.getMethod();\r\n    if (method \u003d\u003d ZipMethod.UNKNOWN_CODE) {\r\n        throw new IllegalArgumentException(\"Method must be set on zipArchiveEntry: \" + zipArchiveEntry);\r\n    }\r\n    final ZipArchiveEntryRequest zipArchiveEntryRequest \u003d createZipArchiveEntryRequest(zipArchiveEntry, source);\r\n    return () -\u003e {\r\n        final ScatterZipOutputStream scatterStream \u003d tlScatterStreams.get();\r\n        scatterStream.addArchiveEntry(zipArchiveEntryRequest);\r\n        return scatterStream;\r\n    };\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ParallelScatterZipCreator\n  ZipArchiveEntry\n  InputStreamSupplier\n  i0 \u003d r0.getMethod()\n  $i2 \u003d (int) -1\n  if (i0 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d IllegalArgumentException\n  $r10 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r10.append(\"Method must be set on zipArchiveEntry: \")\n  $r8 \u003d $r7.append(r0)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r11\n}",
      "B2 {\n  r2 \u003d ZipArchiveEntryRequest.createZipArchiveEntryRequest(r0, r1)\n  $r4 \u003d ParallelScatterZipCreator$lambda_createCallable_0__16.bootstrap$(r3, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ParallelScatterZipCreator#createZipArchiveEntryRequest(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ParallelScatterZipCreator",
    "methodName": "writeTo",
    "signature": "void writeTo(org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        // Make sure we catch any exceptions from parallel phase\r\n        try {\r\n            for (final Future\u003c?\u003e future : futures) {\r\n                future.get();\r\n            }\r\n        } finally {\r\n            executorService.shutdown();\r\n        }\r\n        // \u003d\u003d Infinity. We really *must* wait for this to complete\r\n        executorService.awaitTermination(1000 * 60L, TimeUnit.SECONDS);\r\n        // It is important that all threads terminate before we go on, ensure happens-before relationship\r\n        compressionDoneAt \u003d System.currentTimeMillis();\r\n        for (final Future\u003c? extends ScatterZipOutputStream\u003e future : futures) {\r\n            final ScatterZipOutputStream scatterStream \u003d future.get();\r\n            scatterStream.zipEntryWriter().writeNextZipEntry(targetStream);\r\n        }\r\n        for (final ScatterZipOutputStream scatterStream : streams) {\r\n            scatterStream.close();\r\n        }\r\n        scatterDoneAt \u003d System.currentTimeMillis();\r\n    } finally {\r\n        closeAll();\r\n    }\r\n}",
    "nodes": 14,
    "edges": 14,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  ParallelScatterZipCreator\n  ZipArchiveOutputStream\n  $r1 \u003d Deque futures\u003e\n  r16 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r16.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r12 \u003d r16.next()\n  r17 \u003d Future) $r12\n  r17.get()\n  goto B1\n}",
      "B3 {\n  $r2 \u003d ExecutorService executorService\u003e\n  $r2.shutdown()\n  goto B5\n}",
      "B4 {\n  $r14 :\u003d @caughtexception\n  $r15 \u003d ExecutorService executorService\u003e\n  $r15.shutdown()\n  throw $r14\n}",
      "B5 {\n  $r4 \u003d ExecutorService executorService\u003e\n  $r3 \u003d TimeUnit SECONDS\u003e\n  $r4.awaitTermination(60000L, $r3)\n  $l0 \u003d System.currentTimeMillis()\n  ParallelScatterZipCreator: long compressionDoneAt\u003e \u003d $l0\n  $r5 \u003d Deque futures\u003e\n  r18 \u003d $r5.iterator()\n}",
      "B6 {\n  $z1 \u003d r18.hasNext()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r8 \u003d r18.next()\n  r19 \u003d Future) $r8\n  $r9 \u003d r19.get()\n  r20 \u003d ScatterZipOutputStream) $r9\n  $r11 \u003d r20.zipEntryWriter()\n  $r11.writeNextZipEntry(r10)\n  goto B6\n}",
      "B8 {\n  $r6 \u003d Deque streams\u003e\n  r21 \u003d $r6.iterator()\n}",
      "B9 {\n  $z2 \u003d r21.hasNext()\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r7 \u003d r21.next()\n  r22 \u003d ScatterZipOutputStream) $r7\n  r22.close()\n  goto B9\n}",
      "B11 {\n  $l1 \u003d System.currentTimeMillis()\n  ParallelScatterZipCreator: long scatterDoneAt\u003e \u003d $l1\n  r0.closeAll()\n  goto B13\n}",
      "B12 {\n  $r13 :\u003d @caughtexception\n  r0.closeAll()\n  throw $r13\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B6",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B9",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ParallelScatterZipCreator#closeAll(...0)",
        "body": "{\r\n    for (final ScatterZipOutputStream scatterStream : streams) {\r\n        IOUtils.closeQuietly(scatterStream);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField",
    "methodName": "getCentralDirectoryData",
    "signature": "byte[] getCentralDirectoryData()",
    "visibility": "public",
    "body": "{\r\n    return ZipShort.getBytes(alignment | (allowMethodChange ? ALLOW_METHOD_MESSAGE_CHANGE_FLAG : 0));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ResourceAlignmentExtraField\n  $s0 \u003d ResourceAlignmentExtraField: short alignment\u003e\n  $z0 \u003d ResourceAlignmentExtraField: boolean allowMethodChange\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d 32768\n  goto B3\n}",
      "B2 {\n  $i2 \u003d 0\n}",
      "B3 {\n  $i1 \u003d $s0 | $i2\n  $i3 \u003d (int) $i1\n  $r1 \u003d ZipShort.getBytes($i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField",
    "methodName": "getLocalFileDataData",
    "signature": "byte[] getLocalFileDataData()",
    "visibility": "public",
    "body": "{\r\n    final byte[] content \u003d new byte[BASE_SIZE + padding];\r\n    ZipShort.putShort(alignment | (allowMethodChange ? ALLOW_METHOD_MESSAGE_CHANGE_FLAG : 0), content, 0);\r\n    return content;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ResourceAlignmentExtraField\n  $i0 \u003d ResourceAlignmentExtraField: int padding\u003e\n  $i1 \u003d 2 + $i0\n  r1 \u003d newarray (byte)[$i1]\n  $s2 \u003d ResourceAlignmentExtraField: short alignment\u003e\n  $z0 \u003d ResourceAlignmentExtraField: boolean allowMethodChange\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i4 \u003d 32768\n  goto B3\n}",
      "B2 {\n  $i4 \u003d 0\n}",
      "B3 {\n  $i3 \u003d $s2 | $i4\n  $i5 \u003d (int) $i3\n  ZipShort.putShort($i5, r1, 0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField",
    "methodName": "parseFromCentralDirectoryData",
    "signature": "void parseFromCentralDirectoryData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c BASE_SIZE) {\r\n        throw new ZipException(\"Too short content for ResourceAlignmentExtraField (0xa11e): \" + length);\r\n    }\r\n    final int alignmentValue \u003d ZipShort.getValue(buffer, offset);\r\n    this.alignment \u003d (short) (alignmentValue \u0026 ALLOW_METHOD_MESSAGE_CHANGE_FLAG - 1);\r\n    this.allowMethodChange \u003d (alignmentValue \u0026 ALLOW_METHOD_MESSAGE_CHANGE_FLAG) !\u003d 0;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 2) → B1 | else → B2",
      "B2 : If($i5 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ResourceAlignmentExtraField\n  r0 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 \u003e\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d ZipException\n  $r7 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r7.append(\"Too short content for ResourceAlignmentExtraField (0xa11e): \")\n  $r5 \u003d $r4.append(i0)\n  $r6 \u003d $r5.toString()\n  new ZipException($r6)\n  throw $r8\n}",
      "B2 {\n  i2 \u003d ZipShort.getValue(r0, i1)\n  $i3 \u003d i2 \u0026 32767\n  $s4 \u003d (short) $i3\n  ResourceAlignmentExtraField: short alignment\u003e \u003d $s4\n  $i7 \u003d (int) 32768\n  $i5 \u003d i2 \u0026 $i7\n  if ($i5 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  ResourceAlignmentExtraField: boolean allowMethodChange\u003e \u003d $z0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ScatterZipOutputStream",
    "methodName": "addArchiveEntry",
    "signature": "void addArchiveEntry(org.apache.commons.compress.archivers.zip.ZipArchiveEntryRequest)",
    "visibility": "public",
    "body": "{\r\n    try (InputStream payloadStream \u003d zipArchiveEntryRequest.getPayloadStream()) {\r\n        streamCompressor.deflate(payloadStream, zipArchiveEntryRequest.getMethod());\r\n    }\r\n    items.add(new CompressedEntry(zipArchiveEntryRequest, streamCompressor.getCrc32(), streamCompressor.getBytesWrittenForLastEntry(), streamCompressor.getBytesRead()));\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B6",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ScatterZipOutputStream\n  ZipArchiveEntryRequest\n  r1 \u003d r0.getPayloadStream()\n  $r3 \u003d StreamCompressor streamCompressor\u003e\n  $i0 \u003d r0.getMethod()\n  $r3.deflate(r1, $i0)\n  if (r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  r1.close()\n  goto B6\n}",
      "B2 {\n  $r10 :\u003d @caughtexception\n  if (r1 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  r1.close()\n  goto B5\n}",
      "B4 {\n  $r9 :\u003d @caughtexception\n  $r10.addSuppressed($r9)\n}",
      "B5 {\n  throw $r10\n}",
      "B6 {\n  $r6 \u003d Queue items\u003e\n  $r4 \u003d ScatterZipOutputStream$CompressedEntry\n  $r5 \u003d StreamCompressor streamCompressor\u003e\n  $l3 \u003d $r5.getCrc32()\n  $r7 \u003d StreamCompressor streamCompressor\u003e\n  $l2 \u003d $r7.getBytesWrittenForLastEntry()\n  $r8 \u003d StreamCompressor streamCompressor\u003e\n  $l1 \u003d $r8.getBytesRead()\n  new ScatterZipOutputStream$CompressedEntry(r0, $l3, $l2, $l1)\n  $r6.add($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ScatterZipOutputStream",
    "methodName": "writeTo",
    "signature": "void writeTo(org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream)",
    "visibility": "public",
    "body": "{\r\n    backingStore.closeForWriting();\r\n    try (InputStream data \u003d backingStore.getInputStream()) {\r\n        for (final CompressedEntry compressedEntry : items) {\r\n            // @formatter:off\r\n            try (BoundedInputStream rawStream \u003d BoundedInputStream.builder().setInputStream(data).setMaxCount(compressedEntry.compressedSize).setPropagateClose(false).get()) {\r\n                target.addRawArchiveEntry(compressedEntry.transferToArchiveEntry(), rawStream);\r\n            }\r\n            // @formatter:on\r\n        }\r\n    }\r\n}",
    "nodes": 16,
    "edges": 18,
    "cc": 4,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B9",
      "B2 : If(r13 \u003d\u003d null) → B3 | else → B8",
      "B4 : If(r13 \u003d\u003d null) → B5 | else → B7",
      "B9 : If(r3 \u003d\u003d null) → B10 | else → B15",
      "B11 : If(r3 \u003d\u003d null) → B12 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ScatterZipOutputStream\n  ZipArchiveOutputStream\n  $r1 \u003d ScatterGatherBackingStore backingStore\u003e\n  $r1.closeForWriting()\n  $r2 \u003d ScatterGatherBackingStore backingStore\u003e\n  r3 \u003d $r2.getInputStream()\n  $r4 \u003d Queue items\u003e\n  r20 \u003d $r4.iterator()\n}",
      "B1 {\n  $z0 \u003d r20.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B9\n}",
      "B2 {\n  $r5 \u003d r20.next()\n  r21 \u003d ScatterZipOutputStream$CompressedEntry) $r5\n  $r6 \u003d BoundedInputStream.builder()\n  $r7 \u003d $r6.setInputStream(r3)\n  $r8 \u003d BoundedInputStream$Builder) $r7\n  $l0 \u003d ScatterZipOutputStream$CompressedEntry: long compressedSize\u003e\n  $r9 \u003d $r8.setMaxCount($l0)\n  $r10 \u003d BoundedInputStream$Builder) $r9\n  $r11 \u003d $r10.setPropagateClose(0)\n  $r12 \u003d BoundedInputStream$Builder) $r11\n  r13 \u003d $r12.get()\n  $r15 \u003d r21.transferToArchiveEntry()\n  r14.addRawArchiveEntry($r15, r13)\n  if (r13 \u003d\u003d null) goto B3 else B8\n}",
      "B3 {\n  r13.close()\n  goto B8\n}",
      "B4 {\n  $r19 :\u003d @caughtexception\n  if (r13 \u003d\u003d null) goto B5 else B7\n}",
      "B5 {\n  r13.close()\n  goto B7\n}",
      "B6 {\n  $r18 :\u003d @caughtexception\n  $r19.addSuppressed($r18)\n}",
      "B7 {\n  throw $r19\n}",
      "B8 {\n  goto B1\n}",
      "B9 {\n  if (r3 \u003d\u003d null) goto B10 else B15\n}",
      "B10 {\n  r3.close()\n  goto B15\n}",
      "B11 {\n  $r17 :\u003d @caughtexception\n  if (r3 \u003d\u003d null) goto B12 else B14\n}",
      "B12 {\n  r3.close()\n  goto B14\n}",
      "B13 {\n  $r16 :\u003d @caughtexception\n  $r17.addSuppressed($r16)\n}",
      "B14 {\n  throw $r17\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B1",
      "B9 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B15",
      "B11 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ScatterZipOutputStream",
    "methodName": "zipEntryWriter",
    "signature": "org.apache.commons.compress.archivers.zip.ScatterZipOutputStream$ZipEntryWriter zipEntryWriter()",
    "visibility": "public",
    "body": "{\r\n    if (zipEntryWriter \u003d\u003d null) {\r\n        zipEntryWriter \u003d new ZipEntryWriter(this);\r\n    }\r\n    return zipEntryWriter;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ScatterZipOutputStream\n  $r1 \u003d ScatterZipOutputStream$ZipEntryWriter zipEntryWriter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ScatterZipOutputStream$ZipEntryWriter\n  new ScatterZipOutputStream$ZipEntryWriter(r0)\n  ScatterZipOutputStream$ZipEntryWriter zipEntryWriter\u003e \u003d $r3\n}",
      "B2 {\n  $r2 \u003d ScatterZipOutputStream$ZipEntryWriter zipEntryWriter\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnparseableExtraFieldData",
    "methodName": "getCentralDirectoryData",
    "signature": "byte[] getCentralDirectoryData()",
    "visibility": "public",
    "body": "{\r\n    return centralDirectoryData \u003d\u003d null ? getLocalFileDataData() : ZipUtil.copy(centralDirectoryData);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnparseableExtraFieldData\n  $r1 \u003d UnparseableExtraFieldData: byte[] centralDirectoryData\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.getLocalFileDataData()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d UnparseableExtraFieldData: byte[] centralDirectoryData\u003e\n  $r3 \u003d ZipUtil.copy($r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnparseableExtraFieldData#getLocalFileDataData(...0)",
        "body": "{\r\n    return ZipUtil.copy(localFileData);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnparseableExtraFieldData",
    "methodName": "getCentralDirectoryLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getCentralDirectoryLength()",
    "visibility": "public",
    "body": "{\r\n    return centralDirectoryData \u003d\u003d null ? getLocalFileDataLength() : new ZipShort(centralDirectoryData.length);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnparseableExtraFieldData\n  $r1 \u003d UnparseableExtraFieldData: byte[] centralDirectoryData\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.getLocalFileDataLength()\n  goto B3\n}",
      "B2 {\n  $r3 \u003d ZipShort\n  $r2 \u003d UnparseableExtraFieldData: byte[] centralDirectoryData\u003e\n  $i0 \u003d lengthof $r2\n  new ZipShort($i0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnparseableExtraFieldData#getLocalFileDataLength(...0)",
        "body": "{\r\n    return ZipShort.lengthOf(localFileData);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnparseableExtraFieldData",
    "methodName": "parseFromCentralDirectoryData",
    "signature": "void parseFromCentralDirectoryData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    centralDirectoryData \u003d Arrays.copyOfRange(buffer, offset, offset + length);\r\n    if (localFileData \u003d\u003d null) {\r\n        parseFromLocalFileData(buffer, offset, length);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r3 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnparseableExtraFieldData\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $i2 \u003d i0 + i1\n  $r2 \u003d Arrays.copyOfRange(r1, i0, $i2)\n  UnparseableExtraFieldData: byte[] centralDirectoryData\u003e \u003d $r2\n  $r3 \u003d UnparseableExtraFieldData: byte[] localFileData\u003e\n  if ($r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.parseFromLocalFileData(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnparseableExtraFieldData#parseFromLocalFileData(...3)",
        "body": "{\r\n    localFileData \u003d Arrays.copyOfRange(buffer, offset, offset + length);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField",
    "methodName": "getCentralDirectoryData",
    "signature": "byte[] getCentralDirectoryData()",
    "visibility": "public",
    "body": "{\r\n    if (centralData !\u003d null) {\r\n        return ZipUtil.copy(centralData);\r\n    }\r\n    return getLocalFileDataData();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnrecognizedExtraField\n  $r1 \u003d UnrecognizedExtraField: byte[] centralData\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d UnrecognizedExtraField: byte[] centralData\u003e\n  $r4 \u003d ZipUtil.copy($r3)\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getLocalFileDataData()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnrecognizedExtraField#getLocalFileDataData(...0)",
        "body": "{\r\n    return ZipUtil.copy(localData);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField",
    "methodName": "getCentralDirectoryLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getCentralDirectoryLength()",
    "visibility": "public",
    "body": "{\r\n    if (centralData !\u003d null) {\r\n        return new ZipShort(centralData.length);\r\n    }\r\n    return getLocalFileDataLength();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnrecognizedExtraField\n  $r1 \u003d UnrecognizedExtraField: byte[] centralData\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ZipShort\n  $r4 \u003d UnrecognizedExtraField: byte[] centralData\u003e\n  $i0 \u003d lengthof $r4\n  new ZipShort($i0)\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getLocalFileDataLength()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnrecognizedExtraField#getLocalFileDataLength(...0)",
        "body": "{\r\n    return ZipShort.lengthOf(localData);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.UnrecognizedExtraField",
    "methodName": "parseFromCentralDirectoryData",
    "signature": "void parseFromCentralDirectoryData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    final byte[] tmp \u003d Arrays.copyOfRange(data, offset, offset + length);\r\n    setCentralDirectoryData(tmp);\r\n    if (localData \u003d\u003d null) {\r\n        setLocalFileDataData(tmp);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r3 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UnrecognizedExtraField\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $i2 \u003d i0 + i1\n  r1 \u003d Arrays.copyOfRange(r0, i0, $i2)\n  r2.setCentralDirectoryData(r1)\n  $r3 \u003d UnrecognizedExtraField: byte[] localData\u003e\n  if ($r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r2.setLocalFileDataData(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UnrecognizedExtraField#setLocalFileDataData(...1)",
        "body": "{\r\n    localData \u003d ZipUtil.copy(data);\r\n}"
      },
      {
        "name": "UnrecognizedExtraField#setCentralDirectoryData(...1)",
        "body": "{\r\n    centralData \u003d ZipUtil.copy(data);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o instanceof X000A_NTFS) {\r\n        final X000A_NTFS xf \u003d (X000A_NTFS) o;\r\n        return Objects.equals(modifyTime, xf.modifyTime) \u0026\u0026 Objects.equals(accessTime, xf.accessTime) \u0026\u0026 Objects.equals(createTime, xf.createTime);\r\n    }\r\n    return false;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B7",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z3 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  Object\n  $z0 \u003d X000A_NTFS\n  if ($z0 \u003d\u003d false) goto B1 else B7\n}",
      "B1 {\n  r1 \u003d X000A_NTFS) r0\n  $r4 \u003d ZipEightByteInteger modifyTime\u003e\n  $r3 \u003d ZipEightByteInteger modifyTime\u003e\n  $z1 \u003d Objects.equals($r4, $r3)\n  if ($z1 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r6 \u003d ZipEightByteInteger accessTime\u003e\n  $r5 \u003d ZipEightByteInteger accessTime\u003e\n  $z2 \u003d Objects.equals($r6, $r5)\n  if ($z2 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r8 \u003d ZipEightByteInteger createTime\u003e\n  $r7 \u003d ZipEightByteInteger createTime\u003e\n  $z3 \u003d Objects.equals($r8, $r7)\n  if ($z3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z4 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z4 \u003d 0\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    int hc \u003d -123;\r\n    if (modifyTime !\u003d null) {\r\n        hc ^\u003d modifyTime.hashCode();\r\n    }\r\n    if (accessTime !\u003d null) {\r\n        // Since accessTime is often same as modifyTime,\r\n        // this prevents them from XOR negating each other.\r\n        hc ^\u003d Integer.rotateLeft(accessTime.hashCode(), 11);\r\n    }\r\n    if (createTime !\u003d null) {\r\n        hc ^\u003d Integer.rotateLeft(createTime.hashCode(), 22);\r\n    }\r\n    return hc;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r3 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  $i7 \u003d (int) -123\n  i5 \u003d $i7\n  $r1 \u003d ZipEightByteInteger modifyTime\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ZipEightByteInteger modifyTime\u003e\n  $i4 \u003d $r6.hashCode()\n  $i9 \u003d (int) -123\n  i5 \u003d $i9 ^ $i4\n}",
      "B2 {\n  $r2 \u003d ZipEightByteInteger accessTime\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d ZipEightByteInteger accessTime\u003e\n  $i2 \u003d $r5.hashCode()\n  $i3 \u003d Integer.rotateLeft($i2, 11)\n  i5 \u003d i5 ^ $i3\n}",
      "B4 {\n  $r3 \u003d ZipEightByteInteger createTime\u003e\n  if ($r3 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d ZipEightByteInteger createTime\u003e\n  $i0 \u003d $r4.hashCode()\n  $i1 \u003d Integer.rotateLeft($i0, 22)\n  i5 \u003d i5 ^ $i1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    final int len \u003d offset + length;\r\n    // skip reserved\r\n    offset +\u003d 4;\r\n    while (offset + 4 \u003c\u003d len) {\r\n        final ZipShort tag \u003d new ZipShort(data, offset);\r\n        offset +\u003d 2;\r\n        if (tag.equals(TIME_ATTR_TAG)) {\r\n            readTimeAttr(data, offset, len - offset);\r\n            break;\r\n        }\r\n        final ZipShort size \u003d new ZipShort(data, offset);\r\n        offset +\u003d 2 + size.getValue();\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If($i2 \u003e i1) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  r1 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  i1 \u003d i6 + i0\n  i7 \u003d i6 + 4\n}",
      "B1 {\n  $i2 \u003d i7 + 4\n  if ($i2 \u003e i1) goto B2 else B5\n}",
      "B2 {\n  $r0 \u003d ZipShort\n  new ZipShort(r1, i7)\n  i8 \u003d i7 + 2\n  $r2 \u003d ZipShort TIME_ATTR_TAG\u003e\n  $z0 \u003d $r0.equals($r2)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d i1 - i8\n  r4.readTimeAttr(r1, i8, $i5)\n  goto B5\n}",
      "B4 {\n  $r3 \u003d ZipShort\n  new ZipShort(r1, i8)\n  $i3 \u003d $r3.getValue()\n  $i4 \u003d 2 + $i3\n  i7 \u003d i8 + $i4\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X000A_NTFS#readTimeAttr(...3)",
        "body": "{\r\n    if (length \u003e\u003d 2 + 3 * 8) {\r\n        final ZipShort tagValueLength \u003d new ZipShort(data, offset);\r\n        if (TIME_ATTR_SIZE.equals(tagValueLength)) {\r\n            offset +\u003d 2;\r\n            modifyTime \u003d new ZipEightByteInteger(data, offset);\r\n            offset +\u003d 8;\r\n            accessTime \u003d new ZipEightByteInteger(data, offset);\r\n            offset +\u003d 8;\r\n            createTime \u003d new ZipEightByteInteger(data, offset);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "setAccessTime",
    "signature": "void setAccessTime(org.apache.commons.compress.archivers.zip.ZipEightByteInteger)",
    "visibility": "public",
    "body": "{\r\n    accessTime \u003d t \u003d\u003d null ? ZipEightByteInteger.ZERO : t;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  ZipEightByteInteger\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ZipEightByteInteger ZERO\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  ZipEightByteInteger accessTime\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "setCreateTime",
    "signature": "void setCreateTime(org.apache.commons.compress.archivers.zip.ZipEightByteInteger)",
    "visibility": "public",
    "body": "{\r\n    createTime \u003d t \u003d\u003d null ? ZipEightByteInteger.ZERO : t;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  ZipEightByteInteger\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ZipEightByteInteger ZERO\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  ZipEightByteInteger createTime\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X000A_NTFS",
    "methodName": "setModifyTime",
    "signature": "void setModifyTime(org.apache.commons.compress.archivers.zip.ZipEightByteInteger)",
    "visibility": "public",
    "body": "{\r\n    modifyTime \u003d t \u003d\u003d null ? ZipEightByteInteger.ZERO : t;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  X000A_NTFS\n  ZipEightByteInteger\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ZipEightByteInteger ZERO\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  ZipEightByteInteger modifyTime\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader",
    "methodName": "parseCentralDirectoryFormat",
    "signature": "void parseCentralDirectoryFormat(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    assertMinimalLength(12, length);\r\n    // TODO: double check we really do not want to call super here\r\n    this.format \u003d ZipShort.getValue(data, offset);\r\n    this.algId \u003d EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\r\n    this.bitlen \u003d ZipShort.getValue(data, offset + 4);\r\n    this.flags \u003d ZipShort.getValue(data, offset + 6);\r\n    this.rcount \u003d ZipLong.getValue(data, offset + 8);\r\n    if (rcount \u003e 0) {\r\n        assertMinimalLength(16, length);\r\n        this.hashAlg \u003d HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\r\n        this.hashSize \u003d ZipShort.getValue(data, offset + 14);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i17 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  X0017_StrongEncryptionHeader\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0.assertMinimalLength(12, i0)\n  $i2 \u003d ZipShort.getValue(r1, i1)\n  X0017_StrongEncryptionHeader: int format\u003e \u003d $i2\n  $i3 \u003d i1 + 2\n  $i4 \u003d ZipShort.getValue(r1, $i3)\n  $r2 \u003d PKWareExtraHeader$EncryptionAlgorithm.getAlgorithmByCode($i4)\n  PKWareExtraHeader$EncryptionAlgorithm algId\u003e \u003d $r2\n  $i5 \u003d i1 + 4\n  $i6 \u003d ZipShort.getValue(r1, $i5)\n  X0017_StrongEncryptionHeader: int bitlen\u003e \u003d $i6\n  $i7 \u003d i1 + 6\n  $i8 \u003d ZipShort.getValue(r1, $i7)\n  X0017_StrongEncryptionHeader: int flags\u003e \u003d $i8\n  $i9 \u003d i1 + 8\n  $l10 \u003d ZipLong.getValue(r1, $i9)\n  X0017_StrongEncryptionHeader: long rcount\u003e \u003d $l10\n  $l11 \u003d X0017_StrongEncryptionHeader: long rcount\u003e\n  $b12 \u003d $l11 cmp 0L\n  $i17 \u003d (int) $b12\n  if ($i17 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.assertMinimalLength(16, i0)\n  $i13 \u003d i1 + 12\n  $i14 \u003d ZipShort.getValue(r1, $i13)\n  $r3 \u003d PKWareExtraHeader$HashAlgorithm.getAlgorithmByCode($i14)\n  PKWareExtraHeader$HashAlgorithm hashAlg\u003e \u003d $r3\n  $i15 \u003d i1 + 14\n  $i16 \u003d ZipShort.getValue(r1, $i15)\n  X0017_StrongEncryptionHeader: int hashSize\u003e \u003d $i16\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X0017_StrongEncryptionHeader#assertMinimalLength(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X0017_StrongEncryptionHeader",
    "methodName": "parseFileFormat",
    "signature": "void parseFileFormat(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    assertMinimalLength(4, length);\r\n    final int ivSize \u003d ZipShort.getValue(data, offset);\r\n    assertDynamicLengthFits(\"ivSize\", ivSize, 4, length);\r\n    assertMinimalLength(offset + 4, ivSize);\r\n    // TODO: what is at offset + 2?\r\n    this.ivData \u003d Arrays.copyOfRange(data, offset + 4, ivSize);\r\n    // up to and including erdSize\r\n    assertMinimalLength(16 + ivSize, length);\r\n    // TODO: what is at offset + 4 + ivSize?\r\n    this.format \u003d ZipShort.getValue(data, offset + ivSize + 6);\r\n    this.algId \u003d EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\r\n    this.bitlen \u003d ZipShort.getValue(data, offset + ivSize + 10);\r\n    this.flags \u003d ZipShort.getValue(data, offset + ivSize + 12);\r\n    final int erdSize \u003d ZipShort.getValue(data, offset + ivSize + 14);\r\n    assertDynamicLengthFits(\"erdSize\", erdSize, ivSize + 16, length);\r\n    assertMinimalLength(offset + ivSize + 16, erdSize);\r\n    this.erdData \u003d Arrays.copyOfRange(data, offset + ivSize + 16, erdSize);\r\n    assertMinimalLength(16 + 4 + ivSize + erdSize, length);\r\n    this.rcount \u003d ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\r\n    if (rcount \u003d\u003d 0) {\r\n        assertMinimalLength(ivSize + 20 + erdSize + 2, length);\r\n        final int vSize \u003d ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\r\n        assertDynamicLengthFits(\"vSize\", vSize, ivSize + 22 + erdSize, length);\r\n        if (vSize \u003c 4) {\r\n            throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + vSize + \" is too small to hold CRC\");\r\n        }\r\n        assertMinimalLength(offset + ivSize + 22 + erdSize, vSize - 4);\r\n        this.vData \u003d Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize, vSize - 4);\r\n        assertMinimalLength(offset + ivSize + 22 + erdSize + vSize - 4, 4);\r\n        this.vCRC32 \u003d Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + vSize - 4, 4);\r\n    } else {\r\n        // up to and including resize\r\n        assertMinimalLength(ivSize + 20 + erdSize + 6, length);\r\n        this.hashAlg \u003d HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\r\n        this.hashSize \u003d ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\r\n        final int resize \u003d ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\r\n        if (resize \u003c this.hashSize) {\r\n            throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: resize \" + resize + \" is too small to hold hashSize\" + this.hashSize);\r\n        }\r\n        // TODO: this looks suspicious, 26 rather than 24 would be \"after\" resize\r\n        assertDynamicLengthFits(\"resize\", resize, ivSize + 24 + erdSize, length);\r\n        //\r\n        this.recipientKeyHash \u003d Arrays.copyOfRange(data, offset + ivSize + 24 + erdSize, this.hashSize);\r\n        this.keyBlob \u003d Arrays.copyOfRange(data, offset + ivSize + 24 + erdSize + this.hashSize, resize - this.hashSize);\r\n        assertMinimalLength(ivSize + 26 + erdSize + resize + 2, length);\r\n        final int vSize \u003d ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\r\n        if (vSize \u003c 4) {\r\n            throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: vSize \" + vSize + \" is too small to hold CRC\");\r\n        }\r\n        // TODO: these offsets look even more suspicious, the constant should likely be 28 rather than 22\r\n        assertDynamicLengthFits(\"vSize\", vSize, ivSize + 22 + erdSize + resize, length);\r\n        //\r\n        this.vData \u003d Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + resize, vSize - 4);\r\n        this.vCRC32 \u003d Arrays.copyOfRange(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, 4);\r\n    }\r\n    // validate values?\r\n}",
    "nodes": 10,
    "edges": 10,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b33 !\u003d 0) → B1 | else → B4",
      "B1 : If(i112 \u003e\u003d 4) → B2 | else → B3",
      "B4 : If(i113 \u003e\u003d $i48) → B5 | else → B6",
      "B6 : If(i70 \u003e\u003d 4) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  X0017_StrongEncryptionHeader\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0.assertMinimalLength(4, i0)\n  i2 \u003d ZipShort.getValue(r1, i1)\n  r0.assertDynamicLengthFits(\"ivSize\", i2, 4, i0)\n  $i3 \u003d i1 + 4\n  r0.assertMinimalLength($i3, i2)\n  $i4 \u003d i1 + 4\n  $r2 \u003d Arrays.copyOfRange(r1, $i4, i2)\n  X0017_StrongEncryptionHeader: byte[] ivData\u003e \u003d $r2\n  $i5 \u003d 16 + i2\n  r0.assertMinimalLength($i5, i0)\n  $i6 \u003d i1 + i2\n  $i7 \u003d $i6 + 6\n  $i8 \u003d ZipShort.getValue(r1, $i7)\n  X0017_StrongEncryptionHeader: int format\u003e \u003d $i8\n  $i9 \u003d i1 + i2\n  $i10 \u003d $i9 + 8\n  $i11 \u003d ZipShort.getValue(r1, $i10)\n  $r3 \u003d PKWareExtraHeader$EncryptionAlgorithm.getAlgorithmByCode($i11)\n  PKWareExtraHeader$EncryptionAlgorithm algId\u003e \u003d $r3\n  $i12 \u003d i1 + i2\n  $i13 \u003d $i12 + 10\n  $i14 \u003d ZipShort.getValue(r1, $i13)\n  X0017_StrongEncryptionHeader: int bitlen\u003e \u003d $i14\n  $i15 \u003d i1 + i2\n  $i16 \u003d $i15 + 12\n  $i17 \u003d ZipShort.getValue(r1, $i16)\n  X0017_StrongEncryptionHeader: int flags\u003e \u003d $i17\n  $i18 \u003d i1 + i2\n  $i19 \u003d $i18 + 14\n  i20 \u003d ZipShort.getValue(r1, $i19)\n  $i21 \u003d i2 + 16\n  r0.assertDynamicLengthFits(\"erdSize\", i20, $i21, i0)\n  $i22 \u003d i1 + i2\n  $i23 \u003d $i22 + 16\n  r0.assertMinimalLength($i23, i20)\n  $i24 \u003d i1 + i2\n  $i25 \u003d $i24 + 16\n  $r4 \u003d Arrays.copyOfRange(r1, $i25, i20)\n  X0017_StrongEncryptionHeader: byte[] erdData\u003e \u003d $r4\n  $i26 \u003d 20 + i2\n  $i27 \u003d $i26 + i20\n  r0.assertMinimalLength($i27, i0)\n  $i28 \u003d i1 + i2\n  $i29 \u003d $i28 + 16\n  $i30 \u003d $i29 + i20\n  $l31 \u003d ZipLong.getValue(r1, $i30)\n  X0017_StrongEncryptionHeader: long rcount\u003e \u003d $l31\n  $l32 \u003d X0017_StrongEncryptionHeader: long rcount\u003e\n  $b33 \u003d $l32 cmp 0L\n  if ($b33 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $i86 \u003d i2 + 20\n  $i87 \u003d $i86 + i20\n  $i88 \u003d $i87 + 2\n  r0.assertMinimalLength($i88, i0)\n  $i89 \u003d i1 + i2\n  $i90 \u003d $i89 + 20\n  $i91 \u003d $i90 + i20\n  i112 \u003d ZipShort.getValue(r1, $i91)\n  $i92 \u003d i2 + 22\n  $i93 \u003d $i92 + i20\n  r0.assertDynamicLengthFits(\"vSize\", i112, $i93, i0)\n  if (i112 \u003e\u003d 4) goto B2 else B3\n}",
      "B2 {\n  $r25 \u003d ZipException\n  $r26 \u003d StringBuilder\n  new StringBuilder()\n  $r27 \u003d $r26.append(\"Invalid X0017_StrongEncryptionHeader: vSize \")\n  $r28 \u003d $r27.append(i112)\n  $r29 \u003d $r28.append(\" is too small to hold CRC\")\n  $r30 \u003d $r29.toString()\n  new ZipException($r30)\n  throw $r25\n}",
      "B3 {\n  $i94 \u003d i1 + i2\n  $i95 \u003d $i94 + 22\n  $i97 \u003d $i95 + i20\n  $i96 \u003d i112 - 4\n  r0.assertMinimalLength($i97, $i96)\n  $i98 \u003d i1 + i2\n  $i99 \u003d $i98 + 22\n  $i101 \u003d $i99 + i20\n  $i100 \u003d i112 - 4\n  $r23 \u003d Arrays.copyOfRange(r1, $i101, $i100)\n  X0017_StrongEncryptionHeader: byte[] vData\u003e \u003d $r23\n  $i102 \u003d i1 + i2\n  $i103 \u003d $i102 + 22\n  $i104 \u003d $i103 + i20\n  $i105 \u003d $i104 + i112\n  $i106 \u003d $i105 - 4\n  r0.assertMinimalLength($i106, 4)\n  $i107 \u003d i1 + i2\n  $i108 \u003d $i107 + 22\n  $i109 \u003d $i108 + i20\n  $i110 \u003d $i109 + i112\n  $i111 \u003d $i110 - 4\n  $r24 \u003d Arrays.copyOfRange(r1, $i111, 4)\n  X0017_StrongEncryptionHeader: byte[] vCRC32\u003e \u003d $r24\n  goto B9\n}",
      "B4 {\n  $i34 \u003d i2 + 20\n  $i35 \u003d $i34 + i20\n  $i36 \u003d $i35 + 6\n  r0.assertMinimalLength($i36, i0)\n  $i37 \u003d i1 + i2\n  $i38 \u003d $i37 + 20\n  $i39 \u003d $i38 + i20\n  $i40 \u003d ZipShort.getValue(r1, $i39)\n  $r5 \u003d PKWareExtraHeader$HashAlgorithm.getAlgorithmByCode($i40)\n  PKWareExtraHeader$HashAlgorithm hashAlg\u003e \u003d $r5\n  $i41 \u003d i1 + i2\n  $i42 \u003d $i41 + 22\n  $i43 \u003d $i42 + i20\n  $i44 \u003d ZipShort.getValue(r1, $i43)\n  X0017_StrongEncryptionHeader: int hashSize\u003e \u003d $i44\n  $i45 \u003d i1 + i2\n  $i46 \u003d $i45 + 24\n  $i47 \u003d $i46 + i20\n  i113 \u003d ZipShort.getValue(r1, $i47)\n  $i48 \u003d X0017_StrongEncryptionHeader: int hashSize\u003e\n  if (i113 \u003e\u003d $i48) goto B5 else B6\n}",
      "B5 {\n  $r16 \u003d ZipException\n  $r17 \u003d StringBuilder\n  new StringBuilder()\n  $r18 \u003d $r17.append(\"Invalid X0017_StrongEncryptionHeader: resize \")\n  $r19 \u003d $r18.append(i113)\n  $r20 \u003d $r19.append(\" is too small to hold hashSize\")\n  $i85 \u003d X0017_StrongEncryptionHeader: int hashSize\u003e\n  $r21 \u003d $r20.append($i85)\n  $r22 \u003d $r21.toString()\n  new ZipException($r22)\n  throw $r16\n}",
      "B6 {\n  $i49 \u003d i2 + 24\n  $i50 \u003d $i49 + i20\n  r0.assertDynamicLengthFits(\"resize\", i113, $i50, i0)\n  $i51 \u003d i1 + i2\n  $i52 \u003d $i51 + 24\n  $i54 \u003d $i52 + i20\n  $i53 \u003d X0017_StrongEncryptionHeader: int hashSize\u003e\n  $r6 \u003d Arrays.copyOfRange(r1, $i54, $i53)\n  X0017_StrongEncryptionHeader: byte[] recipientKeyHash\u003e \u003d $r6\n  $i55 \u003d i1 + i2\n  $i56 \u003d $i55 + 24\n  $i58 \u003d $i56 + i20\n  $i57 \u003d X0017_StrongEncryptionHeader: int hashSize\u003e\n  $i61 \u003d $i58 + $i57\n  $i59 \u003d X0017_StrongEncryptionHeader: int hashSize\u003e\n  $i60 \u003d i113 - $i59\n  $r7 \u003d Arrays.copyOfRange(r1, $i61, $i60)\n  X0017_StrongEncryptionHeader: byte[] keyBlob\u003e \u003d $r7\n  $i62 \u003d i2 + 26\n  $i63 \u003d $i62 + i20\n  $i64 \u003d $i63 + i113\n  $i65 \u003d $i64 + 2\n  r0.assertMinimalLength($i65, i0)\n  $i66 \u003d i1 + i2\n  $i67 \u003d $i66 + 26\n  $i68 \u003d $i67 + i20\n  $i69 \u003d $i68 + i113\n  i70 \u003d ZipShort.getValue(r1, $i69)\n  if (i70 \u003e\u003d 4) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d ZipException\n  $r11 \u003d StringBuilder\n  new StringBuilder()\n  $r12 \u003d $r11.append(\"Invalid X0017_StrongEncryptionHeader: vSize \")\n  $r13 \u003d $r12.append(i70)\n  $r14 \u003d $r13.append(\" is too small to hold CRC\")\n  $r15 \u003d $r14.toString()\n  new ZipException($r15)\n  throw $r10\n}",
      "B8 {\n  $i71 \u003d i2 + 22\n  $i72 \u003d $i71 + i20\n  $i73 \u003d $i72 + i113\n  r0.assertDynamicLengthFits(\"vSize\", i70, $i73, i0)\n  $i74 \u003d i1 + i2\n  $i75 \u003d $i74 + 22\n  $i76 \u003d $i75 + i20\n  $i78 \u003d $i76 + i113\n  $i77 \u003d i70 - 4\n  $r8 \u003d Arrays.copyOfRange(r1, $i78, $i77)\n  X0017_StrongEncryptionHeader: byte[] vData\u003e \u003d $r8\n  $i79 \u003d i1 + i2\n  $i80 \u003d $i79 + 22\n  $i81 \u003d $i80 + i20\n  $i82 \u003d $i81 + i113\n  $i83 \u003d $i82 + i70\n  $i84 \u003d $i83 - 4\n  $r9 \u003d Arrays.copyOfRange(r1, $i84, 4)\n  X0017_StrongEncryptionHeader: byte[] vCRC32\u003e \u003d $r9\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X0017_StrongEncryptionHeader#assertMinimalLength(...2)",
        "body": "(source not found)"
      },
      {
        "name": "X0017_StrongEncryptionHeader#assertDynamicLengthFits(...4)",
        "body": "{\r\n    if (prefixLength + dynamicLength \u003e length) {\r\n        throw new ZipException(\"Invalid X0017_StrongEncryptionHeader: \" + what + \" \" + dynamicLength + \" doesn\u0027t fit into \" + length + \" bytes of data at position \" + prefixLength);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o instanceof X5455_ExtendedTimestamp) {\r\n        final X5455_ExtendedTimestamp xf \u003d (X5455_ExtendedTimestamp) o;\r\n        // The ZipLong\u003d\u003dZipLong clauses handle the cases where both are null.\r\n        // and only last 3 bits of flags matter.\r\n        return (flags \u0026 0x07) \u003d\u003d (xf.flags \u0026 0x07) \u0026\u0026 Objects.equals(modifyTime, xf.modifyTime) \u0026\u0026 Objects.equals(accessTime, xf.accessTime) \u0026\u0026 Objects.equals(createTime, xf.createTime);\r\n    }\r\n    return false;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B1 : If($i4 !\u003d $i5) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B6",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B6",
      "B4 : If($z3 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  Object\n  $z0 \u003d X5455_ExtendedTimestamp\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  r1 \u003d X5455_ExtendedTimestamp) r0\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b0 \u0026 7\n  $b1 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b2 \u003d $b1 \u0026 7\n  $i4 \u003d (int) $b3\n  $i5 \u003d (int) $b2\n  if ($i4 !\u003d $i5) goto B2 else B6\n}",
      "B2 {\n  $r4 \u003d ZipLong modifyTime\u003e\n  $r3 \u003d ZipLong modifyTime\u003e\n  $z1 \u003d Objects.equals($r4, $r3)\n  if ($z1 \u003d\u003d false) goto B3 else B6\n}",
      "B3 {\n  $r6 \u003d ZipLong accessTime\u003e\n  $r5 \u003d ZipLong accessTime\u003e\n  $z2 \u003d Objects.equals($r6, $r5)\n  if ($z2 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  $r8 \u003d ZipLong createTime\u003e\n  $r7 \u003d ZipLong createTime\u003e\n  $z3 \u003d Objects.equals($r8, $r7)\n  if ($z3 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $z4 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z4 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "getCentralDirectoryLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getCentralDirectoryLength()",
    "visibility": "public",
    "body": "{\r\n    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  $r0 \u003d ZipShort\n  $z0 \u003d X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d 4\n  goto B3\n}",
      "B2 {\n  $b1 \u003d 0\n}",
      "B3 {\n  $i0 \u003d 1 + $b1\n  new ZipShort($i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "getLocalFileDataData",
    "signature": "byte[] getLocalFileDataData()",
    "visibility": "public",
    "body": "{\r\n    final byte[] data \u003d new byte[getLocalFileDataLength().getValue()];\r\n    int pos \u003d 0;\r\n    data[pos++] \u003d 0;\r\n    if (bit0_modifyTimePresent) {\r\n        data[0] |\u003d MODIFY_TIME_BIT;\r\n        System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\r\n        pos +\u003d 4;\r\n    }\r\n    if (bit1_accessTimePresent \u0026\u0026 accessTime !\u003d null) {\r\n        data[0] |\u003d ACCESS_TIME_BIT;\r\n        System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\r\n        pos +\u003d 4;\r\n    }\r\n    if (bit2_createTimePresent \u0026\u0026 createTime !\u003d null) {\r\n        data[0] |\u003d CREATE_TIME_BIT;\r\n        System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\r\n        // NOSONAR - assignment as documentation\r\n        pos +\u003d 4;\r\n    }\r\n    return data;\r\n}",
    "nodes": 9,
    "edges": 13,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($r6 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($r3 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  $r1 \u003d r0.getLocalFileDataLength()\n  $i0 \u003d $r1.getValue()\n  r2 \u003d newarray (byte)[$i0]\n  i10 \u003d 1\n  b12 \u003d 1\n  b11 \u003d 1\n  r2[0] \u003d 0\n  $z0 \u003d X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $b7 \u003d r2[0]\n  $b8 \u003d $b7 | 1\n  $b9 \u003d (byte) $b8\n  r2[0] \u003d $b9\n  $r9 \u003d ZipLong modifyTime\u003e\n  $r10 \u003d $r9.getBytes()\n  System.arraycopy($r10, 0, r2, 1, 4)\n  i10 \u003d 5\n  b12 \u003d 5\n  b11 \u003d 5\n}",
      "B2 {\n  $z1 \u003d X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r6 \u003d ZipLong accessTime\u003e\n  if ($r6 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $b4 \u003d r2[0]\n  $b5 \u003d $b4 | 2\n  $b6 \u003d (byte) $b5\n  r2[0] \u003d $b6\n  $r7 \u003d ZipLong accessTime\u003e\n  $r8 \u003d $r7.getBytes()\n  System.arraycopy($r8, 0, r2, b12, 4)\n  i10 \u003d b11 + 4\n}",
      "B5 {\n  $z2 \u003d X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e\n  if ($z2 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r3 \u003d ZipLong createTime\u003e\n  if ($r3 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $b1 \u003d r2[0]\n  $b2 \u003d $b1 | 4\n  $b3 \u003d (byte) $b2\n  r2[0] \u003d $b3\n  $r4 \u003d ZipLong createTime\u003e\n  $r5 \u003d $r4.getBytes()\n  System.arraycopy($r5, 0, r2, i10, 4)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X5455_ExtendedTimestamp#getLocalFileDataLength(...0)",
        "body": "{\r\n    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent \u0026\u0026 accessTime !\u003d null ? 4 : 0) + (bit2_createTimePresent \u0026\u0026 createTime !\u003d null ? 4 : 0));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "getLocalFileDataLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getLocalFileDataLength()",
    "visibility": "public",
    "body": "{\r\n    return new ZipShort(1 + (bit0_modifyTimePresent ? 4 : 0) + (bit1_accessTimePresent \u0026\u0026 accessTime !\u003d null ? 4 : 0) + (bit2_createTimePresent \u0026\u0026 createTime !\u003d null ? 4 : 0));\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B6",
      "B4 : If($r2 \u003d\u003d null) → B5 | else → B6",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B10",
      "B8 : If($r1 \u003d\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  $r3 \u003d ZipShort\n  $z0 \u003d X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $b0 \u003d 4\n  goto B3\n}",
      "B2 {\n  $b0 \u003d 0\n}",
      "B3 {\n  $i1 \u003d 1 + $b0\n  $z1 \u003d X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  $r2 \u003d ZipLong accessTime\u003e\n  if ($r2 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $b2 \u003d 4\n  goto B7\n}",
      "B6 {\n  $b2 \u003d 0\n}",
      "B7 {\n  $i3 \u003d $i1 + $b2\n  $z2 \u003d X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e\n  if ($z2 \u003d\u003d false) goto B8 else B10\n}",
      "B8 {\n  $r1 \u003d ZipLong createTime\u003e\n  if ($r1 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $b4 \u003d 4\n  goto B11\n}",
      "B10 {\n  $b4 \u003d 0\n}",
      "B11 {\n  $i5 \u003d $i3 + $b4\n  new ZipShort($i5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    // only last 3 bits of flags matter\r\n    int hc \u003d -123 * (flags \u0026 0x07);\r\n    if (modifyTime !\u003d null) {\r\n        hc ^\u003d modifyTime.hashCode();\r\n    }\r\n    if (accessTime !\u003d null) {\r\n        // Since accessTime is often same as modifyTime,\r\n        // this prevents them from XOR negating each other.\r\n        hc ^\u003d Integer.rotateLeft(accessTime.hashCode(), 11);\r\n    }\r\n    if (createTime !\u003d null) {\r\n        hc ^\u003d Integer.rotateLeft(createTime.hashCode(), 22);\r\n    }\r\n    return hc;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r3 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b1 \u003d $b0 \u0026 7\n  $i9 \u003d (int) -123\n  $i10 \u003d (int) $b1\n  i7 \u003d $i9 * $i10\n  $r1 \u003d ZipLong modifyTime\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ZipLong modifyTime\u003e\n  $i6 \u003d $r6.hashCode()\n  i7 \u003d i7 ^ $i6\n}",
      "B2 {\n  $r2 \u003d ZipLong accessTime\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d ZipLong accessTime\u003e\n  $i4 \u003d $r5.hashCode()\n  $i5 \u003d Integer.rotateLeft($i4, 11)\n  i7 \u003d i7 ^ $i5\n}",
      "B4 {\n  $r3 \u003d ZipLong createTime\u003e\n  if ($r3 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d ZipLong createTime\u003e\n  $i2 \u003d $r4.hashCode()\n  $i3 \u003d Integer.rotateLeft($i2, 22)\n  i7 \u003d i7 ^ $i3\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    reset();\r\n    if (length \u003c 1) {\r\n        throw new ZipException(\"X5455_ExtendedTimestamp too short, only \" + length + \" bytes\");\r\n    }\r\n    final int len \u003d offset + length;\r\n    setFlags(data[offset++]);\r\n    if (bit0_modifyTimePresent \u0026\u0026 offset + 4 \u003c\u003d len) {\r\n        modifyTime \u003d new ZipLong(data, offset);\r\n        offset +\u003d 4;\r\n    } else {\r\n        bit0_modifyTimePresent \u003d false;\r\n    }\r\n    if (bit1_accessTimePresent \u0026\u0026 offset + 4 \u003c\u003d len) {\r\n        accessTime \u003d new ZipLong(data, offset);\r\n        offset +\u003d 4;\r\n    } else {\r\n        bit1_accessTimePresent \u003d false;\r\n    }\r\n    if (bit2_createTimePresent \u0026\u0026 offset + 4 \u003c\u003d len) {\r\n        createTime \u003d new ZipLong(data, offset);\r\n        // NOSONAR - assignment as documentation\r\n        offset +\u003d 4;\r\n    } else {\r\n        bit2_createTimePresent \u003d false;\r\n    }\r\n}",
    "nodes": 15,
    "edges": 20,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($i5 \u003e i1) → B4 | else → B5",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B9",
      "B7 : If($i4 \u003e i1) → B8 | else → B9",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B13",
      "B11 : If($i3 \u003e i1) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  r1 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0.reset()\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d ZipException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"X5455_ExtendedTimestamp too short, only \")\n  $r8 \u003d $r7.append(i0)\n  $r9 \u003d $r8.append(\" bytes\")\n  $r10 \u003d $r9.toString()\n  new ZipException($r10)\n  throw $r5\n}",
      "B2 {\n  i1 \u003d i6 + i0\n  i7 \u003d i6 + 1\n  $b2 \u003d r1[i6]\n  r0.setFlags($b2)\n  $z0 \u003d X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $i5 \u003d i7 + 4\n  if ($i5 \u003e i1) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d ZipLong\n  new ZipLong(r1, i7)\n  ZipLong modifyTime\u003e \u003d $r4\n  i7 \u003d i7 + 4\n  goto B6\n}",
      "B5 {\n  X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e \u003d 0\n}",
      "B6 {\n  $z1 \u003d X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e\n  if ($z1 \u003d\u003d false) goto B7 else B9\n}",
      "B7 {\n  $i4 \u003d i7 + 4\n  if ($i4 \u003e i1) goto B8 else B9\n}",
      "B8 {\n  $r3 \u003d ZipLong\n  new ZipLong(r1, i7)\n  ZipLong accessTime\u003e \u003d $r3\n  i7 \u003d i7 + 4\n  goto B10\n}",
      "B9 {\n  X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e \u003d 0\n}",
      "B10 {\n  $z2 \u003d X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e\n  if ($z2 \u003d\u003d false) goto B11 else B13\n}",
      "B11 {\n  $i3 \u003d i7 + 4\n  if ($i3 \u003e i1) goto B12 else B13\n}",
      "B12 {\n  $r2 \u003d ZipLong\n  new ZipLong(r1, i7)\n  ZipLong createTime\u003e \u003d $r2\n  goto B14\n}",
      "B13 {\n  X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e \u003d 0\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X5455_ExtendedTimestamp#setFlags(...1)",
        "body": "{\r\n    this.flags \u003d flags;\r\n    this.bit0_modifyTimePresent \u003d (flags \u0026 MODIFY_TIME_BIT) \u003d\u003d MODIFY_TIME_BIT;\r\n    this.bit1_accessTimePresent \u003d (flags \u0026 ACCESS_TIME_BIT) \u003d\u003d ACCESS_TIME_BIT;\r\n    this.bit2_createTimePresent \u003d (flags \u0026 CREATE_TIME_BIT) \u003d\u003d CREATE_TIME_BIT;\r\n}"
      },
      {
        "name": "X5455_ExtendedTimestamp#reset(...0)",
        "body": "{\r\n    setFlags((byte) 0);\r\n    this.modifyTime \u003d null;\r\n    this.accessTime \u003d null;\r\n    this.createTime \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "setAccessTime",
    "signature": "void setAccessTime(org.apache.commons.compress.archivers.zip.ZipLong)",
    "visibility": "public",
    "body": "{\r\n    bit1_accessTimePresent \u003d l !\u003d null;\r\n    flags \u003d (byte) (l !\u003d null ? flags | ACCESS_TIME_BIT : flags \u0026 ~ACCESS_TIME_BIT);\r\n    this.accessTime \u003d l;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(r1 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  ZipLong\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e \u003d $z0\n  if (r1 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $b2 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b2 | 2\n  goto B6\n}",
      "B5 {\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b0 \u0026 -3\n}",
      "B6 {\n  $b1 \u003d (byte) $b3\n  X5455_ExtendedTimestamp: byte flags\u003e \u003d $b1\n  ZipLong accessTime\u003e \u003d r1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "setCreateTime",
    "signature": "void setCreateTime(org.apache.commons.compress.archivers.zip.ZipLong)",
    "visibility": "public",
    "body": "{\r\n    bit2_createTimePresent \u003d l !\u003d null;\r\n    flags \u003d (byte) (l !\u003d null ? flags | CREATE_TIME_BIT : flags \u0026 ~CREATE_TIME_BIT);\r\n    this.createTime \u003d l;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(r1 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  ZipLong\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e \u003d $z0\n  if (r1 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $b2 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b2 | 4\n  goto B6\n}",
      "B5 {\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b0 \u0026 -5\n}",
      "B6 {\n  $b1 \u003d (byte) $b3\n  X5455_ExtendedTimestamp: byte flags\u003e \u003d $b1\n  ZipLong createTime\u003e \u003d r1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "setFlags",
    "signature": "void setFlags(byte)",
    "visibility": "public",
    "body": "{\r\n    this.flags \u003d flags;\r\n    this.bit0_modifyTimePresent \u003d (flags \u0026 MODIFY_TIME_BIT) \u003d\u003d MODIFY_TIME_BIT;\r\n    this.bit1_accessTimePresent \u003d (flags \u0026 ACCESS_TIME_BIT) \u003d\u003d ACCESS_TIME_BIT;\r\n    this.bit2_createTimePresent \u003d (flags \u0026 CREATE_TIME_BIT) \u003d\u003d CREATE_TIME_BIT;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($b1 !\u003d 1) → B1 | else → B2",
      "B3 : If($i4 !\u003d 2) → B4 | else → B5",
      "B6 : If($i5 !\u003d 4) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  b0 :\u003d @parameter0: byte\n  X5455_ExtendedTimestamp: byte flags\u003e \u003d b0\n  $b1 \u003d b0 \u0026 1\n  if ($b1 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e \u003d $z0\n  $b2 \u003d b0 \u0026 2\n  $i4 \u003d (int) $b2\n  if ($i4 !\u003d 2) goto B4 else B5\n}",
      "B4 {\n  $z1 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z1 \u003d 0\n}",
      "B6 {\n  X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e \u003d $z1\n  $b3 \u003d b0 \u0026 4\n  $i5 \u003d (int) $b3\n  if ($i5 !\u003d 4) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e \u003d $z2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "setModifyTime",
    "signature": "void setModifyTime(org.apache.commons.compress.archivers.zip.ZipLong)",
    "visibility": "public",
    "body": "{\r\n    bit0_modifyTimePresent \u003d l !\u003d null;\r\n    flags \u003d (byte) (l !\u003d null ? flags | MODIFY_TIME_BIT : flags \u0026 ~MODIFY_TIME_BIT);\r\n    this.modifyTime \u003d l;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(r1 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  ZipLong\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e \u003d $z0\n  if (r1 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $b2 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b2 | 1\n  goto B6\n}",
      "B5 {\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $b3 \u003d $b0 \u0026 -2\n}",
      "B6 {\n  $b1 \u003d (byte) $b3\n  X5455_ExtendedTimestamp: byte flags\u003e \u003d $b1\n  ZipLong modifyTime\u003e \u003d r1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    final StringBuilder buf \u003d new StringBuilder();\r\n    buf.append(\"0x5455 Zip Extra Field: Flags\u003d\");\r\n    buf.append(Integer.toBinaryString(ZipUtil.unsignedIntToSignedByte(flags))).append(\" \");\r\n    if (bit0_modifyTimePresent \u0026\u0026 modifyTime !\u003d null) {\r\n        final Date m \u003d getModifyJavaTime();\r\n        buf.append(\" Modify:[\").append(m).append(\"] \");\r\n    }\r\n    if (bit1_accessTimePresent \u0026\u0026 accessTime !\u003d null) {\r\n        final Date a \u003d getAccessJavaTime();\r\n        buf.append(\" Access:[\").append(a).append(\"] \");\r\n    }\r\n    if (bit2_createTimePresent \u0026\u0026 createTime !\u003d null) {\r\n        final Date c \u003d getCreateJavaTime();\r\n        buf.append(\" Create:[\").append(c).append(\"] \");\r\n    }\r\n    return buf.toString();\r\n}",
    "nodes": 10,
    "edges": 15,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($r10 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B6",
      "B4 : If($r7 \u003d\u003d null) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B9",
      "B7 : If($r4 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  X5455_ExtendedTimestamp\n  $r17 \u003d StringBuilder\n  new StringBuilder()\n  $r17.append(\"0x5455 Zip Extra Field: Flags\u003d\")\n  $b0 \u003d X5455_ExtendedTimestamp: byte flags\u003e\n  $i2 \u003d (int) $b0\n  $b1 \u003d ZipUtil.unsignedIntToSignedByte($i2)\n  $i3 \u003d (int) $b1\n  $r2 \u003d Integer.toBinaryString($i3)\n  $r3 \u003d $r17.append($r2)\n  $r3.append(\" \")\n  $z0 \u003d X5455_ExtendedTimestamp: boolean bit0_modifyTimePresent\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r10 \u003d ZipLong modifyTime\u003e\n  if ($r10 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  r13 \u003d r1.getModifyJavaTime()\n  $r11 \u003d $r17.append(\" Modify:\")\n  $r12 \u003d $r11.append(r13)\n  $r12.append(\" \")\n}",
      "B3 {\n  $z1 \u003d X5455_ExtendedTimestamp: boolean bit1_accessTimePresent\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  $r7 \u003d ZipLong accessTime\u003e\n  if ($r7 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  r14 \u003d r1.getAccessJavaTime()\n  $r8 \u003d $r17.append(\" Access:\")\n  $r9 \u003d $r8.append(r14)\n  $r9.append(\" \")\n}",
      "B6 {\n  $z2 \u003d X5455_ExtendedTimestamp: boolean bit2_createTimePresent\u003e\n  if ($z2 \u003d\u003d false) goto B7 else B9\n}",
      "B7 {\n  $r4 \u003d ZipLong createTime\u003e\n  if ($r4 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  r15 \u003d r1.getCreateJavaTime()\n  $r5 \u003d $r17.append(\" Create:\")\n  $r6 \u003d $r5.append(r15)\n  $r6.append(\" \")\n}",
      "B9 {\n  $r16 \u003d $r17.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X5455_ExtendedTimestamp#getModifyJavaTime(...0)",
        "body": "{\r\n    return zipLongToDate(modifyTime);\r\n}"
      },
      {
        "name": "X5455_ExtendedTimestamp#getCreateJavaTime(...0)",
        "body": "{\r\n    return zipLongToDate(createTime);\r\n}"
      },
      {
        "name": "X5455_ExtendedTimestamp#getAccessJavaTime(...0)",
        "body": "{\r\n    return zipLongToDate(accessTime);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X7875_NewUnix",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o instanceof X7875_NewUnix) {\r\n        final X7875_NewUnix xf \u003d (X7875_NewUnix) o;\r\n        // We assume uid and gid can never be null.\r\n        return version \u003d\u003d xf.version \u0026\u0026 uid.equals(xf.uid) \u0026\u0026 gid.equals(xf.gid);\r\n    }\r\n    return false;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B7",
      "B1 : If($i1 !\u003d $i0) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  X7875_NewUnix\n  Object\n  $z0 \u003d X7875_NewUnix\n  if ($z0 \u003d\u003d false) goto B1 else B7\n}",
      "B1 {\n  r1 \u003d X7875_NewUnix) r0\n  $i1 \u003d X7875_NewUnix: int version\u003e\n  $i0 \u003d X7875_NewUnix: int version\u003e\n  if ($i1 !\u003d $i0) goto B2 else B5\n}",
      "B2 {\n  $r4 \u003d BigInteger uid\u003e\n  $r3 \u003d BigInteger uid\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r6 \u003d BigInteger gid\u003e\n  $r5 \u003d BigInteger gid\u003e\n  $z2 \u003d $r6.equals($r5)\n  if ($z2 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z3 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z3 \u003d 0\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X7875_NewUnix",
    "methodName": "getLocalFileDataData",
    "signature": "byte[] getLocalFileDataData()",
    "visibility": "public",
    "body": "{\r\n    byte[] uidBytes \u003d uid.toByteArray();\r\n    byte[] gidBytes \u003d gid.toByteArray();\r\n    // BigInteger might prepend a leading-zero to force a positive representation\r\n    // (for example, so that the sign-bit is set to zero). We need to remove that\r\n    // before sending the number over the wire.\r\n    uidBytes \u003d trimLeadingZeroesForceMinLength(uidBytes);\r\n    final int uidBytesLen \u003d ArrayUtils.getLength(uidBytes);\r\n    gidBytes \u003d trimLeadingZeroesForceMinLength(gidBytes);\r\n    final int gidBytesLen \u003d ArrayUtils.getLength(gidBytes);\r\n    // Couldn\u0027t bring myself to just call getLocalFileDataLength() when we\u0027ve\r\n    // already got the arrays right here. Yeah, yeah, I know, premature\r\n    // optimization is the root of all...\r\n    //\r\n    // The 3 comes from: version\u003d1 + uidsize\u003d1 + gidsize\u003d1\r\n    final byte[] data \u003d new byte[3 + uidBytesLen + gidBytesLen];\r\n    // reverse() switches byte array from big-endian to little-endian.\r\n    if (uidBytes !\u003d null) {\r\n        reverse(uidBytes);\r\n    }\r\n    if (gidBytes !\u003d null) {\r\n        reverse(gidBytes);\r\n    }\r\n    int pos \u003d 0;\r\n    data[pos++] \u003d unsignedIntToSignedByte(version);\r\n    data[pos++] \u003d unsignedIntToSignedByte(uidBytesLen);\r\n    if (uidBytes !\u003d null) {\r\n        System.arraycopy(uidBytes, 0, data, pos, uidBytesLen);\r\n    }\r\n    pos +\u003d uidBytesLen;\r\n    data[pos++] \u003d unsignedIntToSignedByte(gidBytesLen);\r\n    if (gidBytes !\u003d null) {\r\n        System.arraycopy(gidBytes, 0, data, pos, gidBytesLen);\r\n    }\r\n    return data;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r7 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(r6 \u003d\u003d null) → B5 | else → B6",
      "B6 : If(r7 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  X7875_NewUnix\n  $r1 \u003d BigInteger uid\u003e\n  r4 \u003d $r1.toByteArray()\n  $r2 \u003d BigInteger gid\u003e\n  r5 \u003d $r2.toByteArray()\n  r6 \u003d X7875_NewUnix.trimLeadingZeroesForceMinLength(r4)\n  i0 \u003d ArrayUtils.getLength(r6)\n  r7 \u003d X7875_NewUnix.trimLeadingZeroesForceMinLength(r5)\n  i1 \u003d ArrayUtils.getLength(r7)\n  $i2 \u003d 3 + i0\n  $i3 \u003d $i2 + i1\n  r3 \u003d newarray (byte)[$i3]\n  if (r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  ZipUtil.reverse(r6)\n}",
      "B2 {\n  if (r7 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  ZipUtil.reverse(r7)\n}",
      "B4 {\n  $i4 \u003d X7875_NewUnix: int version\u003e\n  $b5 \u003d ZipUtil.unsignedIntToSignedByte($i4)\n  r3[0] \u003d $b5\n  $b6 \u003d ZipUtil.unsignedIntToSignedByte(i0)\n  r3[1] \u003d $b6\n  if (r6 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  System.arraycopy(r6, 0, r3, 2, i0)\n}",
      "B6 {\n  $i8 \u003d 2 + i0\n  i9 \u003d $i8 + 1\n  $b7 \u003d ZipUtil.unsignedIntToSignedByte(i1)\n  r3[$i8] \u003d $b7\n  if (r7 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  System.arraycopy(r7, 0, r3, i9, i1)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X7875_NewUnix#unsignedIntToSignedByte(...1)",
        "body": "(source not found)"
      },
      {
        "name": "X7875_NewUnix#reverse(...1)",
        "body": "(source not found)"
      },
      {
        "name": "X7875_NewUnix#trimLeadingZeroesForceMinLength(...1)",
        "body": "{\r\n    if (array \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    int pos \u003d 0;\r\n    for (final byte b : array) {\r\n        if (b !\u003d 0) {\r\n            break;\r\n        }\r\n        pos++;\r\n    }\r\n    /*\r\n         * I agonized over my choice of MIN_LENGTH\u003d1. Here\u0027s the situation: InfoZip (the tool I am using to test interop) always sets these to length\u003d4. And so\r\n         * a UID of 0 (typically root) for example is encoded as {4,0,0,0,0} (len\u003d4, 32 bits of zero), when it could just as easily be encoded as {1,0} (len\u003d1,\r\n         * 8 bits of zero) according to the spec.\r\n         *\r\n         * In the end I decided on MIN_LENGTH\u003d1 for four reasons:\r\n         *\r\n         * 1.) We are adhering to the spec as far as I can tell, and so a consumer that cannot parse this is broken.\r\n         *\r\n         * 2.) Fundamentally, ZIP files are about shrinking things, so let\u0027s save a few bytes per entry while we can.\r\n         *\r\n         * 3.) Of all the people creating ZIP files using commons- compress, how many care about Unix UID/GID attributes of the files they store? (for example,\r\n         * I am probably thinking way too hard about this and no one cares!)\r\n         *\r\n         * 4.) InfoZip\u0027s tool, even though it carefully stores every UID/GID for every file zipped on a Unix machine (by default) currently appears unable to\r\n         * ever restore UID/GID. unzip -X has no effect on my machine, even when run as root!!!!\r\n         *\r\n         * And thus it is decided: MIN_LENGTH\u003d1.\r\n         *\r\n         * If anyone runs into interop problems from this, feel free to set it to MIN_LENGTH\u003d4 at some future time, and then we will behave exactly like InfoZip\r\n         * (requires changes to unit tests, though).\r\n         *\r\n         * And I am sorry that the time you spent reading this comment is now gone, and you can never have it back.\r\n         */\r\n    final int MIN_LENGTH \u003d 1;\r\n    final byte[] trimmedArray \u003d new byte[Math.max(MIN_LENGTH, array.length - pos)];\r\n    final int startPos \u003d trimmedArray.length - (array.length - pos);\r\n    System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\r\n    return trimmedArray;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.X7875_NewUnix",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    reset();\r\n    if (length \u003c 3) {\r\n        throw new ZipException(\"X7875_NewUnix length is too short, only \" + length + \" bytes\");\r\n    }\r\n    this.version \u003d Byte.toUnsignedInt(data[offset++]);\r\n    final int uidSize \u003d Byte.toUnsignedInt(data[offset++]);\r\n    if (uidSize + 3 \u003e length) {\r\n        throw new ZipException(\"X7875_NewUnix invalid: uidSize \" + uidSize + \" doesn\u0027t fit into \" + length + \" bytes\");\r\n    }\r\n    final byte[] uidBytes \u003d Arrays.copyOfRange(data, offset, offset + uidSize);\r\n    offset +\u003d uidSize;\r\n    // sign-bit forced positive\r\n    this.uid \u003d new BigInteger(1, reverse(uidBytes));\r\n    final int gidSize \u003d Byte.toUnsignedInt(data[offset++]);\r\n    if (uidSize + 3 + gidSize \u003e length) {\r\n        throw new ZipException(\"X7875_NewUnix invalid: gidSize \" + gidSize + \" doesn\u0027t fit into \" + length + \" bytes\");\r\n    }\r\n    final byte[] gidBytes \u003d Arrays.copyOfRange(data, offset, offset + gidSize);\r\n    // sign-bit forced positive\r\n    this.gid \u003d new BigInteger(1, reverse(gidBytes));\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 3) → B1 | else → B2",
      "B2 : If($i5 \u003c\u003d i0) → B3 | else → B4",
      "B4 : If($i10 \u003c\u003d i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  X7875_NewUnix\n  r1 :\u003d @parameter0: byte[]\n  i12 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0.reset()\n  if (i0 \u003e\u003d 3) goto B1 else B2\n}",
      "B1 {\n  $r24 \u003d ZipException\n  $r25 \u003d StringBuilder\n  new StringBuilder()\n  $r26 \u003d $r25.append(\"X7875_NewUnix length is too short, only \")\n  $r27 \u003d $r26.append(i0)\n  $r28 \u003d $r27.append(\" bytes\")\n  $r29 \u003d $r28.toString()\n  new ZipException($r29)\n  throw $r24\n}",
      "B2 {\n  i13 \u003d i12 + 1\n  $b1 \u003d r1[i12]\n  $i2 \u003d Byte.toUnsignedInt($b1)\n  X7875_NewUnix: int version\u003e \u003d $i2\n  i14 \u003d i13 + 1\n  $b3 \u003d r1[i13]\n  i4 \u003d Byte.toUnsignedInt($b3)\n  $i5 \u003d i4 + 3\n  if ($i5 \u003c\u003d i0) goto B3 else B4\n}",
      "B3 {\n  $r16 \u003d ZipException\n  $r17 \u003d StringBuilder\n  new StringBuilder()\n  $r18 \u003d $r17.append(\"X7875_NewUnix invalid: uidSize \")\n  $r19 \u003d $r18.append(i4)\n  $r20 \u003d $r19.append(\" doesn\\\u0027t fit into \")\n  $r21 \u003d $r20.append(i0)\n  $r22 \u003d $r21.append(\" bytes\")\n  $r23 \u003d $r22.toString()\n  new ZipException($r23)\n  throw $r16\n}",
      "B4 {\n  $i6 \u003d i14 + i4\n  r2 \u003d Arrays.copyOfRange(r1, i14, $i6)\n  i15 \u003d i14 + i4\n  $r3 \u003d BigInteger\n  $r4 \u003d ZipUtil.reverse(r2)\n  new BigInteger(1, $r4)\n  BigInteger uid\u003e \u003d $r3\n  i16 \u003d i15 + 1\n  $b7 \u003d r1[i15]\n  i8 \u003d Byte.toUnsignedInt($b7)\n  $i9 \u003d i4 + 3\n  $i10 \u003d $i9 + i8\n  if ($i10 \u003c\u003d i0) goto B5 else B6\n}",
      "B5 {\n  $r8 \u003d ZipException\n  $r9 \u003d StringBuilder\n  new StringBuilder()\n  $r10 \u003d $r9.append(\"X7875_NewUnix invalid: gidSize \")\n  $r11 \u003d $r10.append(i8)\n  $r12 \u003d $r11.append(\" doesn\\\u0027t fit into \")\n  $r13 \u003d $r12.append(i0)\n  $r14 \u003d $r13.append(\" bytes\")\n  $r15 \u003d $r14.toString()\n  new ZipException($r15)\n  throw $r8\n}",
      "B6 {\n  $i11 \u003d i16 + i8\n  r5 \u003d Arrays.copyOfRange(r1, i16, $i11)\n  $r6 \u003d BigInteger\n  $r7 \u003d ZipUtil.reverse(r5)\n  new BigInteger(1, $r7)\n  BigInteger gid\u003e \u003d $r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "X7875_NewUnix#reverse(...1)",
        "body": "(source not found)"
      },
      {
        "name": "X7875_NewUnix#reset(...0)",
        "body": "{\r\n    // Typical UID/GID of the first non-root user created on a Unix system.\r\n    uid \u003d ONE_THOUSAND;\r\n    gid \u003d ONE_THOUSAND;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "getCentralDirectoryData",
    "signature": "byte[] getCentralDirectoryData()",
    "visibility": "public",
    "body": "{\r\n    final byte[] data \u003d new byte[getCentralDirectoryLength().getValue()];\r\n    int off \u003d addSizes(data);\r\n    if (relativeHeaderOffset !\u003d null) {\r\n        System.arraycopy(relativeHeaderOffset.getBytes(), 0, data, off, DWORD);\r\n        off +\u003d DWORD;\r\n    }\r\n    if (diskStart !\u003d null) {\r\n        System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);\r\n        // NOSONAR - assignment as documentation\r\n        off +\u003d WORD;\r\n    }\r\n    return data;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r3 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r4 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  $r1 \u003d r0.getCentralDirectoryLength()\n  $i0 \u003d $r1.getValue()\n  r2 \u003d newarray (byte)[$i0]\n  i1 \u003d r0.addSizes(r2)\n  $r3 \u003d ZipEightByteInteger relativeHeaderOffset\u003e\n  if ($r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d ZipEightByteInteger relativeHeaderOffset\u003e\n  $r8 \u003d $r7.getBytes()\n  System.arraycopy($r8, 0, r2, i1, 8)\n  i1 \u003d i1 + 8\n}",
      "B2 {\n  $r4 \u003d ZipLong diskStart\u003e\n  if ($r4 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d ZipLong diskStart\u003e\n  $r6 \u003d $r5.getBytes()\n  System.arraycopy($r6, 0, r2, i1, 4)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Zip64ExtendedInformationExtraField#addSizes(...1)",
        "body": "{\r\n    int off \u003d 0;\r\n    if (size !\u003d null) {\r\n        System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\r\n        off +\u003d DWORD;\r\n    }\r\n    if (compressedSize !\u003d null) {\r\n        System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\r\n        off +\u003d DWORD;\r\n    }\r\n    return off;\r\n}"
      },
      {
        "name": "Zip64ExtendedInformationExtraField#getCentralDirectoryLength(...0)",
        "body": "{\r\n    return new ZipShort((size !\u003d null ? DWORD : 0) + (compressedSize !\u003d null ? DWORD : 0) + (relativeHeaderOffset !\u003d null ? DWORD : 0) + (diskStart !\u003d null ? WORD : 0));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "getCentralDirectoryLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getCentralDirectoryLength()",
    "visibility": "public",
    "body": "{\r\n    return new ZipShort((size !\u003d null ? DWORD : 0) + (compressedSize !\u003d null ? DWORD : 0) + (relativeHeaderOffset !\u003d null ? DWORD : 0) + (diskStart !\u003d null ? WORD : 0));\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($r3 \u003d\u003d null) → B4 | else → B5",
      "B6 : If($r5 \u003d\u003d null) → B7 | else → B8",
      "B9 : If($r4 \u003d\u003d null) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  $r0 \u003d ZipShort\n  $r2 \u003d ZipEightByteInteger size\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $b3 \u003d 8\n  goto B3\n}",
      "B2 {\n  $b3 \u003d 0\n}",
      "B3 {\n  $r3 \u003d ZipEightByteInteger compressedSize\u003e\n  if ($r3 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $b4 \u003d 8\n  goto B6\n}",
      "B5 {\n  $b4 \u003d 0\n}",
      "B6 {\n  $i0 \u003d $b3 + $b4\n  $r5 \u003d ZipEightByteInteger relativeHeaderOffset\u003e\n  if ($r5 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $b5 \u003d 8\n  goto B9\n}",
      "B8 {\n  $b5 \u003d 0\n}",
      "B9 {\n  $i1 \u003d $i0 + $b5\n  $r4 \u003d ZipLong diskStart\u003e\n  if ($r4 \u003d\u003d null) goto B10 else B11\n}",
      "B10 {\n  $b6 \u003d 4\n  goto B12\n}",
      "B11 {\n  $b6 \u003d 0\n}",
      "B12 {\n  $i2 \u003d $i1 + $b6\n  new ZipShort($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "getLocalFileDataData",
    "signature": "byte[] getLocalFileDataData()",
    "visibility": "public",
    "body": "{\r\n    if (size !\u003d null || compressedSize !\u003d null) {\r\n        if (size \u003d\u003d null || compressedSize \u003d\u003d null) {\r\n            throw new IllegalArgumentException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\r\n        }\r\n        final byte[] data \u003d new byte[2 * DWORD];\r\n        addSizes(data);\r\n        return data;\r\n    }\r\n    return ByteUtils.EMPTY_BYTE_ARRAY;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B1 : If($r6 \u003d\u003d null) → B2 | else → B6",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r4 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  $r1 \u003d ZipEightByteInteger size\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ZipEightByteInteger compressedSize\u003e\n  if ($r6 \u003d\u003d null) goto B2 else B6\n}",
      "B2 {\n  $r2 \u003d ZipEightByteInteger size\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d ZipEightByteInteger compressedSize\u003e\n  if ($r4 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Zip64 extended information must contain both size values in the local file header.\")\n  throw $r3\n}",
      "B5 {\n  r5 \u003d newarray (byte)[16]\n  r0.addSizes(r5)\n  return\n}",
      "B6 {\n  $r7 \u003d ByteUtils: byte[] EMPTY_BYTE_ARRAY\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Zip64ExtendedInformationExtraField#addSizes(...1)",
        "body": "{\r\n    int off \u003d 0;\r\n    if (size !\u003d null) {\r\n        System.arraycopy(size.getBytes(), 0, data, 0, DWORD);\r\n        off +\u003d DWORD;\r\n    }\r\n    if (compressedSize !\u003d null) {\r\n        System.arraycopy(compressedSize.getBytes(), 0, data, off, DWORD);\r\n        off +\u003d DWORD;\r\n    }\r\n    return off;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "getLocalFileDataLength",
    "signature": "org.apache.commons.compress.archivers.zip.ZipShort getLocalFileDataLength()",
    "visibility": "public",
    "body": "{\r\n    return new ZipShort(size !\u003d null ? 2 * DWORD : 0);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  $r0 \u003d ZipShort\n  $r2 \u003d ZipEightByteInteger size\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $b0 \u003d 16\n  goto B3\n}",
      "B2 {\n  $b0 \u003d 0\n}",
      "B3 {\n  new ZipShort($b0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "parseFromCentralDirectoryData",
    "signature": "void parseFromCentralDirectoryData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // store for processing in reparseCentralDirectoryData\r\n    rawCentralDirectoryData \u003d new byte[length];\r\n    System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\r\n    // if there is no size information in here, we are screwed and\r\n    // can only hope things will get resolved by LFH data later\r\n    // But there are some cases that can be detected\r\n    // * all data is there\r\n    // * length \u003d\u003d 24 -\u003e both sizes and offset\r\n    // * length % 8 \u003d\u003d 4 -\u003e at least we can identify the diskStart field\r\n    if (length \u003e\u003d 3 * DWORD + WORD) {\r\n        parseFromLocalFileData(buffer, offset, length);\r\n    } else if (length \u003d\u003d 3 * DWORD) {\r\n        size \u003d new ZipEightByteInteger(buffer, offset);\r\n        offset +\u003d DWORD;\r\n        compressedSize \u003d new ZipEightByteInteger(buffer, offset);\r\n        offset +\u003d DWORD;\r\n        relativeHeaderOffset \u003d new ZipEightByteInteger(buffer, offset);\r\n    } else if (length % DWORD \u003d\u003d WORD) {\r\n        diskStart \u003d new ZipLong(buffer, offset + length - WORD);\r\n    }\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003c 28) → B1 | else → B2",
      "B2 : If(i0 !\u003d 24) → B3 | else → B4",
      "B4 : If($i1 !\u003d 4) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  r2 :\u003d @parameter0: byte[]\n  i4 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  $r1 \u003d newarray (byte)[i0]\n  Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e \u003d $r1\n  $r3 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  System.arraycopy(r2, i4, $r3, 0, i0)\n  if (i0 \u003c 28) goto B1 else B2\n}",
      "B1 {\n  r0.parseFromLocalFileData(r2, i4, i0)\n  goto B6\n}",
      "B2 {\n  if (i0 !\u003d 24) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i4)\n  ZipEightByteInteger size\u003e \u003d $r5\n  i5 \u003d i4 + 8\n  $r6 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i5)\n  ZipEightByteInteger compressedSize\u003e \u003d $r6\n  i6 \u003d i5 + 8\n  $r7 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i6)\n  ZipEightByteInteger relativeHeaderOffset\u003e \u003d $r7\n  goto B6\n}",
      "B4 {\n  $i1 \u003d i0 % 8\n  if ($i1 !\u003d 4) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d ZipLong\n  $i2 \u003d i4 + i0\n  $i3 \u003d $i2 - 4\n  new ZipLong(r2, $i3)\n  ZipLong diskStart\u003e \u003d $r4\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Zip64ExtendedInformationExtraField#parseFromLocalFileData(...3)",
        "body": "{\r\n    if (length \u003d\u003d 0) {\r\n        // no local file data at all, may happen if an archive\r\n        // only holds a ZIP64 extended information extra field\r\n        // inside the central directory but not inside the local\r\n        // file header\r\n        return;\r\n    }\r\n    if (length \u003c 2 * DWORD) {\r\n        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\r\n    }\r\n    size \u003d new ZipEightByteInteger(buffer, offset);\r\n    offset +\u003d DWORD;\r\n    compressedSize \u003d new ZipEightByteInteger(buffer, offset);\r\n    offset +\u003d DWORD;\r\n    int remaining \u003d length - 2 * DWORD;\r\n    if (remaining \u003e\u003d DWORD) {\r\n        relativeHeaderOffset \u003d new ZipEightByteInteger(buffer, offset);\r\n        offset +\u003d DWORD;\r\n        remaining -\u003d DWORD;\r\n    }\r\n    if (remaining \u003e\u003d WORD) {\r\n        diskStart \u003d new ZipLong(buffer, offset);\r\n        // NOSONAR - assignment as documentation\r\n        offset +\u003d WORD;\r\n        // NOSONAR - assignment as documentation\r\n        remaining -\u003d WORD;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "parseFromLocalFileData",
    "signature": "void parseFromLocalFileData(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003d\u003d 0) {\r\n        // no local file data at all, may happen if an archive\r\n        // only holds a ZIP64 extended information extra field\r\n        // inside the central directory but not inside the local\r\n        // file header\r\n        return;\r\n    }\r\n    if (length \u003c 2 * DWORD) {\r\n        throw new ZipException(LFH_MUST_HAVE_BOTH_SIZES_MSG);\r\n    }\r\n    size \u003d new ZipEightByteInteger(buffer, offset);\r\n    offset +\u003d DWORD;\r\n    compressedSize \u003d new ZipEightByteInteger(buffer, offset);\r\n    offset +\u003d DWORD;\r\n    int remaining \u003d length - 2 * DWORD;\r\n    if (remaining \u003e\u003d DWORD) {\r\n        relativeHeaderOffset \u003d new ZipEightByteInteger(buffer, offset);\r\n        offset +\u003d DWORD;\r\n        remaining -\u003d DWORD;\r\n    }\r\n    if (remaining \u003e\u003d WORD) {\r\n        diskStart \u003d new ZipLong(buffer, offset);\r\n        // NOSONAR - assignment as documentation\r\n        offset +\u003d WORD;\r\n        // NOSONAR - assignment as documentation\r\n        remaining -\u003d WORD;\r\n    }\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003e\u003d 16) → B3 | else → B4",
      "B4 : If(i4 \u003c 8) → B5 | else → B6",
      "B6 : If(i4 \u003c 4) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (i0 \u003e\u003d 16) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d ZipException\n  new ZipException(\"Zip64 extended information must contain both size values in the local file header.\")\n  throw $r7\n}",
      "B4 {\n  $r8 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i1)\n  ZipEightByteInteger size\u003e \u003d $r8\n  i2 \u003d i1 + 8\n  $r9 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i2)\n  ZipEightByteInteger compressedSize\u003e \u003d $r9\n  i3 \u003d i2 + 8\n  i4 \u003d i0 - 16\n  if (i4 \u003c 8) goto B5 else B6\n}",
      "B5 {\n  $r10 \u003d ZipEightByteInteger\n  new ZipEightByteInteger(r2, i3)\n  ZipEightByteInteger relativeHeaderOffset\u003e \u003d $r10\n  i3 \u003d i3 + 8\n  $i6 \u003d (int) -8\n  i4 \u003d i4 + $i6\n}",
      "B6 {\n  if (i4 \u003c 4) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d ZipLong\n  new ZipLong(r2, i3)\n  ZipLong diskStart\u003e \u003d $r11\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField",
    "methodName": "reparseCentralDirectoryData",
    "signature": "void reparseCentralDirectoryData(boolean,boolean,boolean,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (rawCentralDirectoryData !\u003d null) {\r\n        final int expectedLength \u003d (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);\r\n        if (rawCentralDirectoryData.length \u003c expectedLength) {\r\n            throw new ZipException(\"Central directory zip64 extended\" + \" information extra field\u0027s length\" + \" doesn\u0027t match central directory\" + \" data.  Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length);\r\n        }\r\n        int offset \u003d 0;\r\n        if (hasUncompressedSize) {\r\n            size \u003d new ZipEightByteInteger(rawCentralDirectoryData, offset);\r\n            offset +\u003d DWORD;\r\n        }\r\n        if (hasCompressedSize) {\r\n            compressedSize \u003d new ZipEightByteInteger(rawCentralDirectoryData, offset);\r\n            offset +\u003d DWORD;\r\n        }\r\n        if (hasRelativeHeaderOffset) {\r\n            relativeHeaderOffset \u003d new ZipEightByteInteger(rawCentralDirectoryData, offset);\r\n            offset +\u003d DWORD;\r\n        }\r\n        if (hasDiskStart) {\r\n            diskStart \u003d new ZipLong(rawCentralDirectoryData, offset);\r\n            // NOSONAR - assignment as documentation\r\n            offset +\u003d WORD;\r\n        }\r\n    }\r\n}",
    "nodes": 24,
    "edges": 32,
    "cc": 10,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B23",
      "B1 : If(z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(z1 \u003d\u003d false) → B5 | else → B6",
      "B7 : If(z2 \u003d\u003d false) → B8 | else → B9",
      "B10 : If(z3 \u003d\u003d false) → B11 | else → B12",
      "B13 : If($i2 \u003e\u003d $i4) → B14 | else → B15",
      "B15 : If(z0 \u003d\u003d false) → B16 | else → B17",
      "B17 : If(z1 \u003d\u003d false) → B18 | else → B19",
      "B19 : If(z2 \u003d\u003d false) → B20 | else → B21",
      "B21 : If(z3 \u003d\u003d false) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  Zip64ExtendedInformationExtraField\n  z0 :\u003d @parameter0: boolean\n  z1 :\u003d @parameter1: boolean\n  z2 :\u003d @parameter2: boolean\n  z3 :\u003d @parameter3: boolean\n  $r1 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B23\n}",
      "B1 {\n  if (z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $b5 \u003d 8\n  goto B4\n}",
      "B3 {\n  $b5 \u003d 0\n}",
      "B4 {\n  if (z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $b6 \u003d 8\n  goto B7\n}",
      "B6 {\n  $b6 \u003d 0\n}",
      "B7 {\n  $i0 \u003d $b5 + $b6\n  if (z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $b7 \u003d 8\n  goto B10\n}",
      "B9 {\n  $b7 \u003d 0\n}",
      "B10 {\n  $i1 \u003d $i0 + $b7\n  if (z3 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $b8 \u003d 4\n  goto B13\n}",
      "B12 {\n  $b8 \u003d 0\n}",
      "B13 {\n  $i4 \u003d $i1 + $b8\n  $r2 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  $i2 \u003d lengthof $r2\n  if ($i2 \u003e\u003d $i4) goto B14 else B15\n}",
      "B14 {\n  $r11 \u003d ZipException\n  $r12 \u003d StringBuilder\n  new StringBuilder()\n  $r13 \u003d $r12.append(\"Central directory zip64 extended information extra field\\\u0027s length doesn\\\u0027t match central directory data.  Expected length \")\n  $r14 \u003d $r13.append($i4)\n  $r16 \u003d $r14.append(\" but is \")\n  $r15 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  $i3 \u003d lengthof $r15\n  $r17 \u003d $r16.append($i3)\n  $r18 \u003d $r17.toString()\n  new ZipException($r18)\n  throw $r11\n}",
      "B15 {\n  i9 \u003d 0\n  b11 \u003d 0\n  b10 \u003d 0\n  if (z0 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r9 \u003d ZipEightByteInteger\n  $r10 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  new ZipEightByteInteger($r10, 0)\n  ZipEightByteInteger size\u003e \u003d $r9\n  i9 \u003d 8\n  b11 \u003d 8\n  b10 \u003d 8\n}",
      "B17 {\n  if (z1 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r7 \u003d ZipEightByteInteger\n  $r8 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  new ZipEightByteInteger($r8, b11)\n  ZipEightByteInteger compressedSize\u003e \u003d $r7\n  i9 \u003d b10 + 8\n}",
      "B19 {\n  if (z2 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r5 \u003d ZipEightByteInteger\n  $r6 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  new ZipEightByteInteger($r6, i9)\n  ZipEightByteInteger relativeHeaderOffset\u003e \u003d $r5\n  i9 \u003d i9 + 8\n}",
      "B21 {\n  if (z3 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $r3 \u003d ZipLong\n  $r4 \u003d Zip64ExtendedInformationExtraField: byte[] rawCentralDirectoryData\u003e\n  new ZipLong($r4, i9)\n  ZipLong diskStart\u003e \u003d $r3\n}",
      "B23 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B23",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "addAsFirstExtraField",
    "signature": "void addAsFirstExtraField(org.apache.commons.compress.archivers.zip.ZipExtraField)",
    "visibility": "public",
    "body": "{\r\n    if (ze instanceof UnparseableExtraFieldData) {\r\n        unparseableExtra \u003d (UnparseableExtraFieldData) ze;\r\n    } else {\r\n        if (getExtraField(ze.getHeaderId()) !\u003d null) {\r\n            internalRemoveExtraField(ze.getHeaderId());\r\n        }\r\n        final ZipExtraField[] copy \u003d extraFields;\r\n        final int newLen \u003d ArrayUtils.getLength(extraFields) + 1;\r\n        extraFields \u003d new ZipExtraField[newLen];\r\n        extraFields[0] \u003d ze;\r\n        if (copy !\u003d null) {\r\n            System.arraycopy(copy, 0, extraFields, 1, extraFields.length - 1);\r\n        }\r\n    }\r\n    setExtra();\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r10 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  ZipExtraField\n  $z0 \u003d UnparseableExtraFieldData\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d UnparseableExtraFieldData) r0\n  UnparseableExtraFieldData unparseableExtra\u003e \u003d $r11\n  goto B6\n}",
      "B2 {\n  $r2 \u003d r0.getHeaderId()\n  $r3 \u003d r1.getExtraField($r2)\n  if ($r3 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r9 \u003d r0.getHeaderId()\n  r1.internalRemoveExtraField($r9)\n}",
      "B4 {\n  $r10 \u003d ZipExtraField[] extraFields\u003e\n  $r4 \u003d ZipExtraField[] extraFields\u003e\n  $i0 \u003d ArrayUtils.getLength($r4)\n  $i3 \u003d $i0 + 1\n  $r5 \u003d ZipExtraField)[$i3]\n  ZipExtraField[] extraFields\u003e \u003d $r5\n  $r6 \u003d ZipExtraField[] extraFields\u003e\n  $r6[0] \u003d r0\n  if ($r10 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r8 \u003d ZipExtraField[] extraFields\u003e\n  $r7 \u003d ZipExtraField[] extraFields\u003e\n  $i1 \u003d lengthof $r7\n  $i2 \u003d $i1 - 1\n  System.arraycopy($r10, 0, $r8, 1, $i2)\n}",
      "B6 {\n  r1.setExtra()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExtra(...0)",
        "body": "{\r\n    // ZipEntry will update the time fields here, so we need to reprocess them afterwards\r\n    super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\r\n    // Reprocess and overwrite the modifications made by ZipEntry#setExtra(byte[])\r\n    updateTimeFieldsFromExtraFields();\r\n}"
      },
      {
        "name": "ZipArchiveEntry#internalRemoveExtraField(...1)",
        "body": "{\r\n    if (extraFields \u003d\u003d null) {\r\n        return;\r\n    }\r\n    final List\u003cZipExtraField\u003e newResult \u003d new ArrayList\u003c\u003e();\r\n    for (final ZipExtraField extraField : extraFields) {\r\n        if (!type.equals(extraField.getHeaderId())) {\r\n            newResult.add(extraField);\r\n        }\r\n    }\r\n    if (extraFields.length \u003d\u003d newResult.size()) {\r\n        return;\r\n    }\r\n    extraFields \u003d newResult.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getExtraField(...1)",
        "body": "{\r\n    if (extraFields !\u003d null) {\r\n        for (final ZipExtraField extraField : extraFields) {\r\n            if (type.equals(extraField.getHeaderId())) {\r\n                return extraField;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ZipArchiveEntry other \u003d (ZipArchiveEntry) obj;\r\n    final String myName \u003d getName();\r\n    final String otherName \u003d other.getName();\r\n    if (!Objects.equals(myName, otherName)) {\r\n        return false;\r\n    }\r\n    String myComment \u003d getComment();\r\n    String otherComment \u003d other.getComment();\r\n    if (myComment \u003d\u003d null) {\r\n        myComment \u003d \"\";\r\n    }\r\n    if (otherComment \u003d\u003d null) {\r\n        otherComment \u003d \"\";\r\n    }\r\n    return Objects.equals(getLastModifiedTime(), other.getLastModifiedTime()) \u0026\u0026 Objects.equals(getLastAccessTime(), other.getLastAccessTime()) \u0026\u0026 Objects.equals(getCreationTime(), other.getCreationTime()) \u0026\u0026 myComment.equals(otherComment) \u0026\u0026 getInternalAttributes() \u003d\u003d other.getInternalAttributes() \u0026\u0026 getPlatform() \u003d\u003d other.getPlatform() \u0026\u0026 getExternalAttributes() \u003d\u003d other.getExternalAttributes() \u0026\u0026 getMethod() \u003d\u003d other.getMethod() \u0026\u0026 getSize() \u003d\u003d other.getSize() \u0026\u0026 getCrc() \u003d\u003d other.getCrc() \u0026\u0026 getCompressedSize() \u003d\u003d other.getCompressedSize() \u0026\u0026 Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) \u0026\u0026 Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) \u0026\u0026 localHeaderOffset \u003d\u003d other.localHeaderOffset \u0026\u0026 dataOffset \u003d\u003d other.dataOffset \u0026\u0026 generalPurposeBit.equals(other.generalPurposeBit);\r\n}",
    "nodes": 30,
    "edges": 48,
    "cc": 20,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 !\u003d 0) → B6 | else → B7",
      "B7 : If(r19 !\u003d null) → B8 | else → B9",
      "B9 : If(r20 !\u003d null) → B10 | else → B11",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B28",
      "B12 : If($z2 \u003d\u003d false) → B13 | else → B28",
      "B13 : If($z3 \u003d\u003d false) → B14 | else → B28",
      "B14 : If($z4 \u003d\u003d false) → B15 | else → B28",
      "B15 : If($i1 !\u003d $i0) → B16 | else → B28",
      "B16 : If($i3 !\u003d $i2) → B17 | else → B28",
      "B17 : If($b6 !\u003d 0) → B18 | else → B28",
      "B18 : If($i8 !\u003d $i7) → B19 | else → B28",
      "B19 : If($b11 !\u003d 0) → B20 | else → B28",
      "B20 : If($b14 !\u003d 0) → B21 | else → B28",
      "B21 : If($b17 !\u003d 0) → B22 | else → B28",
      "B22 : If($z5 \u003d\u003d false) → B23 | else → B28",
      "B23 : If($z6 \u003d\u003d false) → B24 | else → B28",
      "B24 : If($b20 !\u003d 0) → B25 | else → B28",
      "B25 : If($b23 !\u003d 0) → B26 | else → B28",
      "B26 : If($z7 \u003d\u003d false) → B27 | else → B28"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d ZipArchiveEntry) r1\n  r5 \u003d r0.getName()\n  r6 \u003d r4.getName()\n  $z0 \u003d Objects.equals(r5, r6)\n  if ($z0 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  r19 \u003d r0.getComment()\n  r20 \u003d r4.getComment()\n  if (r19 !\u003d null) goto B8 else B9\n}",
      "B8 {\n  r19 \u003d \"\"\n}",
      "B9 {\n  if (r20 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  r20 \u003d \"\"\n}",
      "B11 {\n  $r8 \u003d r0.getLastModifiedTime()\n  $r7 \u003d r4.getLastModifiedTime()\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B12 else B28\n}",
      "B12 {\n  $r10 \u003d r0.getLastAccessTime()\n  $r9 \u003d r4.getLastAccessTime()\n  $z2 \u003d Objects.equals($r10, $r9)\n  if ($z2 \u003d\u003d false) goto B13 else B28\n}",
      "B13 {\n  $r12 \u003d r0.getCreationTime()\n  $r11 \u003d r4.getCreationTime()\n  $z3 \u003d Objects.equals($r12, $r11)\n  if ($z3 \u003d\u003d false) goto B14 else B28\n}",
      "B14 {\n  $z4 \u003d r19.equals(r20)\n  if ($z4 \u003d\u003d false) goto B15 else B28\n}",
      "B15 {\n  $i1 \u003d r0.getInternalAttributes()\n  $i0 \u003d r4.getInternalAttributes()\n  if ($i1 !\u003d $i0) goto B16 else B28\n}",
      "B16 {\n  $i3 \u003d r0.getPlatform()\n  $i2 \u003d r4.getPlatform()\n  if ($i3 !\u003d $i2) goto B17 else B28\n}",
      "B17 {\n  $l5 \u003d r0.getExternalAttributes()\n  $l4 \u003d r4.getExternalAttributes()\n  $b6 \u003d $l5 cmp $l4\n  if ($b6 !\u003d 0) goto B18 else B28\n}",
      "B18 {\n  $i8 \u003d r0.getMethod()\n  $i7 \u003d r4.getMethod()\n  if ($i8 !\u003d $i7) goto B19 else B28\n}",
      "B19 {\n  $l10 \u003d r0.getSize()\n  $l9 \u003d r4.getSize()\n  $b11 \u003d $l10 cmp $l9\n  if ($b11 !\u003d 0) goto B20 else B28\n}",
      "B20 {\n  $l13 \u003d r0.getCrc()\n  $l12 \u003d r4.getCrc()\n  $b14 \u003d $l13 cmp $l12\n  if ($b14 !\u003d 0) goto B21 else B28\n}",
      "B21 {\n  $l16 \u003d r0.getCompressedSize()\n  $l15 \u003d r4.getCompressedSize()\n  $b17 \u003d $l16 cmp $l15\n  if ($b17 !\u003d 0) goto B22 else B28\n}",
      "B22 {\n  $r14 \u003d r0.getCentralDirectoryExtra()\n  $r13 \u003d r4.getCentralDirectoryExtra()\n  $z5 \u003d Arrays.equals($r14, $r13)\n  if ($z5 \u003d\u003d false) goto B23 else B28\n}",
      "B23 {\n  $r16 \u003d r0.getLocalFileDataExtra()\n  $r15 \u003d r4.getLocalFileDataExtra()\n  $z6 \u003d Arrays.equals($r16, $r15)\n  if ($z6 \u003d\u003d false) goto B24 else B28\n}",
      "B24 {\n  $l19 \u003d ZipArchiveEntry: long localHeaderOffset\u003e\n  $l18 \u003d ZipArchiveEntry: long localHeaderOffset\u003e\n  $b20 \u003d $l19 cmp $l18\n  if ($b20 !\u003d 0) goto B25 else B28\n}",
      "B25 {\n  $l22 \u003d ZipArchiveEntry: long dataOffset\u003e\n  $l21 \u003d ZipArchiveEntry: long dataOffset\u003e\n  $b23 \u003d $l22 cmp $l21\n  if ($b23 !\u003d 0) goto B26 else B28\n}",
      "B26 {\n  $r18 \u003d GeneralPurposeBit generalPurposeBit\u003e\n  $r17 \u003d GeneralPurposeBit generalPurposeBit\u003e\n  $z7 \u003d $r18.equals($r17)\n  if ($z7 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  $z8 \u003d 1\n  goto B29\n}",
      "B28 {\n  $z8 \u003d 0\n}",
      "B29 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B28",
      "B12 --\u003e B13",
      "B12 --\u003e B28",
      "B13 --\u003e B14",
      "B13 --\u003e B28",
      "B14 --\u003e B15",
      "B14 --\u003e B28",
      "B15 --\u003e B16",
      "B15 --\u003e B28",
      "B16 --\u003e B17",
      "B16 --\u003e B28",
      "B17 --\u003e B18",
      "B17 --\u003e B28",
      "B18 --\u003e B19",
      "B18 --\u003e B28",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B28",
      "B21 --\u003e B22",
      "B21 --\u003e B28",
      "B22 --\u003e B23",
      "B22 --\u003e B28",
      "B23 --\u003e B24",
      "B23 --\u003e B28",
      "B24 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B26",
      "B25 --\u003e B28",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getExternalAttributes(...0)",
        "body": "{\r\n    return externalAttributes;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getCompressedSize(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getLastAccessTime(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getCreationTime(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getClass(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getName(...0)",
        "body": "{\r\n    return name \u003d\u003d null ? super.getName() : name;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getLastModifiedTime(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getCrc(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getLocalFileDataExtra(...0)",
        "body": "{\r\n    final byte[] extra \u003d getExtra();\r\n    return extra !\u003d null ? extra : ByteUtils.EMPTY_BYTE_ARRAY;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getPlatform(...0)",
        "body": "{\r\n    return platform;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getInternalAttributes(...0)",
        "body": "{\r\n    return internalAttributes;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getSize(...0)",
        "body": "{\r\n    return size;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getComment(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#getCentralDirectoryExtra(...0)",
        "body": "{\r\n    return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getMethod(...0)",
        "body": "{\r\n    return method;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getExtraField",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField getExtraField(org.apache.commons.compress.archivers.zip.ZipShort)",
    "visibility": "public",
    "body": "{\r\n    if (extraFields !\u003d null) {\r\n        for (final ZipExtraField extraField : extraFields) {\r\n            if (type.equals(extraField.getHeaderId())) {\r\n                return extraField;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B6",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B6",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  ZipShort\n  $r1 \u003d ZipExtraField[] extraFields\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  r2 \u003d ZipExtraField[] extraFields\u003e\n  i0 \u003d lengthof r2\n  i1 \u003d 0\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B6\n}",
      "B3 {\n  r3 \u003d r2[i1]\n  $r5 \u003d r3.getHeaderId()\n  $z0 \u003d r4.equals($r5)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  i1 \u003d i1 + 1\n  goto B2\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B2",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getExtraFields",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField[] getExtraFields(boolean)",
    "visibility": "public",
    "body": "{\r\n    return includeUnparseable ? getAllExtraFields() : getParseableExtraFields();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  z0 :\u003d @parameter0: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getAllExtraFields()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getParseableExtraFields()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getAllExtraFields(...0)",
        "body": "{\r\n    final ZipExtraField[] allExtraFieldsNoCopy \u003d getAllExtraFieldsNoCopy();\r\n    return allExtraFieldsNoCopy \u003d\u003d extraFields ? copyOf(allExtraFieldsNoCopy, allExtraFieldsNoCopy.length) : allExtraFieldsNoCopy;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getParseableExtraFields(...0)",
        "body": "{\r\n    final ZipExtraField[] parseableExtraFields \u003d getParseableExtraFieldsNoCopy();\r\n    return parseableExtraFields \u003d\u003d extraFields ? copyOf(parseableExtraFields, parseableExtraFields.length) : parseableExtraFields;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getExtraFields",
    "signature": "org.apache.commons.compress.archivers.zip.ZipExtraField[] getExtraFields(org.apache.commons.compress.archivers.zip.ExtraFieldParsingBehavior)",
    "visibility": "public",
    "body": "{\r\n    if (parsingBehavior \u003d\u003d ExtraFieldParsingMode.BEST_EFFORT) {\r\n        return getExtraFields(true);\r\n    }\r\n    if (parsingBehavior \u003d\u003d ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT) {\r\n        return getExtraFields(false);\r\n    }\r\n    final byte[] local \u003d getExtra();\r\n    final List\u003cZipExtraField\u003e localFields \u003d new ArrayList\u003c\u003e(Arrays.asList(parseExtraFields(local, true, parsingBehavior)));\r\n    final byte[] central \u003d getCentralDirectoryExtra();\r\n    final List\u003cZipExtraField\u003e centralFields \u003d new ArrayList\u003c\u003e(Arrays.asList(parseExtraFields(central, false, parsingBehavior)));\r\n    final List\u003cZipExtraField\u003e merged \u003d new ArrayList\u003c\u003e();\r\n    for (final ZipExtraField l : localFields) {\r\n        final ZipExtraField c;\r\n        if (l instanceof UnparseableExtraFieldData) {\r\n            c \u003d findUnparseable(centralFields);\r\n        } else {\r\n            c \u003d findMatching(l.getHeaderId(), centralFields);\r\n        }\r\n        if (c !\u003d null) {\r\n            final byte[] cd \u003d c.getCentralDirectoryData();\r\n            if (!ArrayUtils.isEmpty(cd)) {\r\n                l.parseFromCentralDirectoryData(cd, 0, cd.length);\r\n            }\r\n            centralFields.remove(c);\r\n        }\r\n        merged.add(l);\r\n    }\r\n    merged.addAll(centralFields);\r\n    return merged.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d $r2) → B3 | else → B4",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B14",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B9 : If(r23 \u003d\u003d null) → B10 | else → B13",
      "B10 : If($z2 !\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  ExtraFieldParsingBehavior\n  $r1 \u003d ZipArchiveEntry$ExtraFieldParsingMode BEST_EFFORT\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r22 \u003d r3.getExtraFields(1)\n  return\n}",
      "B2 {\n  $r2 \u003d ZipArchiveEntry$ExtraFieldParsingMode ONLY_PARSEABLE_LENIENT\u003e\n  if (r0 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r21 \u003d r3.getExtraFields(0)\n  return\n}",
      "B4 {\n  r4 \u003d r3.getExtra()\n  $r5 \u003d ArrayList\n  $r6 \u003d r3.parseExtraFields(r4, 1, r0)\n  $r7 \u003d Arrays.asList($r6)\n  new ArrayList($r7)\n  r8 \u003d r3.getCentralDirectoryExtra()\n  $r9 \u003d ArrayList\n  $r10 \u003d r3.parseExtraFields(r8, 0, r0)\n  $r11 \u003d Arrays.asList($r10)\n  new ArrayList($r11)\n  $r12 \u003d ArrayList\n  new ArrayList()\n  r13 \u003d $r5.iterator()\n}",
      "B5 {\n  $z0 \u003d r13.hasNext()\n  if ($z0 \u003d\u003d false) goto B6 else B14\n}",
      "B6 {\n  $r17 \u003d r13.next()\n  r18 \u003d ZipExtraField) $r17\n  $z1 \u003d UnparseableExtraFieldData\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  r23 \u003d r3.findUnparseable($r9)\n  goto B9\n}",
      "B8 {\n  $r19 \u003d r18.getHeaderId()\n  r23 \u003d r3.findMatching($r19, $r9)\n}",
      "B9 {\n  if (r23 \u003d\u003d null) goto B10 else B13\n}",
      "B10 {\n  r20 \u003d r23.getCentralDirectoryData()\n  $z2 \u003d ArrayUtils.isEmpty(r20)\n  if ($z2 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $i0 \u003d lengthof r20\n  r18.parseFromCentralDirectoryData(r20, 0, $i0)\n}",
      "B12 {\n  $r9.remove(r23)\n}",
      "B13 {\n  $r12.add(r18)\n  goto B5\n}",
      "B14 {\n  $r12.addAll($r9)\n  $r14 \u003d ZipExtraField[] EMPTY_ZIP_EXTRA_FIELD_ARRAY\u003e\n  $r15 \u003d $r12.toArray($r14)\n  $r16 \u003d ZipExtraField[]) $r15\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B14",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B13 --\u003e B5",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getExtra(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveEntry#findMatching(...2)",
        "body": "{\r\n    return fs.stream().filter(f -\u003e headerId.equals(f.getHeaderId())).findFirst().orElse(null);\r\n}"
      },
      {
        "name": "ZipArchiveEntry#parseExtraFields(...3)",
        "body": "{\r\n    if (extraFieldFactory !\u003d null) {\r\n        return ExtraFieldUtils.parse(data, local, new ExtraFieldParsingBehavior() {\r\n\r\n            @Override\r\n            public ZipExtraField createExtraField(final ZipShort headerId) throws ZipException, InstantiationException, IllegalAccessException {\r\n                final ZipExtraField field \u003d extraFieldFactory.apply(headerId);\r\n                return field \u003d\u003d null ? parsingBehavior.createExtraField(headerId) : field;\r\n            }\r\n\r\n            @Override\r\n            public ZipExtraField fill(final ZipExtraField field, final byte[] data, final int off, final int len, final boolean local) throws ZipException {\r\n                return parsingBehavior.fill(field, data, off, len, local);\r\n            }\r\n\r\n            @Override\r\n            public ZipExtraField onUnparseableExtraField(final byte[] data, final int off, final int len, final boolean local, final int claimedLength) throws ZipException {\r\n                return parsingBehavior.onUnparseableExtraField(data, off, len, local, claimedLength);\r\n            }\r\n        });\r\n    }\r\n    return ExtraFieldUtils.parse(data, local, parsingBehavior);\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getCentralDirectoryExtra(...0)",
        "body": "{\r\n    return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getExtraFields(...1)",
        "body": "{\r\n    return includeUnparseable ? getAllExtraFields() : getParseableExtraFields();\r\n}"
      },
      {
        "name": "ZipArchiveEntry#findUnparseable(...1)",
        "body": "{\r\n    return fs.stream().filter(UnparseableExtraFieldData.class::isInstance).findFirst().orElse(null);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getLocalFileDataExtra",
    "signature": "byte[] getLocalFileDataExtra()",
    "visibility": "public",
    "body": "{\r\n    final byte[] extra \u003d getExtra();\r\n    return extra !\u003d null ? extra : ByteUtils.EMPTY_BYTE_ARRAY;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  r1 \u003d r0.getExtra()\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d ByteUtils: byte[] EMPTY_BYTE_ARRAY\u003e\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getExtra(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getName",
    "signature": "java.lang.String getName()",
    "visibility": "public",
    "body": "{\r\n    return name \u003d\u003d null ? super.getName() : name;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $r1 \u003d String name\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getName()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d String name\u003e\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getRawName",
    "signature": "byte[] getRawName()",
    "visibility": "public",
    "body": "{\r\n    if (rawName !\u003d null) {\r\n        return Arrays.copyOf(rawName, rawName.length);\r\n    }\r\n    return null;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $r1 \u003d ZipArchiveEntry: byte[] rawName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ZipArchiveEntry: byte[] rawName\u003e\n  $r2 \u003d ZipArchiveEntry: byte[] rawName\u003e\n  $i0 \u003d lengthof $r2\n  $r4 \u003d Arrays.copyOf($r3, $i0)\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getTime",
    "signature": "long getTime()",
    "visibility": "public",
    "body": "{\r\n    if (lastModifiedDateSet) {\r\n        return getLastModifiedTime().toMillis();\r\n    }\r\n    return time !\u003d -1 ? time : super.getTime();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($b1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $z0 \u003d ZipArchiveEntry: boolean lastModifiedDateSet\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getLastModifiedTime()\n  $l2 \u003d $r1.toMillis()\n  return\n}",
      "B2 {\n  $l0 \u003d ZipArchiveEntry: long time\u003e\n  $b1 \u003d $l0 cmp -1L\n  if ($b1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $l3 \u003d ZipArchiveEntry: long time\u003e\n  goto B5\n}",
      "B4 {\n  $l3 \u003d r0.getTime()\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getLastModifiedTime(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "getUnixMode",
    "signature": "int getUnixMode()",
    "visibility": "public",
    "body": "{\r\n    return platform !\u003d PLATFORM_UNIX ? 0 : (int) (getExternalAttributes() \u003e\u003e SHORT_SHIFT \u0026 SHORT_MASK);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $i0 \u003d ZipArchiveEntry: int platform\u003e\n  if ($i0 \u003d\u003d 3) goto B1 else B2\n}",
      "B1 {\n  $i4 \u003d 0\n  goto B3\n}",
      "B2 {\n  $l1 \u003d r0.getExternalAttributes()\n  $l2 \u003d $l1 \u003e\u003e 16\n  $l3 \u003d $l2 \u0026 65535L\n  $i4 \u003d (int) $l3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getExternalAttributes(...0)",
        "body": "{\r\n    return externalAttributes;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "isUnixSymlink",
    "signature": "boolean isUnixSymlink()",
    "visibility": "public",
    "body": "{\r\n    return (getUnixMode() \u0026 UnixStat.FILE_TYPE_FLAG) \u003d\u003d UnixStat.LINK_FLAG;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $i0 \u003d r0.getUnixMode()\n  $i3 \u003d (int) 61440\n  $i1 \u003d $i0 \u0026 $i3\n  $i5 \u003d (int) 40960\n  if ($i1 !\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#getUnixMode(...0)",
        "body": "{\r\n    return platform !\u003d PLATFORM_UNIX ? 0 : (int) (getExternalAttributes() \u003e\u003e SHORT_SHIFT \u0026 SHORT_MASK);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "removeExtraField",
    "signature": "void removeExtraField(org.apache.commons.compress.archivers.zip.ZipShort)",
    "visibility": "public",
    "body": "{\r\n    if (getExtraField(type) \u003d\u003d null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    internalRemoveExtraField(type);\r\n    setExtra();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  ZipShort\n  $r2 \u003d r0.getExtraField(r1)\n  if ($r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d NoSuchElementException\n  new NoSuchElementException()\n  throw $r3\n}",
      "B2 {\n  r0.internalRemoveExtraField(r1)\n  r0.setExtra()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExtra(...0)",
        "body": "{\r\n    // ZipEntry will update the time fields here, so we need to reprocess them afterwards\r\n    super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\r\n    // Reprocess and overwrite the modifications made by ZipEntry#setExtra(byte[])\r\n    updateTimeFieldsFromExtraFields();\r\n}"
      },
      {
        "name": "ZipArchiveEntry#internalRemoveExtraField(...1)",
        "body": "{\r\n    if (extraFields \u003d\u003d null) {\r\n        return;\r\n    }\r\n    final List\u003cZipExtraField\u003e newResult \u003d new ArrayList\u003c\u003e();\r\n    for (final ZipExtraField extraField : extraFields) {\r\n        if (!type.equals(extraField.getHeaderId())) {\r\n            newResult.add(extraField);\r\n        }\r\n    }\r\n    if (extraFields.length \u003d\u003d newResult.size()) {\r\n        return;\r\n    }\r\n    extraFields \u003d newResult.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\r\n}"
      },
      {
        "name": "ZipArchiveEntry#getExtraField(...1)",
        "body": "{\r\n    if (extraFields !\u003d null) {\r\n        for (final ZipExtraField extraField : extraFields) {\r\n            if (type.equals(extraField.getHeaderId())) {\r\n                return extraField;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "removeUnparseableExtraFieldData",
    "signature": "void removeUnparseableExtraFieldData()",
    "visibility": "public",
    "body": "{\r\n    if (unparseableExtra \u003d\u003d null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    unparseableExtra \u003d null;\r\n    setExtra();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  $r1 \u003d UnparseableExtraFieldData unparseableExtra\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NoSuchElementException\n  new NoSuchElementException()\n  throw $r2\n}",
      "B2 {\n  UnparseableExtraFieldData unparseableExtra\u003e \u003d null\n  r0.setExtra()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExtra(...0)",
        "body": "{\r\n    // ZipEntry will update the time fields here, so we need to reprocess them afterwards\r\n    super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\r\n    // Reprocess and overwrite the modifications made by ZipEntry#setExtra(byte[])\r\n    updateTimeFieldsFromExtraFields();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setAlignment",
    "signature": "void setAlignment(int)",
    "visibility": "public",
    "body": "{\r\n    if ((alignment \u0026 alignment - 1) !\u003d 0 || alignment \u003e 0xffff) {\r\n        throw new IllegalArgumentException(\"Invalid value for alignment, must be power of two and no bigger than \" + 0xffff + \" but is \" + alignment);\r\n    }\r\n    this.alignment \u003d alignment;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 !\u003d 0) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d $i4) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  i0 :\u003d @parameter0: int\n  $i1 \u003d i0 - 1\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i4 \u003d (int) 65535\n  if (i0 \u003c\u003d $i4) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r6.append(\"Invalid value for alignment, must be power of two and no bigger than 65535 but is \")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IllegalArgumentException($r4)\n  throw $r7\n}",
      "B3 {\n  ZipArchiveEntry: int alignment\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setExtraFields",
    "signature": "void setExtraFields(org.apache.commons.compress.archivers.zip.ZipExtraField[])",
    "visibility": "public",
    "body": "{\r\n    unparseableExtra \u003d null;\r\n    final List\u003cZipExtraField\u003e newFields \u003d new ArrayList\u003c\u003e();\r\n    if (fields !\u003d null) {\r\n        for (final ZipExtraField field : fields) {\r\n            if (field instanceof UnparseableExtraFieldData) {\r\n                unparseableExtra \u003d (UnparseableExtraFieldData) field;\r\n            } else {\r\n                newFields.add(field);\r\n            }\r\n        }\r\n    }\r\n    extraFields \u003d newFields.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);\r\n    setExtra();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B7",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B7",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  ZipExtraField[]\n  UnparseableExtraFieldData unparseableExtra\u003e \u003d null\n  $r1 \u003d ArrayList\n  new ArrayList()\n  if (r2 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  i0 \u003d lengthof r2\n  i1 \u003d 0\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B7\n}",
      "B3 {\n  r6 \u003d r2[i1]\n  $z0 \u003d UnparseableExtraFieldData\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r7 \u003d UnparseableExtraFieldData) r6\n  UnparseableExtraFieldData unparseableExtra\u003e \u003d $r7\n  goto B6\n}",
      "B5 {\n  $r1.add(r6)\n}",
      "B6 {\n  i1 \u003d i1 + 1\n  goto B2\n}",
      "B7 {\n  $r3 \u003d ZipExtraField[] EMPTY_ZIP_EXTRA_FIELD_ARRAY\u003e\n  $r4 \u003d $r1.toArray($r3)\n  $r5 \u003d ZipExtraField[]) $r4\n  ZipExtraField[] extraFields\u003e \u003d $r5\n  r0.setExtra()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExtra(...0)",
        "body": "{\r\n    // ZipEntry will update the time fields here, so we need to reprocess them afterwards\r\n    super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\r\n    // Reprocess and overwrite the modifications made by ZipEntry#setExtra(byte[])\r\n    updateTimeFieldsFromExtraFields();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setMethod",
    "signature": "void setMethod(int)",
    "visibility": "public",
    "body": "{\r\n    if (method \u003c 0) {\r\n        throw new IllegalArgumentException(\"ZIP compression method cannot be negative: \" + method);\r\n    }\r\n    this.method \u003d method;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r2.append(\"ZIP compression method cannot be negative: \")\n  $r4 \u003d $r3.append(i0)\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r1\n}",
      "B2 {\n  ZipArchiveEntry: int method\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setSize",
    "signature": "void setSize(long)",
    "visibility": "public",
    "body": "{\r\n    if (size \u003c 0) {\r\n        throw new IllegalArgumentException(\"Invalid entry size\");\r\n    }\r\n    this.size \u003d size;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Invalid entry size\")\n  throw $r2\n}",
      "B2 {\n  ZipArchiveEntry: long size\u003e \u003d l0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setTime",
    "signature": "void setTime(long)",
    "visibility": "public",
    "body": "{\r\n    if (ZipUtil.isDosTime(timeEpochMillis)) {\r\n        super.setTime(timeEpochMillis);\r\n        this.time \u003d timeEpochMillis;\r\n        lastModifiedDateSet \u003d false;\r\n        setExtraTimeFields();\r\n    } else {\r\n        setLastModifiedTime(FileTime.fromMillis(timeEpochMillis));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  l0 :\u003d @parameter0: long\n  $z0 \u003d ZipUtil.isDosTime(l0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.setTime(l0)\n  ZipArchiveEntry: long time\u003e \u003d l0\n  ZipArchiveEntry: boolean lastModifiedDateSet\u003e \u003d 0\n  r0.setExtraTimeFields()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d FileTime.fromMillis(l0)\n  r0.setLastModifiedTime($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExtraTimeFields(...0)",
        "body": "{\r\n    if (getExtraField(X5455_ExtendedTimestamp.HEADER_ID) !\u003d null) {\r\n        internalRemoveExtraField(X5455_ExtendedTimestamp.HEADER_ID);\r\n    }\r\n    if (getExtraField(X000A_NTFS.HEADER_ID) !\u003d null) {\r\n        internalRemoveExtraField(X000A_NTFS.HEADER_ID);\r\n    }\r\n    if (requiresExtraTimeFields()) {\r\n        final FileTime lastModifiedTime \u003d getLastModifiedTime();\r\n        final FileTime lastAccessTime \u003d getLastAccessTime();\r\n        final FileTime creationTime \u003d getCreationTime();\r\n        if (canConvertToInfoZipExtendedTimestamp(lastModifiedTime, lastAccessTime, creationTime)) {\r\n            addInfoZipExtendedTimestamp(lastModifiedTime, lastAccessTime, creationTime);\r\n        }\r\n        addNTFSTimestamp(lastModifiedTime, lastAccessTime, creationTime);\r\n    }\r\n    setExtra();\r\n}"
      },
      {
        "name": "ZipArchiveEntry#setLastModifiedTime(...1)",
        "body": "{\r\n    internalSetLastModifiedTime(fileTime);\r\n    setExtraTimeFields();\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry",
    "methodName": "setUnixMode",
    "signature": "void setUnixMode(int)",
    "visibility": "public",
    "body": "{\r\n    // CheckStyle:MagicNumberCheck OFF - no point\r\n    setExternalAttributes(mode \u003c\u003c SHORT_SHIFT | // MS-DOS read-only attribute\r\n    ((mode \u0026 0200) \u003d\u003d 0 ? 1 : 0) | // MS-DOS directory flag\r\n    (isDirectory() ? 0x10 : 0));\r\n    // CheckStyle:MagicNumberCheck ON\r\n    platform \u003d PLATFORM_UNIX;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 !\u003d 0) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveEntry\n  i0 :\u003d @parameter0: int\n  $i2 \u003d i0 \u003c\u003c 16\n  $i1 \u003d i0 \u0026 128\n  if ($i1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  $i3 \u003d $i2 | $z1\n  $z0 \u003d r0.isDirectory()\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $b6 \u003d 16\n  goto B6\n}",
      "B5 {\n  $b6 \u003d 0\n}",
      "B6 {\n  $i4 \u003d $i3 | $b6\n  $l5 \u003d (long) $i4\n  r0.setExternalAttributes($l5)\n  ZipArchiveEntry: int platform\u003e \u003d 3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveEntry#setExternalAttributes(...1)",
        "body": "{\r\n    externalAttributes \u003d value;\r\n}"
      },
      {
        "name": "ZipArchiveEntry#isDirectory(...0)",
        "body": "{\r\n    return isDirectoryEntryName(getName());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c ZipArchiveOutputStream.LFH_SIG.length) {\r\n        return false;\r\n    }\r\n    return // normal file\r\n    checkSig(ZipArchiveOutputStream.LFH_SIG, signature) || // empty zip\r\n    checkSig(ZipArchiveOutputStream.EOCD_SIG, signature) || // split zip\r\n    checkSig(ZipArchiveOutputStream.DD_SIG, signature) || checkSig(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes(), signature);\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B6",
      "B3 : If($z1 !\u003d 0) → B4 | else → B6",
      "B4 : If($z2 !\u003d 0) → B5 | else → B6",
      "B5 : If($z3 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d ZipArchiveOutputStream: byte[] LFH_SIG\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d ZipArchiveOutputStream: byte[] LFH_SIG\u003e\n  $z0 \u003d ZipArchiveInputStream.checkSig($r2, r1)\n  if ($z0 !\u003d 0) goto B3 else B6\n}",
      "B3 {\n  $r3 \u003d ZipArchiveOutputStream: byte[] EOCD_SIG\u003e\n  $z1 \u003d ZipArchiveInputStream.checkSig($r3, r1)\n  if ($z1 !\u003d 0) goto B4 else B6\n}",
      "B4 {\n  $r4 \u003d ZipArchiveOutputStream: byte[] DD_SIG\u003e\n  $z2 \u003d ZipArchiveInputStream.checkSig($r4, r1)\n  if ($z2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r5 \u003d ZipLong SINGLE_SEGMENT_SPLIT_MARKER\u003e\n  $r6 \u003d $r5.getBytes()\n  $z3 \u003d ZipArchiveInputStream.checkSig($r6, r1)\n  if ($z3 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z4 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z4 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#checkSig(...2)",
        "body": "{\r\n    for (int i \u003d 0; i \u003c expected.length; i++) {\r\n        if (signature[i] !\u003d expected[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "canReadEntryData",
    "signature": "boolean canReadEntryData(org.apache.commons.compress.archivers.ArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    if (ae instanceof ZipArchiveEntry) {\r\n        final ZipArchiveEntry ze \u003d (ZipArchiveEntry) ae;\r\n        return ZipUtil.canHandleEntryData(ze) \u0026\u0026 supportsDataDescriptorFor(ze) \u0026\u0026 supportsCompressedSizeFor(ze);\r\n    }\r\n    return false;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B7",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z3 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  ArchiveEntry\n  $z0 \u003d ZipArchiveEntry\n  if ($z0 \u003d\u003d false) goto B1 else B7\n}",
      "B1 {\n  r1 \u003d ZipArchiveEntry) r0\n  $z1 \u003d ZipUtil.canHandleEntryData(r1)\n  if ($z1 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $z2 \u003d r2.supportsDataDescriptorFor(r1)\n  if ($z2 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $z3 \u003d r2.supportsCompressedSizeFor(r1)\n  if ($z3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z4 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z4 \u003d 0\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#supportsDataDescriptorFor(...1)",
        "body": "{\r\n    final int method \u003d entry.getMethod();\r\n    return !entry.getGeneralPurposeBit().usesDataDescriptor() || allowStoredEntriesWithDataDescriptor \u0026\u0026 method \u003d\u003d ZipEntry.STORED || method \u003d\u003d ZipEntry.DEFLATED || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode();\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#supportsCompressedSizeFor(...1)",
        "body": "{\r\n    final int method \u003d entry.getMethod();\r\n    return entry.getCompressedSize() !\u003d ArchiveEntry.SIZE_UNKNOWN || method \u003d\u003d ZipEntry.DEFLATED || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || entry.getGeneralPurposeBit().usesDataDescriptor() \u0026\u0026 allowStoredEntriesWithDataDescriptor \u0026\u0026 method \u003d\u003d ZipEntry.STORED || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!closed) {\r\n        closed \u003d true;\r\n        try {\r\n            in.close();\r\n        } finally {\r\n            inf.end();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  $z0 \u003d ZipArchiveInputStream: boolean closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  ZipArchiveInputStream: boolean closed\u003e \u003d 1\n  $r1 \u003d InputStream in\u003e\n  $r1.close()\n  $r2 \u003d Inflater inf\u003e\n  $r2.end()\n  goto B3\n}",
      "B2 {\n  $r3 :\u003d @caughtexception\n  $r4 \u003d Inflater inf\u003e\n  $r4.end()\n  throw $r3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "getCompressedCount",
    "signature": "long getCompressedCount()",
    "visibility": "public",
    "body": "{\r\n    if (current \u003d\u003d null) {\r\n        return -1;\r\n    }\r\n    final int method \u003d current.entry.getMethod();\r\n    if (method \u003d\u003d ZipArchiveOutputStream.STORED) {\r\n        return current.bytesRead;\r\n    }\r\n    if (method \u003d\u003d ZipArchiveOutputStream.DEFLATED) {\r\n        return getBytesInflated();\r\n    }\r\n    if (method \u003d\u003d ZipMethod.UNSHRINKING.getCode() || method \u003d\u003d ZipMethod.IMPLODING.getCode() || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || method \u003d\u003d ZipMethod.BZIP2.getCode()) {\r\n        return ((InputStreamStatistics) current.checkInputStream()).getCompressedCount();\r\n    }\r\n    return -1;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 0) → B3 | else → B4",
      "B4 : If(i0 !\u003d 8) → B5 | else → B6",
      "B6 : If(i0 \u003d\u003d $i1) → B7 | else → B10",
      "B7 : If(i0 \u003d\u003d $i2) → B8 | else → B10",
      "B8 : If(i0 \u003d\u003d $i3) → B9 | else → B10",
      "B9 : If(i0 !\u003d $i4) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  $r1 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r3 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r2)\n  i0 \u003d $r3.getMethod()\n  if (i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $l6 \u003d ZipArchiveInputStream$CurrentEntry.access$400($r8)\n  return\n}",
      "B4 {\n  if (i0 !\u003d 8) goto B5 else B6\n}",
      "B5 {\n  $l5 \u003d r0.getBytesInflated()\n  return\n}",
      "B6 {\n  $r4 \u003d ZipMethod UNSHRINKING\u003e\n  $i1 \u003d $r4.getCode()\n  if (i0 \u003d\u003d $i1) goto B7 else B10\n}",
      "B7 {\n  $r5 \u003d ZipMethod IMPLODING\u003e\n  $i2 \u003d $r5.getCode()\n  if (i0 \u003d\u003d $i2) goto B8 else B10\n}",
      "B8 {\n  $r6 \u003d ZipMethod ENHANCED_DEFLATED\u003e\n  $i3 \u003d $r6.getCode()\n  if (i0 \u003d\u003d $i3) goto B9 else B10\n}",
      "B9 {\n  $r7 \u003d ZipMethod BZIP2\u003e\n  $i4 \u003d $r7.getCode()\n  if (i0 !\u003d $i4) goto B10 else B11\n}",
      "B10 {\n  $r9 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r10 \u003d ZipArchiveInputStream$CurrentEntry.access$600($r9)\n  $r11 \u003d InputStreamStatistics) $r10\n  $l7 \u003d $r11.getCompressedCount()\n  return\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#getBytesInflated(...0)",
        "body": "{\r\n    long inB \u003d inf.getBytesRead();\r\n    if (current.bytesReadFromStream \u003e\u003d TWO_EXP_32) {\r\n        while (inB + TWO_EXP_32 \u003c\u003d current.bytesReadFromStream) {\r\n            inB +\u003d TWO_EXP_32;\r\n        }\r\n    }\r\n    return inB;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "getNextZipEntry",
    "signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry getNextZipEntry()",
    "visibility": "public",
    "body": "{\r\n    uncompressedCount \u003d 0;\r\n    boolean firstEntry \u003d true;\r\n    if (closed || hitCentralDirectory) {\r\n        return null;\r\n    }\r\n    if (current !\u003d null) {\r\n        closeEntry();\r\n        firstEntry \u003d false;\r\n    }\r\n    final long currentHeaderOffset \u003d getBytesRead();\r\n    try {\r\n        if (firstEntry) {\r\n            // split archives have a special signature before the\r\n            // first local file header - look for it and fail with\r\n            // the appropriate error message if this is a split\r\n            // archive.\r\n            if (!readFirstLocalFileHeader()) {\r\n                hitCentralDirectory \u003d true;\r\n                skipRemainderOfArchive();\r\n                return null;\r\n            }\r\n        } else {\r\n            readFully(lfhBuf);\r\n        }\r\n    } catch (final EOFException e) {\r\n        // NOSONAR\r\n        return null;\r\n    }\r\n    final ZipLong sig \u003d new ZipLong(lfhBuf);\r\n    if (!sig.equals(ZipLong.LFH_SIG)) {\r\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(lfhBuf)) {\r\n            hitCentralDirectory \u003d true;\r\n            skipRemainderOfArchive();\r\n            return null;\r\n        }\r\n        throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", sig.getValue()));\r\n    }\r\n    // off: go past the signature\r\n    int off \u003d WORD;\r\n    current \u003d new CurrentEntry();\r\n    // get version\r\n    final int versionMadeBy \u003d ZipShort.getValue(lfhBuf, off);\r\n    off +\u003d SHORT;\r\n    current.entry.setPlatform(ZipFile.toPlatform(versionMadeBy));\r\n    final GeneralPurposeBit gpFlag \u003d GeneralPurposeBit.parse(lfhBuf, off);\r\n    final boolean hasUTF8Flag \u003d gpFlag.usesUTF8ForNames();\r\n    final ZipEncoding entryEncoding \u003d hasUTF8Flag ? ZipEncodingHelper.ZIP_ENCODING_UTF_8 : zipEncoding;\r\n    current.hasDataDescriptor \u003d gpFlag.usesDataDescriptor();\r\n    current.entry.setGeneralPurposeBit(gpFlag);\r\n    off +\u003d SHORT;\r\n    current.entry.setMethod(ZipShort.getValue(lfhBuf, off));\r\n    off +\u003d SHORT;\r\n    final long time \u003d ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));\r\n    current.entry.setTime(time);\r\n    off +\u003d WORD;\r\n    ZipLong size \u003d null;\r\n    ZipLong cSize \u003d null;\r\n    if (!current.hasDataDescriptor) {\r\n        current.entry.setCrc(ZipLong.getValue(lfhBuf, off));\r\n        off +\u003d WORD;\r\n        cSize \u003d new ZipLong(lfhBuf, off);\r\n        off +\u003d WORD;\r\n        size \u003d new ZipLong(lfhBuf, off);\r\n        off +\u003d WORD;\r\n    } else {\r\n        off +\u003d 3 * WORD;\r\n    }\r\n    final int fileNameLen \u003d ZipShort.getValue(lfhBuf, off);\r\n    off +\u003d SHORT;\r\n    final int extraLen \u003d ZipShort.getValue(lfhBuf, off);\r\n    // NOSONAR - assignment as documentation\r\n    off +\u003d SHORT;\r\n    final byte[] fileName \u003d readRange(fileNameLen);\r\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\r\n    if (hasUTF8Flag) {\r\n        current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\r\n    }\r\n    final byte[] extraData \u003d readRange(extraLen);\r\n    try {\r\n        current.entry.setExtra(extraData);\r\n    } catch (final RuntimeException ex) {\r\n        throw ZipUtil.newZipException(\"Invalid extra data in entry \" + current.entry.getName(), ex);\r\n    }\r\n    if (!hasUTF8Flag \u0026\u0026 useUnicodeExtraFields) {\r\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\r\n    }\r\n    processZip64Extra(size, cSize);\r\n    current.entry.setLocalHeaderOffset(currentHeaderOffset);\r\n    current.entry.setDataOffset(getBytesRead());\r\n    current.entry.setStreamContiguous(true);\r\n    final ZipMethod m \u003d ZipMethod.getMethodByCode(current.entry.getMethod());\r\n    if (current.entry.getCompressedSize() !\u003d ArchiveEntry.SIZE_UNKNOWN) {\r\n        if (ZipUtil.canHandleEntryData(current.entry) \u0026\u0026 m !\u003d ZipMethod.STORED \u0026\u0026 m !\u003d ZipMethod.DEFLATED) {\r\n            final InputStream bis \u003d new BoundCountInputStream(in, current.entry.getCompressedSize());\r\n            switch(m) {\r\n                case UNSHRINKING:\r\n                    current.inputStream \u003d new UnshrinkingInputStream(bis);\r\n                    break;\r\n                case IMPLODING:\r\n                    try {\r\n                        current.inputStream \u003d new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);\r\n                    } catch (final IllegalArgumentException ex) {\r\n                        throw new IOException(\"bad IMPLODE data\", ex);\r\n                    }\r\n                    break;\r\n                case BZIP2:\r\n                    current.inputStream \u003d new BZip2CompressorInputStream(bis);\r\n                    break;\r\n                case ENHANCED_DEFLATED:\r\n                    current.inputStream \u003d new Deflate64CompressorInputStream(bis);\r\n                    break;\r\n                case ZSTD:\r\n                case ZSTD_DEPRECATED:\r\n                    current.inputStream \u003d createZstdInputStream(bis);\r\n                    break;\r\n                default:\r\n                    // we should never get here as all supported methods have been covered\r\n                    // will cause an error when read is invoked, don\u0027t throw an exception here so people can\r\n                    // skip unsupported entries\r\n                    break;\r\n            }\r\n        }\r\n    } else if (m \u003d\u003d ZipMethod.ENHANCED_DEFLATED) {\r\n        current.inputStream \u003d new Deflate64CompressorInputStream(in);\r\n    }\r\n    entriesRead++;\r\n    return current.entry;\r\n}",
    "nodes": 44,
    "edges": 60,
    "cc": 18,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($r1 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(z12 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z11 !\u003d 0) → B7 | else → B9",
      "B11 : If($z2 !\u003d 0) → B12 | else → B17",
      "B12 : If($z8 !\u003d 0) → B13 | else → B15",
      "B13 : If($z9 !\u003d 0) → B14 | else → B15",
      "B14 : If($z10 \u003d\u003d false) → B15 | else → B16",
      "B17 : If(z3 \u003d\u003d false) → B18 | else → B19",
      "B20 : If($z5 !\u003d 0) → B21 | else → B22",
      "B22 : If(z3 \u003d\u003d false) → B23 | else → B24",
      "B26 : If(z3 !\u003d 0) → B27 | else → B29",
      "B27 : If($z7 \u003d\u003d false) → B28 | else → B29",
      "B29 : If($b19 \u003d\u003d false) → B30 | else → B41",
      "B30 : If($z6 \u003d\u003d false) → B31 | else → B43",
      "B31 : If($r103 \u003d\u003d $r36) → B32 | else → B43",
      "B32 : If($r103 \u003d\u003d $r37) → B33 | else → B43",
      "B33 : If(switch-on $i6) → B34 | else → B35",
      "B41 : If($r103 !\u003d $r30) → B42 | else → B43"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  ZipArchiveInputStream: long uncompressedCount\u003e \u003d 0L\n  z12 \u003d 1\n  $z0 \u003d ZipArchiveInputStream: boolean closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d ZipArchiveInputStream: boolean hitCentralDirectory\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  if ($r1 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r0.closeEntry()\n  z12 \u003d 0\n}",
      "B5 {\n  $l14 \u003d r0.getBytesRead()\n  if (z12 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $z11 \u003d r0.readFirstLocalFileHeader()\n  if ($z11 !\u003d 0) goto B7 else B9\n}",
      "B7 {\n  ZipArchiveInputStream: boolean hitCentralDirectory\u003e \u003d 1\n  r0.skipRemainderOfArchive()\n  return\n}",
      "B8 {\n  $r2 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  r0.readFully($r2)\n}",
      "B9 {\n  goto B11\n}",
      "B10 {\n  $r91 :\u003d @caughtexception\n  return\n}",
      "B11 {\n  $r3 \u003d ZipLong\n  $r4 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  new ZipLong($r4)\n  $r5 \u003d ZipLong LFH_SIG\u003e\n  $z2 \u003d $r3.equals($r5)\n  if ($z2 !\u003d 0) goto B12 else B17\n}",
      "B12 {\n  $r73 \u003d ZipLong CFH_SIG\u003e\n  $z8 \u003d $r3.equals($r73)\n  if ($z8 !\u003d 0) goto B13 else B15\n}",
      "B13 {\n  $r74 \u003d ZipLong AED_SIG\u003e\n  $z9 \u003d $r3.equals($r74)\n  if ($z9 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r75 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $z10 \u003d r0.isApkSigningBlock($r75)\n  if ($z10 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  ZipArchiveInputStream: boolean hitCentralDirectory\u003e \u003d 1\n  r0.skipRemainderOfArchive()\n  return\n}",
      "B16 {\n  $r76 \u003d ZipException\n  $r77 \u003d Object)[1]\n  $l13 \u003d $r3.getValue()\n  $r78 \u003d Long.valueOf($l13)\n  $r77[0] \u003d $r78\n  $r79 \u003d String.format(\"Unexpected record signature: 0x%x\", $r77)\n  new ZipException($r79)\n  throw $r76\n}",
      "B17 {\n  $r6 \u003d ZipArchiveInputStream$CurrentEntry\n  new ZipArchiveInputStream$CurrentEntry(null)\n  ZipArchiveInputStream$CurrentEntry current\u003e \u003d $r6\n  $r7 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  i0 \u003d ZipShort.getValue($r7, 4)\n  $r8 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r9 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r8)\n  $i1 \u003d ZipFile.toPlatform(i0)\n  $r9.setPlatform($i1)\n  $r10 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  r11 \u003d GeneralPurposeBit.parse($r10, 6)\n  z3 \u003d r11.usesUTF8ForNames()\n  if (z3 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r92 \u003d ZipEncoding ZIP_ENCODING_UTF_8\u003e\n  goto B20\n}",
      "B19 {\n  $r92 \u003d ZipEncoding zipEncoding\u003e\n}",
      "B20 {\n  r12 \u003d $r92\n  $r13 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $z4 \u003d r11.usesDataDescriptor()\n  ZipArchiveInputStream$CurrentEntry.access$502($r13, $z4)\n  $r14 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r15 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r14)\n  $r15.setGeneralPurposeBit(r11)\n  $r16 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r18 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r16)\n  $r17 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $i2 \u003d ZipShort.getValue($r17, 8)\n  $r18.setMethod($i2)\n  $r19 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $l3 \u003d ZipLong.getValue($r19, 10)\n  $l12 \u003d ZipUtil.dosToJavaTime($l3)\n  $r20 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r21 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r20)\n  $r21.setTime($l12)\n  r93 \u003d null\n  r94 \u003d null\n  $r22 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $z5 \u003d ZipArchiveInputStream$CurrentEntry.access$500($r22)\n  if ($z5 !\u003d 0) goto B21 else B22\n}",
      "B21 {\n  $r65 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r67 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r65)\n  $r66 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $l9 \u003d ZipLong.getValue($r66, 14)\n  $r67.setCrc($l9)\n  $r68 \u003d ZipLong\n  $r69 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  new ZipLong($r69, 18)\n  r94 \u003d $r68\n  $r70 \u003d ZipLong\n  $r71 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  new ZipLong($r71, 22)\n  r93 \u003d $r70\n  goto B22\n}",
      "B22 {\n  $r23 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $i10 \u003d ZipShort.getValue($r23, 26)\n  i15 \u003d 26 + 2\n  $r24 \u003d ZipArchiveInputStream: byte[] lfhBuf\u003e\n  $i11 \u003d ZipShort.getValue($r24, i15)\n  $r72 \u003d r0.readRange($i10)\n  $r25 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r27 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r25)\n  $r26 \u003d r12.decode($r72)\n  $r27.setName($r26, $r72)\n  if (z3 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r61 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r63 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r61)\n  $r62 \u003d ZipArchiveEntry$NameSource NAME_WITH_EFS_FLAG\u003e\n  $r63.setNameSource($r62)\n}",
      "B24 {\n  $r64 \u003d r0.readRange($i11)\n  $r28 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r29 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r28)\n  $r29.setExtra($r64)\n  goto B26\n}",
      "B25 {\n  $r82 :\u003d @caughtexception\n  $r83 \u003d StringBuilder\n  new StringBuilder()\n  $r87 \u003d $r83.append(\"Invalid extra data in entry \")\n  $r84 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r85 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r84)\n  $r86 \u003d $r85.getName()\n  $r88 \u003d $r87.append($r86)\n  $r89 \u003d $r88.toString()\n  $r90 \u003d ZipUtil.newZipException($r89, $r82)\n  throw $r90\n}",
      "B26 {\n  if (z3 !\u003d 0) goto B27 else B29\n}",
      "B27 {\n  $z7 \u003d ZipArchiveInputStream: boolean useUnicodeExtraFields\u003e\n  if ($z7 \u003d\u003d false) goto B28 else B29\n}",
      "B28 {\n  $r59 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r60 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r59)\n  ZipUtil.setNameAndCommentFromExtraFields($r60, $r72, null)\n}",
      "B29 {\n  r0.processZip64Extra(r93, r94)\n  $r95 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r96 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r95)\n  $r96.setLocalHeaderOffset($l14)\n  $r97 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r98 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r97)\n  $l16 \u003d r0.getBytesRead()\n  $r98.setDataOffset($l16)\n  $r99 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r100 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r99)\n  $r100.setStreamContiguous(1)\n  $r101 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r102 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r101)\n  $i17 \u003d $r102.getMethod()\n  $r103 \u003d ZipMethod.getMethodByCode($i17)\n  $r104 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r105 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r104)\n  $l18 \u003d $r105.getCompressedSize()\n  $b19 \u003d $l18 cmp -1L\n  if ($b19 \u003d\u003d false) goto B30 else B41\n}",
      "B30 {\n  $r34 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r35 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r34)\n  $z6 \u003d ZipUtil.canHandleEntryData($r35)\n  if ($z6 \u003d\u003d false) goto B31 else B43\n}",
      "B31 {\n  $r36 \u003d ZipMethod STORED\u003e\n  if ($r103 \u003d\u003d $r36) goto B32 else B43\n}",
      "B32 {\n  $r37 \u003d ZipMethod DEFLATED\u003e\n  if ($r103 \u003d\u003d $r37) goto B33 else B43\n}",
      "B33 {\n  $r38 \u003d ZipArchiveInputStream$BoundCountInputStream\n  $r40 \u003d InputStream in\u003e\n  $r39 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r41 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r39)\n  $l4 \u003d $r41.getCompressedSize()\n  new ZipArchiveInputStream$BoundCountInputStream(r0, $r40, $l4)\n  $r42 \u003d ZipArchiveInputStream$1: int[] $SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod\u003e\n  $i5 \u003d $r103.ordinal()\n  $i6 \u003d $r42[$i5]\n  ZipArchiveInputStream: int entriesRead\u003e]; }\n}",
      "B34 {\n  $r58 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r57 \u003d UnshrinkingInputStream\n  new UnshrinkingInputStream($r38)\n  ZipArchiveInputStream$CurrentEntry.access$802($r58, $r57)\n  goto B40\n}",
      "B35 {\n  $r51 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r49 \u003d ExplodingInputStream\n  $r50 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r52 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r50)\n  $r53 \u003d $r52.getGeneralPurposeBit()\n  $i8 \u003d $r53.getSlidingDictionarySize()\n  $r54 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r55 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r54)\n  $r56 \u003d $r55.getGeneralPurposeBit()\n  $i7 \u003d $r56.getNumberOfShannonFanoTrees()\n  new ExplodingInputStream($i8, $i7, $r38)\n  ZipArchiveInputStream$CurrentEntry.access$802($r51, $r49)\n  goto B40\n}",
      "B36 {\n  $r80 :\u003d @caughtexception\n  $r81 \u003d IOException\n  new IOException(\"bad IMPLODE data\", $r80)\n  throw $r81\n}",
      "B37 {\n  $r48 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r47 \u003d BZip2CompressorInputStream\n  new BZip2CompressorInputStream($r38)\n  ZipArchiveInputStream$CurrentEntry.access$802($r48, $r47)\n  goto B40\n}",
      "B38 {\n  $r46 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r45 \u003d Deflate64CompressorInputStream\n  new Deflate64CompressorInputStream($r38)\n  ZipArchiveInputStream$CurrentEntry.access$802($r46, $r45)\n  goto B40\n}",
      "B39 {\n  $r43 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r44 \u003d r0.createZstdInputStream($r38)\n  ZipArchiveInputStream$CurrentEntry.access$802($r43, $r44)\n  goto B40\n}",
      "B40 {\n  goto B43\n}",
      "B41 {\n  $r30 \u003d ZipMethod ENHANCED_DEFLATED\u003e\n  if ($r103 !\u003d $r30) goto B42 else B43\n}",
      "B42 {\n  $r33 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r31 \u003d Deflate64CompressorInputStream\n  $r32 \u003d InputStream in\u003e\n  new Deflate64CompressorInputStream($r32)\n  ZipArchiveInputStream$CurrentEntry.access$802($r33, $r31)\n}",
      "B43 {\n  $i20 \u003d ZipArchiveInputStream: int entriesRead\u003e\n  $i21 \u003d $i20 + 1\n  ZipArchiveInputStream: int entriesRead\u003e \u003d $i21\n  $r106 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r107 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r106)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B17",
      "B12 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B27",
      "B26 --\u003e B29",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B29 --\u003e B41",
      "B30 --\u003e B31",
      "B30 --\u003e B43",
      "B31 --\u003e B32",
      "B31 --\u003e B43",
      "B32 --\u003e B33",
      "B32 --\u003e B43",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B33 --\u003e B37",
      "B33 --\u003e B38",
      "B33 --\u003e B39",
      "B33 --\u003e B40",
      "B34 --\u003e B40",
      "B35 --\u003e B40",
      "B36 --\u003e [EXIT]",
      "B37 --\u003e B40",
      "B38 --\u003e B40",
      "B39 --\u003e B40",
      "B40 --\u003e B43",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B43",
      "B43 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#readFirstLocalFileHeader(...0)",
        "body": "{\r\n    // for empty archive, we may get only EOCD size:\r\n    final byte[] header \u003d new byte[Math.min(LFH_LEN, ZipFile.MIN_EOCD_SIZE)];\r\n    readFully(header);\r\n    try {\r\n        READ_LOOP: for (int i \u003d 0; ; ) {\r\n            for (int j \u003d 0; i \u003c\u003d PREAMBLE_GARBAGE_MAX_SIZE - 4 \u0026\u0026 j \u003c\u003d header.length - 4; ++j, ++i) {\r\n                final ZipLong sig \u003d new ZipLong(header, j);\r\n                if (sig.equals(ZipLong.LFH_SIG) || sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\r\n                    // regular archive containing at least one entry:\r\n                    System.arraycopy(header, j, header, 0, header.length - j);\r\n                    readFully(header, header.length - j);\r\n                    break READ_LOOP;\r\n                }\r\n                if (sig.equals(new ZipLong(ZipArchiveOutputStream.EOCD_SIG))) {\r\n                    // empty archive:\r\n                    pushback(header, j, header.length - j);\r\n                    return false;\r\n                }\r\n            }\r\n            if (i \u003e\u003d PREAMBLE_GARBAGE_MAX_SIZE - 4) {\r\n                throw new ZipException(\"Cannot find zip signature within the first \" + PREAMBLE_GARBAGE_MAX_SIZE + \" bytes\");\r\n            }\r\n            System.arraycopy(header, header.length - 3, header, 0, 3);\r\n            readFully(header, 3);\r\n        }\r\n        System.arraycopy(header, 0, lfhBuf, 0, header.length);\r\n        readFully(lfhBuf, header.length);\r\n    } catch (final EOFException ex) {\r\n        throw new ZipException(\"Cannot find zip signature within the file\");\r\n    }\r\n    final ZipLong sig \u003d new ZipLong(lfhBuf);\r\n    if (!skipSplitSig \u0026\u0026 sig.equals(ZipLong.DD_SIG)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\r\n    }\r\n    // the split ZIP signature(08074B50) should only be skipped when the skipSplitSig is set\r\n    if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {\r\n        // Just skip over the marker.\r\n        System.arraycopy(lfhBuf, 4, lfhBuf, 0, lfhBuf.length - 4);\r\n        readFully(lfhBuf, lfhBuf.length - 4);\r\n    }\r\n    return true;\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#createZstdInputStream(...1)",
        "body": "{\r\n    return new ZstdCompressorInputStream(in);\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#getBytesRead(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ZipArchiveInputStream#readFully(...1)",
        "body": "{\r\n    readFully(b, 0);\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#readRange(...1)",
        "body": "{\r\n    final byte[] ret \u003d IOUtils.readRange(in, len);\r\n    count(ret.length);\r\n    if (ret.length \u003c len) {\r\n        throw new EOFException();\r\n    }\r\n    return ret;\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#processZip64Extra(...2)",
        "body": "{\r\n    final ZipExtraField extra \u003d current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\r\n    if (extra !\u003d null \u0026\u0026 !(extra instanceof Zip64ExtendedInformationExtraField)) {\r\n        throw new ZipException(\"archive contains unparseable zip64 extra field\");\r\n    }\r\n    final Zip64ExtendedInformationExtraField z64 \u003d (Zip64ExtendedInformationExtraField) extra;\r\n    current.usesZip64 \u003d z64 !\u003d null;\r\n    if (!current.hasDataDescriptor) {\r\n        if (// same as current.usesZip64 but avoids NPE warning\r\n        z64 !\u003d null \u0026\u0026 (ZipLong.ZIP64_MAGIC.equals(cSize) || ZipLong.ZIP64_MAGIC.equals(size))) {\r\n            if (z64.getCompressedSize() \u003d\u003d null || z64.getSize() \u003d\u003d null) {\r\n                // avoid NPE if it\u0027s a corrupted ZIP archive\r\n                throw new ZipException(\"archive contains corrupted zip64 extra field\");\r\n            }\r\n            long s \u003d z64.getCompressedSize().getLongValue();\r\n            if (s \u003c 0) {\r\n                throw new ZipException(\"broken archive, entry with negative compressed size\");\r\n            }\r\n            current.entry.setCompressedSize(s);\r\n            s \u003d z64.getSize().getLongValue();\r\n            if (s \u003c 0) {\r\n                throw new ZipException(\"broken archive, entry with negative size\");\r\n            }\r\n            current.entry.setSize(s);\r\n        } else if (cSize !\u003d null \u0026\u0026 size !\u003d null) {\r\n            if (cSize.getValue() \u003c 0) {\r\n                throw new ZipException(\"broken archive, entry with negative compressed size\");\r\n            }\r\n            current.entry.setCompressedSize(cSize.getValue());\r\n            if (size.getValue() \u003c 0) {\r\n                throw new ZipException(\"broken archive, entry with negative size\");\r\n            }\r\n            current.entry.setSize(size.getValue());\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#skipRemainderOfArchive(...0)",
        "body": "{\r\n    // skip over central directory. One LFH has been read too much\r\n    // already. The calculation discounts file names and extra\r\n    // data, so it will be too short.\r\n    if (entriesRead \u003e 0) {\r\n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\r\n    }\r\n    final boolean foundEocd \u003d findEocdRecord();\r\n    if (foundEocd) {\r\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD - /* signature */\r\n        SHORT);\r\n        readFully(shortBuf);\r\n        // file comment\r\n        final int commentLen \u003d ZipShort.getValue(shortBuf);\r\n        if (commentLen \u003e\u003d 0) {\r\n            realSkip(commentLen);\r\n            return;\r\n        }\r\n    }\r\n    throw new IOException(\"Truncated ZIP file\");\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#isApkSigningBlock(...1)",
        "body": "{\r\n    // length of block excluding the size field itself\r\n    final BigInteger len \u003d ZipEightByteInteger.getValue(suspectLocalFileHeader);\r\n    // LFH has already been read and all but the first eight bytes contain (part of) the APK signing block,\r\n    // also subtract 16 bytes in order to position us at the magic string\r\n    BigInteger toSkip \u003d len.add(BigInteger.valueOf(DWORD - suspectLocalFileHeader.length - (long) APK_SIGNING_BLOCK_MAGIC.length));\r\n    final byte[] magic \u003d new byte[APK_SIGNING_BLOCK_MAGIC.length];\r\n    try {\r\n        if (toSkip.signum() \u003c 0) {\r\n            // suspectLocalFileHeader contains the start of suspect magic string\r\n            final int off \u003d suspectLocalFileHeader.length + toSkip.intValue();\r\n            // length was shorter than magic length\r\n            if (off \u003c DWORD) {\r\n                return false;\r\n            }\r\n            final int bytesInBuffer \u003d Math.abs(toSkip.intValue());\r\n            System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));\r\n            if (bytesInBuffer \u003c magic.length) {\r\n                readFully(magic, bytesInBuffer);\r\n            }\r\n        } else {\r\n            while (toSkip.compareTo(LONG_MAX) \u003e 0) {\r\n                realSkip(Long.MAX_VALUE);\r\n                toSkip \u003d toSkip.add(LONG_MAX.negate());\r\n            }\r\n            realSkip(toSkip.longValue());\r\n            readFully(magic);\r\n        }\r\n    } catch (final EOFException ex) {\r\n        // NOSONAR\r\n        // length was invalid\r\n        return false;\r\n    }\r\n    return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#closeEntry(...0)",
        "body": "{\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (current \u003d\u003d null) {\r\n        return;\r\n    }\r\n    // Ensure all entry bytes are read\r\n    if (currentEntryHasOutstandingBytes()) {\r\n        drainCurrentEntryData();\r\n    } else {\r\n        // this is guaranteed to exhaust the stream\r\n        if (skip(Long.MAX_VALUE) \u003c 0) {\r\n            throw new IllegalStateException(\"Can\u0027t read the remainder of the stream\");\r\n        }\r\n        final long inB \u003d current.entry.getMethod() \u003d\u003d ZipArchiveOutputStream.DEFLATED ? getBytesInflated() : current.bytesRead;\r\n        // this is at most a single read() operation and can\u0027t\r\n        // exceed the range of int\r\n        final int diff \u003d (int) (current.bytesReadFromStream - inB);\r\n        // Pushback any required bytes\r\n        if (diff \u003e 0) {\r\n            pushback(buf.array(), buf.limit() - diff, diff);\r\n            current.bytesReadFromStream -\u003d diff;\r\n        }\r\n        // Drain remainder of entry if not all data bytes were required\r\n        if (currentEntryHasOutstandingBytes()) {\r\n            drainCurrentEntryData();\r\n        }\r\n    }\r\n    if (lastStoredEntry \u003d\u003d null \u0026\u0026 current.hasDataDescriptor) {\r\n        readDataDescriptor();\r\n    }\r\n    inf.reset();\r\n    buf.clear().flip();\r\n    current \u003d null;\r\n    lastStoredEntry \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (current \u003d\u003d null) {\r\n        return -1;\r\n    }\r\n    // avoid int overflow, check null buffer\r\n    if (offset \u003e buffer.length || length \u003c 0 || offset \u003c 0 || buffer.length - offset \u003c length) {\r\n        throw new ArrayIndexOutOfBoundsException();\r\n    }\r\n    ZipUtil.checkRequestedFeatures(current.entry);\r\n    if (!supportsDataDescriptorFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\r\n    }\r\n    if (!supportsCompressedSizeFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);\r\n    }\r\n    final int read;\r\n    final int method \u003d current.entry.getMethod();\r\n    if (method \u003d\u003d ZipArchiveOutputStream.STORED) {\r\n        read \u003d readStored(buffer, offset, length);\r\n    } else if (method \u003d\u003d ZipArchiveOutputStream.DEFLATED) {\r\n        read \u003d readDeflated(buffer, offset, length);\r\n    } else if (method \u003d\u003d ZipMethod.UNSHRINKING.getCode() || method \u003d\u003d ZipMethod.IMPLODING.getCode() || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || method \u003d\u003d ZipMethod.BZIP2.getCode() || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode()) {\r\n        read \u003d current.inputStream.read(buffer, offset, length);\r\n    } else {\r\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(method), current.entry);\r\n    }\r\n    if (read \u003e\u003d 0) {\r\n        current.crc.update(buffer, offset, read);\r\n        uncompressedCount +\u003d read;\r\n    }\r\n    return read;\r\n}",
    "nodes": 30,
    "edges": 40,
    "cc": 12,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($r1 !\u003d null) → B5 | else → B6",
      "B6 : If(i1 \u003e $i2) → B7 | else → B10",
      "B7 : If(i0 \u003c 0) → B8 | else → B10",
      "B8 : If(i1 \u003c 0) → B9 | else → B10",
      "B9 : If($i4 \u003e\u003d i0) → B10 | else → B11",
      "B11 : If($z1 !\u003d 0) → B12 | else → B13",
      "B13 : If($z2 !\u003d 0) → B14 | else → B15",
      "B15 : If(i5 !\u003d 0) → B16 | else → B17",
      "B17 : If(i5 !\u003d 8) → B18 | else → B19",
      "B19 : If(i5 \u003d\u003d $i6) → B20 | else → B25",
      "B20 : If(i5 \u003d\u003d $i10) → B21 | else → B25",
      "B21 : If(i5 \u003d\u003d $i11) → B22 | else → B25",
      "B22 : If(i5 \u003d\u003d $i12) → B23 | else → B25",
      "B23 : If($z3 !\u003d 0) → B24 | else → B25",
      "B24 : If(i5 !\u003d $i13) → B25 | else → B26",
      "B27 : If(i14 \u003c 0) → B28 | else → B29"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d ZipArchiveInputStream: boolean closed\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r34 \u003d IOException\n  new IOException(\"The stream is closed\")\n  throw $r34\n}",
      "B4 {\n  $r1 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  if ($r1 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $i16 \u003d (int) -1\n  return\n}",
      "B6 {\n  $i2 \u003d lengthof r2\n  if (i1 \u003e $i2) goto B7 else B10\n}",
      "B7 {\n  if (i0 \u003c 0) goto B8 else B10\n}",
      "B8 {\n  if (i1 \u003c 0) goto B9 else B10\n}",
      "B9 {\n  $i3 \u003d lengthof r2\n  $i4 \u003d $i3 - i1\n  if ($i4 \u003e\u003d i0) goto B10 else B11\n}",
      "B10 {\n  $r35 \u003d ArrayIndexOutOfBoundsException\n  new ArrayIndexOutOfBoundsException()\n  throw $r35\n}",
      "B11 {\n  $r3 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r4 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r3)\n  ZipUtil.checkRequestedFeatures($r4)\n  $r5 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r6 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r5)\n  $z1 \u003d r0.supportsDataDescriptorFor($r6)\n  if ($z1 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r36 \u003d UnsupportedZipFeatureException\n  $r28 \u003d UnsupportedZipFeatureException$Feature DATA_DESCRIPTOR\u003e\n  $r27 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r29 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r27)\n  new UnsupportedZipFeatureException($r28, $r29)\n  throw $r36\n}",
      "B13 {\n  $r7 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r8 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r7)\n  $z2 \u003d r0.supportsCompressedSizeFor($r8)\n  if ($z2 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r37 \u003d UnsupportedZipFeatureException\n  $r24 \u003d UnsupportedZipFeatureException$Feature UNKNOWN_COMPRESSED_SIZE\u003e\n  $r23 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r25 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r23)\n  new UnsupportedZipFeatureException($r24, $r25)\n  throw $r37\n}",
      "B15 {\n  $r9 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r10 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r9)\n  i5 \u003d $r10.getMethod()\n  if (i5 !\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i14 \u003d r0.readStored(r2, i1, i0)\n  goto B27\n}",
      "B17 {\n  if (i5 !\u003d 8) goto B18 else B19\n}",
      "B18 {\n  i14 \u003d r0.readDeflated(r2, i1, i0)\n  goto B27\n}",
      "B19 {\n  $r11 \u003d ZipMethod UNSHRINKING\u003e\n  $i6 \u003d $r11.getCode()\n  if (i5 \u003d\u003d $i6) goto B20 else B25\n}",
      "B20 {\n  $r14 \u003d ZipMethod IMPLODING\u003e\n  $i10 \u003d $r14.getCode()\n  if (i5 \u003d\u003d $i10) goto B21 else B25\n}",
      "B21 {\n  $r15 \u003d ZipMethod ENHANCED_DEFLATED\u003e\n  $i11 \u003d $r15.getCode()\n  if (i5 \u003d\u003d $i11) goto B22 else B25\n}",
      "B22 {\n  $r16 \u003d ZipMethod BZIP2\u003e\n  $i12 \u003d $r16.getCode()\n  if (i5 \u003d\u003d $i12) goto B23 else B25\n}",
      "B23 {\n  $z3 \u003d ZipMethod.isZstd(i5)\n  if ($z3 !\u003d 0) goto B24 else B25\n}",
      "B24 {\n  $r17 \u003d ZipMethod XZ\u003e\n  $i13 \u003d $r17.getCode()\n  if (i5 !\u003d $i13) goto B25 else B26\n}",
      "B25 {\n  $r32 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r33 \u003d ZipArchiveInputStream$CurrentEntry.access$800($r32)\n  i14 \u003d $r33.read(r2, i1, i0)\n  goto B27\n}",
      "B26 {\n  $r38 \u003d UnsupportedZipFeatureException\n  $r21 \u003d ZipMethod.getMethodByCode(i5)\n  $r19 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r20 \u003d ZipArchiveInputStream$CurrentEntry.access$300($r19)\n  new UnsupportedZipFeatureException($r21, $r20)\n  throw $r38\n}",
      "B27 {\n  if (i14 \u003c 0) goto B28 else B29\n}",
      "B28 {\n  $r12 \u003d ZipArchiveInputStream$CurrentEntry current\u003e\n  $r13 \u003d ZipArchiveInputStream$CurrentEntry.access$1000($r12)\n  $r13.update(r2, i1, i14)\n  $l8 \u003d ZipArchiveInputStream: long uncompressedCount\u003e\n  $l7 \u003d (long) i14\n  $l9 \u003d $l8 + $l7\n  ZipArchiveInputStream: long uncompressedCount\u003e \u003d $l9\n}",
      "B29 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B27",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B27",
      "B19 --\u003e B20",
      "B19 --\u003e B25",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B25",
      "B22 --\u003e B23",
      "B22 --\u003e B25",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#readStored(...3)",
        "body": "{\r\n    if (current.hasDataDescriptor) {\r\n        if (lastStoredEntry \u003d\u003d null) {\r\n            readStoredEntry();\r\n        }\r\n        return lastStoredEntry.read(buffer, offset, length);\r\n    }\r\n    final long csize \u003d current.entry.getSize();\r\n    if (current.bytesRead \u003e\u003d csize) {\r\n        return -1;\r\n    }\r\n    if (buf.position() \u003e\u003d buf.limit()) {\r\n        buf.position(0);\r\n        final int l \u003d in.read(buf.array());\r\n        if (l \u003d\u003d -1) {\r\n            buf.limit(0);\r\n            throw new IOException(\"Truncated ZIP file\");\r\n        }\r\n        buf.limit(l);\r\n        count(l);\r\n        current.bytesReadFromStream +\u003d l;\r\n    }\r\n    int toRead \u003d Math.min(buf.remaining(), length);\r\n    if (csize - current.bytesRead \u003c toRead) {\r\n        // if it is smaller than toRead then it fits into an int\r\n        toRead \u003d (int) (csize - current.bytesRead);\r\n    }\r\n    buf.get(buffer, offset, toRead);\r\n    current.bytesRead +\u003d toRead;\r\n    return toRead;\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#supportsDataDescriptorFor(...1)",
        "body": "{\r\n    final int method \u003d entry.getMethod();\r\n    return !entry.getGeneralPurposeBit().usesDataDescriptor() || allowStoredEntriesWithDataDescriptor \u0026\u0026 method \u003d\u003d ZipEntry.STORED || method \u003d\u003d ZipEntry.DEFLATED || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode();\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#readDeflated(...3)",
        "body": "{\r\n    final int read \u003d readFromInflater(buffer, offset, length);\r\n    if (read \u003c\u003d 0) {\r\n        if (inf.finished()) {\r\n            return -1;\r\n        }\r\n        if (inf.needsDictionary()) {\r\n            throw new ZipException(\"This archive needs a preset dictionary\" + \" which is not supported by Commons\" + \" Compress.\");\r\n        }\r\n        if (read \u003d\u003d -1) {\r\n            throw new IOException(\"Truncated ZIP file\");\r\n        }\r\n    }\r\n    return read;\r\n}"
      },
      {
        "name": "ZipArchiveInputStream#supportsCompressedSizeFor(...1)",
        "body": "{\r\n    final int method \u003d entry.getMethod();\r\n    return entry.getCompressedSize() !\u003d ArchiveEntry.SIZE_UNKNOWN || method \u003d\u003d ZipEntry.DEFLATED || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || entry.getGeneralPurposeBit().usesDataDescriptor() \u0026\u0026 allowStoredEntriesWithDataDescriptor \u0026\u0026 method \u003d\u003d ZipEntry.STORED || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
    "methodName": "skip",
    "signature": "long skip(long)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003e\u003d 0) {\r\n        long skipped \u003d 0;\r\n        while (skipped \u003c value) {\r\n            final long rem \u003d value - skipped;\r\n            final int x \u003d read(skipBuf, 0, (int) (skipBuf.length \u003e rem ? rem : skipBuf.length));\r\n            if (x \u003d\u003d -1) {\r\n                return skipped;\r\n            }\r\n            skipped +\u003d x;\r\n        }\r\n        return skipped;\r\n    }\r\n    throw new IllegalArgumentException(\"Negative skip value\");\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i13 \u003c 0) → B1 | else → B10",
      "B2 : If($i14 \u003e\u003d 0) → B3 | else → B9",
      "B3 : If($i15 \u003c\u003d 0) → B4 | else → B5",
      "B6 : If($i10 !\u003d $i17) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveInputStream\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i13 \u003d (int) $b1\n  if ($i13 \u003c 0) goto B1 else B10\n}",
      "B1 {\n  l11 \u003d 0L\n}",
      "B2 {\n  $b2 \u003d l11 cmp l0\n  $i14 \u003d (int) $b2\n  if ($i14 \u003e\u003d 0) goto B3 else B9\n}",
      "B3 {\n  l3 \u003d l0 - l11\n  $r4 \u003d ZipArchiveInputStream: byte[] skipBuf\u003e\n  $r2 \u003d ZipArchiveInputStream: byte[] skipBuf\u003e\n  $i4 \u003d lengthof $r2\n  $l5 \u003d (long) $i4\n  $b6 \u003d $l5 cmp l3\n  $i15 \u003d (int) $b6\n  if ($i15 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $l12 \u003d l3\n  goto B6\n}",
      "B5 {\n  $r3 \u003d ZipArchiveInputStream: byte[] skipBuf\u003e\n  $i7 \u003d lengthof $r3\n  $l12 \u003d (long) $i7\n}",
      "B6 {\n  $i8 \u003d (int) $l12\n  $i10 \u003d r1.read($r4, 0, $i8)\n  $i17 \u003d (int) -1\n  if ($i10 !\u003d $i17) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $l9 \u003d (long) $i10\n  l11 \u003d l11 + $l9\n  goto B2\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Negative skip value\")\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B2",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveInputStream#read(...3)",
        "body": "{\r\n    if (length \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (current \u003d\u003d null) {\r\n        return -1;\r\n    }\r\n    // avoid int overflow, check null buffer\r\n    if (offset \u003e buffer.length || length \u003c 0 || offset \u003c 0 || buffer.length - offset \u003c length) {\r\n        throw new ArrayIndexOutOfBoundsException();\r\n    }\r\n    ZipUtil.checkRequestedFeatures(current.entry);\r\n    if (!supportsDataDescriptorFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\r\n    }\r\n    if (!supportsCompressedSizeFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);\r\n    }\r\n    final int read;\r\n    final int method \u003d current.entry.getMethod();\r\n    if (method \u003d\u003d ZipArchiveOutputStream.STORED) {\r\n        read \u003d readStored(buffer, offset, length);\r\n    } else if (method \u003d\u003d ZipArchiveOutputStream.DEFLATED) {\r\n        read \u003d readDeflated(buffer, offset, length);\r\n    } else if (method \u003d\u003d ZipMethod.UNSHRINKING.getCode() || method \u003d\u003d ZipMethod.IMPLODING.getCode() || method \u003d\u003d ZipMethod.ENHANCED_DEFLATED.getCode() || method \u003d\u003d ZipMethod.BZIP2.getCode() || ZipMethod.isZstd(method) || method \u003d\u003d ZipMethod.XZ.getCode()) {\r\n        read \u003d current.inputStream.read(buffer, offset, length);\r\n    } else {\r\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(method), current.entry);\r\n    }\r\n    if (read \u003e\u003d 0) {\r\n        current.crc.update(buffer, offset, read);\r\n        uncompressedCount +\u003d read;\r\n    }\r\n    return read;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "addRawArchiveEntry",
    "signature": "void addRawArchiveEntry(org.apache.commons.compress.archivers.zip.ZipArchiveEntry,java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final ZipArchiveEntry ae \u003d new ZipArchiveEntry(entry);\r\n    if (hasZip64Extra(ae)) {\r\n        // Will be re-added as required. this may make the file generated with this method\r\n        // somewhat smaller than standard mode,\r\n        // since standard mode is unable to remove the ZIP 64 header.\r\n        ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\r\n    }\r\n    final boolean is2PhaseSource \u003d ae.getCrc() !\u003d ZipArchiveEntry.CRC_UNKNOWN \u0026\u0026 ae.getSize() !\u003d ArchiveEntry.SIZE_UNKNOWN \u0026\u0026 ae.getCompressedSize() !\u003d ArchiveEntry.SIZE_UNKNOWN;\r\n    putArchiveEntry(ae, is2PhaseSource);\r\n    copyFromZipInputStream(rawStream, is2PhaseSource);\r\n    closeCopiedEntry(is2PhaseSource);\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($b1 \u003d\u003d false) → B3 | else → B6",
      "B3 : If($b3 \u003d\u003d false) → B4 | else → B6",
      "B4 : If($b5 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  ZipArchiveEntry\n  InputStream\n  $r0 \u003d ZipArchiveEntry\n  new ZipArchiveEntry(r1)\n  $z0 \u003d r2.hasZip64Extra($r0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d ZipShort HEADER_ID\u003e\n  $r0.removeExtraField($r4)\n}",
      "B2 {\n  $l0 \u003d $r0.getCrc()\n  $b1 \u003d $l0 cmp -1L\n  if ($b1 \u003d\u003d false) goto B3 else B6\n}",
      "B3 {\n  $l2 \u003d $r0.getSize()\n  $b3 \u003d $l2 cmp -1L\n  if ($b3 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  $l4 \u003d $r0.getCompressedSize()\n  $b5 \u003d $l4 cmp -1L\n  if ($b5 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $z4 \u003d 1\n  $z3 \u003d 1\n  $z2 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z4 \u003d 0\n  $z3 \u003d 0\n  $z2 \u003d 0\n}",
      "B7 {\n  r2.putArchiveEntry($r0, $z4)\n  r2.copyFromZipInputStream(r3, $z2)\n  r2.closeCopiedEntry($z3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveOutputStream#hasZip64Extra(...1)",
        "body": "{\r\n    return ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID) instanceof Zip64ExtendedInformationExtraField;\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#putArchiveEntry(...2)",
        "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"Stream has already been finished\");\r\n    }\r\n    if (entry !\u003d null) {\r\n        closeArchiveEntry();\r\n    }\r\n    entry \u003d new CurrentEntry(archiveEntry);\r\n    entries.add(entry.entry);\r\n    setDefaults(entry.entry);\r\n    final Zip64Mode effectiveMode \u003d getEffectiveZip64Mode(entry.entry);\r\n    validateSizeInformation(effectiveMode);\r\n    if (shouldAddZip64Extra(entry.entry, effectiveMode)) {\r\n        final Zip64ExtendedInformationExtraField z64 \u003d getZip64Extra(entry.entry);\r\n        final ZipEightByteInteger size;\r\n        final ZipEightByteInteger compressedSize;\r\n        if (phased) {\r\n            // sizes are already known\r\n            size \u003d new ZipEightByteInteger(entry.entry.getSize());\r\n            compressedSize \u003d new ZipEightByteInteger(entry.entry.getCompressedSize());\r\n        } else if (entry.entry.getMethod() \u003d\u003d STORED \u0026\u0026 entry.entry.getSize() !\u003d ArchiveEntry.SIZE_UNKNOWN) {\r\n            // actually, we already know the sizes\r\n            compressedSize \u003d size \u003d new ZipEightByteInteger(entry.entry.getSize());\r\n        } else {\r\n            // just a placeholder, real data will be in data\r\n            // descriptor or inserted later via SeekableByteChannel\r\n            compressedSize \u003d size \u003d ZipEightByteInteger.ZERO;\r\n        }\r\n        z64.setSize(size);\r\n        z64.setCompressedSize(compressedSize);\r\n        entry.entry.setExtra();\r\n    }\r\n    if (entry.entry.getMethod() \u003d\u003d DEFLATED \u0026\u0026 hasCompressionLevelChanged) {\r\n        def.setLevel(level);\r\n        hasCompressionLevelChanged \u003d false;\r\n    }\r\n    writeLocalFileHeader(archiveEntry, phased);\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#copyFromZipInputStream(...2)",
        "body": "{\r\n    if (entry \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current entry\");\r\n    }\r\n    if (!phased) {\r\n        ZipUtil.checkRequestedFeatures(entry.entry);\r\n    }\r\n    entry.hasWritten \u003d true;\r\n    int length;\r\n    while ((length \u003d src.read(copyBuffer)) \u003e\u003d 0) {\r\n        streamCompressor.writeCounted(copyBuffer, 0, length);\r\n        count(length);\r\n    }\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#closeCopiedEntry(...1)",
        "body": "{\r\n    preClose();\r\n    entry.bytesRead \u003d entry.entry.getSize();\r\n    final Zip64Mode effectiveMode \u003d getEffectiveZip64Mode(entry.entry);\r\n    final boolean actuallyNeedsZip64 \u003d checkIfNeedsZip64(effectiveMode);\r\n    closeEntry(actuallyNeedsZip64, phased);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "canWriteEntryData",
    "signature": "boolean canWriteEntryData(org.apache.commons.compress.archivers.ArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    if (ae instanceof ZipArchiveEntry) {\r\n        final ZipArchiveEntry zae \u003d (ZipArchiveEntry) ae;\r\n        return zae.getMethod() !\u003d ZipMethod.IMPLODING.getCode() \u0026\u0026 zae.getMethod() !\u003d ZipMethod.UNSHRINKING.getCode() \u0026\u0026 ZipUtil.canHandleEntryData(zae);\r\n    }\r\n    return false;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B7",
      "B1 : If($i1 \u003d\u003d $i0) → B2 | else → B5",
      "B2 : If($i3 \u003d\u003d $i2) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  ArchiveEntry\n  $z0 \u003d ZipArchiveEntry\n  if ($z0 \u003d\u003d false) goto B1 else B7\n}",
      "B1 {\n  r1 \u003d ZipArchiveEntry) r0\n  $i1 \u003d r1.getMethod()\n  $r2 \u003d ZipMethod IMPLODING\u003e\n  $i0 \u003d $r2.getCode()\n  if ($i1 \u003d\u003d $i0) goto B2 else B5\n}",
      "B2 {\n  $i3 \u003d r1.getMethod()\n  $r3 \u003d ZipMethod UNSHRINKING\u003e\n  $i2 \u003d $r3.getCode()\n  if ($i3 \u003d\u003d $i2) goto B3 else B5\n}",
      "B3 {\n  $z1 \u003d ZipUtil.canHandleEntryData(r1)\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z2 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z2 \u003d 0\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        if (!finished) {\r\n            finish();\r\n        }\r\n    } finally {\r\n        destroy();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  $z0 \u003d ZipArchiveOutputStream: boolean finished\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.finish()\n}",
      "B2 {\n  r0.destroy()\n  goto B4\n}",
      "B3 {\n  $r1 :\u003d @caughtexception\n  r0.destroy()\n  throw $r1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveOutputStream#finish(...0)",
        "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"This archive has already been finished\");\r\n    }\r\n    if (entry !\u003d null) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    final long cdOverallOffset \u003d streamCompressor.getTotalBytesWritten();\r\n    cdOffset \u003d cdOverallOffset;\r\n    if (isSplitZip) {\r\n        // when creating a split zip, the offset should be\r\n        // the offset to the corresponding segment disk\r\n        final ZipSplitOutputStream zipSplitOutputStream \u003d (ZipSplitOutputStream) this.out;\r\n        cdOffset \u003d zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\r\n        cdDiskNumberStart \u003d zipSplitOutputStream.getCurrentSplitSegmentIndex();\r\n    }\r\n    writeCentralDirectoryInChunks();\r\n    cdLength \u003d streamCompressor.getTotalBytesWritten() - cdOverallOffset;\r\n    // calculate the length of end of central directory, as it may be used in writeZip64CentralDirectory\r\n    final ByteBuffer commentData \u003d this.zipEncoding.encode(comment);\r\n    final long commentLength \u003d (long) commentData.limit() - commentData.position();\r\n    eocdLength \u003d ZipConstants.WORD + /* length of EOCD_SIG */\r\n    ZipConstants.SHORT + /* number of this disk */\r\n    ZipConstants.SHORT + /* disk number of start of central directory */\r\n    ZipConstants.SHORT + /* total number of entries on this disk */\r\n    ZipConstants.SHORT + /* total number of entries */\r\n    ZipConstants.WORD + /* size of central directory */\r\n    ZipConstants.WORD + /* offset of start of central directory */\r\n    ZipConstants.SHORT + /* ZIP comment length */\r\n    commentLength;\r\n    writeZip64CentralDirectory();\r\n    writeCentralDirectoryEnd();\r\n    metaData.clear();\r\n    entries.clear();\r\n    streamCompressor.close();\r\n    if (isSplitZip) {\r\n        // trigger the ZipSplitOutputStream to write the final split segment\r\n        out.close();\r\n    }\r\n    finished \u003d true;\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#destroy(...0)",
        "body": "{\r\n    if (out !\u003d null) {\r\n        super.close();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "createArchiveEntry",
    "signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry createArchiveEntry(java.io.File,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"Stream has already been finished\");\r\n    }\r\n    return new ZipArchiveEntry(inputFile, entryName);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  File\n  String\n  $z0 \u003d ZipArchiveOutputStream: boolean finished\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IOException\n  new IOException(\"Stream has already been finished\")\n  throw $r4\n}",
      "B2 {\n  $r1 \u003d ZipArchiveEntry\n  new ZipArchiveEntry(r2, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "createArchiveEntry",
    "signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry createArchiveEntry(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption[])",
    "visibility": "public",
    "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"Stream has already been finished\");\r\n    }\r\n    return new ZipArchiveEntry(inputPath, entryName);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  Path\n  String\n  LinkOption[]\n  $z0 \u003d ZipArchiveOutputStream: boolean finished\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IOException\n  new IOException(\"Stream has already been finished\")\n  throw $r5\n}",
      "B2 {\n  $r1 \u003d ZipArchiveEntry\n  $r4 \u003d LinkOption)[0]\n  new ZipArchiveEntry(r2, r3, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (finished) {\r\n        throw new IOException(\"This archive has already been finished\");\r\n    }\r\n    if (entry !\u003d null) {\r\n        throw new IOException(\"This archive contains unclosed entries.\");\r\n    }\r\n    final long cdOverallOffset \u003d streamCompressor.getTotalBytesWritten();\r\n    cdOffset \u003d cdOverallOffset;\r\n    if (isSplitZip) {\r\n        // when creating a split zip, the offset should be\r\n        // the offset to the corresponding segment disk\r\n        final ZipSplitOutputStream zipSplitOutputStream \u003d (ZipSplitOutputStream) this.out;\r\n        cdOffset \u003d zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\r\n        cdDiskNumberStart \u003d zipSplitOutputStream.getCurrentSplitSegmentIndex();\r\n    }\r\n    writeCentralDirectoryInChunks();\r\n    cdLength \u003d streamCompressor.getTotalBytesWritten() - cdOverallOffset;\r\n    // calculate the length of end of central directory, as it may be used in writeZip64CentralDirectory\r\n    final ByteBuffer commentData \u003d this.zipEncoding.encode(comment);\r\n    final long commentLength \u003d (long) commentData.limit() - commentData.position();\r\n    eocdLength \u003d ZipConstants.WORD + /* length of EOCD_SIG */\r\n    ZipConstants.SHORT + /* number of this disk */\r\n    ZipConstants.SHORT + /* disk number of start of central directory */\r\n    ZipConstants.SHORT + /* total number of entries on this disk */\r\n    ZipConstants.SHORT + /* total number of entries */\r\n    ZipConstants.WORD + /* size of central directory */\r\n    ZipConstants.WORD + /* offset of start of central directory */\r\n    ZipConstants.SHORT + /* ZIP comment length */\r\n    commentLength;\r\n    writeZip64CentralDirectory();\r\n    writeCentralDirectoryEnd();\r\n    metaData.clear();\r\n    entries.clear();\r\n    streamCompressor.close();\r\n    if (isSplitZip) {\r\n        // trigger the ZipSplitOutputStream to write the final split segment\r\n        out.close();\r\n    }\r\n    finished \u003d true;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  $z0 \u003d ZipArchiveOutputStream: boolean finished\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d IOException\n  new IOException(\"This archive has already been finished\")\n  throw $r13\n}",
      "B2 {\n  $r1 \u003d ZipArchiveOutputStream$CurrentEntry entry\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d IOException\n  new IOException(\"This archive contains unclosed entries.\")\n  throw $r12\n}",
      "B4 {\n  $r2 \u003d StreamCompressor streamCompressor\u003e\n  l0 \u003d $r2.getTotalBytesWritten()\n  ZipArchiveOutputStream: long cdOffset\u003e \u003d l0\n  $z1 \u003d ZipArchiveOutputStream: boolean isSplitZip\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r10 \u003d OutputStream out\u003e\n  r14 \u003d ZipSplitOutputStream) $r10\n  $l8 \u003d r14.getCurrentSplitSegmentBytesWritten()\n  ZipArchiveOutputStream: long cdOffset\u003e \u003d $l8\n  $i9 \u003d r14.getCurrentSplitSegmentIndex()\n  $l10 \u003d (long) $i9\n  ZipArchiveOutputStream: long cdDiskNumberStart\u003e \u003d $l10\n}",
      "B6 {\n  r0.writeCentralDirectoryInChunks()\n  $r3 \u003d StreamCompressor streamCompressor\u003e\n  $l1 \u003d $r3.getTotalBytesWritten()\n  $l2 \u003d $l1 - l0\n  ZipArchiveOutputStream: long cdLength\u003e \u003d $l2\n  $r5 \u003d ZipEncoding zipEncoding\u003e\n  $r4 \u003d String comment\u003e\n  $r11 \u003d $r5.encode($r4)\n  $i3 \u003d $r11.limit()\n  $l6 \u003d (long) $i3\n  $i4 \u003d $r11.position()\n  $l5 \u003d (long) $i4\n  $l11 \u003d $l6 - $l5\n  $l7 \u003d 22L + $l11\n  ZipArchiveOutputStream: long eocdLength\u003e \u003d $l7\n  r0.writeZip64CentralDirectory()\n  r0.writeCentralDirectoryEnd()\n  $r6 \u003d Map metaData\u003e\n  $r6.clear()\n  $r7 \u003d List entries\u003e\n  $r7.clear()\n  $r8 \u003d StreamCompressor streamCompressor\u003e\n  $r8.close()\n  $z2 \u003d ZipArchiveOutputStream: boolean isSplitZip\u003e\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r9 \u003d OutputStream out\u003e\n  $r9.close()\n}",
      "B8 {\n  ZipArchiveOutputStream: boolean finished\u003e \u003d 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveOutputStream#writeZip64CentralDirectory(...0)",
        "body": "{\r\n    if (zip64Mode \u003d\u003d Zip64Mode.Never) {\r\n        return;\r\n    }\r\n    if (!hasUsedZip64 \u0026\u0026 shouldUseZip64EOCD()) {\r\n        // actually \"will use\"\r\n        hasUsedZip64 \u003d true;\r\n    }\r\n    if (!hasUsedZip64) {\r\n        return;\r\n    }\r\n    long offset \u003d streamCompressor.getTotalBytesWritten();\r\n    long diskNumberStart \u003d 0L;\r\n    if (isSplitZip) {\r\n        // when creating a split zip, the offset of should be\r\n        // the offset to the corresponding segment disk\r\n        final ZipSplitOutputStream zipSplitOutputStream \u003d (ZipSplitOutputStream) this.out;\r\n        offset \u003d zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();\r\n        diskNumberStart \u003d zipSplitOutputStream.getCurrentSplitSegmentIndex();\r\n    }\r\n    writeOut(ZIP64_EOCD_SIG);\r\n    // size of zip64 end of central directory, we don\u0027t have any variable length\r\n    // as we don\u0027t support the extensible data sector, yet\r\n    writeOut(ZipEightByteInteger.getBytes(ZipConstants.SHORT + /* version made by */\r\n    ZipConstants.SHORT + /* version needed to extract */\r\n    ZipConstants.WORD + /* disk number */\r\n    ZipConstants.WORD + /* disk with central directory */\r\n    ZipConstants.DWORD + /* number of entries in CD on this disk */\r\n    ZipConstants.DWORD + /* total number of entries */\r\n    ZipConstants.DWORD + /* size of CD */\r\n    (long) ZipConstants.DWORD));\r\n    // version made by and version needed to extract\r\n    writeOut(ZipShort.getBytes(ZipConstants.ZIP64_MIN_VERSION));\r\n    writeOut(ZipShort.getBytes(ZipConstants.ZIP64_MIN_VERSION));\r\n    // number of this disk\r\n    int numberOfThisDisk \u003d 0;\r\n    if (isSplitZip) {\r\n        numberOfThisDisk \u003d ((ZipSplitOutputStream) this.out).getCurrentSplitSegmentIndex();\r\n    }\r\n    writeOut(ZipLong.getBytes(numberOfThisDisk));\r\n    // disk number of the start of central directory\r\n    writeOut(ZipLong.getBytes(cdDiskNumberStart));\r\n    // total number of entries in the central directory on this disk\r\n    final int numOfEntriesOnThisDisk \u003d isSplitZip ? numberOfCDInDiskData.getOrDefault(numberOfThisDisk, 0) : entries.size();\r\n    final byte[] numOfEntriesOnThisDiskData \u003d ZipEightByteInteger.getBytes(numOfEntriesOnThisDisk);\r\n    writeOut(numOfEntriesOnThisDiskData);\r\n    // number of entries\r\n    final byte[] num \u003d ZipEightByteInteger.getBytes(entries.size());\r\n    writeOut(num);\r\n    // length and location of CD\r\n    writeOut(ZipEightByteInteger.getBytes(cdLength));\r\n    writeOut(ZipEightByteInteger.getBytes(cdOffset));\r\n    // no \"zip64 extensible data sector\" for now\r\n    if (isSplitZip) {\r\n        // based on the ZIP specification, the End Of Central Directory record and\r\n        // the Zip64 End Of Central Directory locator record must be on the same segment\r\n        final int zip64EOCDLOCLength \u003d ZipConstants.WORD + /* length of ZIP64_EOCD_LOC_SIG */\r\n        ZipConstants.WORD + /* disk number of ZIP64_EOCD_SIG */\r\n        ZipConstants.DWORD + /* offset of ZIP64_EOCD_SIG */\r\n        ZipConstants.WORD;\r\n        final long unsplittableContentSize \u003d zip64EOCDLOCLength + eocdLength;\r\n        ((ZipSplitOutputStream) this.out).prepareToWriteUnsplittableContent(unsplittableContentSize);\r\n    }\r\n    // and now the \"ZIP64 end of central directory locator\"\r\n    writeOut(ZIP64_EOCD_LOC_SIG);\r\n    // disk number holding the ZIP64 EOCD record\r\n    writeOut(ZipLong.getBytes(diskNumberStart));\r\n    // relative offset of ZIP64 EOCD record\r\n    writeOut(ZipEightByteInteger.getBytes(offset));\r\n    // total number of disks\r\n    if (isSplitZip) {\r\n        // the Zip64 End Of Central Directory Locator and the End Of Central Directory must be\r\n        // in the same split disk, it means they must be located in the last disk\r\n        final int totalNumberOfDisks \u003d ((ZipSplitOutputStream) this.out).getCurrentSplitSegmentIndex() + 1;\r\n        writeOut(ZipLong.getBytes(totalNumberOfDisks));\r\n    } else {\r\n        writeOut(ONE);\r\n    }\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#writeCentralDirectoryEnd(...0)",
        "body": "{\r\n    if (!hasUsedZip64 \u0026\u0026 isSplitZip) {\r\n        ((ZipSplitOutputStream) this.out).prepareToWriteUnsplittableContent(eocdLength);\r\n    }\r\n    validateIfZip64IsNeededInEOCD();\r\n    writeCounted(EOCD_SIG);\r\n    // number of this disk\r\n    int numberOfThisDisk \u003d 0;\r\n    if (isSplitZip) {\r\n        numberOfThisDisk \u003d ((ZipSplitOutputStream) this.out).getCurrentSplitSegmentIndex();\r\n    }\r\n    writeCounted(ZipShort.getBytes(numberOfThisDisk));\r\n    // disk number of the start of central directory\r\n    writeCounted(ZipShort.getBytes((int) cdDiskNumberStart));\r\n    // number of entries\r\n    final int numberOfEntries \u003d entries.size();\r\n    // total number of entries in the central directory on this disk\r\n    final int numOfEntriesOnThisDisk \u003d isSplitZip ? numberOfCDInDiskData.getOrDefault(numberOfThisDisk, 0) : numberOfEntries;\r\n    final byte[] numOfEntriesOnThisDiskData \u003d ZipShort.getBytes(Math.min(numOfEntriesOnThisDisk, ZipConstants.ZIP64_MAGIC_SHORT));\r\n    writeCounted(numOfEntriesOnThisDiskData);\r\n    // number of entries\r\n    final byte[] num \u003d ZipShort.getBytes(Math.min(numberOfEntries, ZipConstants.ZIP64_MAGIC_SHORT));\r\n    writeCounted(num);\r\n    // length and location of CD\r\n    writeCounted(ZipLong.getBytes(Math.min(cdLength, ZipConstants.ZIP64_MAGIC)));\r\n    writeCounted(ZipLong.getBytes(Math.min(cdOffset, ZipConstants.ZIP64_MAGIC)));\r\n    // ZIP file comment\r\n    final ByteBuffer data \u003d this.zipEncoding.encode(comment);\r\n    final int dataLen \u003d data.limit() - data.position();\r\n    writeCounted(ZipShort.getBytes(dataLen));\r\n    streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\r\n}"
      },
      {
        "name": "ZipArchiveOutputStream#writeCentralDirectoryInChunks(...0)",
        "body": "{\r\n    final int NUM_PER_WRITE \u003d 1000;\r\n    final ByteArrayOutputStream byteArrayOutputStream \u003d new ByteArrayOutputStream(70 * NUM_PER_WRITE);\r\n    int count \u003d 0;\r\n    for (final ZipArchiveEntry ze : entries) {\r\n        byteArrayOutputStream.write(createCentralFileHeader(ze));\r\n        if (++count \u003e NUM_PER_WRITE) {\r\n            writeCounted(byteArrayOutputStream.toByteArray());\r\n            byteArrayOutputStream.reset();\r\n            count \u003d 0;\r\n        }\r\n    }\r\n    writeCounted(byteArrayOutputStream.toByteArray());\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    if (out !\u003d null) {\r\n        out.flush();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  $r1 \u003d OutputStream out\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d OutputStream out\u003e\n  $r2.flush()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "getEncoding",
    "signature": "java.lang.String getEncoding()",
    "visibility": "public",
    "body": "{\r\n    return charset !\u003d null ? charset.name() : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  $r1 \u003d Charset charset\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Charset charset\u003e\n  $r3 \u003d $r2.name()\n  goto B3\n}",
      "B2 {\n  $r3 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "setLevel",
    "signature": "void setLevel(int)",
    "visibility": "public",
    "body": "{\r\n    if (level \u003c Deflater.DEFAULT_COMPRESSION || level \u003e Deflater.BEST_COMPRESSION) {\r\n        throw new IllegalArgumentException(\"Invalid compression level: \" + level);\r\n    }\r\n    if (this.level \u003d\u003d level) {\r\n        return;\r\n    }\r\n    hasCompressionLevelChanged \u003d true;\r\n    this.level \u003d level;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c $i3) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d 9) → B2 | else → B3",
      "B3 : If($i1 !\u003d i0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  i0 :\u003d @parameter0: int\n  $i3 \u003d (int) -1\n  if (i0 \u003c $i3) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d 9) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r6.append(\"Invalid compression level: \")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IllegalArgumentException($r4)\n  throw $r7\n}",
      "B3 {\n  $i1 \u003d ZipArchiveOutputStream: int level\u003e\n  if ($i1 !\u003d i0) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  ZipArchiveOutputStream: boolean hasCompressionLevelChanged\u003e \u003d 1\n  ZipArchiveOutputStream: int level\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "setUseLanguageEncodingFlag",
    "signature": "void setUseLanguageEncodingFlag(boolean)",
    "visibility": "public",
    "body": "{\r\n    useUtf8Flag \u003d b \u0026\u0026 ZipEncodingHelper.isUTF8(charset);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  z0 :\u003d @parameter0: boolean\n  if (z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r1 \u003d Charset charset\u003e\n  $z1 \u003d ZipEncodingHelper.isUTF8($r1)\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  ZipArchiveOutputStream: boolean useUtf8Flag\u003e \u003d $z2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (entry \u003d\u003d null) {\r\n        throw new IllegalStateException(\"No current entry\");\r\n    }\r\n    ZipUtil.checkRequestedFeatures(entry.entry);\r\n    final long writtenThisTime \u003d streamCompressor.write(b, offset, length, entry.entry.getMethod());\r\n    count(writtenThisTime);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  r4 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $r1 \u003d ZipArchiveOutputStream$CurrentEntry entry\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalStateException\n  new IllegalStateException(\"No current entry\")\n  throw $r8\n}",
      "B2 {\n  $r2 \u003d ZipArchiveOutputStream$CurrentEntry entry\u003e\n  $r3 \u003d ZipArchiveOutputStream$CurrentEntry.access$000($r2)\n  ZipUtil.checkRequestedFeatures($r3)\n  $r6 \u003d StreamCompressor streamCompressor\u003e\n  $r5 \u003d ZipArchiveOutputStream$CurrentEntry entry\u003e\n  $r7 \u003d ZipArchiveOutputStream$CurrentEntry.access$000($r5)\n  $i2 \u003d $r7.getMethod()\n  l3 \u003d $r6.write(r4, i0, i1, $i2)\n  r0.count(l3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipArchiveOutputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream",
    "methodName": "writePreamble",
    "signature": "void writePreamble(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (entry !\u003d null) {\r\n        throw new IllegalStateException(\"Preamble must be written before creating an entry\");\r\n    }\r\n    this.streamCompressor.writeCounted(preamble, offset, length);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipArchiveOutputStream\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $r1 \u003d ZipArchiveOutputStream$CurrentEntry entry\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalStateException\n  new IllegalStateException(\"Preamble must be written before creating an entry\")\n  throw $r4\n}",
      "B2 {\n  $r3 \u003d StreamCompressor streamCompressor\u003e\n  $r3.writeCounted(r2, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (!(o instanceof ZipEightByteInteger)) {\r\n        return false;\r\n    }\r\n    return value \u003d\u003d ((ZipEightByteInteger) o).value;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($b2 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipEightByteInteger\n  Object\n  $z0 \u003d ZipEightByteInteger\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l1 \u003d ZipEightByteInteger: long value\u003e\n  $r2 \u003d ZipEightByteInteger) r0\n  $l0 \u003d ZipEightByteInteger: long value\u003e\n  $b2 \u003d $l1 cmp $l0\n  if ($b2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z1 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z1 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipFile",
    "methodName": "copyRawEntries",
    "signature": "void copyRawEntries(org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream,org.apache.commons.compress.archivers.zip.ZipArchiveEntryPredicate)",
    "visibility": "public",
    "body": "{\r\n    final Enumeration\u003cZipArchiveEntry\u003e src \u003d getEntriesInPhysicalOrder();\r\n    while (src.hasMoreElements()) {\r\n        final ZipArchiveEntry entry \u003d src.nextElement();\r\n        if (predicate.test(entry)) {\r\n            target.addRawArchiveEntry(entry, getRawInputStream(entry));\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipFile\n  ZipArchiveOutputStream\n  ZipArchiveEntryPredicate\n  r1 \u003d r0.getEntriesInPhysicalOrder()\n}",
      "B1 {\n  $z0 \u003d r1.hasMoreElements()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r2 \u003d r1.nextElement()\n  r3 \u003d ZipArchiveEntry) $r2\n  $z1 \u003d r4.test(r3)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r0.getRawInputStream(r3)\n  r5.addRawArchiveEntry(r3, $r6)\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipFile#getRawInputStream(...1)",
        "body": "{\r\n    if (!(entry instanceof Entry)) {\r\n        return null;\r\n    }\r\n    final long start \u003d getDataOffset(entry);\r\n    if (start \u003d\u003d EntryStreamOffsets.OFFSET_UNKNOWN) {\r\n        return null;\r\n    }\r\n    return createBoundedInputStream(start, entry.getCompressedSize());\r\n}"
      },
      {
        "name": "ZipFile#getEntriesInPhysicalOrder(...0)",
        "body": "{\r\n    final ZipArchiveEntry[] allEntries \u003d entries.toArray(ZipArchiveEntry.EMPTY_ARRAY);\r\n    return Collections.enumeration(Arrays.asList(sortByOffset(allEntries)));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipFile",
    "methodName": "getContentBeforeFirstLocalFileHeader",
    "signature": "java.io.InputStream getContentBeforeFirstLocalFileHeader()",
    "visibility": "public",
    "body": "{\r\n    return firstLocalFileHeaderOffset \u003d\u003d 0 ? null : createBoundedInputStream(0, firstLocalFileHeaderOffset);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipFile\n  $l0 \u003d ZipFile: long firstLocalFileHeaderOffset\u003e\n  $b1 \u003d $l0 cmp 0L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d null\n  goto B3\n}",
      "B2 {\n  $l2 \u003d ZipFile: long firstLocalFileHeaderOffset\u003e\n  $r1 \u003d r0.createBoundedInputStream(0L, $l2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipFile#createBoundedInputStream(...2)",
        "body": "{\r\n    if (start \u003c 0 || remaining \u003c 0 || start + remaining \u003c start) {\r\n        throw new IllegalArgumentException(\"Corrupted archive, stream boundaries\" + \" are out of range\");\r\n    }\r\n    return archive instanceof FileChannel ? new BoundedFileChannelInputStream(start, remaining, (FileChannel) archive) : new BoundedSeekableByteChannelInputStream(start, remaining, archive);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipFile",
    "methodName": "getEntry",
    "signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry getEntry(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final LinkedList\u003cZipArchiveEntry\u003e entries \u003d nameMap.get(name);\r\n    return entries !\u003d null ? entries.getFirst() : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZipFile\n  String\n  $r2 \u003d Map nameMap\u003e\n  $r3 \u003d $r2.get(r1)\n  r4 \u003d LinkedList) $r3\n  if (r4 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r4.getFirst()\n  $r6 \u003d ZipArchiveEntry) $r5\n  goto B3\n}",
      "B2 {\n  $r6 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipFile",
    "methodName": "getRawInputStream",
    "signature": "java.io.InputStream getRawInputStream(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    if (!(entry instanceof Entry)) {\r\n        return null;\r\n    }\r\n    final long start \u003d getDataOffset(entry);\r\n    if (start \u003d\u003d EntryStreamOffsets.OFFSET_UNKNOWN) {\r\n        return null;\r\n    }\r\n    return createBoundedInputStream(start, entry.getCompressedSize());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($b1 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipFile\n  ZipArchiveEntry\n  $z0 \u003d ZipFile$Entry\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  l0 \u003d r1.getDataOffset(r0)\n  $b1 \u003d l0 cmp -1L\n  if ($b1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $l2 \u003d r0.getCompressedSize()\n  $r2 \u003d r1.createBoundedInputStream(l0, $l2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipFile#createBoundedInputStream(...2)",
        "body": "{\r\n    if (start \u003c 0 || remaining \u003c 0 || start + remaining \u003c start) {\r\n        throw new IllegalArgumentException(\"Corrupted archive, stream boundaries\" + \" are out of range\");\r\n    }\r\n    return archive instanceof FileChannel ? new BoundedFileChannelInputStream(start, remaining, (FileChannel) archive) : new BoundedSeekableByteChannelInputStream(start, remaining, archive);\r\n}"
      },
      {
        "name": "ZipFile#getDataOffset(...1)",
        "body": "{\r\n    final long s \u003d ze.getDataOffset();\r\n    if (s \u003d\u003d EntryStreamOffsets.OFFSET_UNKNOWN) {\r\n        setDataOffset(ze);\r\n        return ze.getDataOffset();\r\n    }\r\n    return s;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipFile",
    "methodName": "getUnixSymlink",
    "signature": "java.lang.String getUnixSymlink(org.apache.commons.compress.archivers.zip.ZipArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    if (entry !\u003d null \u0026\u0026 entry.isUnixSymlink()) {\r\n        try (InputStream in \u003d getInputStream(entry)) {\r\n            return zipEncoding.decode(org.apache.commons.io.IOUtils.toByteArray(in));\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B9",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B9",
      "B2 : If(r2 \u003d\u003d null) → B3 | else → B4",
      "B5 : If(r2 \u003d\u003d null) → B6 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ZipFile\n  ZipArchiveEntry\n  if (r0 \u003d\u003d null) goto B1 else B9\n}",
      "B1 {\n  $z0 \u003d r0.isUnixSymlink()\n  if ($z0 \u003d\u003d false) goto B2 else B9\n}",
      "B2 {\n  r2 \u003d r1.getInputStream(r0)\n  $r3 \u003d ZipEncoding zipEncoding\u003e\n  $r4 \u003d IOUtils.toByteArray(r2)\n  r7 \u003d $r3.decode($r4)\n  if (r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  r2.close()\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r6 :\u003d @caughtexception\n  if (r2 \u003d\u003d null) goto B6 else B8\n}",
      "B6 {\n  r2.close()\n  goto B8\n}",
      "B7 {\n  $r5 :\u003d @caughtexception\n  $r6.addSuppressed($r5)\n}",
      "B8 {\n  throw $r6\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B9",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipFile#getInputStream(...1)",
        "body": "{\r\n    if (!(entry instanceof Entry)) {\r\n        return null;\r\n    }\r\n    // cast validity is checked just above\r\n    ZipUtil.checkRequestedFeatures(entry);\r\n    // doesn\u0027t get closed if the method is not supported - which\r\n    // should never happen because of the checkRequestedFeatures\r\n    // call above\r\n    // NOSONAR\r\n    final InputStream is \u003d new BufferedInputStream(getRawInputStream(entry));\r\n    switch(ZipMethod.getMethodByCode(entry.getMethod())) {\r\n        case STORED:\r\n            return new StoredStatisticsStream(is);\r\n        case UNSHRINKING:\r\n            return new UnshrinkingInputStream(is);\r\n        case IMPLODING:\r\n            try {\r\n                return new ExplodingInputStream(entry.getGeneralPurposeBit().getSlidingDictionarySize(), entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);\r\n            } catch (final IllegalArgumentException ex) {\r\n                throw new IOException(\"bad IMPLODE data\", ex);\r\n            }\r\n        case DEFLATED:\r\n            final Inflater inflater \u003d new Inflater(true);\r\n            // Inflater with nowrap\u003dtrue has this odd contract for a zero padding\r\n            // byte following the data stream; this used to be zlib\u0027s requirement\r\n            // and has been fixed a long time ago, but the contract persists so\r\n            // we comply.\r\n            // https://docs.oracle.com/javase/8/docs/api/java/util/zip/Inflater.html#Inflater(boolean)\r\n            return new InflaterInputStreamWithStatistics(new SequenceInputStream(is, new ByteArrayInputStream(ONE_ZERO_BYTE)), inflater) {\r\n\r\n                @Override\r\n                public void close() throws IOException {\r\n                    try {\r\n                        super.close();\r\n                    } finally {\r\n                        inflater.end();\r\n                    }\r\n                }\r\n            };\r\n        case BZIP2:\r\n            return new BZip2CompressorInputStream(is);\r\n        case ENHANCED_DEFLATED:\r\n            return new Deflate64CompressorInputStream(is);\r\n        case ZSTD:\r\n        case ZSTD_DEPRECATED:\r\n            return createZstdInputStream(is);\r\n        case XZ:\r\n            return new XZCompressorInputStream(is);\r\n        case AES_ENCRYPTED:\r\n        case EXPANDING_LEVEL_1:\r\n        case EXPANDING_LEVEL_2:\r\n        case EXPANDING_LEVEL_3:\r\n        case EXPANDING_LEVEL_4:\r\n        case JPEG:\r\n        case LZMA:\r\n        case PKWARE_IMPLODING:\r\n        case PPMD:\r\n        case TOKENIZATION:\r\n        case UNKNOWN:\r\n        case WAVPACK:\r\n        default:\r\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(entry.getMethod()), entry);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipLong",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (!(o instanceof ZipLong)) {\r\n        return false;\r\n    }\r\n    return value \u003d\u003d ((ZipLong) o).getValue();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($b2 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipLong\n  Object\n  $z0 \u003d ZipLong\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $l0 \u003d ZipLong: long value\u003e\n  $r2 \u003d ZipLong) r0\n  $l1 \u003d $r2.getValue()\n  $b2 \u003d $l0 cmp $l1\n  if ($b2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z1 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z1 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipShort",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (!(o instanceof ZipShort)) {\r\n        return false;\r\n    }\r\n    return value \u003d\u003d ((ZipShort) o).getValue();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i0 !\u003d $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ZipShort\n  Object\n  $z0 \u003d ZipShort\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d ZipShort: int value\u003e\n  $r2 \u003d ZipShort) r0\n  $i1 \u003d $r2.getValue()\n  if ($i0 !\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  $z1 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z1 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel",
    "methodName": "buildFromLastSplitSegment",
    "signature": "java.nio.channels.SeekableByteChannel buildFromLastSplitSegment(java.nio.file.Path)",
    "visibility": "public",
    "body": "{\r\n    final String extension \u003d PathUtils.getExtension(lastSegmentPath);\r\n    if (!extension.equalsIgnoreCase(ArchiveStreamFactory.ZIP)) {\r\n        throw new IllegalArgumentException(\"The extension of last ZIP split segment should be .zip\");\r\n    }\r\n    final Path parent \u003d Objects.nonNull(lastSegmentPath.getParent()) ? lastSegmentPath.getParent() : lastSegmentPath.getFileSystem().getPath(\".\");\r\n    final String fileBaseName \u003d PathUtils.getBaseName(lastSegmentPath);\r\n    final ArrayList\u003cPath\u003e splitZipSegments;\r\n    // ZIP split segments should be like z01,z02....z(n-1) based on the ZIP specification\r\n    final Pattern pattern \u003d Pattern.compile(Pattern.quote(fileBaseName) + \".[zZ][0-9]+\");\r\n    try (Stream\u003cPath\u003e walk \u003d Files.walk(parent, 1)) {\r\n        splitZipSegments \u003d walk.filter(Files::isRegularFile).filter(path -\u003e pattern.matcher(path.getFileName().toString()).matches()).sorted(new ZipSplitSegmentComparator()).collect(Collectors.toCollection(ArrayList::new));\r\n    }\r\n    return forPaths(lastSegmentPath, splitZipSegments);\r\n}",
    "nodes": 12,
    "edges": 13,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B5 : If($r23 \u003d\u003d null) → B6 | else → B11",
      "B7 : If($r23 \u003d\u003d null) → B8 | else → B10"
    ],
    "blockList": [
      "B0 {\n  Path\n  r1 \u003d PathUtils.getExtension(r0)\n  $z0 \u003d r1.equalsIgnoreCase(\"zip\")\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r25 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"The extension of last ZIP split segment should be .zip\")\n  throw $r25\n}",
      "B2 {\n  $r2 \u003d r0.getParent()\n  $z1 \u003d Objects.nonNull($r2)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r28 \u003d r0.getParent()\n  goto B5\n}",
      "B4 {\n  $r4 \u003d r0.getFileSystem()\n  $r3 \u003d String)[0]\n  $r28 \u003d $r4.getPath(\".\", $r3)\n}",
      "B5 {\n  $r21 \u003d PathUtils.getBaseName(r0)\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d Pattern.quote($r21)\n  $r7 \u003d $r5.append($r6)\n  $r8 \u003d $r7.append(\".zZ0-9+\")\n  $r9 \u003d $r8.toString()\n  $r22 \u003d Pattern.compile($r9)\n  $r10 \u003d FileVisitOption)[0]\n  $r23 \u003d Files.walk($r28, 1, $r10)\n  $r11 \u003d ZipSplitReadOnlySeekableByteChannel$lambda_buildFromLastSplitSegment_0__19.bootstrap$()\n  $r13 \u003d $r23.filter($r11)\n  $r12 \u003d ZipSplitReadOnlySeekableByteChannel$lambda_buildFromLastSplitSegment_1__20.bootstrap$($r22)\n  $r15 \u003d $r13.filter($r12)\n  $r14 \u003d ZipSplitReadOnlySeekableByteChannel$ZipSplitSegmentComparator\n  new ZipSplitReadOnlySeekableByteChannel$ZipSplitSegmentComparator(null)\n  $r18 \u003d $r15.sorted($r14)\n  $r16 \u003d ZipSplitReadOnlySeekableByteChannel$init__21.bootstrap$()\n  $r17 \u003d Collectors.toCollection($r16)\n  $r19 \u003d $r18.collect($r17)\n  $r24 \u003d ArrayList) $r19\n  if ($r23 \u003d\u003d null) goto B6 else B11\n}",
      "B6 {\n  $r23.close()\n  goto B11\n}",
      "B7 {\n  $r27 :\u003d @caughtexception\n  if ($r23 \u003d\u003d null) goto B8 else B10\n}",
      "B8 {\n  $r23.close()\n  goto B10\n}",
      "B9 {\n  $r26 :\u003d @caughtexception\n  $r27.addSuppressed($r26)\n}",
      "B10 {\n  throw $r27\n}",
      "B11 {\n  $r20 \u003d ZipSplitReadOnlySeekableByteChannel.forPaths(r0, $r24)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipSplitReadOnlySeekableByteChannel#forPaths(...2)",
        "body": "{\r\n    final List\u003cSeekableByteChannel\u003e channels \u003d new ArrayList\u003c\u003e();\r\n    for (final Path path : Objects.requireNonNull(paths, \"paths\")) {\r\n        channels.add(Files.newByteChannel(path, openOptions));\r\n    }\r\n    if (channels.size() \u003d\u003d 1) {\r\n        return channels.get(0);\r\n    }\r\n    return new ZipSplitReadOnlySeekableByteChannel(channels);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel",
    "methodName": "forFiles",
    "signature": "java.nio.channels.SeekableByteChannel forFiles(java.io.File[])",
    "visibility": "public",
    "body": "{\r\n    final List\u003cPath\u003e paths \u003d new ArrayList\u003c\u003e();\r\n    for (final File f : Objects.requireNonNull(files, \"files\")) {\r\n        paths.add(f.toPath());\r\n    }\r\n    return forPaths(paths.toArray(EMPTY_PATH_ARRAY));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  File[]\n  $r0 \u003d ArrayList\n  new ArrayList()\n  $r2 \u003d Objects.requireNonNull(r1, \"files\")\n  r3 \u003d File[]) $r2\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r8 \u003d r3[i1]\n  $r9 \u003d r8.toPath()\n  $r0.add($r9)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  $r4 \u003d Path[] EMPTY_PATH_ARRAY\u003e\n  $r5 \u003d $r0.toArray($r4)\n  $r6 \u003d Path[]) $r5\n  $r7 \u003d ZipSplitReadOnlySeekableByteChannel.forPaths($r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZipSplitReadOnlySeekableByteChannel#forPaths(...1)",
        "body": "{\r\n    return forPaths(Arrays.asList(paths), new OpenOption[] { StandardOpenOption.READ });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel",
    "methodName": "forOrderedSeekableByteChannels",
    "signature": "java.nio.channels.SeekableByteChannel forOrderedSeekableByteChannels(java.nio.channels.SeekableByteChannel[])",
    "visibility": "public",
    "body": "{\r\n    if (Objects.requireNonNull(channels, \"channels\").length \u003d\u003d 1) {\r\n        return channels[0];\r\n    }\r\n    return new ZipSplitReadOnlySeekableByteChannel(Arrays.asList(channels));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SeekableByteChannel[]\n  $r1 \u003d Objects.requireNonNull(r0, \"channels\")\n  $r2 \u003d SeekableByteChannel[]) $r1\n  $i0 \u003d lengthof $r2\n  if ($i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0[0]\n  return\n}",
      "B2 {\n  $r3 \u003d ZipSplitReadOnlySeekableByteChannel\n  $r4 \u003d Arrays.asList(r0)\n  new ZipSplitReadOnlySeekableByteChannel($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.archivers.zip.ZipSplitReadOnlySeekableByteChannel",
    "methodName": "forPaths",
    "signature": "java.nio.channels.SeekableByteChannel forPaths(java.util.List,java.nio.file.OpenOption[])",
    "visibility": "public",
    "body": "{\r\n    final List\u003cSeekableByteChannel\u003e channels \u003d new ArrayList\u003c\u003e();\r\n    for (final Path path : Objects.requireNonNull(paths, \"paths\")) {\r\n        channels.add(Files.newByteChannel(path, openOptions));\r\n    }\r\n    if (channels.size() \u003d\u003d 1) {\r\n        return channels.get(0);\r\n    }\r\n    return new ZipSplitReadOnlySeekableByteChannel(channels);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($i0 !\u003d 1) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  List\n  OpenOption[]\n  $r0 \u003d ArrayList\n  new ArrayList()\n  $r2 \u003d Objects.requireNonNull(r1, \"paths\")\n  $r3 \u003d List) $r2\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d r4.next()\n  r9 \u003d Path) $r8\n  $r11 \u003d Files.newByteChannel(r9, r10)\n  $r0.add($r11)\n  goto B1\n}",
      "B3 {\n  $i0 \u003d $r0.size()\n  if ($i0 !\u003d 1) goto B4 else B5\n}",
      "B4 {\n  $r6 \u003d $r0.get(0)\n  $r7 \u003d SeekableByteChannel) $r6\n  return\n}",
      "B5 {\n  $r5 \u003d ZipSplitReadOnlySeekableByteChannel\n  new ZipSplitReadOnlySeekableByteChannel($r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.brotli.BrotliCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    final int ret \u003d brotliInputStream.read();\r\n    count(ret \u003d\u003d -1 ? 0 : 1);\r\n    return ret;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BrotliCompressorInputStream\n  $r1 \u003d BrotliInputStream brotliInputStream\u003e\n  i0 \u003d $r1.read()\n  $i3 \u003d (int) -1\n  if (i0 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d 0\n  goto B3\n}",
      "B2 {\n  $b1 \u003d 1\n}",
      "B3 {\n  r0.count($b1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BrotliCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.brotli.BrotliUtils",
    "methodName": "isBrotliCompressionAvailable",
    "signature": "boolean isBrotliCompressionAvailable()",
    "visibility": "public",
    "body": "{\r\n    final CachedAvailability cachedResult \u003d cachedBrotliAvailability;\r\n    if (cachedResult !\u003d CachedAvailability.DONT_CACHE) {\r\n        return cachedResult \u003d\u003d CachedAvailability.CACHED_AVAILABLE;\r\n    }\r\n    return internalIsBrotliCompressionAvailable();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r1) → B1 | else → B5",
      "B1 : If(r0 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 \u003d BrotliUtils$CachedAvailability cachedBrotliAvailability\u003e\n  $r1 \u003d BrotliUtils$CachedAvailability DONT_CACHE\u003e\n  if (r0 \u003d\u003d $r1) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d BrotliUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  if (r0 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d BrotliUtils.internalIsBrotliCompressionAvailable()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BrotliUtils#internalIsBrotliCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        Class.forName(\"org.brotli.dec.BrotliInputStream\");\r\n        return true;\r\n    } catch (final NoClassDefFoundError | Exception error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.brotli.BrotliUtils",
    "methodName": "setCacheBrotliAvailablity",
    "signature": "void setCacheBrotliAvailablity(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!doCache) {\r\n        cachedBrotliAvailability \u003d CachedAvailability.DONT_CACHE;\r\n    } else if (cachedBrotliAvailability \u003d\u003d CachedAvailability.DONT_CACHE) {\r\n        final boolean hasBrotli \u003d internalIsBrotliCompressionAvailable();\r\n        cachedBrotliAvailability \u003d hasBrotli ? CachedAvailability.CACHED_AVAILABLE : CachedAvailability.CACHED_UNAVAILABLE;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d $r0) → B3 | else → B7",
      "B3 : If(z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d BrotliUtils$CachedAvailability DONT_CACHE\u003e\n  BrotliUtils$CachedAvailability cachedBrotliAvailability\u003e \u003d $r2\n  goto B7\n}",
      "B2 {\n  $r1 \u003d BrotliUtils$CachedAvailability cachedBrotliAvailability\u003e\n  $r0 \u003d BrotliUtils$CachedAvailability DONT_CACHE\u003e\n  if ($r1 !\u003d $r0) goto B3 else B7\n}",
      "B3 {\n  z1 \u003d BrotliUtils.internalIsBrotliCompressionAvailable()\n  if (z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d BrotliUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  goto B6\n}",
      "B5 {\n  $r3 \u003d BrotliUtils$CachedAvailability CACHED_UNAVAILABLE\u003e\n}",
      "B6 {\n  BrotliUtils$CachedAvailability cachedBrotliAvailability\u003e \u003d $r3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BrotliUtils#internalIsBrotliCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        Class.forName(\"org.brotli.dec.BrotliInputStream\");\r\n        return true;\r\n    } catch (final NoClassDefFoundError | Exception error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return length \u003e\u003d 3 \u0026\u0026 signature[0] \u003d\u003d \u0027B\u0027 \u0026\u0026 signature[1] \u003d\u003d \u0027Z\u0027 \u0026\u0026 signature[2] \u003d\u003d \u0027h\u0027;\r\n}",
    "nodes": 7,
    "edges": 10,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003c 3) → B1 | else → B5",
      "B1 : If($i4 !\u003d 66) → B2 | else → B5",
      "B2 : If($i5 !\u003d 90) → B3 | else → B5",
      "B3 : If($i6 !\u003d 104) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c 3) goto B1 else B5\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $i4 \u003d (int) $b1\n  if ($i4 !\u003d 66) goto B2 else B5\n}",
      "B2 {\n  $b2 \u003d r0[1]\n  $i5 \u003d (int) $b2\n  if ($i5 !\u003d 90) goto B3 else B5\n}",
      "B3 {\n  $b3 \u003d r0[2]\n  $i6 \u003d (int) $b3\n  if ($i6 !\u003d 104) goto B4 else B5\n}",
      "B4 {\n  $z0 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z0 \u003d 0\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    final BitInputStream inShadow \u003d this.bin;\r\n    if (inShadow !\u003d null) {\r\n        try {\r\n            inShadow.close();\r\n        } finally {\r\n            this.data \u003d null;\r\n            this.bin \u003d null;\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorInputStream\n  r1 \u003d BitInputStream bin\u003e\n  if (r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  r1.close()\n  BZip2CompressorInputStream$Data data\u003e \u003d null\n  BitInputStream bin\u003e \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 :\u003d @caughtexception\n  BZip2CompressorInputStream$Data data\u003e \u003d null\n  BitInputStream bin\u003e \u003d null\n  throw $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    if (this.bin !\u003d null) {\r\n        final int r \u003d read0();\r\n        count(r \u003c 0 ? -1 : 1);\r\n        return r;\r\n    }\r\n    throw new IOException(\"Stream closed\");\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B5",
      "B1 : If(i0 \u003e\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorInputStream\n  $r1 \u003d BitInputStream bin\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  i0 \u003d r0.read0()\n  if (i0 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $b1 \u003d -1\n  goto B4\n}",
      "B3 {\n  $b1 \u003d 1\n}",
      "B4 {\n  r0.count($b1)\n  return\n}",
      "B5 {\n  $r2 \u003d IOException\n  new IOException(\"Stream closed\")\n  throw $r2\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BZip2CompressorInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "BZip2CompressorInputStream#read0(...0)",
        "body": "{\r\n    switch(currentState) {\r\n        case EOF:\r\n            return -1;\r\n        case START_BLOCK_STATE:\r\n            return setupBlock();\r\n        case RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_B_STATE:\r\n            return setupRandPartB();\r\n        case RAND_PART_C_STATE:\r\n            return setupRandPartC();\r\n        case NO_RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case NO_RAND_PART_B_STATE:\r\n            return setupNoRandPartB();\r\n        case NO_RAND_PART_C_STATE:\r\n            return setupNoRandPartC();\r\n        default:\r\n            throw new IllegalStateException();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (offs \u003c 0) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") \u003c 0.\");\r\n    }\r\n    if (len \u003c 0) {\r\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") \u003c 0.\");\r\n    }\r\n    if (offs + len \u003e dest.length) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") \u003e dest.length(\" + dest.length + \").\");\r\n    }\r\n    if (this.bin \u003d\u003d null) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final int hi \u003d offs + len;\r\n    int destOffs \u003d offs;\r\n    int b;\r\n    while (destOffs \u003c hi \u0026\u0026 (b \u003d read0()) \u003e\u003d 0) {\r\n        dest[destOffs++] \u003d (byte) b;\r\n        count(1);\r\n    }\r\n    return destOffs \u003d\u003d offs ? -1 : destOffs - offs;\r\n}",
    "nodes": 18,
    "edges": 20,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If($i3 \u003c\u003d $i2) → B5 | else → B6",
      "B6 : If($r2 !\u003d null) → B7 | else → B8",
      "B8 : If(i1 !\u003d 0) → B9 | else → B10",
      "B11 : If(i9 \u003e\u003d i4) → B12 | else → B14",
      "B12 : If($i5 \u003c 0) → B13 | else → B14",
      "B14 : If(i9 !\u003d i0) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorInputStream\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r27 \u003d IndexOutOfBoundsException\n  $r26 \u003d StringBuilder\n  new StringBuilder()\n  $r22 \u003d $r26.append(\"offs(\")\n  $r23 \u003d $r22.append(i0)\n  $r24 \u003d $r23.append(\") \u003c 0.\")\n  $r25 \u003d $r24.toString()\n  new IndexOutOfBoundsException($r25)\n  throw $r27\n}",
      "B2 {\n  if (i1 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r29 \u003d IndexOutOfBoundsException\n  $r28 \u003d StringBuilder\n  new StringBuilder()\n  $r16 \u003d $r28.append(\"len(\")\n  $r17 \u003d $r16.append(i1)\n  $r18 \u003d $r17.append(\") \u003c 0.\")\n  $r19 \u003d $r18.toString()\n  new IndexOutOfBoundsException($r19)\n  throw $r29\n}",
      "B4 {\n  $i3 \u003d i0 + i1\n  $i2 \u003d lengthof r0\n  if ($i3 \u003c\u003d $i2) goto B5 else B6\n}",
      "B5 {\n  $r31 \u003d IndexOutOfBoundsException\n  $r30 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r30.append(\"offs(\")\n  $r7 \u003d $r6.append(i0)\n  $r8 \u003d $r7.append(\") + len(\")\n  $r9 \u003d $r8.append(i1)\n  $r10 \u003d $r9.append(\") \u003e dest.length(\")\n  $i8 \u003d lengthof r0\n  $r11 \u003d $r10.append($i8)\n  $r12 \u003d $r11.append(\").\")\n  $r13 \u003d $r12.toString()\n  new IndexOutOfBoundsException($r13)\n  throw $r31\n}",
      "B6 {\n  $r2 \u003d BitInputStream bin\u003e\n  if ($r2 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r32 \u003d IOException\n  new IOException(\"Stream closed\")\n  throw $r32\n}",
      "B8 {\n  if (i1 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  i4 \u003d i0 + i1\n  i9 \u003d i0\n}",
      "B11 {\n  if (i9 \u003e\u003d i4) goto B12 else B14\n}",
      "B12 {\n  $i5 \u003d r1.read0()\n  if ($i5 \u003c 0) goto B13 else B14\n}",
      "B13 {\n  $i6 \u003d i9\n  i9 \u003d i9 + 1\n  $b7 \u003d (byte) $i5\n  r0[$i6] \u003d $b7\n  r1.count(1)\n  goto B11\n}",
      "B14 {\n  if (i9 !\u003d i0) goto B15 else B16\n}",
      "B15 {\n  $i12 \u003d (int) -1\n  $i10 \u003d $i12\n  goto B17\n}",
      "B16 {\n  $i10 \u003d i9 - i0\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B11",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BZip2CompressorInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "BZip2CompressorInputStream#read0(...0)",
        "body": "{\r\n    switch(currentState) {\r\n        case EOF:\r\n            return -1;\r\n        case START_BLOCK_STATE:\r\n            return setupBlock();\r\n        case RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_B_STATE:\r\n            return setupRandPartB();\r\n        case RAND_PART_C_STATE:\r\n            return setupRandPartC();\r\n        case NO_RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case NO_RAND_PART_B_STATE:\r\n            return setupNoRandPartB();\r\n        case NO_RAND_PART_C_STATE:\r\n            return setupNoRandPartC();\r\n        default:\r\n            throw new IllegalStateException();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream",
    "methodName": "chooseBlockSize",
    "signature": "int chooseBlockSize(long)",
    "visibility": "public",
    "body": "{\r\n    return inputLength \u003e 0 ? (int) Math.min(inputLength / 132000 + 1, 9) : MAX_BLOCKSIZE;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i6 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i6 \u003d (int) $b1\n  if ($i6 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $l2 \u003d l0 / 132000L\n  $l3 \u003d $l2 + 1L\n  $l4 \u003d Math.min($l3, 9L)\n  $i5 \u003d (int) $l4\n  goto B3\n}",
      "B2 {\n  $i5 \u003d 9\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!isClosed()) {\r\n        try {\r\n            finish();\r\n        } finally {\r\n            super.close();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorOutputStream\n  $z0 \u003d r0.isClosed()\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  r0.finish()\n  r0.close()\n  goto B3\n}",
      "B2 {\n  $r1 :\u003d @caughtexception\n  r0.close()\n  throw $r1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BZip2CompressorOutputStream#finish(...0)",
        "body": "{\r\n    if (!isClosed()) {\r\n        try {\r\n            if (this.runLength \u003e 0) {\r\n                writeRun();\r\n            }\r\n            this.currentChar \u003d -1;\r\n            endBlock();\r\n            endCompression();\r\n        } finally {\r\n            this.blockSorter \u003d null;\r\n            this.data \u003d null;\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "BZip2CompressorOutputStream#isClosed(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!isClosed()) {\r\n        try {\r\n            if (this.runLength \u003e 0) {\r\n                writeRun();\r\n            }\r\n            this.currentChar \u003d -1;\r\n            endBlock();\r\n            endCompression();\r\n        } finally {\r\n            this.blockSorter \u003d null;\r\n            this.data \u003d null;\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B5",
      "B1 : If($i0 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorOutputStream\n  $z0 \u003d r0.isClosed()\n  if ($z0 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $i0 \u003d BZip2CompressorOutputStream: int runLength\u003e\n  if ($i0 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0.writeRun()\n}",
      "B3 {\n  $i2 \u003d (int) -1\n  BZip2CompressorOutputStream: int currentChar\u003e \u003d $i2\n  r0.endBlock()\n  r0.endCompression()\n  BlockSort blockSorter\u003e \u003d null\n  BZip2CompressorOutputStream$Data data\u003e \u003d null\n  goto B5\n}",
      "B4 {\n  $r1 :\u003d @caughtexception\n  BlockSort blockSorter\u003e \u003d null\n  BZip2CompressorOutputStream$Data data\u003e \u003d null\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BZip2CompressorOutputStream#writeRun(...0)",
        "body": "{\r\n    final int lastShadow \u003d this.last;\r\n    if (lastShadow \u003c this.allowableBlockSize) {\r\n        final int currentCharShadow \u003d this.currentChar;\r\n        final Data dataShadow \u003d this.data;\r\n        dataShadow.inUse[currentCharShadow] \u003d true;\r\n        final byte ch \u003d (byte) currentCharShadow;\r\n        int runLengthShadow \u003d this.runLength;\r\n        this.crc.update(currentCharShadow, runLengthShadow);\r\n        switch(runLengthShadow) {\r\n            case 1:\r\n                dataShadow.block[lastShadow + 2] \u003d ch;\r\n                this.last \u003d lastShadow + 1;\r\n                break;\r\n            case 2:\r\n                dataShadow.block[lastShadow + 2] \u003d ch;\r\n                dataShadow.block[lastShadow + 3] \u003d ch;\r\n                this.last \u003d lastShadow + 2;\r\n                break;\r\n            case 3:\r\n                {\r\n                    final byte[] block \u003d dataShadow.block;\r\n                    block[lastShadow + 2] \u003d ch;\r\n                    block[lastShadow + 3] \u003d ch;\r\n                    block[lastShadow + 4] \u003d ch;\r\n                    this.last \u003d lastShadow + 3;\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    runLengthShadow -\u003d 4;\r\n                    dataShadow.inUse[runLengthShadow] \u003d true;\r\n                    final byte[] block \u003d dataShadow.block;\r\n                    block[lastShadow + 2] \u003d ch;\r\n                    block[lastShadow + 3] \u003d ch;\r\n                    block[lastShadow + 4] \u003d ch;\r\n                    block[lastShadow + 5] \u003d ch;\r\n                    block[lastShadow + 6] \u003d (byte) runLengthShadow;\r\n                    this.last \u003d lastShadow + 5;\r\n                }\r\n                break;\r\n        }\r\n    } else {\r\n        endBlock();\r\n        initBlock();\r\n        writeRun();\r\n    }\r\n}"
      },
      {
        "name": "BZip2CompressorOutputStream#endBlock(...0)",
        "body": "{\r\n    final int blockCRC \u003d this.crc.getValue();\r\n    this.combinedCRC \u003d this.combinedCRC \u003c\u003c 1 | this.combinedCRC \u003e\u003e\u003e 31;\r\n    this.combinedCRC ^\u003d blockCRC;\r\n    // empty block at end of file\r\n    if (this.last \u003d\u003d -1) {\r\n        return;\r\n    }\r\n    /* sort the block and establish posn of original string */\r\n    blockSort();\r\n    /*\r\n         * A 6-byte block header, the value chosen arbitrarily as 0x314159265359 :-). A 32 bit value does not really give a strong enough guarantee that the\r\n         * value will not appear by chance in the compressed data stream. Worst-case probability of this event, for a 900k block, is about 2.0e-3 for 32 bits,\r\n         * 1.0e-5 for 40 bits and 4.0e-8 for 48 bits. For a compressed file of size 100Gb -- about 100000 blocks -- only a 48-bit marker will do. NB: normal\r\n         * compression/ decompression doesn\u0027t rely on these statistical properties. They are only important when trying to recover blocks from damaged files.\r\n         */\r\n    bsPutUByte(0x31);\r\n    bsPutUByte(0x41);\r\n    bsPutUByte(0x59);\r\n    bsPutUByte(0x26);\r\n    bsPutUByte(0x53);\r\n    bsPutUByte(0x59);\r\n    /* Now the block\u0027s CRC, so it is in a known place. */\r\n    bsPutInt(blockCRC);\r\n    /* Now a single bit indicating no randomization. */\r\n    bsW(1, 0);\r\n    /* Finally, block\u0027s contents proper. */\r\n    moveToFrontCodeAndSend();\r\n}"
      },
      {
        "name": "BZip2CompressorOutputStream#isClosed(...0)",
        "body": "(source not found)"
      },
      {
        "name": "BZip2CompressorOutputStream#endCompression(...0)",
        "body": "{\r\n    /*\r\n         * Now another magic 48-bit number, 0x177245385090, to indicate the end of the last block. (sqrt(pi), if you want to know. I did want to use e, but it\r\n         * contains too much repetition -- 27 18 28 18 28 46 -- for me to feel statistically comfortable. Call me paranoid.)\r\n         */\r\n    bsPutUByte(0x17);\r\n    bsPutUByte(0x72);\r\n    bsPutUByte(0x45);\r\n    bsPutUByte(0x38);\r\n    bsPutUByte(0x50);\r\n    bsPutUByte(0x90);\r\n    bsPutInt(this.combinedCRC);\r\n    bsFinishedWithStream();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    if (out !\u003d null) {\r\n        super.flush();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorOutputStream\n  $r1 \u003d OutputStream out\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0.flush()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (offs \u003c 0) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") \u003c 0.\");\r\n    }\r\n    if (len \u003c 0) {\r\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") \u003c 0.\");\r\n    }\r\n    if (offs + len \u003e buf.length) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") \u003e buf.length(\" + buf.length + \").\");\r\n    }\r\n    checkOpen();\r\n    for (final int hi \u003d offs + len; offs \u003c hi; ) {\r\n        write0(buf[offs++]);\r\n    }\r\n}",
    "nodes": 10,
    "edges": 10,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i7 \u003e\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If($i2 \u003c\u003d $i1) → B5 | else → B6",
      "B7 : If(i7 \u003e\u003d i3) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  BZip2CompressorOutputStream\n  r0 :\u003d @parameter0: byte[]\n  i7 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i7 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r25 \u003d IndexOutOfBoundsException\n  $r24 \u003d StringBuilder\n  new StringBuilder()\n  $r20 \u003d $r24.append(\"offs(\")\n  $r21 \u003d $r20.append(i7)\n  $r22 \u003d $r21.append(\") \u003c 0.\")\n  $r23 \u003d $r22.toString()\n  new IndexOutOfBoundsException($r23)\n  throw $r25\n}",
      "B2 {\n  if (i0 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r27 \u003d IndexOutOfBoundsException\n  $r26 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r26.append(\"len(\")\n  $r15 \u003d $r14.append(i0)\n  $r16 \u003d $r15.append(\") \u003c 0.\")\n  $r17 \u003d $r16.toString()\n  new IndexOutOfBoundsException($r17)\n  throw $r27\n}",
      "B4 {\n  $i2 \u003d i7 + i0\n  $i1 \u003d lengthof r0\n  if ($i2 \u003c\u003d $i1) goto B5 else B6\n}",
      "B5 {\n  $r29 \u003d IndexOutOfBoundsException\n  $r28 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r28.append(\"offs(\")\n  $r5 \u003d $r4.append(i7)\n  $r6 \u003d $r5.append(\") + len(\")\n  $r7 \u003d $r6.append(i0)\n  $r8 \u003d $r7.append(\") \u003e buf.length(\")\n  $i6 \u003d lengthof r0\n  $r9 \u003d $r8.append($i6)\n  $r10 \u003d $r9.append(\").\")\n  $r11 \u003d $r10.toString()\n  new IndexOutOfBoundsException($r11)\n  throw $r29\n}",
      "B6 {\n  r1.checkOpen()\n  i3 \u003d i7 + i0\n}",
      "B7 {\n  if (i7 \u003e\u003d i3) goto B8 else B9\n}",
      "B8 {\n  $i4 \u003d i7\n  i7 \u003d i7 + 1\n  $b5 \u003d r0[$i4]\n  $i8 \u003d (int) $b5\n  r1.write0($i8)\n  goto B7\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BZip2CompressorOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      },
      {
        "name": "BZip2CompressorOutputStream#write0(...1)",
        "body": "{\r\n    if (this.currentChar !\u003d -1) {\r\n        b \u0026\u003d 0xff;\r\n        if (this.currentChar \u003d\u003d b) {\r\n            if (++this.runLength \u003e 254) {\r\n                writeRun();\r\n                this.currentChar \u003d -1;\r\n                this.runLength \u003d 0;\r\n            }\r\n            // else nothing to do\r\n        } else {\r\n            writeRun();\r\n            this.runLength \u003d 1;\r\n            this.currentChar \u003d b;\r\n        }\r\n    } else {\r\n        this.currentChar \u003d b \u0026 0xff;\r\n        this.runLength++;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.CompressorStreamFactory",
    "methodName": "createCompressorInputStream",
    "signature": "org.apache.commons.compress.compressors.CompressorInputStream createCompressorInputStream(java.lang.String,java.io.InputStream,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (name \u003d\u003d null || in \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Compressor name and stream must not be null.\");\r\n    }\r\n    try {\r\n        if (GZIP.equalsIgnoreCase(name)) {\r\n            // @formatter:off\r\n            return GzipCompressorInputStream.builder().setInputStream(in).setDecompressConcatenated(actualDecompressConcatenated).get();\r\n            // @formatter:on\r\n        }\r\n        if (BZIP2.equalsIgnoreCase(name)) {\r\n            return new BZip2CompressorInputStream(in, actualDecompressConcatenated);\r\n        }\r\n        if (BROTLI.equalsIgnoreCase(name)) {\r\n            if (!BrotliUtils.isBrotliCompressionAvailable()) {\r\n                throw new CompressorException(\"Brotli compression is not available.\" + YOU_NEED_BROTLI_DEC);\r\n            }\r\n            return new BrotliCompressorInputStream(in);\r\n        }\r\n        if (XZ.equalsIgnoreCase(name)) {\r\n            if (!XZUtils.isXZCompressionAvailable()) {\r\n                throw new CompressorException(\"XZ compression is not available.\" + YOU_NEED_XZ_JAVA);\r\n            }\r\n            // @formatter:off\r\n            return XZCompressorInputStream.builder().setInputStream(in).setDecompressConcatenated(actualDecompressConcatenated).setMemoryLimitKiB(memoryLimitInKb).get();\r\n            // @formatter:on\r\n        }\r\n        if (ZSTANDARD.equalsIgnoreCase(name)) {\r\n            if (!ZstdUtils.isZstdCompressionAvailable()) {\r\n                throw new CompressorException(\"Zstandard compression is not available.\" + YOU_NEED_ZSTD_JNI);\r\n            }\r\n            return new ZstdCompressorInputStream(in);\r\n        }\r\n        if (LZMA.equalsIgnoreCase(name)) {\r\n            if (!LZMAUtils.isLZMACompressionAvailable()) {\r\n                throw new CompressorException(\"LZMA compression is not available\" + YOU_NEED_XZ_JAVA);\r\n            }\r\n            return LZMACompressorInputStream.builder().setInputStream(in).setMemoryLimitKiB(memoryLimitInKb).get();\r\n        }\r\n        if (PACK200.equalsIgnoreCase(name)) {\r\n            return new Pack200CompressorInputStream(in);\r\n        }\r\n        if (SNAPPY_RAW.equalsIgnoreCase(name)) {\r\n            return new SnappyCompressorInputStream(in);\r\n        }\r\n        if (SNAPPY_FRAMED.equalsIgnoreCase(name)) {\r\n            return new FramedSnappyCompressorInputStream(in);\r\n        }\r\n        if (Z.equalsIgnoreCase(name)) {\r\n            return new ZCompressorInputStream(in, memoryLimitInKb);\r\n        }\r\n        if (DEFLATE.equalsIgnoreCase(name)) {\r\n            return new DeflateCompressorInputStream(in);\r\n        }\r\n        if (DEFLATE64.equalsIgnoreCase(name)) {\r\n            return new Deflate64CompressorInputStream(in);\r\n        }\r\n        if (LZ4_BLOCK.equalsIgnoreCase(name)) {\r\n            return new BlockLZ4CompressorInputStream(in);\r\n        }\r\n        if (LZ4_FRAMED.equalsIgnoreCase(name)) {\r\n            return new FramedLZ4CompressorInputStream(in, actualDecompressConcatenated);\r\n        }\r\n    } catch (final IOException e) {\r\n        throw new CompressorException(\"Could not create CompressorInputStream.\", e);\r\n    }\r\n    final CompressorStreamProvider compressorStreamProvider \u003d getCompressorInputStreamProviders().get(toKey(name));\r\n    if (compressorStreamProvider !\u003d null) {\r\n        return compressorStreamProvider.createCompressorInputStream(name, in, actualDecompressConcatenated);\r\n    }\r\n    throw new CompressorException(\"Compressor: \" + name + \" not found.\");\r\n}",
    "nodes": 44,
    "edges": 43,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B11",
      "B8 : If($z18 !\u003d 0) → B9 | else → B10",
      "B11 : If($z3 \u003d\u003d false) → B12 | else → B15",
      "B12 : If($z17 !\u003d 0) → B13 | else → B14",
      "B15 : If($z4 \u003d\u003d false) → B16 | else → B19",
      "B16 : If($z16 !\u003d 0) → B17 | else → B18",
      "B19 : If($z5 \u003d\u003d false) → B20 | else → B23",
      "B20 : If($z15 !\u003d 0) → B21 | else → B22",
      "B23 : If($z6 \u003d\u003d false) → B24 | else → B25",
      "B25 : If($z7 \u003d\u003d false) → B26 | else → B27",
      "B27 : If($z8 \u003d\u003d false) → B28 | else → B29",
      "B29 : If($z9 \u003d\u003d false) → B30 | else → B31",
      "B31 : If($z10 \u003d\u003d false) → B32 | else → B33",
      "B33 : If($z11 \u003d\u003d false) → B34 | else → B35",
      "B35 : If($z12 \u003d\u003d false) → B36 | else → B37",
      "B37 : If($z13 \u003d\u003d false) → B38 | else → B39",
      "B41 : If(r81 \u003d\u003d null) → B42 | else → B43"
    ],
    "blockList": [
      "B0 {\n  CompressorStreamFactory\n  String\n  InputStream\n  z14 :\u003d @parameter2: boolean\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Compressor name and stream must not be null.\")\n  throw $r1\n}",
      "B3 {\n  $r3 \u003d \"gz\"\n  $z0 \u003d $r3.equalsIgnoreCase(r0)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r74 \u003d GzipCompressorInputStream.builder()\n  $r75 \u003d $r74.setInputStream(r2)\n  $r76 \u003d GzipCompressorInputStream$Builder) $r75\n  $r77 \u003d $r76.setDecompressConcatenated(z14)\n  $r78 \u003d $r77.get()\n  return\n}",
      "B5 {\n  $r4 \u003d \"bzip2\"\n  $z1 \u003d $r4.equalsIgnoreCase(r0)\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r73 \u003d BZip2CompressorInputStream\n  new BZip2CompressorInputStream(r2, z14)\n  return\n}",
      "B7 {\n  $r5 \u003d \"br\"\n  $z2 \u003d $r5.equalsIgnoreCase(r0)\n  if ($z2 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  $z18 \u003d BrotliUtils.isBrotliCompressionAvailable()\n  if ($z18 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $r67 \u003d CompressorException\n  $r68 \u003d StringBuilder\n  new StringBuilder()\n  $r70 \u003d $r68.append(\"Brotli compression is not available.\")\n  $r69 \u003d String YOU_NEED_BROTLI_DEC\u003e\n  $r71 \u003d $r70.append($r69)\n  $r72 \u003d $r71.toString()\n  new CompressorException($r72)\n  throw $r67\n}",
      "B10 {\n  $r66 \u003d BrotliCompressorInputStream\n  new BrotliCompressorInputStream(r2)\n  return\n}",
      "B11 {\n  $r6 \u003d \"xz\"\n  $z3 \u003d $r6.equalsIgnoreCase(r0)\n  if ($z3 \u003d\u003d false) goto B12 else B15\n}",
      "B12 {\n  $z17 \u003d XZUtils.isXZCompressionAvailable()\n  if ($z17 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $r60 \u003d CompressorException\n  $r61 \u003d StringBuilder\n  new StringBuilder()\n  $r63 \u003d $r61.append(\"XZ compression is not available.\")\n  $r62 \u003d String YOU_NEED_XZ_JAVA\u003e\n  $r64 \u003d $r63.append($r62)\n  $r65 \u003d $r64.toString()\n  new CompressorException($r65)\n  throw $r60\n}",
      "B14 {\n  $r54 \u003d XZCompressorInputStream.builder()\n  $r55 \u003d $r54.setInputStream(r2)\n  $r56 \u003d XZCompressorInputStream$Builder) $r55\n  $r57 \u003d $r56.setDecompressConcatenated(z14)\n  $i2 \u003d CompressorStreamFactory: int memoryLimitInKb\u003e\n  $r58 \u003d $r57.setMemoryLimitKiB($i2)\n  $r59 \u003d $r58.get()\n  return\n}",
      "B15 {\n  $r7 \u003d \"zstd\"\n  $z4 \u003d $r7.equalsIgnoreCase(r0)\n  if ($z4 \u003d\u003d false) goto B16 else B19\n}",
      "B16 {\n  $z16 \u003d ZstdUtils.isZstdCompressionAvailable()\n  if ($z16 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r48 \u003d CompressorException\n  $r49 \u003d StringBuilder\n  new StringBuilder()\n  $r51 \u003d $r49.append(\"Zstandard compression is not available.\")\n  $r50 \u003d String YOU_NEED_ZSTD_JNI\u003e\n  $r52 \u003d $r51.append($r50)\n  $r53 \u003d $r52.toString()\n  new CompressorException($r53)\n  throw $r48\n}",
      "B18 {\n  $r47 \u003d ZstdCompressorInputStream\n  new ZstdCompressorInputStream(r2)\n  return\n}",
      "B19 {\n  $r8 \u003d \"lzma\"\n  $z5 \u003d $r8.equalsIgnoreCase(r0)\n  if ($z5 \u003d\u003d false) goto B20 else B23\n}",
      "B20 {\n  $z15 \u003d LZMAUtils.isLZMACompressionAvailable()\n  if ($z15 !\u003d 0) goto B21 else B22\n}",
      "B21 {\n  $r41 \u003d CompressorException\n  $r42 \u003d StringBuilder\n  new StringBuilder()\n  $r44 \u003d $r42.append(\"LZMA compression is not available\")\n  $r43 \u003d String YOU_NEED_XZ_JAVA\u003e\n  $r45 \u003d $r44.append($r43)\n  $r46 \u003d $r45.toString()\n  new CompressorException($r46)\n  throw $r41\n}",
      "B22 {\n  $r36 \u003d LZMACompressorInputStream.builder()\n  $r37 \u003d $r36.setInputStream(r2)\n  $r38 \u003d LZMACompressorInputStream$Builder) $r37\n  $i1 \u003d CompressorStreamFactory: int memoryLimitInKb\u003e\n  $r39 \u003d $r38.setMemoryLimitKiB($i1)\n  $r40 \u003d $r39.get()\n  return\n}",
      "B23 {\n  $r9 \u003d \"pack200\"\n  $z6 \u003d $r9.equalsIgnoreCase(r0)\n  if ($z6 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $r35 \u003d Pack200CompressorInputStream\n  new Pack200CompressorInputStream(r2)\n  return\n}",
      "B25 {\n  $r10 \u003d \"snappy-raw\"\n  $z7 \u003d $r10.equalsIgnoreCase(r0)\n  if ($z7 \u003d\u003d false) goto B26 else B27\n}",
      "B26 {\n  $r34 \u003d SnappyCompressorInputStream\n  new SnappyCompressorInputStream(r2)\n  return\n}",
      "B27 {\n  $r11 \u003d \"snappy-framed\"\n  $z8 \u003d $r11.equalsIgnoreCase(r0)\n  if ($z8 \u003d\u003d false) goto B28 else B29\n}",
      "B28 {\n  $r33 \u003d FramedSnappyCompressorInputStream\n  new FramedSnappyCompressorInputStream(r2)\n  return\n}",
      "B29 {\n  $r12 \u003d \"z\"\n  $z9 \u003d $r12.equalsIgnoreCase(r0)\n  if ($z9 \u003d\u003d false) goto B30 else B31\n}",
      "B30 {\n  $r32 \u003d ZCompressorInputStream\n  $i0 \u003d CompressorStreamFactory: int memoryLimitInKb\u003e\n  new ZCompressorInputStream(r2, $i0)\n  return\n}",
      "B31 {\n  $r13 \u003d \"deflate\"\n  $z10 \u003d $r13.equalsIgnoreCase(r0)\n  if ($z10 \u003d\u003d false) goto B32 else B33\n}",
      "B32 {\n  $r31 \u003d DeflateCompressorInputStream\n  new DeflateCompressorInputStream(r2)\n  return\n}",
      "B33 {\n  $r14 \u003d \"deflate64\"\n  $z11 \u003d $r14.equalsIgnoreCase(r0)\n  if ($z11 \u003d\u003d false) goto B34 else B35\n}",
      "B34 {\n  $r30 \u003d Deflate64CompressorInputStream\n  new Deflate64CompressorInputStream(r2)\n  return\n}",
      "B35 {\n  $r15 \u003d \"lz4-block\"\n  $z12 \u003d $r15.equalsIgnoreCase(r0)\n  if ($z12 \u003d\u003d false) goto B36 else B37\n}",
      "B36 {\n  $r29 \u003d BlockLZ4CompressorInputStream\n  new BlockLZ4CompressorInputStream(r2)\n  return\n}",
      "B37 {\n  $r16 \u003d \"lz4-framed\"\n  $z13 \u003d $r16.equalsIgnoreCase(r0)\n  if ($z13 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r28 \u003d FramedLZ4CompressorInputStream\n  new FramedLZ4CompressorInputStream(r2, z14)\n  return\n}",
      "B39 {\n  goto B41\n}",
      "B40 {\n  $r79 :\u003d @caughtexception\n  $r80 \u003d CompressorException\n  new CompressorException(\"Could not create CompressorInputStream.\", $r79)\n  throw $r80\n}",
      "B41 {\n  $r19 \u003d r17.getCompressorInputStreamProviders()\n  $r18 \u003d CompressorStreamFactory.toKey(r0)\n  $r20 \u003d $r19.get($r18)\n  r81 \u003d CompressorStreamProvider) $r20\n  if (r81 \u003d\u003d null) goto B42 else B43\n}",
      "B42 {\n  $r27 \u003d r81.createCompressorInputStream(r0, r2, z14)\n  return\n}",
      "B43 {\n  $r21 \u003d CompressorException\n  $r22 \u003d StringBuilder\n  new StringBuilder()\n  $r23 \u003d $r22.append(\"Compressor: \")\n  $r24 \u003d $r23.append(r0)\n  $r25 \u003d $r24.append(\" not found.\")\n  $r26 \u003d $r25.toString()\n  new CompressorException($r26)\n  throw $r21\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B23",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e [EXIT]",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e [EXIT]",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e [EXIT]",
      "B39 --\u003e B41",
      "B40 --\u003e [EXIT]",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e [EXIT]",
      "B43 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CompressorStreamFactory#getCompressorInputStreamProviders(...0)",
        "body": "{\r\n    if (compressorInputStreamProviders \u003d\u003d null) {\r\n        compressorInputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableCompressorInputStreamProviders());\r\n    }\r\n    return compressorInputStreamProviders;\r\n}"
      },
      {
        "name": "CompressorStreamFactory#toKey(...1)",
        "body": "{\r\n    return name.toUpperCase(Locale.ROOT);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.CompressorStreamFactory",
    "methodName": "createCompressorOutputStream",
    "signature": "org.apache.commons.compress.compressors.CompressorOutputStream createCompressorOutputStream(java.lang.String,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    if (name \u003d\u003d null || out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Compressor name and stream must not be null.\");\r\n    }\r\n    try {\r\n        if (GZIP.equalsIgnoreCase(name)) {\r\n            return new GzipCompressorOutputStream(out);\r\n        }\r\n        if (BZIP2.equalsIgnoreCase(name)) {\r\n            return new BZip2CompressorOutputStream(out);\r\n        }\r\n        if (XZ.equalsIgnoreCase(name)) {\r\n            return new XZCompressorOutputStream(out);\r\n        }\r\n        if (PACK200.equalsIgnoreCase(name)) {\r\n            return new Pack200CompressorOutputStream(out);\r\n        }\r\n        if (LZMA.equalsIgnoreCase(name)) {\r\n            return new LZMACompressorOutputStream(out);\r\n        }\r\n        if (DEFLATE.equalsIgnoreCase(name)) {\r\n            return new DeflateCompressorOutputStream(out);\r\n        }\r\n        if (SNAPPY_FRAMED.equalsIgnoreCase(name)) {\r\n            return new FramedSnappyCompressorOutputStream(out);\r\n        }\r\n        if (LZ4_BLOCK.equalsIgnoreCase(name)) {\r\n            return new BlockLZ4CompressorOutputStream(out);\r\n        }\r\n        if (LZ4_FRAMED.equalsIgnoreCase(name)) {\r\n            return new FramedLZ4CompressorOutputStream(out);\r\n        }\r\n        if (ZSTANDARD.equalsIgnoreCase(name)) {\r\n            return new ZstdCompressorOutputStream(out);\r\n        }\r\n    } catch (final IOException e) {\r\n        throw new CompressorException(\"Could not create CompressorOutputStream.\", e);\r\n    }\r\n    final CompressorStreamProvider compressorStreamProvider \u003d getCompressorOutputStreamProviders().get(toKey(name));\r\n    if (compressorStreamProvider !\u003d null) {\r\n        return compressorStreamProvider.createCompressorOutputStream(name, out);\r\n    }\r\n    throw new CompressorException(\"Compressor: \" + name + \" not found.\");\r\n}",
    "nodes": 28,
    "edges": 27,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11",
      "B11 : If($z4 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z5 \u003d\u003d false) → B14 | else → B15",
      "B15 : If($z6 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($z7 \u003d\u003d false) → B18 | else → B19",
      "B19 : If($z8 \u003d\u003d false) → B20 | else → B21",
      "B21 : If($z9 \u003d\u003d false) → B22 | else → B23",
      "B25 : If(r36 \u003d\u003d null) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  CompressorStreamFactory\n  String\n  OutputStream\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Compressor name and stream must not be null.\")\n  throw $r1\n}",
      "B3 {\n  $r3 \u003d \"gz\"\n  $z0 \u003d $r3.equalsIgnoreCase(r0)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r33 \u003d GzipCompressorOutputStream\n  new GzipCompressorOutputStream(r2)\n  return\n}",
      "B5 {\n  $r4 \u003d \"bzip2\"\n  $z1 \u003d $r4.equalsIgnoreCase(r0)\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r32 \u003d BZip2CompressorOutputStream\n  new BZip2CompressorOutputStream(r2)\n  return\n}",
      "B7 {\n  $r5 \u003d \"xz\"\n  $z2 \u003d $r5.equalsIgnoreCase(r0)\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r31 \u003d XZCompressorOutputStream\n  new XZCompressorOutputStream(r2)\n  return\n}",
      "B9 {\n  $r6 \u003d \"pack200\"\n  $z3 \u003d $r6.equalsIgnoreCase(r0)\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r30 \u003d Pack200CompressorOutputStream\n  new Pack200CompressorOutputStream(r2)\n  return\n}",
      "B11 {\n  $r7 \u003d \"lzma\"\n  $z4 \u003d $r7.equalsIgnoreCase(r0)\n  if ($z4 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r29 \u003d LZMACompressorOutputStream\n  new LZMACompressorOutputStream(r2)\n  return\n}",
      "B13 {\n  $r8 \u003d \"deflate\"\n  $z5 \u003d $r8.equalsIgnoreCase(r0)\n  if ($z5 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r28 \u003d DeflateCompressorOutputStream\n  new DeflateCompressorOutputStream(r2)\n  return\n}",
      "B15 {\n  $r9 \u003d \"snappy-framed\"\n  $z6 \u003d $r9.equalsIgnoreCase(r0)\n  if ($z6 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r27 \u003d FramedSnappyCompressorOutputStream\n  new FramedSnappyCompressorOutputStream(r2)\n  return\n}",
      "B17 {\n  $r10 \u003d \"lz4-block\"\n  $z7 \u003d $r10.equalsIgnoreCase(r0)\n  if ($z7 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r26 \u003d BlockLZ4CompressorOutputStream\n  new BlockLZ4CompressorOutputStream(r2)\n  return\n}",
      "B19 {\n  $r11 \u003d \"lz4-framed\"\n  $z8 \u003d $r11.equalsIgnoreCase(r0)\n  if ($z8 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r25 \u003d FramedLZ4CompressorOutputStream\n  new FramedLZ4CompressorOutputStream(r2)\n  return\n}",
      "B21 {\n  $r12 \u003d \"zstd\"\n  $z9 \u003d $r12.equalsIgnoreCase(r0)\n  if ($z9 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $r24 \u003d ZstdCompressorOutputStream\n  new ZstdCompressorOutputStream(r2)\n  return\n}",
      "B23 {\n  goto B25\n}",
      "B24 {\n  $r34 :\u003d @caughtexception\n  $r35 \u003d CompressorException\n  new CompressorException(\"Could not create CompressorOutputStream.\", $r34)\n  throw $r35\n}",
      "B25 {\n  $r15 \u003d r13.getCompressorOutputStreamProviders()\n  $r14 \u003d CompressorStreamFactory.toKey(r0)\n  $r16 \u003d $r15.get($r14)\n  r36 \u003d CompressorStreamProvider) $r16\n  if (r36 \u003d\u003d null) goto B26 else B27\n}",
      "B26 {\n  $r23 \u003d r36.createCompressorOutputStream(r0, r2)\n  return\n}",
      "B27 {\n  $r17 \u003d CompressorException\n  $r18 \u003d StringBuilder\n  new StringBuilder()\n  $r19 \u003d $r18.append(\"Compressor: \")\n  $r20 \u003d $r19.append(r0)\n  $r21 \u003d $r20.append(\" not found.\")\n  $r22 \u003d $r21.toString()\n  new CompressorException($r22)\n  throw $r17\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CompressorStreamFactory#getCompressorOutputStreamProviders(...0)",
        "body": "{\r\n    if (compressorOutputStreamProviders \u003d\u003d null) {\r\n        compressorOutputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableCompressorOutputStreamProviders());\r\n    }\r\n    return compressorOutputStreamProviders;\r\n}"
      },
      {
        "name": "CompressorStreamFactory#toKey(...1)",
        "body": "{\r\n    return name.toUpperCase(Locale.ROOT);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.CompressorStreamFactory",
    "methodName": "getCompressorInputStreamProviders",
    "signature": "java.util.SortedMap getCompressorInputStreamProviders()",
    "visibility": "public",
    "body": "{\r\n    if (compressorInputStreamProviders \u003d\u003d null) {\r\n        compressorInputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableCompressorInputStreamProviders());\r\n    }\r\n    return compressorInputStreamProviders;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CompressorStreamFactory\n  $r1 \u003d SortedMap compressorInputStreamProviders\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d CompressorStreamFactory.findAvailableCompressorInputStreamProviders()\n  $r4 \u003d Collections.unmodifiableSortedMap($r3)\n  SortedMap compressorInputStreamProviders\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d SortedMap compressorInputStreamProviders\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CompressorStreamFactory#findAvailableCompressorInputStreamProviders(...0)",
        "body": "{\r\n    return AccessController.doPrivileged((PrivilegedAction\u003cSortedMap\u003cString, CompressorStreamProvider\u003e\u003e) () -\u003e {\r\n        final TreeMap\u003cString, CompressorStreamProvider\u003e map \u003d new TreeMap\u003c\u003e();\r\n        putAll(SINGLETON.getInputStreamCompressorNames(), SINGLETON, map);\r\n        archiveStreamProviderIterable().forEach(provider -\u003e putAll(provider.getInputStreamCompressorNames(), provider, map));\r\n        return map;\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.CompressorStreamFactory",
    "methodName": "getCompressorOutputStreamProviders",
    "signature": "java.util.SortedMap getCompressorOutputStreamProviders()",
    "visibility": "public",
    "body": "{\r\n    if (compressorOutputStreamProviders \u003d\u003d null) {\r\n        compressorOutputStreamProviders \u003d Collections.unmodifiableSortedMap(findAvailableCompressorOutputStreamProviders());\r\n    }\r\n    return compressorOutputStreamProviders;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CompressorStreamFactory\n  $r1 \u003d SortedMap compressorOutputStreamProviders\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d CompressorStreamFactory.findAvailableCompressorOutputStreamProviders()\n  $r4 \u003d Collections.unmodifiableSortedMap($r3)\n  SortedMap compressorOutputStreamProviders\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d SortedMap compressorOutputStreamProviders\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CompressorStreamFactory#findAvailableCompressorOutputStreamProviders(...0)",
        "body": "{\r\n    return AccessController.doPrivileged((PrivilegedAction\u003cSortedMap\u003cString, CompressorStreamProvider\u003e\u003e) () -\u003e {\r\n        final TreeMap\u003cString, CompressorStreamProvider\u003e map \u003d new TreeMap\u003c\u003e();\r\n        putAll(SINGLETON.getOutputStreamCompressorNames(), SINGLETON, map);\r\n        archiveStreamProviderIterable().forEach(provider -\u003e putAll(provider.getOutputStreamCompressorNames(), provider, map));\r\n        return map;\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.CompressorStreamFactory",
    "methodName": "setDecompressConcatenated",
    "signature": "void setDecompressConcatenated(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (this.decompressUntilEof !\u003d null) {\r\n        throw new IllegalStateException(\"Cannot override the setting defined by the constructor\");\r\n    }\r\n    this.decompressConcatenated \u003d decompressConcatenated;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CompressorStreamFactory\n  z0 :\u003d @parameter0: boolean\n  $r1 \u003d Boolean decompressUntilEof\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalStateException\n  new IllegalStateException(\"Cannot override the setting defined by the constructor\")\n  throw $r2\n}",
      "B2 {\n  CompressorStreamFactory: boolean decompressConcatenated\u003e \u003d z0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return length \u003e 3 \u0026\u0026 signature[0] \u003d\u003d MAGIC_1 \u0026\u0026 (signature[1] \u003d\u003d (byte) MAGIC_2a || signature[1] \u003d\u003d (byte) MAGIC_2b || signature[1] \u003d\u003d (byte) MAGIC_2c || signature[1] \u003d\u003d (byte) MAGIC_2d);\r\n}",
    "nodes": 9,
    "edges": 14,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 3) → B1 | else → B7",
      "B1 : If($i6 !\u003d 120) → B2 | else → B7",
      "B2 : If($b2 \u003d\u003d 1) → B3 | else → B6",
      "B3 : If($i7 \u003d\u003d 94) → B4 | else → B6",
      "B4 : If($i8 \u003d\u003d $i10) → B5 | else → B6",
      "B5 : If($i11 !\u003d $i13) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c\u003d 3) goto B1 else B7\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $i6 \u003d (int) $b1\n  if ($i6 !\u003d 120) goto B2 else B7\n}",
      "B2 {\n  $b2 \u003d r0[1]\n  if ($b2 \u003d\u003d 1) goto B3 else B6\n}",
      "B3 {\n  $b3 \u003d r0[1]\n  $i7 \u003d (int) $b3\n  if ($i7 \u003d\u003d 94) goto B4 else B6\n}",
      "B4 {\n  $b4 \u003d r0[1]\n  $i8 \u003d (int) $b4\n  $i10 \u003d (int) -100\n  if ($i8 \u003d\u003d $i10) goto B5 else B6\n}",
      "B5 {\n  $b5 \u003d r0[1]\n  $i11 \u003d (int) $b5\n  $i13 \u003d (int) -38\n  if ($i11 !\u003d $i13) goto B6 else B7\n}",
      "B6 {\n  $z0 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z0 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    final int ret \u003d in.read();\r\n    count(ret \u003d\u003d -1 ? 0 : 1);\r\n    return ret;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DeflateCompressorInputStream\n  $r1 \u003d InputStream in\u003e\n  i0 \u003d $r1.read()\n  $i3 \u003d (int) -1\n  if (i0 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d 0\n  goto B3\n}",
      "B2 {\n  $b1 \u003d 1\n}",
      "B3 {\n  r0.count($b1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DeflateCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate.DeflateCompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final int ret \u003d in.read(buf, off, len);\r\n    count(ret);\r\n    return ret;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DeflateCompressorInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d InputStream in\u003e\n  i2 \u003d $r2.read(r1, i1, i0)\n  r0.count(i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DeflateCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate.DeflateParameters",
    "methodName": "setCompressionLevel",
    "signature": "void setCompressionLevel(int)",
    "visibility": "public",
    "body": "{\r\n    if (compressionLevel \u003c MIN_LEVEL || compressionLevel \u003e MAX_LEVEL) {\r\n        throw new IllegalArgumentException(\"Invalid Deflate compression level: \" + compressionLevel);\r\n    }\r\n    this.compressionLevel \u003d compressionLevel;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d 9) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DeflateParameters\n  i0 :\u003d @parameter0: int\n  if (i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d 9) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IllegalArgumentException\n  $r1 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r1.append(\"Invalid Deflate compression level: \")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IllegalArgumentException($r4)\n  throw $r0\n}",
      "B3 {\n  DeflateParameters: int compressionLevel\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream",
    "methodName": "available",
    "signature": "int available()",
    "visibility": "public",
    "body": "{\r\n    return decoder !\u003d null ? decoder.available() : 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Deflate64CompressorInputStream\n  $r1 \u003d HuffmanDecoder decoder\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d HuffmanDecoder decoder\u003e\n  $i0 \u003d $r2.available()\n  goto B3\n}",
      "B2 {\n  $i0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    while (true) {\r\n        final int r \u003d read(oneByte);\r\n        switch(r) {\r\n            case 1:\r\n                return oneByte[0] \u0026 0xFF;\r\n            case -1:\r\n                return -1;\r\n            case 0:\r\n                continue;\r\n            default:\r\n                throw new IllegalStateException(\"Invalid return value from read: \" + r);\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(switch-on $i2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Deflate64CompressorInputStream\n}",
      "B1 {\n  $r1 \u003d Deflate64CompressorInputStream: byte[] oneByte\u003e\n  $i2 \u003d r0.read($r1)\n  IllegalStateException; }\n}",
      "B2 {\n  $r2 \u003d Deflate64CompressorInputStream: byte[] oneByte\u003e\n  $b0 \u003d $r2[0]\n  $s3 \u003d (short) $b0\n  $s1 \u003d $s3 \u0026 255\n  $i4 \u003d (int) $s1\n  return\n}",
      "B3 {\n  $i6 \u003d (int) -1\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r9 \u003d IllegalStateException\n  $r8 \u003d StringBuilder\n  new StringBuilder()\n  $r5 \u003d $r8.append(\"Invalid return value from read: \")\n  $r6 \u003d $r5.append($i2)\n  $r7 \u003d $r6.toString()\n  new IllegalStateException($r7)\n  throw $r9\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B3",
      "B1 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Deflate64CompressorInputStream#read(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    int read \u003d -1;\r\n    if (decoder !\u003d null) {\r\n        try {\r\n            read \u003d decoder.decode(b, off, len);\r\n        } catch (final RuntimeException ex) {\r\n            throw new IOException(\"Invalid Deflate64 input\", ex);\r\n        }\r\n        compressedBytesRead \u003d decoder.getBytesRead();\r\n        count(read);\r\n        if (read \u003d\u003d -1) {\r\n            closeDecoder();\r\n        }\r\n    }\r\n    return read;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B7",
      "B5 : If(i3 !\u003d $i7) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Deflate64CompressorInputStream\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i5 \u003d (int) -1\n  i3 \u003d $i5\n  $r1 \u003d HuffmanDecoder decoder\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B7\n}",
      "B3 {\n  $r3 \u003d HuffmanDecoder decoder\u003e\n  i3 \u003d $r3.decode(r2, i1, i0)\n  goto B5\n}",
      "B4 {\n  $r5 :\u003d @caughtexception\n  $r7 \u003d IOException\n  new IOException(\"Invalid Deflate64 input\", $r5)\n  throw $r7\n}",
      "B5 {\n  $r4 \u003d HuffmanDecoder decoder\u003e\n  $l2 \u003d $r4.getBytesRead()\n  Deflate64CompressorInputStream: long compressedBytesRead\u003e \u003d $l2\n  r0.count(i3)\n  $i7 \u003d (int) -1\n  if (i3 !\u003d $i7) goto B6 else B7\n}",
      "B6 {\n  r0.closeDecoder()\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Deflate64CompressorInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "Deflate64CompressorInputStream#closeDecoder(...0)",
        "body": "{\r\n    final Closeable c \u003d decoder;\r\n    IOUtils.closeQuietly(c);\r\n    decoder \u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.FileNameUtil",
    "methodName": "getCompressedFileName",
    "signature": "java.lang.String getCompressedFileName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String lower \u003d fileName.toLowerCase(Locale.ROOT);\r\n    final int n \u003d lower.length();\r\n    for (int i \u003d shortestUncompressedSuffix; i \u003c\u003d longestUncompressedSuffix \u0026\u0026 i \u003c n; i++) {\r\n        final String suffix \u003d compressSuffix.get(lower.substring(n - i));\r\n        if (suffix !\u003d null) {\r\n            return fileName.substring(0, n - i) + suffix;\r\n        }\r\n    }\r\n    // No custom suffix found, just append the default\r\n    return fileName + defaultExtension;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e $i1) → B2 | else → B6",
      "B2 : If(i4 \u003e\u003d i0) → B3 | else → B6",
      "B3 : If(r12 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileNameUtil\n  String\n  $r1 \u003d Locale ROOT\u003e\n  r2 \u003d r0.toLowerCase($r1)\n  i0 \u003d r2.length()\n  i4 \u003d FileNameUtil: int shortestUncompressedSuffix\u003e\n}",
      "B1 {\n  $i1 \u003d FileNameUtil: int longestUncompressedSuffix\u003e\n  if (i4 \u003e $i1) goto B2 else B6\n}",
      "B2 {\n  if (i4 \u003e\u003d i0) goto B3 else B6\n}",
      "B3 {\n  $r9 \u003d Map compressSuffix\u003e\n  $i2 \u003d i0 - i4\n  $r10 \u003d r2.substring($i2)\n  $r11 \u003d $r9.get($r10)\n  r12 \u003d String) $r11\n  if (r12 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r13 \u003d StringBuilder\n  new StringBuilder()\n  $i3 \u003d i0 - i4\n  $r14 \u003d r0.substring(0, $i3)\n  $r15 \u003d $r13.append($r14)\n  $r16 \u003d $r15.append(r12)\n  $r17 \u003d $r16.toString()\n  return\n}",
      "B5 {\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B6 {\n  $r4 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r4.append(r0)\n  $r5 \u003d String defaultExtension\u003e\n  $r7 \u003d $r6.append($r5)\n  $r8 \u003d $r7.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.FileNameUtil",
    "methodName": "getUncompressedFileName",
    "signature": "java.lang.String getUncompressedFileName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String lower \u003d fileName.toLowerCase(Locale.ROOT);\r\n    final int n \u003d lower.length();\r\n    for (int i \u003d shortestCompressedSuffix; i \u003c\u003d longestCompressedSuffix \u0026\u0026 i \u003c n; i++) {\r\n        final String suffix \u003d uncompressSuffix.get(lower.substring(n - i));\r\n        if (suffix !\u003d null) {\r\n            return fileName.substring(0, n - i) + suffix;\r\n        }\r\n    }\r\n    return fileName;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e $i1) → B2 | else → B6",
      "B2 : If(i4 \u003e\u003d i0) → B3 | else → B6",
      "B3 : If(r7 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileNameUtil\n  String\n  $r1 \u003d Locale ROOT\u003e\n  r2 \u003d r0.toLowerCase($r1)\n  i0 \u003d r2.length()\n  i4 \u003d FileNameUtil: int shortestCompressedSuffix\u003e\n}",
      "B1 {\n  $i1 \u003d FileNameUtil: int longestCompressedSuffix\u003e\n  if (i4 \u003e $i1) goto B2 else B6\n}",
      "B2 {\n  if (i4 \u003e\u003d i0) goto B3 else B6\n}",
      "B3 {\n  $r4 \u003d Map uncompressSuffix\u003e\n  $i2 \u003d i0 - i4\n  $r5 \u003d r2.substring($i2)\n  $r6 \u003d $r4.get($r5)\n  r7 \u003d String) $r6\n  if (r7 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d StringBuilder\n  new StringBuilder()\n  $i3 \u003d i0 - i4\n  $r9 \u003d r0.substring(0, $i3)\n  $r10 \u003d $r8.append($r9)\n  $r11 \u003d $r10.append(r7)\n  $r12 \u003d $r11.toString()\n  return\n}",
      "B5 {\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.FileNameUtil",
    "methodName": "isCompressedFileName",
    "signature": "boolean isCompressedFileName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String lower \u003d fileName.toLowerCase(Locale.ROOT);\r\n    final int n \u003d lower.length();\r\n    for (int i \u003d shortestCompressedSuffix; i \u003c\u003d longestCompressedSuffix \u0026\u0026 i \u003c n; i++) {\r\n        if (uncompressSuffix.containsKey(lower.substring(n - i))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e $i1) → B2 | else → B6",
      "B2 : If(i3 \u003e\u003d i0) → B3 | else → B6",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileNameUtil\n  String\n  $r1 \u003d Locale ROOT\u003e\n  r2 \u003d r0.toLowerCase($r1)\n  i0 \u003d r2.length()\n  i3 \u003d FileNameUtil: int shortestCompressedSuffix\u003e\n}",
      "B1 {\n  $i1 \u003d FileNameUtil: int longestCompressedSuffix\u003e\n  if (i3 \u003e $i1) goto B2 else B6\n}",
      "B2 {\n  if (i3 \u003e\u003d i0) goto B3 else B6\n}",
      "B3 {\n  $r4 \u003d Map uncompressSuffix\u003e\n  $i2 \u003d i0 - i3\n  $r5 \u003d r2.substring($i2)\n  $z0 \u003d $r4.containsKey($r5)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.ExtraField",
    "methodName": "addSubField",
    "signature": "org.apache.commons.compress.compressors.gzip.ExtraField addSubField(java.lang.String,byte[])",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(id, \"payload\");\r\n    Objects.requireNonNull(payload, \"payload\");\r\n    if (id.length() !\u003d 2) {\r\n        throw new IllegalArgumentException(\"Subfield id must be a 2 character ISO-8859-1 string.\");\r\n    }\r\n    final char si1 \u003d id.charAt(0);\r\n    final char si2 \u003d id.charAt(1);\r\n    if ((si1 \u0026 0xff00) !\u003d 0 || (si2 \u0026 0xff00) !\u003d 0) {\r\n        throw new IllegalArgumentException(\"Subfield id must be a 2 character ISO-8859-1 string.\");\r\n    }\r\n    final SubField f \u003d new SubField((byte) (si1 \u0026 0xff), (byte) (si2 \u0026 0xff), payload);\r\n    final int len \u003d 4 + payload.length;\r\n    if (totalSize + len \u003e MAX_SIZE) {\r\n        throw new IOException(\"Extra subfield \u0027\" + f.getId() + \"\u0027 too big (extras total size is already at \" + totalSize + \")\");\r\n    }\r\n    subFields.add(f);\r\n    totalSize +\u003d len;\r\n    return this;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 2) → B1 | else → B2",
      "B2 : If($c3 !\u003d 0) → B3 | else → B4",
      "B3 : If($c4 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($i12 \u003c\u003d $i17) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ExtraField\n  String\n  r1 :\u003d @parameter1: byte[]\n  Objects.requireNonNull(r0, \"payload\")\n  Objects.requireNonNull(r1, \"payload\")\n  $i0 \u003d r0.length()\n  if ($i0 \u003d\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $r16 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Subfield id must be a 2 character ISO-8859-1 string.\")\n  throw $r16\n}",
      "B2 {\n  c1 \u003d r0.charAt(0)\n  c2 \u003d r0.charAt(1)\n  $c3 \u003d c1 \u0026 65280\n  if ($c3 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $c4 \u003d c2 \u0026 65280\n  if ($c4 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r17 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Subfield id must be a 2 character ISO-8859-1 string.\")\n  throw $r17\n}",
      "B5 {\n  $r18 \u003d ExtraField$SubField\n  $c5 \u003d c1 \u0026 255\n  $b8 \u003d (byte) $c5\n  $c6 \u003d c2 \u0026 255\n  $b7 \u003d (byte) $c6\n  new ExtraField$SubField($b8, $b7, r1)\n  $i9 \u003d lengthof r1\n  i10 \u003d 4 + $i9\n  $i11 \u003d ExtraField: int totalSize\u003e\n  $i12 \u003d $i11 + i10\n  $i17 \u003d (int) 65535\n  if ($i12 \u003c\u003d $i17) goto B6 else B7\n}",
      "B6 {\n  $r20 \u003d IOException\n  $r19 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r19.append(\"Extra subfield \\\u0027\")\n  $r8 \u003d $r18.getId()\n  $r10 \u003d $r9.append($r8)\n  $r11 \u003d $r10.append(\"\\\u0027 too big (extras total size is already at \")\n  $i15 \u003d ExtraField: int totalSize\u003e\n  $r12 \u003d $r11.append($i15)\n  $r13 \u003d $r12.append(\")\")\n  $r14 \u003d $r13.toString()\n  new IOException($r14)\n  throw $r20\n}",
      "B7 {\n  $r5 \u003d List subFields\u003e\n  $r5.add($r18)\n  $i13 \u003d ExtraField: int totalSize\u003e\n  $i14 \u003d $i13 + i10\n  ExtraField: int totalSize\u003e \u003d $i14\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.ExtraField",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ExtraField other \u003d (ExtraField) obj;\r\n    return Objects.equals(subFields, other.subFields) \u0026\u0026 totalSize \u003d\u003d other.totalSize;\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If($r3 \u003d\u003d $r2) → B5 | else → B6",
      "B6 : If($z0 \u003d\u003d false) → B7 | else → B9",
      "B7 : If($i1 !\u003d $i0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  ExtraField\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r4 \u003d ExtraField) r1\n  $r6 \u003d List subFields\u003e\n  $r5 \u003d List subFields\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B7 else B9\n}",
      "B7 {\n  $i1 \u003d ExtraField: int totalSize\u003e\n  $i0 \u003d ExtraField: int totalSize\u003e\n  if ($i1 !\u003d $i0) goto B8 else B9\n}",
      "B8 {\n  $z1 \u003d 1\n  goto B10\n}",
      "B9 {\n  $z1 \u003d 0\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ExtraField#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return length \u003e\u003d 2 \u0026\u0026 signature[0] \u003d\u003d 31 \u0026\u0026 signature[1] \u003d\u003d -117;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003c 2) → B1 | else → B4",
      "B1 : If($i3 !\u003d 31) → B2 | else → B4",
      "B2 : If($i4 !\u003d $i6) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c 2) goto B1 else B4\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $i3 \u003d (int) $b1\n  if ($i3 !\u003d 31) goto B2 else B4\n}",
      "B2 {\n  $b2 \u003d r0[1]\n  $i4 \u003d (int) $b2\n  $i6 \u003d (int) -117\n  if ($i4 !\u003d $i6) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (inflater !\u003d null) {\r\n        inflater.end();\r\n        inflater \u003d null;\r\n    }\r\n    if (this.in !\u003d System.in) {\r\n        this.in.close();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorInputStream\n  $r1 \u003d Inflater inflater\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d Inflater inflater\u003e\n  $r5.end()\n  Inflater inflater\u003e \u003d null\n}",
      "B2 {\n  $r3 \u003d InputStream in\u003e\n  $r2 \u003d InputStream in\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d InputStream in\u003e\n  $r4.close()\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    return read(oneByte, 0, 1) \u003d\u003d -1 ? -1 : oneByte[0] \u0026 0xFF;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d $i4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorInputStream\n  $r1 \u003d GzipCompressorInputStream: byte[] oneByte\u003e\n  $i0 \u003d r0.read($r1, 0, 1)\n  $i4 \u003d (int) -1\n  if ($i0 !\u003d $i4) goto B1 else B2\n}",
      "B1 {\n  $s2 \u003d -1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d GzipCompressorInputStream: byte[] oneByte\u003e\n  $b1 \u003d $r2[0]\n  $s2 \u003d $b1 \u0026 255\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GzipCompressorInputStream#read(...3)",
        "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    int size \u003d 0;\r\n    while (len \u003e 0) {\r\n        if (inflater.needsInput()) {\r\n            // Remember the current position because we may need to\r\n            // rewind after reading too much input.\r\n            in.mark(buf.length);\r\n            bufUsed \u003d in.read(buf);\r\n            if (bufUsed \u003d\u003d -1) {\r\n                throw new EOFException();\r\n            }\r\n            inflater.setInput(buf, 0, bufUsed);\r\n        }\r\n        final int ret;\r\n        try {\r\n            ret \u003d inflater.inflate(b, off, len);\r\n        } catch (final DataFormatException e) {\r\n            // NOSONAR\r\n            throw new IOException(\"Gzip-compressed data is corrupt.\", e);\r\n        }\r\n        crc.update(b, off, ret);\r\n        off +\u003d ret;\r\n        len -\u003d ret;\r\n        size +\u003d ret;\r\n        count(ret);\r\n        if (inflater.finished()) {\r\n            // We may have read too many bytes. Rewind the read\r\n            // position to match the actual amount used.\r\n            in.reset();\r\n            final int skipAmount \u003d bufUsed - inflater.getRemaining();\r\n            if (IOUtils.skip(in, skipAmount) !\u003d skipAmount) {\r\n                throw new IOException();\r\n            }\r\n            bufUsed \u003d 0;\r\n            final DataInput inData \u003d new DataInputStream(in);\r\n            // CRC32\r\n            final long trailerCrc \u003d ByteUtils.fromLittleEndian(inData, 4);\r\n            if (trailerCrc !\u003d crc.getValue()) {\r\n                throw new IOException(\"Gzip-compressed data is corrupt (CRC32 error).\");\r\n            }\r\n            // Uncompressed size modulo 2^32, ISIZE in the RFC.\r\n            final long iSize \u003d ByteUtils.fromLittleEndian(inData, 4);\r\n            if (iSize !\u003d (inflater.getBytesWritten() \u0026 0xffffffffL)) {\r\n                throw new IOException(\"Gzip-compressed data is corrupt (uncompressed size mismatch).\");\r\n            }\r\n            parameters.setTrailerCrc(trailerCrc);\r\n            parameters.setTrailerISize(iSize);\r\n            onMemberEnd.accept(this);\r\n            // See if this is the end of the file.\r\n            if (!decompressConcatenated || !init(false)) {\r\n                inflater.end();\r\n                inflater \u003d null;\r\n                endReached \u003d true;\r\n                return size \u003d\u003d 0 ? -1 : size;\r\n            }\r\n        }\r\n    }\r\n    return size;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    int size \u003d 0;\r\n    while (len \u003e 0) {\r\n        if (inflater.needsInput()) {\r\n            // Remember the current position because we may need to\r\n            // rewind after reading too much input.\r\n            in.mark(buf.length);\r\n            bufUsed \u003d in.read(buf);\r\n            if (bufUsed \u003d\u003d -1) {\r\n                throw new EOFException();\r\n            }\r\n            inflater.setInput(buf, 0, bufUsed);\r\n        }\r\n        final int ret;\r\n        try {\r\n            ret \u003d inflater.inflate(b, off, len);\r\n        } catch (final DataFormatException e) {\r\n            // NOSONAR\r\n            throw new IOException(\"Gzip-compressed data is corrupt.\", e);\r\n        }\r\n        crc.update(b, off, ret);\r\n        off +\u003d ret;\r\n        len -\u003d ret;\r\n        size +\u003d ret;\r\n        count(ret);\r\n        if (inflater.finished()) {\r\n            // We may have read too many bytes. Rewind the read\r\n            // position to match the actual amount used.\r\n            in.reset();\r\n            final int skipAmount \u003d bufUsed - inflater.getRemaining();\r\n            if (IOUtils.skip(in, skipAmount) !\u003d skipAmount) {\r\n                throw new IOException();\r\n            }\r\n            bufUsed \u003d 0;\r\n            final DataInput inData \u003d new DataInputStream(in);\r\n            // CRC32\r\n            final long trailerCrc \u003d ByteUtils.fromLittleEndian(inData, 4);\r\n            if (trailerCrc !\u003d crc.getValue()) {\r\n                throw new IOException(\"Gzip-compressed data is corrupt (CRC32 error).\");\r\n            }\r\n            // Uncompressed size modulo 2^32, ISIZE in the RFC.\r\n            final long iSize \u003d ByteUtils.fromLittleEndian(inData, 4);\r\n            if (iSize !\u003d (inflater.getBytesWritten() \u0026 0xffffffffL)) {\r\n                throw new IOException(\"Gzip-compressed data is corrupt (uncompressed size mismatch).\");\r\n            }\r\n            parameters.setTrailerCrc(trailerCrc);\r\n            parameters.setTrailerISize(iSize);\r\n            onMemberEnd.accept(this);\r\n            // See if this is the end of the file.\r\n            if (!decompressConcatenated || !init(false)) {\r\n                inflater.end();\r\n                inflater \u003d null;\r\n                endReached \u003d true;\r\n                return size \u003d\u003d 0 ? -1 : size;\r\n            }\r\n        }\r\n    }\r\n    return size;\r\n}",
    "nodes": 27,
    "edges": 30,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i19 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(i19 \u003c\u003d 0) → B6 | else → B26",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B10",
      "B7 : If($i15 !\u003d $i26) → B8 | else → B9",
      "B12 : If($z2 \u003d\u003d false) → B13 | else → B25",
      "B13 : If($b5 \u003d\u003d false) → B14 | else → B15",
      "B15 : If($b8 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($b12 \u003d\u003d false) → B18 | else → B19",
      "B19 : If($z3 \u003d\u003d false) → B20 | else → B21",
      "B20 : If($z4 !\u003d 0) → B21 | else → B25",
      "B21 : If(i20 !\u003d 0) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorInputStream\n  r2 :\u003d @parameter0: byte[]\n  i18 :\u003d @parameter1: int\n  i19 :\u003d @parameter2: int\n  if (i19 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d GzipCompressorInputStream: boolean endReached\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i24 \u003d (int) -1\n  return\n}",
      "B4 {\n  i20 \u003d 0\n}",
      "B5 {\n  if (i19 \u003c\u003d 0) goto B6 else B26\n}",
      "B6 {\n  $r1 \u003d Inflater inflater\u003e\n  $z1 \u003d $r1.needsInput()\n  if ($z1 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  $r21 \u003d InputStream in\u003e\n  $r20 \u003d GzipCompressorInputStream: byte[] buf\u003e\n  $i13 \u003d lengthof $r20\n  $r21.mark($i13)\n  $r23 \u003d InputStream in\u003e\n  $r22 \u003d GzipCompressorInputStream: byte[] buf\u003e\n  $i14 \u003d $r23.read($r22)\n  GzipCompressorInputStream: int bufUsed\u003e \u003d $i14\n  $i15 \u003d GzipCompressorInputStream: int bufUsed\u003e\n  $i26 \u003d (int) -1\n  if ($i15 !\u003d $i26) goto B8 else B9\n}",
      "B8 {\n  $r29 \u003d EOFException\n  new EOFException()\n  throw $r29\n}",
      "B9 {\n  $r25 \u003d Inflater inflater\u003e\n  $r24 \u003d GzipCompressorInputStream: byte[] buf\u003e\n  $i16 \u003d GzipCompressorInputStream: int bufUsed\u003e\n  $r25.setInput($r24, 0, $i16)\n}",
      "B10 {\n  $r3 \u003d Inflater inflater\u003e\n  $i17 \u003d $r3.inflate(r2, i18, i19)\n  goto B12\n}",
      "B11 {\n  $r27 :\u003d @caughtexception\n  $r30 \u003d IOException\n  new IOException(\"Gzip-compressed data is corrupt.\", $r27)\n  throw $r30\n}",
      "B12 {\n  $r4 \u003d CRC32 crc\u003e\n  $r4.update(r2, i18, $i17)\n  i18 \u003d i18 + $i17\n  i19 \u003d i19 - $i17\n  i20 \u003d i20 + $i17\n  r0.count($i17)\n  $r5 \u003d Inflater inflater\u003e\n  $z2 \u003d $r5.finished()\n  if ($z2 \u003d\u003d false) goto B13 else B25\n}",
      "B13 {\n  $r6 \u003d InputStream in\u003e\n  $r6.reset()\n  $i0 \u003d GzipCompressorInputStream: int bufUsed\u003e\n  $r7 \u003d Inflater inflater\u003e\n  $i1 \u003d $r7.getRemaining()\n  i21 \u003d $i0 - $i1\n  $r8 \u003d InputStream in\u003e\n  $l2 \u003d (long) i21\n  $l4 \u003d IOUtils.skip($r8, $l2)\n  $l3 \u003d (long) i21\n  $b5 \u003d $l4 cmp $l3\n  if ($b5 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r31 \u003d IOException\n  new IOException()\n  throw $r31\n}",
      "B15 {\n  GzipCompressorInputStream: int bufUsed\u003e \u003d 0\n  $r32 \u003d DataInputStream\n  $r10 \u003d InputStream in\u003e\n  new DataInputStream($r10)\n  l6 \u003d ByteUtils.fromLittleEndian($r32, 4)\n  $r11 \u003d CRC32 crc\u003e\n  $l7 \u003d $r11.getValue()\n  $b8 \u003d l6 cmp $l7\n  if ($b8 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r33 \u003d IOException\n  new IOException(\"Gzip-compressed data is corrupt (CRC32 error).\")\n  throw $r33\n}",
      "B17 {\n  l9 \u003d ByteUtils.fromLittleEndian($r32, 4)\n  $r12 \u003d Inflater inflater\u003e\n  $l10 \u003d $r12.getBytesWritten()\n  $l11 \u003d $l10 \u0026 4294967295L\n  $b12 \u003d l9 cmp $l11\n  if ($b12 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r34 \u003d IOException\n  new IOException(\"Gzip-compressed data is corrupt (uncompressed size mismatch).\")\n  throw $r34\n}",
      "B19 {\n  $r13 \u003d GzipParameters parameters\u003e\n  $r13.setTrailerCrc(l6)\n  $r14 \u003d GzipParameters parameters\u003e\n  $r14.setTrailerISize(l9)\n  $r15 \u003d IOConsumer onMemberEnd\u003e\n  $r15.accept(r0)\n  $z3 \u003d GzipCompressorInputStream: boolean decompressConcatenated\u003e\n  if ($z3 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $z4 \u003d r0.init(0)\n  if ($z4 !\u003d 0) goto B21 else B25\n}",
      "B21 {\n  $r16 \u003d Inflater inflater\u003e\n  $r16.end()\n  Inflater inflater\u003e \u003d null\n  GzipCompressorInputStream: boolean endReached\u003e \u003d 1\n  if (i20 !\u003d 0) goto B22 else B23\n}",
      "B22 {\n  $i28 \u003d (int) -1\n  $i22 \u003d $i28\n  goto B24\n}",
      "B23 {\n  $i22 \u003d i20\n}",
      "B24 {\n  return\n}",
      "B25 {\n  goto B5\n}",
      "B26 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B26",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B25",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B5",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GzipCompressorInputStream#count(...1)",
        "body": "(source not found)"
      },
      {
        "name": "GzipCompressorInputStream#init(...1)",
        "body": "{\r\n    if (!isFirstMember \u0026\u0026 !decompressConcatenated) {\r\n        // at least one must be true\r\n        throw new IllegalStateException(\"Unexpected: isFirstMember and decompressConcatenated are both false.\");\r\n    }\r\n    // Check the magic bytes without a possibility of EOFException.\r\n    final int magic0 \u003d in.read();\r\n    // If end of input was reached after decompressing at least\r\n    // one .gz member, we have reached the end of the file successfully.\r\n    if (magic0 \u003d\u003d -1 \u0026\u0026 !isFirstMember) {\r\n        return false;\r\n    }\r\n    if (magic0 !\u003d GzipUtils.ID1 || in.read() !\u003d GzipUtils.ID2) {\r\n        throw new IOException(isFirstMember ? \"Input is not in the .gz format.\" : \"Unexpected data after a valid .gz stream.\");\r\n    }\r\n    parameters \u003d new GzipParameters();\r\n    parameters.setFileNameCharset(fileNameCharset);\r\n    // Parsing the rest of the header may throw EOFException.\r\n    final DataInput inData \u003d new DataInputStream(in);\r\n    final int method \u003d inData.readUnsignedByte();\r\n    if (method !\u003d Deflater.DEFLATED) {\r\n        throw new IOException(\"Unsupported compression method \" + method + \" in the .gz header\");\r\n    }\r\n    final int flg \u003d inData.readUnsignedByte();\r\n    if ((flg \u0026 GzipUtils.FRESERVED) !\u003d 0) {\r\n        throw new IOException(\"Reserved flags are set in the .gz header.\");\r\n    }\r\n    parameters.setModificationTime(ByteUtils.fromLittleEndian(inData, 4));\r\n    switch(// extra flags\r\n    inData.readUnsignedByte()) {\r\n        case GzipUtils.XFL_MAX_COMPRESSION:\r\n            parameters.setCompressionLevel(Deflater.BEST_COMPRESSION);\r\n            break;\r\n        case GzipUtils.XFL_MAX_SPEED:\r\n            parameters.setCompressionLevel(Deflater.BEST_SPEED);\r\n            break;\r\n        default:\r\n            parameters.setCompressionLevel(Deflater.DEFAULT_COMPRESSION);\r\n            break;\r\n    }\r\n    parameters.setOperatingSystem(inData.readUnsignedByte());\r\n    // Extra field\r\n    if ((flg \u0026 GzipUtils.FEXTRA) !\u003d 0) {\r\n        int xlen \u003d inData.readUnsignedByte();\r\n        xlen |\u003d inData.readUnsignedByte() \u003c\u003c 8;\r\n        final byte[] extra \u003d new byte[xlen];\r\n        inData.readFully(extra);\r\n        parameters.setExtraField(ExtraField.fromBytes(extra));\r\n    }\r\n    // Original file name\r\n    if ((flg \u0026 GzipUtils.FNAME) !\u003d 0) {\r\n        parameters.setFileName(new String(readToNull(inData), parameters.getFileNameCharset()));\r\n    }\r\n    // Comment\r\n    if ((flg \u0026 GzipUtils.FCOMMENT) !\u003d 0) {\r\n        parameters.setComment(new String(readToNull(inData), parameters.getFileNameCharset()));\r\n    }\r\n    // Header \"CRC16\" which is actually a truncated CRC32 (which isn\u0027t\r\n    // as good as real CRC16). I don\u0027t know if any encoder implementation\r\n    // sets this, so it\u0027s not worth trying to verify it. GNU gzip 1.4\r\n    // doesn\u0027t support this field, but zlib seems to be able to at least\r\n    // skip over it.\r\n    if ((flg \u0026 GzipUtils.FHCRC) !\u003d 0) {\r\n        parameters.setHeaderCRC(true);\r\n        inData.readShort();\r\n    }\r\n    // Reset\r\n    inflater.reset();\r\n    crc.reset();\r\n    onMemberStart.accept(this);\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!isClosed()) {\r\n        try {\r\n            finish();\r\n        } finally {\r\n            deflater.end();\r\n            super.close();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorOutputStream\n  $z0 \u003d r0.isClosed()\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  r0.finish()\n  $r1 \u003d Deflater deflater\u003e\n  $r1.end()\n  r0.close()\n  goto B3\n}",
      "B2 {\n  $r2 :\u003d @caughtexception\n  $r3 \u003d Deflater deflater\u003e\n  $r3.end()\n  r0.close()\n  throw $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GzipCompressorOutputStream#finish(...0)",
        "body": "{\r\n    if (!deflater.finished()) {\r\n        deflater.finish();\r\n        while (!deflater.finished()) {\r\n            deflate();\r\n        }\r\n        writeMemberTrailer();\r\n        deflater.reset();\r\n    }\r\n}"
      },
      {
        "name": "GzipCompressorOutputStream#isClosed(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!deflater.finished()) {\r\n        deflater.finish();\r\n        while (!deflater.finished()) {\r\n            deflate();\r\n        }\r\n        writeMemberTrailer();\r\n        deflater.reset();\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B5",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorOutputStream\n  $r1 \u003d Deflater deflater\u003e\n  $z0 \u003d $r1.finished()\n  if ($z0 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d Deflater deflater\u003e\n  $r2.finish()\n}",
      "B2 {\n  $r3 \u003d Deflater deflater\u003e\n  $z1 \u003d $r3.finished()\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  r0.deflate()\n  goto B2\n}",
      "B4 {\n  r0.writeMemberTrailer()\n  $r4 \u003d Deflater deflater\u003e\n  $r4.reset()\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GzipCompressorOutputStream#writeMemberTrailer(...0)",
        "body": "{\r\n    final ByteBuffer buffer \u003d ByteBuffer.allocate(8);\r\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\r\n    buffer.putInt((int) crc.getValue());\r\n    buffer.putInt(deflater.getTotalIn());\r\n    out.write(buffer.array());\r\n}"
      },
      {
        "name": "GzipCompressorOutputStream#deflate(...0)",
        "body": "{\r\n    final int length \u003d deflater.deflate(deflateBuffer, 0, deflateBuffer.length);\r\n    if (length \u003e 0) {\r\n        out.write(deflateBuffer, 0, length);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    checkOpen();\r\n    if (deflater.finished()) {\r\n        throw new IOException(\"Cannot write more data, the end of the compressed data stream has been reached.\");\r\n    }\r\n    if (length \u003e 0) {\r\n        deflater.setInput(buffer, offset, length);\r\n        while (!deflater.needsInput()) {\r\n            deflate();\r\n        }\r\n        crc.update(buffer, offset, length);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(i0 \u003c\u003d 0) → B3 | else → B7",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  GzipCompressorOutputStream\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0.checkOpen()\n  $r1 \u003d Deflater deflater\u003e\n  $z0 \u003d $r1.finished()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IOException\n  new IOException(\"Cannot write more data, the end of the compressed data stream has been reached.\")\n  throw $r6\n}",
      "B2 {\n  if (i0 \u003c\u003d 0) goto B3 else B7\n}",
      "B3 {\n  $r3 \u003d Deflater deflater\u003e\n  $r3.setInput(r2, i1, i0)\n}",
      "B4 {\n  $r4 \u003d Deflater deflater\u003e\n  $z1 \u003d $r4.needsInput()\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.deflate()\n  goto B4\n}",
      "B6 {\n  $r5 \u003d CRC32 crc\u003e\n  $r5.update(r2, i1, i0)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "GzipCompressorOutputStream#checkOpen(...0)",
        "body": "(source not found)"
      },
      {
        "name": "GzipCompressorOutputStream#deflate(...0)",
        "body": "{\r\n    final int length \u003d deflater.deflate(deflateBuffer, 0, deflateBuffer.length);\r\n    if (length \u003e 0) {\r\n        out.write(deflateBuffer, 0, length);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipParameters",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!(obj instanceof GzipParameters)) {\r\n        return false;\r\n    }\r\n    final GzipParameters other \u003d (GzipParameters) obj;\r\n    return bufferSize \u003d\u003d other.bufferSize \u0026\u0026 Objects.equals(comment, other.comment) \u0026\u0026 compressionLevel \u003d\u003d other.compressionLevel \u0026\u0026 deflateStrategy \u003d\u003d other.deflateStrategy \u0026\u0026 Objects.equals(extraField, other.extraField) \u0026\u0026 Objects.equals(fileName, other.fileName) \u0026\u0026 Objects.equals(fileNameCharset, other.fileNameCharset) \u0026\u0026 headerCrc \u003d\u003d other.headerCrc \u0026\u0026 Objects.equals(modificationInstant, other.modificationInstant) \u0026\u0026 operatingSystem \u003d\u003d other.operatingSystem \u0026\u0026 trailerCrc \u003d\u003d other.trailerCrc \u0026\u0026 trailerISize \u003d\u003d other.trailerISize;\r\n}",
    "nodes": 19,
    "edges": 30,
    "cc": 13,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If($i1 !\u003d $i0) → B5 | else → B17",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B17",
      "B6 : If($i3 !\u003d $i2) → B7 | else → B17",
      "B7 : If($i5 !\u003d $i4) → B8 | else → B17",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B17",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B17",
      "B10 : If($z4 \u003d\u003d false) → B11 | else → B17",
      "B11 : If($z6 !\u003d $z5) → B12 | else → B17",
      "B12 : If($z7 \u003d\u003d false) → B13 | else → B17",
      "B13 : If($r14 !\u003d $r13) → B14 | else → B17",
      "B14 : If($b8 !\u003d 0) → B15 | else → B17",
      "B15 : If($b11 !\u003d 0) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  GzipParameters\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d GzipParameters\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r2 \u003d GzipParameters) r1\n  $i1 \u003d GzipParameters: int bufferSize\u003e\n  $i0 \u003d GzipParameters: int bufferSize\u003e\n  if ($i1 !\u003d $i0) goto B5 else B17\n}",
      "B5 {\n  $r4 \u003d String comment\u003e\n  $r3 \u003d String comment\u003e\n  $z1 \u003d Objects.equals($r4, $r3)\n  if ($z1 \u003d\u003d false) goto B6 else B17\n}",
      "B6 {\n  $i3 \u003d GzipParameters: int compressionLevel\u003e\n  $i2 \u003d GzipParameters: int compressionLevel\u003e\n  if ($i3 !\u003d $i2) goto B7 else B17\n}",
      "B7 {\n  $i5 \u003d GzipParameters: int deflateStrategy\u003e\n  $i4 \u003d GzipParameters: int deflateStrategy\u003e\n  if ($i5 !\u003d $i4) goto B8 else B17\n}",
      "B8 {\n  $r6 \u003d ExtraField extraField\u003e\n  $r5 \u003d ExtraField extraField\u003e\n  $z2 \u003d Objects.equals($r6, $r5)\n  if ($z2 \u003d\u003d false) goto B9 else B17\n}",
      "B9 {\n  $r8 \u003d String fileName\u003e\n  $r7 \u003d String fileName\u003e\n  $z3 \u003d Objects.equals($r8, $r7)\n  if ($z3 \u003d\u003d false) goto B10 else B17\n}",
      "B10 {\n  $r10 \u003d Charset fileNameCharset\u003e\n  $r9 \u003d Charset fileNameCharset\u003e\n  $z4 \u003d Objects.equals($r10, $r9)\n  if ($z4 \u003d\u003d false) goto B11 else B17\n}",
      "B11 {\n  $z6 \u003d GzipParameters: boolean headerCrc\u003e\n  $z5 \u003d GzipParameters: boolean headerCrc\u003e\n  if ($z6 !\u003d $z5) goto B12 else B17\n}",
      "B12 {\n  $r12 \u003d Instant modificationInstant\u003e\n  $r11 \u003d Instant modificationInstant\u003e\n  $z7 \u003d Objects.equals($r12, $r11)\n  if ($z7 \u003d\u003d false) goto B13 else B17\n}",
      "B13 {\n  $r14 \u003d GzipParameters$OS operatingSystem\u003e\n  $r13 \u003d GzipParameters$OS operatingSystem\u003e\n  if ($r14 !\u003d $r13) goto B14 else B17\n}",
      "B14 {\n  $l7 \u003d GzipParameters: long trailerCrc\u003e\n  $l6 \u003d GzipParameters: long trailerCrc\u003e\n  $b8 \u003d $l7 cmp $l6\n  if ($b8 !\u003d 0) goto B15 else B17\n}",
      "B15 {\n  $l10 \u003d GzipParameters: long trailerISize\u003e\n  $l9 \u003d GzipParameters: long trailerISize\u003e\n  $b11 \u003d $l10 cmp $l9\n  if ($b11 !\u003d 0) goto B16 else B17\n}",
      "B16 {\n  $z8 \u003d 1\n  goto B18\n}",
      "B17 {\n  $z8 \u003d 0\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B17",
      "B5 --\u003e B6",
      "B5 --\u003e B17",
      "B6 --\u003e B7",
      "B6 --\u003e B17",
      "B7 --\u003e B8",
      "B7 --\u003e B17",
      "B8 --\u003e B9",
      "B8 --\u003e B17",
      "B9 --\u003e B10",
      "B9 --\u003e B17",
      "B10 --\u003e B11",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B17",
      "B12 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipParameters",
    "methodName": "setBufferSize",
    "signature": "void setBufferSize(int)",
    "visibility": "public",
    "body": "{\r\n    if (bufferSize \u003c\u003d 0) {\r\n        throw new IllegalArgumentException(\"invalid buffer size: \" + bufferSize);\r\n    }\r\n    this.bufferSize \u003d bufferSize;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GzipParameters\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r2.append(\"invalid buffer size: \")\n  $r4 \u003d $r3.append(i0)\n  $r5 \u003d $r4.toString()\n  new IllegalArgumentException($r5)\n  throw $r1\n}",
      "B2 {\n  GzipParameters: int bufferSize\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipParameters",
    "methodName": "setCompressionLevel",
    "signature": "void setCompressionLevel(int)",
    "visibility": "public",
    "body": "{\r\n    if (compressionLevel \u003c -1 || compressionLevel \u003e 9) {\r\n        throw new IllegalArgumentException(\"Invalid gzip compression level: \" + compressionLevel);\r\n    }\r\n    this.compressionLevel \u003d compressionLevel;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c $i2) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d 9) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  GzipParameters\n  i0 :\u003d @parameter0: int\n  $i2 \u003d (int) -1\n  if (i0 \u003c $i2) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d 9) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r6.append(\"Invalid gzip compression level: \")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IllegalArgumentException($r4)\n  throw $r7\n}",
      "B3 {\n  GzipParameters: int compressionLevel\u003e \u003d i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipParameters",
    "methodName": "setModificationInstant",
    "signature": "void setModificationInstant(java.time.Instant)",
    "visibility": "public",
    "body": "{\r\n    this.modificationInstant \u003d modificationTime !\u003d null ? modificationTime : Instant.EPOCH;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GzipParameters\n  Instant\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d Instant EPOCH\u003e\n}",
      "B3 {\n  Instant modificationInstant\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.gzip.GzipParameters",
    "methodName": "setOS",
    "signature": "void setOS(org.apache.commons.compress.compressors.gzip.GzipParameters$OS)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  GzipParameters\n  GzipParameters$OS\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d GzipParameters$OS UNKNOWN\u003e\n}",
      "B3 {\n  GzipParameters$OS operatingSystem\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    switch(state) {\r\n        case EOF:\r\n            return -1;\r\n        case // NOSONAR - fallthrough intended\r\n        NO_BLOCK:\r\n            readSizes();\r\n        // falls-through\r\n        case IN_LITERAL:\r\n            final int litLen \u003d readLiteral(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.LOOKING_FOR_BACK_REFERENCE;\r\n            }\r\n            return litLen \u003e 0 ? litLen : read(b, off, len);\r\n        case // NOSONAR - fallthrough intended\r\n        LOOKING_FOR_BACK_REFERENCE:\r\n            if (!initializeBackReference()) {\r\n                state \u003d State.EOF;\r\n                return -1;\r\n            }\r\n        // falls-through\r\n        case IN_BACK_REFERENCE:\r\n            final int backReferenceLen \u003d readBackReference(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return backReferenceLen \u003e 0 ? backReferenceLen : read(b, off, len);\r\n        default:\r\n            throw new IOException(\"Unknown stream state \" + state);\r\n    }\r\n}",
    "nodes": 20,
    "edges": 25,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(switch-on $i1) → B4 | else → B5",
      "B5 : If($z2 !\u003d 0) → B6 | else → B7",
      "B7 : If($i4 \u003c\u003d 0) → B8 | else → B9",
      "B11 : If($z1 !\u003d 0) → B12 | else → B13",
      "B13 : If($z0 !\u003d 0) → B14 | else → B15",
      "B15 : If($i3 \u003c\u003d 0) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  BlockLZ4CompressorInputStream\n  r2 :\u003d @parameter0: byte[]\n  i2 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d BlockLZ4CompressorInputStream$State state\u003e\n  $i1 \u003d $r1.ordinal()\n  IOException; }\n}",
      "B3 {\n  $i8 \u003d (int) -1\n  return\n}",
      "B4 {\n  r0.readSizes()\n}",
      "B5 {\n  $i4 \u003d r0.readLiteral(r2, i2, i0)\n  $z2 \u003d r0.hasMoreDataInBlock()\n  if ($z2 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r5 \u003d BlockLZ4CompressorInputStream$State LOOKING_FOR_BACK_REFERENCE\u003e\n  BlockLZ4CompressorInputStream$State state\u003e \u003d $r5\n}",
      "B7 {\n  if ($i4 \u003c\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $i5 \u003d $i4\n  goto B10\n}",
      "B9 {\n  $i5 \u003d r0.read(r2, i2, i0)\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $z1 \u003d r0.initializeBackReference()\n  if ($z1 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r4 \u003d BlockLZ4CompressorInputStream$State EOF\u003e\n  BlockLZ4CompressorInputStream$State state\u003e \u003d $r4\n  $i10 \u003d (int) -1\n  return\n}",
      "B13 {\n  $i3 \u003d r0.readBackReference(r2, i2, i0)\n  $z0 \u003d r0.hasMoreDataInBlock()\n  if ($z0 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $r3 \u003d BlockLZ4CompressorInputStream$State NO_BLOCK\u003e\n  BlockLZ4CompressorInputStream$State state\u003e \u003d $r3\n}",
      "B15 {\n  if ($i3 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  $i6 \u003d $i3\n  goto B18\n}",
      "B17 {\n  $i6 \u003d r0.read(r2, i2, i0)\n}",
      "B18 {\n  return\n}",
      "B19 {\n  $r13 \u003d IOException\n  $r12 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r12.append(\"Unknown stream state \")\n  $r8 \u003d BlockLZ4CompressorInputStream$State state\u003e\n  $r10 \u003d $r9.append($r8)\n  $r11 \u003d $r10.toString()\n  new IOException($r11)\n  throw $r13\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B2 --\u003e B11",
      "B2 --\u003e B13",
      "B2 --\u003e B3",
      "B2 --\u003e B19",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BlockLZ4CompressorInputStream#readBackReference(...3)",
        "body": "(source not found)"
      },
      {
        "name": "BlockLZ4CompressorInputStream#readLiteral(...3)",
        "body": "(source not found)"
      },
      {
        "name": "BlockLZ4CompressorInputStream#hasMoreDataInBlock(...0)",
        "body": "(source not found)"
      },
      {
        "name": "BlockLZ4CompressorInputStream#read(...3)",
        "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    switch(state) {\r\n        case EOF:\r\n            return -1;\r\n        case // NOSONAR - fallthrough intended\r\n        NO_BLOCK:\r\n            readSizes();\r\n        // falls-through\r\n        case IN_LITERAL:\r\n            final int litLen \u003d readLiteral(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.LOOKING_FOR_BACK_REFERENCE;\r\n            }\r\n            return litLen \u003e 0 ? litLen : read(b, off, len);\r\n        case // NOSONAR - fallthrough intended\r\n        LOOKING_FOR_BACK_REFERENCE:\r\n            if (!initializeBackReference()) {\r\n                state \u003d State.EOF;\r\n                return -1;\r\n            }\r\n        // falls-through\r\n        case IN_BACK_REFERENCE:\r\n            final int backReferenceLen \u003d readBackReference(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return backReferenceLen \u003e 0 ? backReferenceLen : read(b, off, len);\r\n        default:\r\n            throw new IOException(\"Unknown stream state \" + state);\r\n    }\r\n}"
      },
      {
        "name": "BlockLZ4CompressorInputStream#readSizes(...0)",
        "body": "{\r\n    final int nextBlock \u003d readOneByte();\r\n    if (nextBlock \u003d\u003d -1) {\r\n        throw new IOException(\"Premature end of stream while looking for next block\");\r\n    }\r\n    nextBackReferenceSize \u003d nextBlock \u0026 BACK_REFERENCE_SIZE_MASK;\r\n    long literalSizePart \u003d (nextBlock \u0026 LITERAL_SIZE_MASK) \u003e\u003e SIZE_BITS;\r\n    if (literalSizePart \u003d\u003d BACK_REFERENCE_SIZE_MASK) {\r\n        literalSizePart +\u003d readSizeBytes();\r\n    }\r\n    if (literalSizePart \u003c 0) {\r\n        throw new IOException(\"Illegal block with a negative literal size found\");\r\n    }\r\n    startLiteral(literalSizePart);\r\n    state \u003d State.IN_LITERAL;\r\n}"
      },
      {
        "name": "BlockLZ4CompressorInputStream#initializeBackReference(...0)",
        "body": "{\r\n    final int backReferenceOffset;\r\n    try {\r\n        backReferenceOffset \u003d (int) ByteUtils.fromLittleEndian(supplier, 2);\r\n    } catch (final IOException ex) {\r\n        if (nextBackReferenceSize \u003d\u003d 0) {\r\n            // the last block has no back-reference\r\n            return false;\r\n        }\r\n        throw ex;\r\n    }\r\n    long backReferenceSize \u003d nextBackReferenceSize;\r\n    if (nextBackReferenceSize \u003d\u003d BACK_REFERENCE_SIZE_MASK) {\r\n        backReferenceSize +\u003d readSizeBytes();\r\n    }\r\n    // minimal match length 4 is encoded as 0\r\n    if (backReferenceSize \u003c 0) {\r\n        throw new IOException(\"Illegal block with a negative match length found\");\r\n    }\r\n    try {\r\n        startBackReference(backReferenceOffset, backReferenceSize + 4);\r\n    } catch (final IllegalArgumentException ex) {\r\n        throw new IOException(\"Illegal block with bad offset found\", ex);\r\n    }\r\n    state \u003d State.IN_BACK_REFERENCE;\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!isFinished()) {\r\n        compressor.finish();\r\n        super.finish();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BlockLZ4CompressorOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d LZ77Compressor compressor\u003e\n  $r1.finish()\n  r0.finish()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BlockLZ4CompressorOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.BlockLZ4CompressorOutputStream",
    "methodName": "prefill",
    "signature": "void prefill(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003e 0) {\r\n        final byte[] b \u003d Arrays.copyOfRange(data, off, off + len);\r\n        compressor.prefill(b);\r\n        recordLiteral(b);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BlockLZ4CompressorOutputStream\n  r0 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d i1 + i0\n  r1 \u003d Arrays.copyOfRange(r0, i1, $i2)\n  $r3 \u003d LZ77Compressor compressor\u003e\n  $r3.prefill(r1)\n  r2.recordLiteral(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BlockLZ4CompressorOutputStream#recordLiteral(...1)",
        "body": "{\r\n    expandedBlocks.addFirst(b);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c LZ4_SIGNATURE.length) {\r\n        return false;\r\n    }\r\n    byte[] shortenedSig \u003d signature;\r\n    if (signature.length \u003e LZ4_SIGNATURE.length) {\r\n        shortenedSig \u003d Arrays.copyOf(signature, LZ4_SIGNATURE.length);\r\n    }\r\n    return Arrays.equals(shortenedSig, LZ4_SIGNATURE);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B2 : If($i3 \u003c\u003d $i2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d FramedLZ4CompressorInputStream: byte[] LZ4_SIGNATURE\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r5 \u003d r1\n  $i3 \u003d lengthof r1\n  $r2 \u003d FramedLZ4CompressorInputStream: byte[] LZ4_SIGNATURE\u003e\n  $i2 \u003d lengthof $r2\n  if ($i3 \u003c\u003d $i2) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d FramedLZ4CompressorInputStream: byte[] LZ4_SIGNATURE\u003e\n  $i4 \u003d lengthof $r4\n  r5 \u003d Arrays.copyOf(r1, $i4)\n}",
      "B4 {\n  $r3 \u003d FramedLZ4CompressorInputStream: byte[] LZ4_SIGNATURE\u003e\n  $z0 \u003d Arrays.equals(r5, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    return read(oneByte, 0, 1) \u003d\u003d -1 ? -1 : oneByte[0] \u0026 0xFF;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d $i4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FramedLZ4CompressorInputStream\n  $r1 \u003d FramedLZ4CompressorInputStream: byte[] oneByte\u003e\n  $i0 \u003d r0.read($r1, 0, 1)\n  $i4 \u003d (int) -1\n  if ($i0 !\u003d $i4) goto B1 else B2\n}",
      "B1 {\n  $s2 \u003d -1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d FramedLZ4CompressorInputStream: byte[] oneByte\u003e\n  $b1 \u003d $r2[0]\n  $s2 \u003d $b1 \u0026 255\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedLZ4CompressorInputStream#read(...3)",
        "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    int r \u003d readOnce(b, off, len);\r\n    if (r \u003d\u003d -1) {\r\n        nextBlock();\r\n        if (!endReached) {\r\n            r \u003d readOnce(b, off, len);\r\n        }\r\n    }\r\n    if (r !\u003d -1) {\r\n        if (expectBlockDependency) {\r\n            appendToBlockDependencyBuffer(b, off, r);\r\n        }\r\n        if (expectContentChecksum) {\r\n            contentHash.update(b, off, r);\r\n        }\r\n    }\r\n    return r;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    int r \u003d readOnce(b, off, len);\r\n    if (r \u003d\u003d -1) {\r\n        nextBlock();\r\n        if (!endReached) {\r\n            r \u003d readOnce(b, off, len);\r\n        }\r\n    }\r\n    if (r !\u003d -1) {\r\n        if (expectBlockDependency) {\r\n            appendToBlockDependencyBuffer(b, off, r);\r\n        }\r\n        if (expectContentChecksum) {\r\n            contentHash.update(b, off, r);\r\n        }\r\n    }\r\n    return r;\r\n}",
    "nodes": 13,
    "edges": 17,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(i2 !\u003d $i6) → B5 | else → B7",
      "B5 : If($z3 !\u003d 0) → B6 | else → B7",
      "B7 : If(i2 \u003d\u003d $i8) → B8 | else → B12",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  FramedLZ4CompressorInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d FramedLZ4CompressorInputStream: boolean endReached\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i4 \u003d (int) -1\n  return\n}",
      "B4 {\n  i2 \u003d r0.readOnce(r1, i1, i0)\n  $i6 \u003d (int) -1\n  if (i2 !\u003d $i6) goto B5 else B7\n}",
      "B5 {\n  r0.nextBlock()\n  $z3 \u003d FramedLZ4CompressorInputStream: boolean endReached\u003e\n  if ($z3 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  i2 \u003d r0.readOnce(r1, i1, i0)\n}",
      "B7 {\n  $i8 \u003d (int) -1\n  if (i2 \u003d\u003d $i8) goto B8 else B12\n}",
      "B8 {\n  $z1 \u003d FramedLZ4CompressorInputStream: boolean expectBlockDependency\u003e\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r0.appendToBlockDependencyBuffer(r1, i1, i2)\n}",
      "B10 {\n  $z2 \u003d FramedLZ4CompressorInputStream: boolean expectContentChecksum\u003e\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r2 \u003d XXHash32 contentHash\u003e\n  $r2.update(r1, i1, i2)\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedLZ4CompressorInputStream#readOnce(...3)",
        "body": "{\r\n    if (inUncompressed) {\r\n        final int cnt \u003d currentBlock.read(b, off, len);\r\n        count(cnt);\r\n        return cnt;\r\n    }\r\n    final BlockLZ4CompressorInputStream l \u003d (BlockLZ4CompressorInputStream) currentBlock;\r\n    final long before \u003d l.getBytesRead();\r\n    final int cnt \u003d currentBlock.read(b, off, len);\r\n    count(l.getBytesRead() - before);\r\n    return cnt;\r\n}"
      },
      {
        "name": "FramedLZ4CompressorInputStream#nextBlock(...0)",
        "body": "{\r\n    maybeFinishCurrentBlock();\r\n    final long len \u003d ByteUtils.fromLittleEndian(supplier, 4);\r\n    final boolean uncompressed \u003d (len \u0026 UNCOMPRESSED_FLAG_MASK) !\u003d 0;\r\n    final int realLen \u003d (int) (len \u0026 ~UNCOMPRESSED_FLAG_MASK);\r\n    if (realLen \u003d\u003d 0) {\r\n        verifyContentChecksum();\r\n        if (!decompressConcatenated) {\r\n            endReached \u003d true;\r\n        } else {\r\n            init(false);\r\n        }\r\n        return;\r\n    }\r\n    // @formatter:off\r\n    InputStream capped \u003d BoundedInputStream.builder().setInputStream(inputStream).setMaxCount(realLen).setPropagateClose(false).get();\r\n    // @formatter:on\r\n    if (expectBlockChecksum) {\r\n        capped \u003d new CheckedInputStream(capped, blockHash);\r\n    }\r\n    if (uncompressed) {\r\n        inUncompressed \u003d true;\r\n        currentBlock \u003d capped;\r\n    } else {\r\n        inUncompressed \u003d false;\r\n        final BlockLZ4CompressorInputStream s \u003d new BlockLZ4CompressorInputStream(capped);\r\n        if (expectBlockDependency) {\r\n            s.prefill(blockDependencyBuffer);\r\n        }\r\n        currentBlock \u003d s;\r\n    }\r\n}"
      },
      {
        "name": "FramedLZ4CompressorInputStream#appendToBlockDependencyBuffer(...3)",
        "body": "{\r\n    len \u003d Math.min(len, blockDependencyBuffer.length);\r\n    if (len \u003e 0) {\r\n        final int keep \u003d blockDependencyBuffer.length - len;\r\n        if (keep \u003e 0) {\r\n            // move last keep bytes towards the start of the buffer\r\n            System.arraycopy(blockDependencyBuffer, len, blockDependencyBuffer, 0, keep);\r\n        }\r\n        // append new data\r\n        System.arraycopy(b, off, blockDependencyBuffer, keep, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!isFinished()) {\r\n        flushBlock();\r\n        writeTrailer();\r\n        super.finish();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FramedLZ4CompressorOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.flushBlock()\n  r0.writeTrailer()\n  r0.finish()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedLZ4CompressorOutputStream#isFinished(...0)",
        "body": "(source not found)"
      },
      {
        "name": "FramedLZ4CompressorOutputStream#writeTrailer(...0)",
        "body": "{\r\n    out.write(END_MARK);\r\n    if (params.withContentChecksum) {\r\n        ByteUtils.toLittleEndian(out, contentHash.getValue(), 4);\r\n    }\r\n}"
      },
      {
        "name": "FramedLZ4CompressorOutputStream#flushBlock(...0)",
        "body": "{\r\n    if (currentIndex \u003d\u003d 0) {\r\n        return;\r\n    }\r\n    final boolean withBlockDependency \u003d params.withBlockDependency;\r\n    final ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\r\n    try (BlockLZ4CompressorOutputStream o \u003d new BlockLZ4CompressorOutputStream(baos, params.lz77params)) {\r\n        if (withBlockDependency) {\r\n            o.prefill(blockDependencyBuffer, blockDependencyBuffer.length - collectedBlockDependencyBytes, collectedBlockDependencyBytes);\r\n        }\r\n        o.write(blockData, 0, currentIndex);\r\n    }\r\n    if (withBlockDependency) {\r\n        appendToBlockDependencyBuffer(blockData, 0, currentIndex);\r\n    }\r\n    final byte[] b \u003d baos.toByteArray();\r\n    if (b.length \u003e currentIndex) {\r\n        // compression increased size, maybe beyond blocksize\r\n        ByteUtils.toLittleEndian(out, currentIndex | FramedLZ4CompressorInputStream.UNCOMPRESSED_FLAG_MASK, 4);\r\n        out.write(blockData, 0, currentIndex);\r\n        if (params.withBlockChecksum) {\r\n            blockHash.update(blockData, 0, currentIndex);\r\n        }\r\n    } else {\r\n        ByteUtils.toLittleEndian(out, b.length, 4);\r\n        out.write(b);\r\n        if (params.withBlockChecksum) {\r\n            blockHash.update(b, 0, b.length);\r\n        }\r\n    }\r\n    if (params.withBlockChecksum) {\r\n        ByteUtils.toLittleEndian(out, blockHash.getValue(), 4);\r\n        blockHash.reset();\r\n    }\r\n    currentIndex \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (params.withContentChecksum) {\r\n        contentHash.update(data, off, len);\r\n    }\r\n    int blockDataRemaining \u003d blockData.length - currentIndex;\r\n    while (len \u003e 0) {\r\n        final int copyLen \u003d Math.min(len, blockDataRemaining);\r\n        System.arraycopy(data, off, blockData, currentIndex, copyLen);\r\n        off +\u003d copyLen;\r\n        blockDataRemaining -\u003d copyLen;\r\n        len -\u003d copyLen;\r\n        currentIndex +\u003d copyLen;\r\n        if (blockDataRemaining \u003d\u003d 0) {\r\n            flushBlock();\r\n            blockDataRemaining \u003d blockData.length;\r\n        }\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i7 \u003c\u003d 0) → B4 | else → B7",
      "B4 : If(i8 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  FramedLZ4CompressorOutputStream\n  r3 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i7 :\u003d @parameter2: int\n  $r1 \u003d FramedLZ4CompressorOutputStream$Parameters params\u003e\n  $z0 \u003d FramedLZ4CompressorOutputStream$Parameters.access$400($r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d XXHash32 contentHash\u003e\n  $r6.update(r3, i6, i7)\n}",
      "B2 {\n  $r2 \u003d FramedLZ4CompressorOutputStream: byte[] blockData\u003e\n  $i1 \u003d lengthof $r2\n  $i0 \u003d FramedLZ4CompressorOutputStream: int currentIndex\u003e\n  i8 \u003d $i1 - $i0\n}",
      "B3 {\n  if (i7 \u003c\u003d 0) goto B4 else B7\n}",
      "B4 {\n  i2 \u003d Math.min(i7, i8)\n  $r4 \u003d FramedLZ4CompressorOutputStream: byte[] blockData\u003e\n  $i3 \u003d FramedLZ4CompressorOutputStream: int currentIndex\u003e\n  System.arraycopy(r3, i6, $r4, $i3, i2)\n  i6 \u003d i6 + i2\n  i8 \u003d i8 - i2\n  i7 \u003d i7 - i2\n  $i4 \u003d FramedLZ4CompressorOutputStream: int currentIndex\u003e\n  $i5 \u003d $i4 + i2\n  FramedLZ4CompressorOutputStream: int currentIndex\u003e \u003d $i5\n  if (i8 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.flushBlock()\n  $r5 \u003d FramedLZ4CompressorOutputStream: byte[] blockData\u003e\n  i8 \u003d lengthof $r5\n}",
      "B6 {\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedLZ4CompressorOutputStream#flushBlock(...0)",
        "body": "{\r\n    if (currentIndex \u003d\u003d 0) {\r\n        return;\r\n    }\r\n    final boolean withBlockDependency \u003d params.withBlockDependency;\r\n    final ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\r\n    try (BlockLZ4CompressorOutputStream o \u003d new BlockLZ4CompressorOutputStream(baos, params.lz77params)) {\r\n        if (withBlockDependency) {\r\n            o.prefill(blockDependencyBuffer, blockDependencyBuffer.length - collectedBlockDependencyBytes, collectedBlockDependencyBytes);\r\n        }\r\n        o.write(blockData, 0, currentIndex);\r\n    }\r\n    if (withBlockDependency) {\r\n        appendToBlockDependencyBuffer(blockData, 0, currentIndex);\r\n    }\r\n    final byte[] b \u003d baos.toByteArray();\r\n    if (b.length \u003e currentIndex) {\r\n        // compression increased size, maybe beyond blocksize\r\n        ByteUtils.toLittleEndian(out, currentIndex | FramedLZ4CompressorInputStream.UNCOMPRESSED_FLAG_MASK, 4);\r\n        out.write(blockData, 0, currentIndex);\r\n        if (params.withBlockChecksum) {\r\n            blockHash.update(blockData, 0, currentIndex);\r\n        }\r\n    } else {\r\n        ByteUtils.toLittleEndian(out, b.length, 4);\r\n        out.write(b);\r\n        if (params.withBlockChecksum) {\r\n            blockHash.update(b, 0, b.length);\r\n        }\r\n    }\r\n    if (params.withBlockChecksum) {\r\n        ByteUtils.toLittleEndian(out, blockHash.getValue(), 4);\r\n        blockHash.reset();\r\n    }\r\n    currentIndex \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz77support.LZ77Compressor",
    "methodName": "compress",
    "signature": "void compress(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    final int wSize \u003d params.getWindowSize();\r\n    while (len \u003e wSize) {\r\n        // chop into windowSize sized chunks\r\n        doCompress(data, off, wSize);\r\n        off +\u003d wSize;\r\n        len -\u003d wSize;\r\n    }\r\n    if (len \u003e 0) {\r\n        doCompress(data, off, len);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i2 \u003c\u003d i0) → B2 | else → B3",
      "B3 : If(i2 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LZ77Compressor\n  r2 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  $r1 \u003d Parameters params\u003e\n  i0 \u003d $r1.getWindowSize()\n}",
      "B1 {\n  if (i2 \u003c\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r0.doCompress(r2, i1, i0)\n  i1 \u003d i1 + i0\n  i2 \u003d i2 - i0\n  goto B1\n}",
      "B3 {\n  if (i2 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r0.doCompress(r2, i1, i2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZ77Compressor#doCompress(...3)",
        "body": "{\r\n    final int spaceLeft \u003d window.length - currentPosition - lookahead;\r\n    if (len \u003e spaceLeft) {\r\n        slide();\r\n    }\r\n    System.arraycopy(data, off, window, currentPosition + lookahead, len);\r\n    lookahead +\u003d len;\r\n    if (!initialized \u0026\u0026 lookahead \u003e\u003d params.getMinBackReferenceLength()) {\r\n        initialize();\r\n    }\r\n    if (initialized) {\r\n        compress();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz77support.LZ77Compressor",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (blockStart !\u003d currentPosition || lookahead \u003e 0) {\r\n        currentPosition +\u003d lookahead;\r\n        flushLiteralBlock();\r\n    }\r\n    callback.accept(EOD.INSTANCE);\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 !\u003d $i0) → B1 | else → B2",
      "B1 : If($i5 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  LZ77Compressor\n  $i1 \u003d LZ77Compressor: int blockStart\u003e\n  $i0 \u003d LZ77Compressor: int currentPosition\u003e\n  if ($i1 !\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  $i5 \u003d LZ77Compressor: int lookahead\u003e\n  if ($i5 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i3 \u003d LZ77Compressor: int currentPosition\u003e\n  $i2 \u003d LZ77Compressor: int lookahead\u003e\n  $i4 \u003d $i3 + $i2\n  LZ77Compressor: int currentPosition\u003e \u003d $i4\n  r0.flushLiteralBlock()\n}",
      "B3 {\n  $r1 \u003d LZ77Compressor$Callback callback\u003e\n  $r2 \u003d LZ77Compressor$EOD.access$000()\n  $r1.accept($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZ77Compressor#flushLiteralBlock(...0)",
        "body": "{\r\n    callback.accept(new LiteralBlock(window, blockStart, currentPosition - blockStart));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lz77support.LZ77Compressor",
    "methodName": "prefill",
    "signature": "void prefill(byte[])",
    "visibility": "public",
    "body": "{\r\n    if (currentPosition !\u003d 0 || lookahead !\u003d 0) {\r\n        throw new IllegalStateException(\"The compressor has already started to accept data, can\u0027t prefill anymore\");\r\n    }\r\n    // don\u0027t need more than windowSize for back-references\r\n    final int len \u003d Math.min(params.getWindowSize(), data.length);\r\n    System.arraycopy(data, data.length - len, window, 0, len);\r\n    if (len \u003e\u003d NUMBER_OF_BYTES_IN_HASH) {\r\n        initialize();\r\n        final int stop \u003d len - NUMBER_OF_BYTES_IN_HASH + 1;\r\n        for (int i \u003d 0; i \u003c stop; i++) {\r\n            insertString(i);\r\n        }\r\n        missedInserts \u003d NUMBER_OF_BYTES_IN_HASH - 1;\r\n    } else {\r\n        // not enough data to hash anything\r\n        missedInserts \u003d len;\r\n    }\r\n    blockStart \u003d currentPosition \u003d len;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B1 : If($i1 \u003d\u003d false) → B2 | else → B3",
      "B3 : If(i4 \u003c 3) → B4 | else → B8",
      "B5 : If(i9 \u003e\u003d i8) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  LZ77Compressor\n  r3 :\u003d @parameter0: byte[]\n  $i0 \u003d LZ77Compressor: int currentPosition\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d LZ77Compressor: int lookahead\u003e\n  if ($i1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalStateException\n  new IllegalStateException(\"The compressor has already started to accept data, can\\\u0027t prefill anymore\")\n  throw $r1\n}",
      "B3 {\n  $r2 \u003d Parameters params\u003e\n  $i3 \u003d $r2.getWindowSize()\n  $i2 \u003d lengthof r3\n  i4 \u003d Math.min($i3, $i2)\n  $i5 \u003d lengthof r3\n  $i6 \u003d $i5 - i4\n  $r4 \u003d LZ77Compressor: byte[] window\u003e\n  System.arraycopy(r3, $i6, $r4, 0, i4)\n  if (i4 \u003c 3) goto B4 else B8\n}",
      "B4 {\n  r0.initialize()\n  $i7 \u003d i4 - 3\n  i8 \u003d $i7 + 1\n  i9 \u003d 0\n}",
      "B5 {\n  if (i9 \u003e\u003d i8) goto B6 else B7\n}",
      "B6 {\n  r0.insertString(i9)\n  i9 \u003d i9 + 1\n  goto B5\n}",
      "B7 {\n  LZ77Compressor: int missedInserts\u003e \u003d 2\n  goto B9\n}",
      "B8 {\n  LZ77Compressor: int missedInserts\u003e \u003d i4\n}",
      "B9 {\n  LZ77Compressor: int currentPosition\u003e \u003d i4\n  LZ77Compressor: int blockStart\u003e \u003d i4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZ77Compressor#insertString(...1)",
        "body": "{\r\n    insertHash \u003d nextHash(insertHash, window[pos - 1 + NUMBER_OF_BYTES_IN_HASH]);\r\n    final int hashHead \u003d head[insertHash];\r\n    prev[pos \u0026 wMask] \u003d hashHead;\r\n    head[insertHash] \u003d pos;\r\n    return hashHead;\r\n}"
      },
      {
        "name": "LZ77Compressor#initialize(...0)",
        "body": "{\r\n    for (int i \u003d 0; i \u003c NUMBER_OF_BYTES_IN_HASH - 1; i++) {\r\n        insertHash \u003d nextHash(insertHash, window[i]);\r\n    }\r\n    initialized \u003d true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return signature !\u003d null \u0026\u0026 length \u003e\u003d 3 \u0026\u0026 signature[0] \u003d\u003d 0x5d \u0026\u0026 signature[1] \u003d\u003d 0 \u0026\u0026 signature[2] \u003d\u003d 0;\r\n}",
    "nodes": 8,
    "edges": 12,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B6",
      "B1 : If(i0 \u003c 3) → B2 | else → B6",
      "B2 : If($i4 !\u003d 93) → B3 | else → B6",
      "B3 : If($b2 !\u003d 0) → B4 | else → B6",
      "B4 : If($b3 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (r0 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  if (i0 \u003c 3) goto B2 else B6\n}",
      "B2 {\n  $b1 \u003d r0[0]\n  $i4 \u003d (int) $b1\n  if ($i4 !\u003d 93) goto B3 else B6\n}",
      "B3 {\n  $b2 \u003d r0[1]\n  if ($b2 !\u003d 0) goto B4 else B6\n}",
      "B4 {\n  $b3 \u003d r0[2]\n  if ($b3 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z0 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z0 \u003d 0\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    final int ret \u003d in.read();\r\n    count(ret \u003d\u003d -1 ? 0 : 1);\r\n    return ret;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LZMACompressorInputStream\n  $r1 \u003d InputStream in\u003e\n  i0 \u003d $r1.read()\n  $i3 \u003d (int) -1\n  if (i0 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d 0\n  goto B3\n}",
      "B2 {\n  $b1 \u003d 1\n}",
      "B3 {\n  r0.count($b1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZMACompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lzma.LZMAUtils",
    "methodName": "isLZMACompressionAvailable",
    "signature": "boolean isLZMACompressionAvailable()",
    "visibility": "public",
    "body": "{\r\n    final CachedAvailability cachedResult \u003d cachedLZMAAvailability;\r\n    if (cachedResult !\u003d CachedAvailability.DONT_CACHE) {\r\n        return cachedResult \u003d\u003d CachedAvailability.CACHED_AVAILABLE;\r\n    }\r\n    return internalIsLZMACompressionAvailable();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r1) → B1 | else → B5",
      "B1 : If(r0 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 \u003d LZMAUtils$CachedAvailability cachedLZMAAvailability\u003e\n  $r1 \u003d LZMAUtils$CachedAvailability DONT_CACHE\u003e\n  if (r0 \u003d\u003d $r1) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d LZMAUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  if (r0 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d LZMAUtils.internalIsLZMACompressionAvailable()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZMAUtils#internalIsLZMACompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        LZMACompressorInputStream.matches(null, 0);\r\n        return true;\r\n    } catch (final NoClassDefFoundError error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lzma.LZMAUtils",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c HEADER_MAGIC.length) {\r\n        return false;\r\n    }\r\n    for (int i \u003d 0; i \u003c HEADER_MAGIC.length; ++i) {\r\n        if (signature[i] !\u003d HEADER_MAGIC[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i6 \u003d\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d LZMAUtils: byte[] HEADER_MAGIC\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i5 \u003d 0\n}",
      "B3 {\n  $r1 \u003d LZMAUtils: byte[] HEADER_MAGIC\u003e\n  $i2 \u003d lengthof $r1\n  if (i5 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b4 \u003d r2[i5]\n  $r3 \u003d LZMAUtils: byte[] HEADER_MAGIC\u003e\n  $b3 \u003d $r3[i5]\n  $i6 \u003d (int) $b4\n  $i7 \u003d (int) $b3\n  if ($i6 \u003d\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.lzma.LZMAUtils",
    "methodName": "setCacheLZMAAvailablity",
    "signature": "void setCacheLZMAAvailablity(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!doCache) {\r\n        cachedLZMAAvailability \u003d CachedAvailability.DONT_CACHE;\r\n    } else if (cachedLZMAAvailability \u003d\u003d CachedAvailability.DONT_CACHE) {\r\n        final boolean hasLzma \u003d internalIsLZMACompressionAvailable();\r\n        cachedLZMAAvailability \u003d // NOSONAR\r\n        hasLzma ? // NOSONAR\r\n        CachedAvailability.CACHED_AVAILABLE : CachedAvailability.CACHED_UNAVAILABLE;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d $r0) → B3 | else → B7",
      "B3 : If(z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d LZMAUtils$CachedAvailability DONT_CACHE\u003e\n  LZMAUtils$CachedAvailability cachedLZMAAvailability\u003e \u003d $r2\n  goto B7\n}",
      "B2 {\n  $r1 \u003d LZMAUtils$CachedAvailability cachedLZMAAvailability\u003e\n  $r0 \u003d LZMAUtils$CachedAvailability DONT_CACHE\u003e\n  if ($r1 !\u003d $r0) goto B3 else B7\n}",
      "B3 {\n  z1 \u003d LZMAUtils.internalIsLZMACompressionAvailable()\n  if (z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d LZMAUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  goto B6\n}",
      "B5 {\n  $r3 \u003d LZMAUtils$CachedAvailability CACHED_UNAVAILABLE\u003e\n}",
      "B6 {\n  LZMAUtils$CachedAvailability cachedLZMAAvailability\u003e \u003d $r3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LZMAUtils#internalIsLZMACompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        LZMACompressorInputStream.matches(null, 0);\r\n        return true;\r\n    } catch (final NoClassDefFoundError error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.pack200.Pack200CompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c SIG_LENGTH) {\r\n        return false;\r\n    }\r\n    for (int i \u003d 0; i \u003c SIG_LENGTH; i++) {\r\n        if (signature[i] !\u003d CAFE_DOOD[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i6 \u003d\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $i1 \u003d Pack200CompressorInputStream: int SIG_LENGTH\u003e\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i5 \u003d 0\n}",
      "B3 {\n  $i2 \u003d Pack200CompressorInputStream: int SIG_LENGTH\u003e\n  if (i5 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b4 \u003d r0[i5]\n  $r1 \u003d Pack200CompressorInputStream: byte[] CAFE_DOOD\u003e\n  $b3 \u003d $r1[i5]\n  $i6 \u003d (int) $b4\n  $i7 \u003d (int) $b3\n  if ($i6 \u003d\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.pack200.Pack200CompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!isFinished()) {\r\n        super.finish();\r\n        final Pack200.Packer p \u003d Pack200.newPacker();\r\n        if (properties !\u003d null) {\r\n            p.properties().putAll(properties);\r\n        }\r\n        try (JarInputStream ji \u003d new JarInputStream(abstractStreamBridge.getInputStream())) {\r\n            p.pack(ji, out);\r\n        }\r\n    }\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B7",
      "B1 : If($r2 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Pack200CompressorOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B7\n}",
      "B1 {\n  r0.finish()\n  r1 \u003d Pack200.newPacker()\n  $r2 \u003d Map properties\u003e\n  if ($r2 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d r1.properties()\n  $r7 \u003d Map properties\u003e\n  $r8.putAll($r7)\n}",
      "B3 {\n  $r3 \u003d JarInputStream\n  $r4 \u003d AbstractStreamBridge abstractStreamBridge\u003e\n  $r5 \u003d $r4.getInputStream()\n  new JarInputStream($r5)\n  $r6 \u003d OutputStream out\u003e\n  r1.pack($r3, $r6)\n  $r3.close()\n  goto B7\n}",
      "B4 {\n  $r10 :\u003d @caughtexception\n  $r3.close()\n  goto B6\n}",
      "B5 {\n  $r9 :\u003d @caughtexception\n  $r10.addSuppressed($r9)\n}",
      "B6 {\n  throw $r10\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B7",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Pack200CompressorOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c SZ_SIGNATURE.length) {\r\n        return false;\r\n    }\r\n    byte[] shortenedSig \u003d signature;\r\n    if (signature.length \u003e SZ_SIGNATURE.length) {\r\n        shortenedSig \u003d Arrays.copyOf(signature, SZ_SIGNATURE.length);\r\n    }\r\n    return Arrays.equals(shortenedSig, SZ_SIGNATURE);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B2 : If($i3 \u003c\u003d $i2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d FramedSnappyCompressorInputStream: byte[] SZ_SIGNATURE\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r5 \u003d r1\n  $i3 \u003d lengthof r1\n  $r2 \u003d FramedSnappyCompressorInputStream: byte[] SZ_SIGNATURE\u003e\n  $i2 \u003d lengthof $r2\n  if ($i3 \u003c\u003d $i2) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d FramedSnappyCompressorInputStream: byte[] SZ_SIGNATURE\u003e\n  $i4 \u003d lengthof $r4\n  r5 \u003d Arrays.copyOf(r1, $i4)\n}",
      "B4 {\n  $r3 \u003d FramedSnappyCompressorInputStream: byte[] SZ_SIGNATURE\u003e\n  $z0 \u003d Arrays.equals(r5, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream",
    "methodName": "available",
    "signature": "int available()",
    "visibility": "public",
    "body": "{\r\n    if (inUncompressedChunk) {\r\n        return Math.min(uncompressedBytesRemaining, inputStream.available());\r\n    }\r\n    if (currentCompressedChunk !\u003d null) {\r\n        return currentCompressedChunk.available();\r\n    }\r\n    return 0;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FramedSnappyCompressorInputStream\n  $z0 \u003d FramedSnappyCompressorInputStream: boolean inUncompressedChunk\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d FramedSnappyCompressorInputStream: int uncompressedBytesRemaining\u003e\n  $r3 \u003d PushbackInputStream inputStream\u003e\n  $i2 \u003d $r3.available()\n  $i3 \u003d Math.min($i1, $i2)\n  return\n}",
      "B2 {\n  $r1 \u003d SnappyCompressorInputStream currentCompressedChunk\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d SnappyCompressorInputStream currentCompressedChunk\u003e\n  $i0 \u003d $r2.available()\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    return read(oneByte, 0, 1) \u003d\u003d -1 ? -1 : oneByte[0] \u0026 0xFF;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d $i4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FramedSnappyCompressorInputStream\n  $r1 \u003d FramedSnappyCompressorInputStream: byte[] oneByte\u003e\n  $i0 \u003d r0.read($r1, 0, 1)\n  $i4 \u003d (int) -1\n  if ($i0 !\u003d $i4) goto B1 else B2\n}",
      "B1 {\n  $s2 \u003d -1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d FramedSnappyCompressorInputStream: byte[] oneByte\u003e\n  $b1 \u003d $r2[0]\n  $s2 \u003d $b1 \u0026 255\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedSnappyCompressorInputStream#read(...3)",
        "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    int read \u003d readOnce(b, off, len);\r\n    if (read \u003d\u003d -1) {\r\n        readNextBlock();\r\n        if (endReached) {\r\n            return -1;\r\n        }\r\n        read \u003d readOnce(b, off, len);\r\n    }\r\n    return read;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    int read \u003d readOnce(b, off, len);\r\n    if (read \u003d\u003d -1) {\r\n        readNextBlock();\r\n        if (endReached) {\r\n            return -1;\r\n        }\r\n        read \u003d readOnce(b, off, len);\r\n    }\r\n    return read;\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i2 !\u003d $i4) → B3 | else → B6",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FramedSnappyCompressorInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i2 \u003d r0.readOnce(r1, i1, i0)\n  $i4 \u003d (int) -1\n  if (i2 !\u003d $i4) goto B3 else B6\n}",
      "B3 {\n  r0.readNextBlock()\n  $z0 \u003d FramedSnappyCompressorInputStream: boolean endReached\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $i6 \u003d (int) -1\n  return\n}",
      "B5 {\n  i2 \u003d r0.readOnce(r1, i1, i0)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedSnappyCompressorInputStream#readOnce(...3)",
        "body": "{\r\n    int read \u003d -1;\r\n    if (inUncompressedChunk) {\r\n        final int amount \u003d Math.min(uncompressedBytesRemaining, len);\r\n        if (amount \u003d\u003d 0) {\r\n            return -1;\r\n        }\r\n        read \u003d inputStream.read(b, off, amount);\r\n        if (read !\u003d -1) {\r\n            uncompressedBytesRemaining -\u003d read;\r\n            count(read);\r\n        }\r\n    } else if (currentCompressedChunk !\u003d null) {\r\n        final long before \u003d currentCompressedChunk.getBytesRead();\r\n        read \u003d currentCompressedChunk.read(b, off, len);\r\n        if (read \u003d\u003d -1) {\r\n            currentCompressedChunk.close();\r\n            currentCompressedChunk \u003d null;\r\n        } else {\r\n            count(currentCompressedChunk.getBytesRead() - before);\r\n        }\r\n    }\r\n    if (read \u003e 0) {\r\n        checksum.update(b, off, read);\r\n    }\r\n    return read;\r\n}"
      },
      {
        "name": "FramedSnappyCompressorInputStream#readNextBlock(...0)",
        "body": "{\r\n    verifyLastChecksumAndReset();\r\n    inUncompressedChunk \u003d false;\r\n    final int type \u003d readOneByte();\r\n    if (type \u003d\u003d -1) {\r\n        endReached \u003d true;\r\n    } else if (type \u003d\u003d STREAM_IDENTIFIER_TYPE) {\r\n        inputStream.unread(type);\r\n        unreadBytes++;\r\n        pushedBackBytes(1);\r\n        readStreamIdentifier();\r\n        readNextBlock();\r\n    } else if (type \u003d\u003d PADDING_CHUNK_TYPE || type \u003e MAX_UNSKIPPABLE_TYPE \u0026\u0026 type \u003c\u003d MAX_SKIPPABLE_TYPE) {\r\n        skipBlock();\r\n        readNextBlock();\r\n    } else if (type \u003e\u003d MIN_UNSKIPPABLE_TYPE \u0026\u0026 type \u003c\u003d MAX_UNSKIPPABLE_TYPE) {\r\n        throw new IOException(\"Unskippable chunk with type \" + type + \" (hex \" + Integer.toHexString(type) + \")\" + \" detected.\");\r\n    } else if (type \u003d\u003d UNCOMPRESSED_CHUNK_TYPE) {\r\n        inUncompressedChunk \u003d true;\r\n        uncompressedBytesRemaining \u003d readSize() - 4;\r\n        if (uncompressedBytesRemaining \u003c 0) {\r\n            throw new IOException(\"Found illegal chunk with negative size\");\r\n        }\r\n        expectedChecksum \u003d unmask(readCrc());\r\n    } else if (type \u003d\u003d COMPRESSED_CHUNK_TYPE) {\r\n        final boolean expectChecksum \u003d dialect.usesChecksumWithCompressedChunks();\r\n        final long size \u003d readSize() - (expectChecksum ? 4L : 0L);\r\n        if (size \u003c 0) {\r\n            throw new IOException(\"Found illegal chunk with negative size\");\r\n        }\r\n        if (expectChecksum) {\r\n            expectedChecksum \u003d unmask(readCrc());\r\n        } else {\r\n            expectedChecksum \u003d -1;\r\n        }\r\n        // @formatter:off\r\n        currentCompressedChunk \u003d new SnappyCompressorInputStream(BoundedInputStream.builder().setInputStream(inputStream).setMaxCount(size).setPropagateClose(false).get(), blockSize);\r\n        // @formatter:on\r\n        // constructor reads uncompressed size\r\n        count(currentCompressedChunk.getBytesRead());\r\n    } else {\r\n        // impossible as all potential byte values have been covered\r\n        throw new IOException(\"Unknown chunk type \" + type + \" detected.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.FramedSnappyCompressorOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    int blockDataRemaining \u003d buffer.length - currentIndex;\r\n    while (len \u003e 0) {\r\n        final int copyLen \u003d Math.min(len, blockDataRemaining);\r\n        System.arraycopy(data, off, buffer, currentIndex, copyLen);\r\n        off +\u003d copyLen;\r\n        blockDataRemaining -\u003d copyLen;\r\n        len -\u003d copyLen;\r\n        currentIndex +\u003d copyLen;\r\n        if (blockDataRemaining \u003d\u003d 0) {\r\n            flushBuffer();\r\n            blockDataRemaining \u003d buffer.length;\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i7 \u003c\u003d 0) → B2 | else → B5",
      "B2 : If(i8 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FramedSnappyCompressorOutputStream\n  r2 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i7 :\u003d @parameter2: int\n  $r1 \u003d FramedSnappyCompressorOutputStream: byte[] buffer\u003e\n  $i1 \u003d lengthof $r1\n  $i0 \u003d FramedSnappyCompressorOutputStream: int currentIndex\u003e\n  i8 \u003d $i1 - $i0\n}",
      "B1 {\n  if (i7 \u003c\u003d 0) goto B2 else B5\n}",
      "B2 {\n  i2 \u003d Math.min(i7, i8)\n  $r3 \u003d FramedSnappyCompressorOutputStream: byte[] buffer\u003e\n  $i3 \u003d FramedSnappyCompressorOutputStream: int currentIndex\u003e\n  System.arraycopy(r2, i6, $r3, $i3, i2)\n  i6 \u003d i6 + i2\n  i8 \u003d i8 - i2\n  i7 \u003d i7 - i2\n  $i4 \u003d FramedSnappyCompressorOutputStream: int currentIndex\u003e\n  $i5 \u003d $i4 + i2\n  FramedSnappyCompressorOutputStream: int currentIndex\u003e \u003d $i5\n  if (i8 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  r0.flushBuffer()\n  $r4 \u003d FramedSnappyCompressorOutputStream: byte[] buffer\u003e\n  i8 \u003d lengthof $r4\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FramedSnappyCompressorOutputStream#flushBuffer(...0)",
        "body": "{\r\n    if (currentIndex \u003d\u003d 0) {\r\n        return;\r\n    }\r\n    out.write(FramedSnappyCompressorInputStream.COMPRESSED_CHUNK_TYPE);\r\n    final ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\r\n    try (OutputStream o \u003d new SnappyCompressorOutputStream(baos, currentIndex, params)) {\r\n        o.write(buffer, 0, currentIndex);\r\n    }\r\n    final byte[] b \u003d baos.toByteArray();\r\n    writeLittleEndian(3, b.length + 4L);\r\n    writeCrc();\r\n    out.write(b);\r\n    currentIndex \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.SnappyCompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    switch(state) {\r\n        case NO_BLOCK:\r\n            fill();\r\n            return read(b, off, len);\r\n        case IN_LITERAL:\r\n            final int litLen \u003d readLiteral(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return litLen \u003e 0 ? litLen : read(b, off, len);\r\n        case IN_BACK_REFERENCE:\r\n            final int backReferenceLen \u003d readBackReference(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return backReferenceLen \u003e 0 ? backReferenceLen : read(b, off, len);\r\n        default:\r\n            throw new IOException(\"Unknown stream state \" + state);\r\n    }\r\n}",
    "nodes": 19,
    "edges": 22,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(switch-on $i1) → B5 | else → B6",
      "B6 : If($z2 !\u003d 0) → B7 | else → B8",
      "B8 : If(i4 \u003c\u003d 0) → B9 | else → B10",
      "B12 : If($z1 !\u003d 0) → B13 | else → B14",
      "B14 : If(i3 \u003c\u003d 0) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  SnappyCompressorInputStream\n  r2 :\u003d @parameter0: byte[]\n  i2 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d SnappyCompressorInputStream: boolean endReached\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i9 \u003d (int) -1\n  return\n}",
      "B4 {\n  $r1 \u003d SnappyCompressorInputStream$State state\u003e\n  $i1 \u003d $r1.ordinal()\n  IOException; }\n}",
      "B5 {\n  r0.fill()\n  $i5 \u003d r0.read(r2, i2, i0)\n  return\n}",
      "B6 {\n  i4 \u003d r0.readLiteral(r2, i2, i0)\n  $z2 \u003d r0.hasMoreDataInBlock()\n  if ($z2 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $r4 \u003d SnappyCompressorInputStream$State NO_BLOCK\u003e\n  SnappyCompressorInputStream$State state\u003e \u003d $r4\n}",
      "B8 {\n  if (i4 \u003c\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $i6 \u003d i4\n  goto B11\n}",
      "B10 {\n  $i6 \u003d r0.read(r2, i2, i0)\n}",
      "B11 {\n  return\n}",
      "B12 {\n  i3 \u003d r0.readBackReference(r2, i2, i0)\n  $z1 \u003d r0.hasMoreDataInBlock()\n  if ($z1 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $r3 \u003d SnappyCompressorInputStream$State NO_BLOCK\u003e\n  SnappyCompressorInputStream$State state\u003e \u003d $r3\n}",
      "B14 {\n  if (i3 \u003c\u003d 0) goto B15 else B16\n}",
      "B15 {\n  $i7 \u003d i3\n  goto B17\n}",
      "B16 {\n  $i7 \u003d r0.read(r2, i2, i0)\n}",
      "B17 {\n  return\n}",
      "B18 {\n  $r12 \u003d IOException\n  $r11 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r11.append(\"Unknown stream state \")\n  $r7 \u003d SnappyCompressorInputStream$State state\u003e\n  $r9 \u003d $r8.append($r7)\n  $r10 \u003d $r9.toString()\n  new IOException($r10)\n  throw $r12\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B4 --\u003e B12",
      "B4 --\u003e B18",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SnappyCompressorInputStream#fill(...0)",
        "body": "{\r\n    if (uncompressedBytesRemaining \u003d\u003d 0) {\r\n        endReached \u003d true;\r\n        return;\r\n    }\r\n    int b \u003d readOneByte();\r\n    if (b \u003d\u003d -1) {\r\n        throw new IOException(\"Premature end of stream reading block start\");\r\n    }\r\n    int length \u003d 0;\r\n    int offset \u003d 0;\r\n    switch(b \u0026 TAG_MASK) {\r\n        case 0x00:\r\n            length \u003d readLiteralLength(b);\r\n            if (length \u003c 0) {\r\n                throw new IOException(\"Illegal block with a negative literal size found\");\r\n            }\r\n            uncompressedBytesRemaining -\u003d length;\r\n            startLiteral(length);\r\n            state \u003d State.IN_LITERAL;\r\n            break;\r\n        case 0x01:\r\n            /*\r\n             * These elements can encode lengths between [4..11] bytes and offsets between [0..2047] bytes. (len-4) occupies three bits and is stored in bits\r\n             * [2..4] of the tag byte. The offset occupies 11 bits, of which the upper three are stored in the upper three bits ([5..7]) of the tag byte, and\r\n             * the lower eight are stored in a byte following the tag byte.\r\n             */\r\n            length \u003d 4 + (b \u003e\u003e 2 \u0026 0x07);\r\n            uncompressedBytesRemaining -\u003d length;\r\n            offset \u003d (b \u0026 0xE0) \u003c\u003c 3;\r\n            b \u003d readOneByte();\r\n            if (b \u003d\u003d -1) {\r\n                throw new IOException(\"Premature end of stream reading back-reference length\");\r\n            }\r\n            offset |\u003d b;\r\n            try {\r\n                startBackReference(offset, length);\r\n            } catch (final IllegalArgumentException ex) {\r\n                throw new IOException(\"Illegal block with bad offset found\", ex);\r\n            }\r\n            state \u003d State.IN_BACK_REFERENCE;\r\n            break;\r\n        case 0x02:\r\n            /*\r\n             * These elements can encode lengths between [1..64] and offsets from [0..65535]. (len-1) occupies six bits and is stored in the upper six bits\r\n             * ([2..7]) of the tag byte. The offset is stored as a little-endian 16-bit integer in the two bytes following the tag byte.\r\n             */\r\n            length \u003d (b \u003e\u003e 2) + 1;\r\n            if (length \u003c 0) {\r\n                throw new IOException(\"Illegal block with a negative match length found\");\r\n            }\r\n            uncompressedBytesRemaining -\u003d length;\r\n            offset \u003d (int) ByteUtils.fromLittleEndian(supplier, 2);\r\n            try {\r\n                startBackReference(offset, length);\r\n            } catch (final IllegalArgumentException ex) {\r\n                throw new IOException(\"Illegal block with bad offset found\", ex);\r\n            }\r\n            state \u003d State.IN_BACK_REFERENCE;\r\n            break;\r\n        case 0x03:\r\n            /*\r\n             * These are like the copies with 2-byte offsets (see previous subsection), except that the offset is stored as a 32-bit integer instead of a 16-bit\r\n             * integer (and thus will occupy four bytes).\r\n             */\r\n            length \u003d (b \u003e\u003e 2) + 1;\r\n            if (length \u003c 0) {\r\n                throw new IOException(\"Illegal block with a negative match length found\");\r\n            }\r\n            uncompressedBytesRemaining -\u003d length;\r\n            offset \u003d (int) ByteUtils.fromLittleEndian(supplier, 4) \u0026 0x7fffffff;\r\n            try {\r\n                startBackReference(offset, length);\r\n            } catch (final IllegalArgumentException ex) {\r\n                throw new IOException(\"Illegal block with bad offset found\", ex);\r\n            }\r\n            state \u003d State.IN_BACK_REFERENCE;\r\n            break;\r\n        default:\r\n            // impossible as TAG_MASK is two bits and all four possible cases have been covered\r\n            break;\r\n    }\r\n}"
      },
      {
        "name": "SnappyCompressorInputStream#readBackReference(...3)",
        "body": "(source not found)"
      },
      {
        "name": "SnappyCompressorInputStream#readLiteral(...3)",
        "body": "(source not found)"
      },
      {
        "name": "SnappyCompressorInputStream#hasMoreDataInBlock(...0)",
        "body": "(source not found)"
      },
      {
        "name": "SnappyCompressorInputStream#read(...3)",
        "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    if (endReached) {\r\n        return -1;\r\n    }\r\n    switch(state) {\r\n        case NO_BLOCK:\r\n            fill();\r\n            return read(b, off, len);\r\n        case IN_LITERAL:\r\n            final int litLen \u003d readLiteral(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return litLen \u003e 0 ? litLen : read(b, off, len);\r\n        case IN_BACK_REFERENCE:\r\n            final int backReferenceLen \u003d readBackReference(b, off, len);\r\n            if (!hasMoreDataInBlock()) {\r\n                state \u003d State.NO_BLOCK;\r\n            }\r\n            return backReferenceLen \u003e 0 ? backReferenceLen : read(b, off, len);\r\n        default:\r\n            throw new IOException(\"Unknown stream state \" + state);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.snappy.SnappyCompressorOutputStream",
    "methodName": "finish",
    "signature": "void finish()",
    "visibility": "public",
    "body": "{\r\n    if (!isFinished()) {\r\n        compressor.finish();\r\n        super.finish();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SnappyCompressorOutputStream\n  $z0 \u003d r0.isFinished()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d LZ77Compressor compressor\u003e\n  $r1.finish()\n  r0.finish()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SnappyCompressorOutputStream#isFinished(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c XZ.HEADER_MAGIC.length) {\r\n        return false;\r\n    }\r\n    for (int i \u003d 0; i \u003c XZ.HEADER_MAGIC.length; ++i) {\r\n        if (signature[i] !\u003d XZ.HEADER_MAGIC[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i6 \u003d\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d XZ: byte[] HEADER_MAGIC\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i5 \u003d 0\n}",
      "B3 {\n  $r1 \u003d XZ: byte[] HEADER_MAGIC\u003e\n  $i2 \u003d lengthof $r1\n  if (i5 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b4 \u003d r2[i5]\n  $r3 \u003d XZ: byte[] HEADER_MAGIC\u003e\n  $b3 \u003d $r3[i5]\n  $i6 \u003d (int) $b4\n  $i7 \u003d (int) $b3\n  if ($i6 \u003d\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.xz.XZCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        final int ret \u003d in.read();\r\n        count(ret \u003d\u003d -1 ? -1 : 1);\r\n        return ret;\r\n    } catch (final org.tukaani.xz.MemoryLimitException e) {\r\n        throw new MemoryLimitException(e.getMemoryNeeded(), e.getMemoryLimit(), (Throwable) e);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i3 !\u003d $i6) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  XZCompressorInputStream\n  $r1 \u003d InputStream in\u003e\n  i3 \u003d $r1.read()\n  $i6 \u003d (int) -1\n  if (i3 !\u003d $i6) goto B1 else B2\n}",
      "B1 {\n  $b4 \u003d -1\n  goto B3\n}",
      "B2 {\n  $b4 \u003d 1\n}",
      "B3 {\n  r0.count($b4)\n  return\n}",
      "B4 {\n  $r2 :\u003d @caughtexception\n  $r4 \u003d MemoryLimitException\n  $r5 \u003d MemoryLimitException) $r2\n  $i0 \u003d $r5.getMemoryNeeded()\n  $l2 \u003d (long) $i0\n  $r6 \u003d MemoryLimitException) $r2\n  $i1 \u003d $r6.getMemoryLimit()\n  new MemoryLimitException($l2, $i1, $r2)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XZCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.xz.XZUtils",
    "methodName": "isXZCompressionAvailable",
    "signature": "boolean isXZCompressionAvailable()",
    "visibility": "public",
    "body": "{\r\n    final CachedAvailability cachedResult \u003d cachedXZAvailability;\r\n    if (cachedResult !\u003d CachedAvailability.DONT_CACHE) {\r\n        return cachedResult \u003d\u003d CachedAvailability.CACHED_AVAILABLE;\r\n    }\r\n    return internalIsXZCompressionAvailable();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r1) → B1 | else → B5",
      "B1 : If(r0 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 \u003d XZUtils$CachedAvailability cachedXZAvailability\u003e\n  $r1 \u003d XZUtils$CachedAvailability DONT_CACHE\u003e\n  if (r0 \u003d\u003d $r1) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d XZUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  if (r0 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d XZUtils.internalIsXZCompressionAvailable()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XZUtils#internalIsXZCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        XZCompressorInputStream.matches(null, 0);\r\n        return true;\r\n    } catch (final NoClassDefFoundError error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.xz.XZUtils",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c HEADER_MAGIC.length) {\r\n        return false;\r\n    }\r\n    for (int i \u003d 0; i \u003c HEADER_MAGIC.length; ++i) {\r\n        if (signature[i] !\u003d HEADER_MAGIC[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i6 \u003d\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d XZUtils: byte[] HEADER_MAGIC\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i5 \u003d 0\n}",
      "B3 {\n  $r1 \u003d XZUtils: byte[] HEADER_MAGIC\u003e\n  $i2 \u003d lengthof $r1\n  if (i5 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b4 \u003d r2[i5]\n  $r3 \u003d XZUtils: byte[] HEADER_MAGIC\u003e\n  $b3 \u003d $r3[i5]\n  $i6 \u003d (int) $b4\n  $i7 \u003d (int) $b3\n  if ($i6 \u003d\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.xz.XZUtils",
    "methodName": "setCacheXZAvailablity",
    "signature": "void setCacheXZAvailablity(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!doCache) {\r\n        cachedXZAvailability \u003d CachedAvailability.DONT_CACHE;\r\n    } else if (cachedXZAvailability \u003d\u003d CachedAvailability.DONT_CACHE) {\r\n        final boolean hasXz \u003d internalIsXZCompressionAvailable();\r\n        cachedXZAvailability \u003d // NOSONAR\r\n        hasXz ? // NOSONAR\r\n        CachedAvailability.CACHED_AVAILABLE : CachedAvailability.CACHED_UNAVAILABLE;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d $r0) → B3 | else → B7",
      "B3 : If(z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d XZUtils$CachedAvailability DONT_CACHE\u003e\n  XZUtils$CachedAvailability cachedXZAvailability\u003e \u003d $r2\n  goto B7\n}",
      "B2 {\n  $r1 \u003d XZUtils$CachedAvailability cachedXZAvailability\u003e\n  $r0 \u003d XZUtils$CachedAvailability DONT_CACHE\u003e\n  if ($r1 !\u003d $r0) goto B3 else B7\n}",
      "B3 {\n  z1 \u003d XZUtils.internalIsXZCompressionAvailable()\n  if (z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d XZUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  goto B6\n}",
      "B5 {\n  $r3 \u003d XZUtils$CachedAvailability CACHED_UNAVAILABLE\u003e\n}",
      "B6 {\n  XZUtils$CachedAvailability cachedXZAvailability\u003e \u003d $r3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "XZUtils#internalIsXZCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        XZCompressorInputStream.matches(null, 0);\r\n        return true;\r\n    } catch (final NoClassDefFoundError error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.z.ZCompressorInputStream",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    return length \u003e 3 \u0026\u0026 signature[0] \u003d\u003d MAGIC_1 \u0026\u0026 signature[1] \u003d\u003d (byte) MAGIC_2;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 3) → B1 | else → B4",
      "B1 : If($i3 !\u003d 31) → B2 | else → B4",
      "B2 : If($i4 !\u003d $i6) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c\u003d 3) goto B1 else B4\n}",
      "B1 {\n  $b1 \u003d r0[0]\n  $i3 \u003d (int) $b1\n  if ($i3 !\u003d 31) goto B2 else B4\n}",
      "B2 {\n  $b2 \u003d r0[1]\n  $i4 \u003d (int) $b2\n  $i6 \u003d (int) -99\n  if ($i4 !\u003d $i6) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    final int ret \u003d decIS.read();\r\n    count(ret \u003d\u003d -1 ? 0 : 1);\r\n    return ret;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZstdCompressorInputStream\n  $r1 \u003d ZstdInputStream decIS\u003e\n  i0 \u003d $r1.read()\n  $i3 \u003d (int) -1\n  if (i0 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $b1 \u003d 0\n  goto B3\n}",
      "B2 {\n  $b1 \u003d 1\n}",
      "B3 {\n  r0.count($b1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZstdCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final int ret \u003d decIS.read(buf, off, len);\r\n    count(ret);\r\n    return ret;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ZstdCompressorInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d ZstdInputStream decIS\u003e\n  i2 \u003d $r2.read(r1, i1, i0)\n  r0.count(i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZstdCompressorInputStream#count(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.zstandard.ZstdUtils",
    "methodName": "isZstdCompressionAvailable",
    "signature": "boolean isZstdCompressionAvailable()",
    "visibility": "public",
    "body": "{\r\n    final CachedAvailability cachedResult \u003d cachedZstdAvailability;\r\n    if (cachedResult !\u003d CachedAvailability.DONT_CACHE) {\r\n        return cachedResult \u003d\u003d CachedAvailability.CACHED_AVAILABLE;\r\n    }\r\n    return internalIsZstdCompressionAvailable();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d $r1) → B1 | else → B5",
      "B1 : If(r0 !\u003d $r2) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 \u003d ZstdUtils$CachedAvailability cachedZstdAvailability\u003e\n  $r1 \u003d ZstdUtils$CachedAvailability DONT_CACHE\u003e\n  if (r0 \u003d\u003d $r1) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d ZstdUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  if (r0 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d ZstdUtils.internalIsZstdCompressionAvailable()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZstdUtils#internalIsZstdCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        Class.forName(\"com.github.luben.zstd.ZstdInputStream\");\r\n        return true;\r\n    } catch (final NoClassDefFoundError | Exception error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.compressors.zstandard.ZstdUtils",
    "methodName": "matches",
    "signature": "boolean matches(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c ZSTANDARD_FRAME_MAGIC.length) {\r\n        return false;\r\n    }\r\n    boolean isZstandard \u003d true;\r\n    for (int i \u003d 0; i \u003c ZSTANDARD_FRAME_MAGIC.length; ++i) {\r\n        if (signature[i] !\u003d ZSTANDARD_FRAME_MAGIC[i]) {\r\n            isZstandard \u003d false;\r\n            break;\r\n        }\r\n    }\r\n    if (isZstandard) {\r\n        return true;\r\n    }\r\n    if (0x50 \u003d\u003d (signature[0] \u0026 0xF0)) {\r\n        // skippable frame\r\n        for (int i \u003d 0; i \u003c SKIPPABLE_FRAME_MAGIC.length; ++i) {\r\n            if (signature[i + 1] !\u003d SKIPPABLE_FRAME_MAGIC[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "nodes": 17,
    "edges": 19,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B2",
      "B3 : If(i11 \u003e\u003d $i2) → B4 | else → B7",
      "B4 : If($i13 \u003d\u003d $i14) → B5 | else → B6",
      "B7 : If(z0 \u003d\u003d false) → B8 | else → B9",
      "B9 : If(80 !\u003d $i16) → B10 | else → B16",
      "B11 : If(i12 \u003e\u003d $i5) → B12 | else → B15",
      "B12 : If($i17 \u003d\u003d $i18) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  $r0 \u003d ZstdUtils: byte[] ZSTANDARD_FRAME_MAGIC\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  z0 \u003d 1\n  i11 \u003d 0\n}",
      "B3 {\n  $r1 \u003d ZstdUtils: byte[] ZSTANDARD_FRAME_MAGIC\u003e\n  $i2 \u003d lengthof $r1\n  if (i11 \u003e\u003d $i2) goto B4 else B7\n}",
      "B4 {\n  $b10 \u003d r2[i11]\n  $r5 \u003d ZstdUtils: byte[] ZSTANDARD_FRAME_MAGIC\u003e\n  $b9 \u003d $r5[i11]\n  $i13 \u003d (int) $b10\n  $i14 \u003d (int) $b9\n  if ($i13 \u003d\u003d $i14) goto B5 else B6\n}",
      "B5 {\n  z0 \u003d 0\n  goto B7\n}",
      "B6 {\n  i11 \u003d i11 + 1\n  goto B3\n}",
      "B7 {\n  if (z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $b3 \u003d r2[0]\n  $s15 \u003d (short) $b3\n  $s4 \u003d $s15 \u0026 240\n  $i16 \u003d (int) $s4\n  if (80 !\u003d $i16) goto B10 else B16\n}",
      "B10 {\n  i12 \u003d 0\n}",
      "B11 {\n  $r3 \u003d ZstdUtils: byte[] SKIPPABLE_FRAME_MAGIC\u003e\n  $i5 \u003d lengthof $r3\n  if (i12 \u003e\u003d $i5) goto B12 else B15\n}",
      "B12 {\n  $i6 \u003d i12 + 1\n  $b8 \u003d r2[$i6]\n  $r4 \u003d ZstdUtils: byte[] SKIPPABLE_FRAME_MAGIC\u003e\n  $b7 \u003d $r4[i12]\n  $i17 \u003d (int) $b8\n  $i18 \u003d (int) $b7\n  if ($i17 \u003d\u003d $i18) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  i12 \u003d i12 + 1\n  goto B11\n}",
      "B15 {\n  return\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B3",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B16",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B11",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.compressors.zstandard.ZstdUtils",
    "methodName": "setCacheZstdAvailablity",
    "signature": "void setCacheZstdAvailablity(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (!doCache) {\r\n        cachedZstdAvailability \u003d CachedAvailability.DONT_CACHE;\r\n    } else if (cachedZstdAvailability \u003d\u003d CachedAvailability.DONT_CACHE) {\r\n        final boolean hasZstd \u003d internalIsZstdCompressionAvailable();\r\n        cachedZstdAvailability \u003d hasZstd ? CachedAvailability.CACHED_AVAILABLE : CachedAvailability.CACHED_UNAVAILABLE;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 !\u003d $r0) → B3 | else → B7",
      "B3 : If(z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ZstdUtils$CachedAvailability DONT_CACHE\u003e\n  ZstdUtils$CachedAvailability cachedZstdAvailability\u003e \u003d $r2\n  goto B7\n}",
      "B2 {\n  $r1 \u003d ZstdUtils$CachedAvailability cachedZstdAvailability\u003e\n  $r0 \u003d ZstdUtils$CachedAvailability DONT_CACHE\u003e\n  if ($r1 !\u003d $r0) goto B3 else B7\n}",
      "B3 {\n  z1 \u003d ZstdUtils.internalIsZstdCompressionAvailable()\n  if (z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d ZstdUtils$CachedAvailability CACHED_AVAILABLE\u003e\n  goto B6\n}",
      "B5 {\n  $r3 \u003d ZstdUtils$CachedAvailability CACHED_UNAVAILABLE\u003e\n}",
      "B6 {\n  ZstdUtils$CachedAvailability cachedZstdAvailability\u003e \u003d $r3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ZstdUtils#internalIsZstdCompressionAvailable(...0)",
        "body": "{\r\n    try {\r\n        Class.forName(\"com.github.luben.zstd.ZstdInputStream\");\r\n        return true;\r\n    } catch (final NoClassDefFoundError | Exception error) {\r\n        // NOSONAR\r\n        return false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.archive.internal.nls.Messages",
    "methodName": "format",
    "signature": "java.lang.String format(java.lang.String,java.lang.Object[])",
    "visibility": "public",
    "body": "{\r\n    final StringBuilder answer \u003d new StringBuilder(format.length() + args.length * 20);\r\n    final String[] argStrings \u003d new String[args.length];\r\n    //$NON-NLS-1$\r\n    Arrays.setAll(argStrings, i -\u003e Objects.toString(args[i], \"\u003cnull\u003e\"));\r\n    int lastI \u003d 0;\r\n    for (int i \u003d format.indexOf(\u0027{\u0027, 0); i \u003e\u003d 0; i \u003d format.indexOf(\u0027{\u0027, lastI)) {\r\n        if (i !\u003d 0 \u0026\u0026 format.charAt(i - 1) \u003d\u003d \u0027\\\\\u0027) {\r\n            // It\u0027s escaped, just print and loop.\r\n            if (i !\u003d 1) {\r\n                answer.append(format.substring(lastI, i - 1));\r\n            }\r\n            answer.append(\u0027{\u0027);\r\n            lastI \u003d i + 1;\r\n        } else // It\u0027s a format character.\r\n        if (i \u003e format.length() - 3) {\r\n            // Bad format, just print and loop.\r\n            answer.append(format.substring(lastI));\r\n            lastI \u003d format.length();\r\n        } else {\r\n            final int argnum \u003d (byte) Character.digit(format.charAt(i + 1), 10);\r\n            if (argnum \u003c 0 || format.charAt(i + 2) !\u003d \u0027}\u0027) {\r\n                // Bad format, just print and loop.\r\n                answer.append(format.substring(lastI, i + 1));\r\n                lastI \u003d i + 1;\r\n            } else {\r\n                // Got a good one!\r\n                answer.append(format.substring(lastI, i));\r\n                if (argnum \u003e\u003d argStrings.length) {\r\n                    //$NON-NLS-1$\r\n                    answer.append(\"\u003cmissing argument\u003e\");\r\n                } else {\r\n                    answer.append(argStrings[argnum]);\r\n                }\r\n                lastI \u003d i + 3;\r\n            }\r\n        }\r\n    }\r\n    if (lastI \u003c format.length()) {\r\n        answer.append(format.substring(lastI));\r\n    }\r\n    return answer.toString();\r\n}",
    "nodes": 20,
    "edges": 28,
    "cc": 10,
    "flowSummary": [
      "B1 : If(i20 \u003c 0) → B2 | else → B17",
      "B2 : If(i20 \u003d\u003d false) → B3 | else → B7",
      "B3 : If($i21 !\u003d 92) → B4 | else → B7",
      "B4 : If(i20 \u003d\u003d 1) → B5 | else → B6",
      "B7 : If(i20 \u003c\u003d $i7) → B8 | else → B9",
      "B9 : If($i22 \u003c 0) → B10 | else → B11",
      "B10 : If($i23 \u003d\u003d 125) → B11 | else → B12",
      "B12 : If($i24 \u003c $i15) → B13 | else → B14",
      "B17 : If(i19 \u003e\u003d $i5) → B18 | else → B19"
    ],
    "blockList": [
      "B0 {\n  String\n  Object[]\n  $r12 \u003d StringBuilder\n  $i2 \u003d r1.length()\n  $i0 \u003d lengthof r2\n  $i1 \u003d $i0 * 20\n  $i3 \u003d $i2 + $i1\n  new StringBuilder($i3)\n  $i4 \u003d lengthof r2\n  r3 \u003d String)[$i4]\n  $r4 \u003d Messages$lambda_format_0__28.bootstrap$(r2)\n  Arrays.setAll(r3, $r4)\n  i19 \u003d 0\n  i20 \u003d r1.indexOf(123, 0)\n}",
      "B1 {\n  if (i20 \u003c 0) goto B2 else B17\n}",
      "B2 {\n  if (i20 \u003d\u003d false) goto B3 else B7\n}",
      "B3 {\n  $i16 \u003d i20 - 1\n  $c17 \u003d r1.charAt($i16)\n  $i21 \u003d (int) $c17\n  if ($i21 !\u003d 92) goto B4 else B7\n}",
      "B4 {\n  if (i20 \u003d\u003d 1) goto B5 else B6\n}",
      "B5 {\n  $i18 \u003d i20 - 1\n  $r11 \u003d r1.substring(i19, $i18)\n  $r12.append($r11)\n}",
      "B6 {\n  $r12.append(123)\n  i19 \u003d i20 + 1\n  goto B16\n}",
      "B7 {\n  $i6 \u003d r1.length()\n  $i7 \u003d $i6 - 3\n  if (i20 \u003c\u003d $i7) goto B8 else B9\n}",
      "B8 {\n  $r10 \u003d r1.substring(i19)\n  $r12.append($r10)\n  i19 \u003d r1.length()\n  goto B16\n}",
      "B9 {\n  $i8 \u003d i20 + 1\n  $c9 \u003d r1.charAt($i8)\n  $i10 \u003d Character.digit($c9, 10)\n  b11 \u003d (byte) $i10\n  $i22 \u003d (int) b11\n  if ($i22 \u003c 0) goto B10 else B11\n}",
      "B10 {\n  $i13 \u003d i20 + 2\n  $c14 \u003d r1.charAt($i13)\n  $i23 \u003d (int) $c14\n  if ($i23 \u003d\u003d 125) goto B11 else B12\n}",
      "B11 {\n  $i12 \u003d i20 + 1\n  $r7 \u003d r1.substring(i19, $i12)\n  $r12.append($r7)\n  i19 \u003d i20 + 1\n  goto B16\n}",
      "B12 {\n  $r8 \u003d r1.substring(i19, i20)\n  $r12.append($r8)\n  $i15 \u003d lengthof r3\n  $i24 \u003d (int) b11\n  if ($i24 \u003c $i15) goto B13 else B14\n}",
      "B13 {\n  $r12.append(\"\u003cmissing argument\u003e\")\n  goto B15\n}",
      "B14 {\n  $i25 \u003d (int) b11\n  $r9 \u003d r3[$i25]\n  $r12.append($r9)\n}",
      "B15 {\n  i19 \u003d i20 + 3\n}",
      "B16 {\n  i20 \u003d r1.indexOf(123, i19)\n  goto B1\n}",
      "B17 {\n  $i5 \u003d r1.length()\n  if (i19 \u003e\u003d $i5) goto B18 else B19\n}",
      "B18 {\n  $r6 \u003d r1.substring(i19)\n  $r12.append($r6)\n}",
      "B19 {\n  $r5 \u003d $r12.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B17",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B16",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B16",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B16 --\u003e B1",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.archive.internal.nls.Messages",
    "methodName": "getString",
    "signature": "java.lang.String getString(java.lang.String,java.lang.Object[])",
    "visibility": "public",
    "body": "{\r\n    return getString(msg, new Object[] { arg });\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  String\n  Object[]\n  r5 \u003d r0\n  $r1 \u003d ResourceBundle bundle\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d ResourceBundle bundle\u003e\n  r5 \u003d $r3.getString(r0)\n  goto B3\n}",
      "B2 {\n  $r4 :\u003d @caughtexception\n}",
      "B3 {\n  $r6 \u003d Messages.format(r5, r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Messages#getString(...2)",
        "body": "{\r\n    return getString(msg, new Object[] { String.valueOf(arg) });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Archive",
    "methodName": "pack",
    "signature": "void pack()",
    "visibility": "public",
    "body": "{\r\n    if (0 \u003d\u003d options.getEffort()) {\r\n        doZeroEffortPack();\r\n    } else {\r\n        doNormalPack();\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(0 !\u003d $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Archive\n  $r1 \u003d PackingOptions options\u003e\n  $i0 \u003d $r1.getEffort()\n  if (0 !\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  r0.doZeroEffortPack()\n  goto B3\n}",
      "B2 {\n  r0.doNormalPack()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Archive#doZeroEffortPack(...0)",
        "body": "{\r\n    PackingUtils.log(\"Start to perform a zero-effort packing\");\r\n    if (jarInputStream !\u003d null) {\r\n        PackingUtils.copyThroughJar(jarInputStream, outputStream);\r\n    } else {\r\n        PackingUtils.copyThroughJar(jarFile, outputStream);\r\n    }\r\n}"
      },
      {
        "name": "Archive#doNormalPack(...0)",
        "body": "{\r\n    PackingUtils.log(\"Start to perform a normal packing\");\r\n    final List\u003cPackingFile\u003e packingFileList;\r\n    if (jarInputStream !\u003d null) {\r\n        packingFileList \u003d PackingUtils.getPackingFileListFromJar(jarInputStream, options.isKeepFileOrder());\r\n    } else {\r\n        packingFileList \u003d PackingUtils.getPackingFileListFromJar(jarFile, options.isKeepFileOrder());\r\n    }\r\n    final List\u003cSegmentUnit\u003e segmentUnitList \u003d splitIntoSegments(packingFileList);\r\n    int previousByteAmount \u003d 0;\r\n    int packedByteAmount \u003d 0;\r\n    final int segmentSize \u003d segmentUnitList.size();\r\n    SegmentUnit segmentUnit;\r\n    for (int index \u003d 0; index \u003c segmentSize; index++) {\r\n        segmentUnit \u003d segmentUnitList.get(index);\r\n        new Segment().pack(segmentUnit, outputStream, options);\r\n        previousByteAmount +\u003d segmentUnit.getByteAmount();\r\n        packedByteAmount +\u003d segmentUnit.getPackedByteAmount();\r\n    }\r\n    PackingUtils.log(\"Total: Packed \" + previousByteAmount + \" input bytes of \" + packingFileList.size() + \" files into \" + packedByteAmount + \" bytes in \" + segmentSize + \" segments\");\r\n    outputStream.close();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.AttributeDefinitionBands",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    PackingUtils.log(\"Writing attribute definition bands...\");\r\n    final int[] attributeDefinitionHeader \u003d new int[attributeDefinitions.size()];\r\n    final int[] attributeDefinitionName \u003d new int[attributeDefinitions.size()];\r\n    final int[] attributeDefinitionLayout \u003d new int[attributeDefinitions.size()];\r\n    for (int i \u003d 0; i \u003c attributeDefinitionLayout.length; i++) {\r\n        final AttributeDefinition def \u003d attributeDefinitions.get(i);\r\n        attributeDefinitionHeader[i] \u003d def.contextType | def.index + 1 \u003c\u003c 2;\r\n        attributeDefinitionName[i] \u003d def.name.getIndex();\r\n        attributeDefinitionLayout[i] \u003d def.layout.getIndex();\r\n    }\r\n    byte[] encodedBand \u003d encodeBandInt(\"attributeDefinitionHeader\", attributeDefinitionHeader, Codec.BYTE1);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from attributeDefinitionHeader[\" + attributeDefinitionHeader.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"attributeDefinitionName\", attributeDefinitionName, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from attributeDefinitionName[\" + attributeDefinitionName.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"attributeDefinitionLayout\", attributeDefinitionLayout, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from attributeDefinitionLayout[\" + attributeDefinitionLayout.length + \"]\");\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i17 \u003e\u003d $i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  AttributeDefinitionBands\n  OutputStream\n  PackingUtils.log(\"Writing attribute definition bands...\")\n  $r1 \u003d List attributeDefinitions\u003e\n  $i0 \u003d $r1.size()\n  r2 \u003d newarray (int)[$i0]\n  $r3 \u003d List attributeDefinitions\u003e\n  $i1 \u003d $r3.size()\n  r4 \u003d newarray (int)[$i1]\n  $r5 \u003d List attributeDefinitions\u003e\n  $i2 \u003d $r5.size()\n  r6 \u003d newarray (int)[$i2]\n  i17 \u003d 0\n}",
      "B1 {\n  $i3 \u003d lengthof r6\n  if (i17 \u003e\u003d $i3) goto B2 else B3\n}",
      "B2 {\n  $r32 \u003d List attributeDefinitions\u003e\n  $r33 \u003d $r32.get(i17)\n  r34 \u003d AttributeDefinitionBands$AttributeDefinition) $r33\n  $i13 \u003d AttributeDefinitionBands$AttributeDefinition: int contextType\u003e\n  $i10 \u003d AttributeDefinitionBands$AttributeDefinition: int index\u003e\n  $i11 \u003d $i10 + 1\n  $i12 \u003d $i11 \u003c\u003c 2\n  $i14 \u003d $i13 | $i12\n  r2[i17] \u003d $i14\n  $r35 \u003d CPUTF8 name\u003e\n  $i15 \u003d $r35.getIndex()\n  r4[i17] \u003d $i15\n  $r36 \u003d CPUTF8 layout\u003e\n  $i16 \u003d $r36.getIndex()\n  r6[i17] \u003d $i16\n  i17 \u003d i17 + 1\n  goto B1\n}",
      "B3 {\n  $r7 \u003d BHSDCodec BYTE1\u003e\n  r37 \u003d r0.encodeBandInt(\"attributeDefinitionHeader\", r2, $r7)\n  r8.write(r37)\n  $r9 \u003d StringBuilder\n  new StringBuilder()\n  $r10 \u003d $r9.append(\"Wrote \")\n  $i4 \u003d lengthof r37\n  $r11 \u003d $r10.append($i4)\n  $r12 \u003d $r11.append(\" bytes from attributeDefinitionHeader\")\n  $i5 \u003d lengthof r2\n  $r13 \u003d $r12.append($i5)\n  $r14 \u003d $r13.append(\"\")\n  $r15 \u003d $r14.toString()\n  PackingUtils.log($r15)\n  $r16 \u003d BHSDCodec UNSIGNED5\u003e\n  r38 \u003d r0.encodeBandInt(\"attributeDefinitionName\", r4, $r16)\n  r8.write(r38)\n  $r17 \u003d StringBuilder\n  new StringBuilder()\n  $r18 \u003d $r17.append(\"Wrote \")\n  $i6 \u003d lengthof r38\n  $r19 \u003d $r18.append($i6)\n  $r20 \u003d $r19.append(\" bytes from attributeDefinitionName\")\n  $i7 \u003d lengthof r4\n  $r21 \u003d $r20.append($i7)\n  $r22 \u003d $r21.append(\"\")\n  $r23 \u003d $r22.toString()\n  PackingUtils.log($r23)\n  $r24 \u003d BHSDCodec UNSIGNED5\u003e\n  r39 \u003d r0.encodeBandInt(\"attributeDefinitionLayout\", r6, $r24)\n  r8.write(r39)\n  $r25 \u003d StringBuilder\n  new StringBuilder()\n  $r26 \u003d $r25.append(\"Wrote \")\n  $i8 \u003d lengthof r39\n  $r27 \u003d $r26.append($i8)\n  $r28 \u003d $r27.append(\" bytes from attributeDefinitionLayout\")\n  $i9 \u003d lengthof r6\n  $r29 \u003d $r28.append($i9)\n  $r30 \u003d $r29.append(\"\")\n  $r31 \u003d $r30.toString()\n  PackingUtils.log($r31)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AttributeDefinitionBands#encodeBandInt(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitEnd",
    "signature": "void visitEnd()",
    "visibility": "public",
    "body": "{\r\n    for (int i \u003d 0; i \u003c bciRenumbering.size(); i++) {\r\n        if (bciRenumbering.get(i) \u003d\u003d -1) {\r\n            bciRenumbering.remove(i);\r\n            bciRenumbering.add(i, ++renumberedOffset);\r\n        }\r\n    }\r\n    if (renumberedOffset !\u003d 0) {\r\n        if (renumberedOffset + 1 !\u003d bciRenumbering.size()) {\r\n            throw new IllegalStateException(\"Mistake made with renumbering\");\r\n        }\r\n        for (int i \u003d bcLabel.size() - 1; i \u003e\u003d 0; i--) {\r\n            final Object label \u003d bcLabel.get(i);\r\n            if (label instanceof Integer) {\r\n                break;\r\n            }\r\n            if (label instanceof Label) {\r\n                bcLabel.remove(i);\r\n                final Integer offset \u003d labelsToOffsets.get(label);\r\n                final int relativeOffset \u003d bcLabelRelativeOffsets.get(i);\r\n                bcLabel.add(i, Integer.valueOf(bciRenumbering.get(offset.intValue()) - bciRenumbering.get(relativeOffset)));\r\n            }\r\n        }\r\n        bcCodes.add(endMarker);\r\n        segment.getClassBands().doBciRenumbering(bciRenumbering, labelsToOffsets);\r\n        bciRenumbering.clear();\r\n        labelsToOffsets.clear();\r\n        byteCodeOffset \u003d 0;\r\n        renumberedOffset \u003d 0;\r\n    }\r\n}",
    "nodes": 17,
    "edges": 22,
    "cc": 7,
    "flowSummary": [
      "B1 : If(i14 \u003e\u003d $i0) → B2 | else → B5",
      "B2 : If($i11 !\u003d $i17) → B3 | else → B4",
      "B5 : If($i1 \u003d\u003d false) → B6 | else → B16",
      "B6 : If($i4 \u003d\u003d $i3) → B7 | else → B8",
      "B9 : If(i15 \u003c 0) → B10 | else → B15",
      "B10 : If($z0 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($z1 \u003d\u003d false) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i14 \u003d 0\n}",
      "B1 {\n  $r1 \u003d IntList bciRenumbering\u003e\n  $i0 \u003d $r1.size()\n  if (i14 \u003e\u003d $i0) goto B2 else B5\n}",
      "B2 {\n  $r23 \u003d IntList bciRenumbering\u003e\n  $i11 \u003d $r23.get(i14)\n  $i17 \u003d (int) -1\n  if ($i11 !\u003d $i17) goto B3 else B4\n}",
      "B3 {\n  $r24 \u003d IntList bciRenumbering\u003e\n  $r24.remove(i14)\n  $r25 \u003d IntList bciRenumbering\u003e\n  $i12 \u003d BcBands: int renumberedOffset\u003e\n  $i13 \u003d $i12 + 1\n  BcBands: int renumberedOffset\u003e \u003d $i13\n  $r25.add(i14, $i13)\n}",
      "B4 {\n  i14 \u003d i14 + 1\n  goto B1\n}",
      "B5 {\n  $i1 \u003d BcBands: int renumberedOffset\u003e\n  if ($i1 \u003d\u003d false) goto B6 else B16\n}",
      "B6 {\n  $i2 \u003d BcBands: int renumberedOffset\u003e\n  $i4 \u003d $i2 + 1\n  $r2 \u003d IntList bciRenumbering\u003e\n  $i3 \u003d $r2.size()\n  if ($i4 \u003d\u003d $i3) goto B7 else B8\n}",
      "B7 {\n  $r26 \u003d IllegalStateException\n  new IllegalStateException(\"Mistake made with renumbering\")\n  throw $r26\n}",
      "B8 {\n  $r3 \u003d List bcLabel\u003e\n  $i5 \u003d $r3.size()\n  i15 \u003d $i5 - 1\n}",
      "B9 {\n  if (i15 \u003c 0) goto B10 else B15\n}",
      "B10 {\n  $r11 \u003d List bcLabel\u003e\n  r12 \u003d $r11.get(i15)\n  $z0 \u003d Integer\n  if ($z0 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  goto B15\n}",
      "B12 {\n  $z1 \u003d Label\n  if ($z1 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $r13 \u003d List bcLabel\u003e\n  $r13.remove(i15)\n  $r14 \u003d Map labelsToOffsets\u003e\n  $r15 \u003d $r14.get(r12)\n  r16 \u003d Integer) $r15\n  $r17 \u003d IntList bcLabelRelativeOffsets\u003e\n  i6 \u003d $r17.get(i15)\n  $r18 \u003d List bcLabel\u003e\n  $r19 \u003d IntList bciRenumbering\u003e\n  $i7 \u003d r16.intValue()\n  $i9 \u003d $r19.get($i7)\n  $r20 \u003d IntList bciRenumbering\u003e\n  $i8 \u003d $r20.get(i6)\n  $i10 \u003d $i9 - $i8\n  $r21 \u003d Integer.valueOf($i10)\n  $r18.add(i15, $r21)\n}",
      "B14 {\n  $i19 \u003d (int) -1\n  i15 \u003d i15 + $i19\n  goto B9\n}",
      "B15 {\n  $r4 \u003d IntList bcCodes\u003e\n  $r4.add(255)\n  $r5 \u003d Segment segment\u003e\n  $r8 \u003d $r5.getClassBands()\n  $r7 \u003d IntList bciRenumbering\u003e\n  $r6 \u003d Map labelsToOffsets\u003e\n  $r8.doBciRenumbering($r7, $r6)\n  $r9 \u003d IntList bciRenumbering\u003e\n  $r9.clear()\n  $r10 \u003d Map labelsToOffsets\u003e\n  $r10.clear()\n  BcBands: int byteCodeOffset\u003e \u003d 0\n  BcBands: int renumberedOffset\u003e \u003d 0\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B16",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B9",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitFieldInsn",
    "signature": "void visitFieldInsn(int,java.lang.String,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    byteCodeOffset +\u003d 3;\r\n    updateRenumbering();\r\n    boolean aload_0 \u003d false;\r\n    if (bcCodes.size() \u003e 0 \u0026\u0026 bcCodes.get(bcCodes.size() - 1) \u003d\u003d ALOAD_0) {\r\n        bcCodes.remove(bcCodes.size() - 1);\r\n        aload_0 \u003d true;\r\n    }\r\n    final CPMethodOrField cpField \u003d cpBands.getCPField(owner, name, desc);\r\n    if (aload_0) {\r\n        opcode +\u003d 7;\r\n    }\r\n    if (owner.equals(currentClass)) {\r\n        // change to getstatic_this, putstatic_this etc.\r\n        opcode +\u003d 24;\r\n        bcThisField.add(cpField);\r\n        //        } else if (owner.equals(superClass)) {\r\n        //            opcode +\u003d 38; // change to getstatic_super etc.\r\n        //            bcSuperField.add(cpField);\r\n    } else {\r\n        if (aload_0) {\r\n            opcode -\u003d 7;\r\n            // add aload_0 back in because\r\n            bcCodes.add(ALOAD_0);\r\n            // there\u0027s no special rewrite in\r\n            // this case.\r\n        }\r\n        bcFieldRef.add(cpField);\r\n    }\r\n    aload_0 \u003d false;\r\n    bcCodes.add(opcode);\r\n}",
    "nodes": 11,
    "edges": 15,
    "cc": 6,
    "flowSummary": [
      "B0 : If($i2 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($i5 !\u003d 42) → B2 | else → B3",
      "B3 : If(z2 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B7",
      "B7 : If(z3 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i8 :\u003d @parameter0: int\n  String\n  String\n  String\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $i1 \u003d $i0 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i1\n  r0.updateRenumbering()\n  z1 \u003d 0\n  z3 \u003d 0\n  z2 \u003d 0\n  $r1 \u003d IntList bcCodes\u003e\n  $i2 \u003d $r1.size()\n  if ($i2 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r10 \u003d IntList bcCodes\u003e\n  $r9 \u003d IntList bcCodes\u003e\n  $i3 \u003d $r9.size()\n  $i4 \u003d $i3 - 1\n  $i5 \u003d $r10.get($i4)\n  if ($i5 !\u003d 42) goto B2 else B3\n}",
      "B2 {\n  $r12 \u003d IntList bcCodes\u003e\n  $r11 \u003d IntList bcCodes\u003e\n  $i6 \u003d $r11.size()\n  $i7 \u003d $i6 - 1\n  $r12.remove($i7)\n  z1 \u003d 1\n  z3 \u003d 1\n  z2 \u003d 1\n}",
      "B3 {\n  $r13 \u003d CpBands cpBands\u003e\n  $r14 \u003d $r13.getCPField(r2, r3, r4)\n  if (z2 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  i8 \u003d i8 + 7\n}",
      "B5 {\n  $r5 \u003d String currentClass\u003e\n  $z0 \u003d r2.equals($r5)\n  if ($z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  i8 \u003d i8 + 24\n  $r8 \u003d List bcThisField\u003e\n  $r8.add($r14)\n  goto B10\n}",
      "B7 {\n  if (z3 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $i10 \u003d (int) -7\n  i8 \u003d i8 + $i10\n  $r7 \u003d IntList bcCodes\u003e\n  $r7.add(42)\n}",
      "B9 {\n  $r6 \u003d List bcFieldRef\u003e\n  $r6.add($r14)\n}",
      "B10 {\n  $r15 \u003d IntList bcCodes\u003e\n  $r15.add(i8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitIincInsn",
    "signature": "void visitIincInsn(int,int)",
    "visibility": "public",
    "body": "{\r\n    if (var \u003e 255 || increment \u003e 255) {\r\n        byteCodeOffset +\u003d 6;\r\n        bcCodes.add(WIDE);\r\n        bcCodes.add(IINC);\r\n        bcLocal.add(var);\r\n        bcShort.add(increment);\r\n    } else {\r\n        byteCodeOffset +\u003d 3;\r\n        bcCodes.add(IINC);\r\n        bcLocal.add(var);\r\n        bcByte.add(increment \u0026 0xFF);\r\n    }\r\n    updateRenumbering();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 \u003e 255) → B1 | else → B2",
      "B1 : If(i3 \u003c\u003d 255) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i0 :\u003d @parameter0: int\n  i3 :\u003d @parameter1: int\n  if (i0 \u003e 255) goto B1 else B2\n}",
      "B1 {\n  if (i3 \u003c\u003d 255) goto B2 else B3\n}",
      "B2 {\n  $i1 \u003d BcBands: int byteCodeOffset\u003e\n  $i2 \u003d $i1 + 6\n  BcBands: int byteCodeOffset\u003e \u003d $i2\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(196)\n  $r2 \u003d IntList bcCodes\u003e\n  $r2.add(132)\n  $r3 \u003d IntList bcLocal\u003e\n  $r3.add(i0)\n  $r4 \u003d IntList bcShort\u003e\n  $r4.add(i3)\n  goto B4\n}",
      "B3 {\n  $i4 \u003d BcBands: int byteCodeOffset\u003e\n  $i5 \u003d $i4 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i5\n  $r5 \u003d IntList bcCodes\u003e\n  $r5.add(132)\n  $r6 \u003d IntList bcLocal\u003e\n  $r6.add(i0)\n  $r7 \u003d IntList bcByte\u003e\n  $i6 \u003d i3 \u0026 255\n  $r7.add($i6)\n}",
      "B4 {\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitInsn",
    "signature": "void visitInsn(int)",
    "visibility": "public",
    "body": "{\r\n    if (opcode \u003e\u003d 202) {\r\n        throw new IllegalArgumentException(\"Non-standard bytecode instructions not supported\");\r\n    }\r\n    bcCodes.add(opcode);\r\n    byteCodeOffset++;\r\n    updateRenumbering();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c 202) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i0 :\u003d @parameter0: int\n  if (i0 \u003c 202) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Non-standard bytecode instructions not supported\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(i0)\n  $i1 \u003d BcBands: int byteCodeOffset\u003e\n  $i2 \u003d $i1 + 1\n  BcBands: int byteCodeOffset\u003e \u003d $i2\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitIntInsn",
    "signature": "void visitIntInsn(int,int)",
    "visibility": "public",
    "body": "{\r\n    switch(opcode) {\r\n        case // sipush\r\n        17:\r\n            bcCodes.add(opcode);\r\n            bcShort.add(operand);\r\n            byteCodeOffset +\u003d 3;\r\n            break;\r\n        // bipush\r\n        case 16:\r\n        case // newarray\r\n        188:\r\n            bcCodes.add(opcode);\r\n            bcByte.add(operand \u0026 0xFF);\r\n            byteCodeOffset +\u003d 2;\r\n    }\r\n    updateRenumbering();\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(switch-on i0) → B2 | else → B1"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  BcBands: void updateRenumbering()\u003e(); }\n}",
      "B1 {\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(i0)\n  $r2 \u003d IntList bcShort\u003e\n  $r2.add(i1)\n  $i2 \u003d BcBands: int byteCodeOffset\u003e\n  $i3 \u003d $i2 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i3\n  goto B3\n}",
      "B2 {\n  $r3 \u003d IntList bcCodes\u003e\n  $r3.add(i0)\n  $r4 \u003d IntList bcByte\u003e\n  $i4 \u003d i1 \u0026 255\n  $r4.add($i4)\n  $i5 \u003d BcBands: int byteCodeOffset\u003e\n  $i6 \u003d $i5 + 2\n  BcBands: int byteCodeOffset\u003e \u003d $i6\n}",
      "B3 {\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitLdcInsn",
    "signature": "void visitLdcInsn(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    final CPConstant\u003c?\u003e constant \u003d cpBands.getConstant(cst);\r\n    if (segment.lastConstantHadWideIndex() || constant instanceof CPLong || constant instanceof CPDouble) {\r\n        byteCodeOffset +\u003d 3;\r\n        if (constant instanceof CPInt) {\r\n            // ildc_w\r\n            bcCodes.add(237);\r\n            bcIntref.add((CPInt) constant);\r\n        } else if (constant instanceof CPFloat) {\r\n            // fldc\r\n            bcCodes.add(238);\r\n            bcFloatRef.add((CPFloat) constant);\r\n        } else if (constant instanceof CPLong) {\r\n            // lldc2_w\r\n            bcCodes.add(20);\r\n            bcLongRef.add((CPLong) constant);\r\n        } else if (constant instanceof CPDouble) {\r\n            // dldc2_w\r\n            bcCodes.add(239);\r\n            bcDoubleRef.add((CPDouble) constant);\r\n        } else if (constant instanceof CPString) {\r\n            // aldc\r\n            bcCodes.add(19);\r\n            bcStringRef.add((CPString) constant);\r\n        } else if (constant instanceof CPClass) {\r\n            // cldc\r\n            bcCodes.add(236);\r\n            bcClassRef.add((CPClass) constant);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Constant should not be null\");\r\n        }\r\n    } else {\r\n        byteCodeOffset +\u003d 2;\r\n        if (constant instanceof CPInt) {\r\n            // ildc\r\n            bcCodes.add(234);\r\n            bcIntref.add((CPInt) constant);\r\n        } else if (constant instanceof CPFloat) {\r\n            // fldc\r\n            bcCodes.add(235);\r\n            bcFloatRef.add((CPFloat) constant);\r\n        } else if (constant instanceof CPString) {\r\n            // aldc\r\n            bcCodes.add(18);\r\n            bcStringRef.add((CPString) constant);\r\n        } else if (constant instanceof CPClass) {\r\n            // cldc\r\n            bcCodes.add(233);\r\n            bcClassRef.add((CPClass) constant);\r\n        }\r\n    }\r\n    updateRenumbering();\r\n}",
    "nodes": 25,
    "edges": 36,
    "cc": 13,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z6 !\u003d 0) → B2 | else → B3",
      "B2 : If($z7 \u003d\u003d false) → B3 | else → B16",
      "B3 : If($z12 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11",
      "B11 : If($z4 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z5 \u003d\u003d false) → B14 | else → B15",
      "B16 : If($z8 \u003d\u003d false) → B17 | else → B18",
      "B18 : If($z9 \u003d\u003d false) → B19 | else → B20",
      "B20 : If($z10 \u003d\u003d false) → B21 | else → B22",
      "B22 : If($z11 \u003d\u003d false) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  Object\n  $r2 \u003d CpBands cpBands\u003e\n  r3 \u003d $r2.getConstant(r1)\n  $r4 \u003d Segment segment\u003e\n  $z0 \u003d $r4.lastConstantHadWideIndex()\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z6 \u003d CPLong\n  if ($z6 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z7 \u003d CPDouble\n  if ($z7 \u003d\u003d false) goto B3 else B16\n}",
      "B3 {\n  $i2 \u003d BcBands: int byteCodeOffset\u003e\n  $i3 \u003d $i2 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i3\n  $z12 \u003d CPInt\n  if ($z12 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r21 \u003d IntList bcCodes\u003e\n  $r21.add(237)\n  $r23 \u003d List bcIntref\u003e\n  $r22 \u003d CPInt) r3\n  $r23.add($r22)\n  goto B24\n}",
      "B5 {\n  $z1 \u003d CPFloat\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r18 \u003d IntList bcCodes\u003e\n  $r18.add(238)\n  $r20 \u003d List bcFloatRef\u003e\n  $r19 \u003d CPFloat) r3\n  $r20.add($r19)\n  goto B24\n}",
      "B7 {\n  $z2 \u003d CPLong\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r15 \u003d IntList bcCodes\u003e\n  $r15.add(20)\n  $r17 \u003d List bcLongRef\u003e\n  $r16 \u003d CPLong) r3\n  $r17.add($r16)\n  goto B24\n}",
      "B9 {\n  $z3 \u003d CPDouble\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r12 \u003d IntList bcCodes\u003e\n  $r12.add(239)\n  $r14 \u003d List bcDoubleRef\u003e\n  $r13 \u003d CPDouble) r3\n  $r14.add($r13)\n  goto B24\n}",
      "B11 {\n  $z4 \u003d CPString\n  if ($z4 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r9 \u003d IntList bcCodes\u003e\n  $r9.add(19)\n  $r11 \u003d List bcStringRef\u003e\n  $r10 \u003d CPString) r3\n  $r11.add($r10)\n  goto B24\n}",
      "B13 {\n  $z5 \u003d CPClass\n  if ($z5 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r6 \u003d IntList bcCodes\u003e\n  $r6.add(236)\n  $r8 \u003d List bcClassRef\u003e\n  $r7 \u003d CPClass) r3\n  $r8.add($r7)\n  goto B24\n}",
      "B15 {\n  $r5 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Constant should not be null\")\n  throw $r5\n}",
      "B16 {\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $i1 \u003d $i0 + 2\n  BcBands: int byteCodeOffset\u003e \u003d $i1\n  $z8 \u003d CPInt\n  if ($z8 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r33 \u003d IntList bcCodes\u003e\n  $r33.add(234)\n  $r35 \u003d List bcIntref\u003e\n  $r34 \u003d CPInt) r3\n  $r35.add($r34)\n  goto B24\n}",
      "B18 {\n  $z9 \u003d CPFloat\n  if ($z9 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r30 \u003d IntList bcCodes\u003e\n  $r30.add(235)\n  $r32 \u003d List bcFloatRef\u003e\n  $r31 \u003d CPFloat) r3\n  $r32.add($r31)\n  goto B24\n}",
      "B20 {\n  $z10 \u003d CPString\n  if ($z10 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  $r27 \u003d IntList bcCodes\u003e\n  $r27.add(18)\n  $r29 \u003d List bcStringRef\u003e\n  $r28 \u003d CPString) r3\n  $r29.add($r28)\n  goto B24\n}",
      "B22 {\n  $z11 \u003d CPClass\n  if ($z11 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r24 \u003d IntList bcCodes\u003e\n  $r24.add(233)\n  $r26 \u003d List bcClassRef\u003e\n  $r25 \u003d CPClass) r3\n  $r26.add($r25)\n}",
      "B24 {\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B16",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B24",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B24",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B24",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B24",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B24",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B24",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B24",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B24",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B24",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitLookupSwitchInsn",
    "signature": "void visitLookupSwitchInsn(org.objectweb.asm.Label,int[],org.objectweb.asm.Label[])",
    "visibility": "public",
    "body": "{\r\n    bcCodes.add(LOOKUPSWITCH);\r\n    bcLabel.add(dflt);\r\n    bcLabelRelativeOffsets.add(byteCodeOffset);\r\n    bcCaseCount.add(keys.length);\r\n    for (int i \u003d 0; i \u003c labels.length; i++) {\r\n        bcCaseValue.add(keys[i]);\r\n        bcLabel.add(labels[i]);\r\n        bcLabelRelativeOffsets.add(byteCodeOffset);\r\n    }\r\n    final int padding \u003d (byteCodeOffset + 1) % 4 \u003d\u003d 0 ? 0 : 4 - (byteCodeOffset + 1) % 4;\r\n    byteCodeOffset +\u003d 1 + padding + 8 + 8 * keys.length;\r\n    updateRenumbering();\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i18 \u003e\u003d $i2) → B2 | else → B3",
      "B3 : If($i5 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  Label\n  r5 :\u003d @parameter1: int[]\n  Label[]\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(171)\n  $r3 \u003d List bcLabel\u003e\n  $r3.add(r2)\n  $r4 \u003d IntList bcLabelRelativeOffsets\u003e\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $r4.add($i0)\n  $r6 \u003d IntList bcCaseCount\u003e\n  $i1 \u003d lengthof r5\n  $r6.add($i1)\n  i18 \u003d 0\n}",
      "B1 {\n  $i2 \u003d lengthof r7\n  if (i18 \u003e\u003d $i2) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d IntList bcCaseValue\u003e\n  $i16 \u003d r5[i18]\n  $r8.add($i16)\n  $r10 \u003d List bcLabel\u003e\n  $r9 \u003d r7[i18]\n  $r10.add($r9)\n  $r11 \u003d IntList bcLabelRelativeOffsets\u003e\n  $i17 \u003d BcBands: int byteCodeOffset\u003e\n  $r11.add($i17)\n  i18 \u003d i18 + 1\n  goto B1\n}",
      "B3 {\n  $i3 \u003d BcBands: int byteCodeOffset\u003e\n  $i4 \u003d $i3 + 1\n  $i5 \u003d $i4 % 4\n  if ($i5 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i19 \u003d 0\n  goto B6\n}",
      "B5 {\n  $i6 \u003d BcBands: int byteCodeOffset\u003e\n  $i7 \u003d $i6 + 1\n  $i8 \u003d $i7 % 4\n  $i19 \u003d 4 - $i8\n}",
      "B6 {\n  $i14 \u003d BcBands: int byteCodeOffset\u003e\n  $i9 \u003d 1 + $i19\n  $i12 \u003d $i9 + 8\n  $i10 \u003d lengthof r5\n  $i11 \u003d 8 * $i10\n  $i13 \u003d $i12 + $i11\n  $i15 \u003d $i14 + $i13\n  BcBands: int byteCodeOffset\u003e \u003d $i15\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitMethodInsn",
    "signature": "void visitMethodInsn(int,java.lang.String,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    byteCodeOffset +\u003d 3;\r\n    switch(opcode) {\r\n        // invokevirtual\r\n        case 182:\r\n        // invokespecial\r\n        case 183:\r\n        case // invokestatic\r\n        184:\r\n            boolean aload_0 \u003d false;\r\n            if (bcCodes.size() \u003e 0 \u0026\u0026 bcCodes.get(bcCodes.size() - 1) \u003d\u003d ALOAD_0) {\r\n                bcCodes.remove(bcCodes.size() - 1);\r\n                aload_0 \u003d true;\r\n                opcode +\u003d 7;\r\n            }\r\n            if (owner.equals(currentClass)) {\r\n                // change to invokevirtual_this,\r\n                opcode +\u003d 24;\r\n                // invokespecial_this etc.\r\n                if (name.equals(\"\u003cinit\u003e\") \u0026\u0026 opcode \u003d\u003d 207) {\r\n                    // invokespecial_this_init\r\n                    opcode \u003d 230;\r\n                    bcInitRef.add(cpBands.getCPMethod(owner, name, desc));\r\n                } else {\r\n                    bcThisMethod.add(cpBands.getCPMethod(owner, name, desc));\r\n                }\r\n            } else if (owner.equals(superClass)) {\r\n                // TODO\r\n                // change to invokevirtual_super,\r\n                opcode +\u003d 38;\r\n                // invokespecial_super etc.\r\n                if (name.equals(\"\u003cinit\u003e\") \u0026\u0026 opcode \u003d\u003d 221) {\r\n                    // invokespecial_super_init\r\n                    opcode \u003d 231;\r\n                    bcInitRef.add(cpBands.getCPMethod(owner, name, desc));\r\n                } else {\r\n                    bcSuperMethod.add(cpBands.getCPMethod(owner, name, desc));\r\n                }\r\n            } else {\r\n                if (aload_0) {\r\n                    opcode -\u003d 7;\r\n                    // add aload_0 back in\r\n                    bcCodes.add(ALOAD_0);\r\n                    // because there\u0027s no\r\n                    // special rewrite in this\r\n                    // case.\r\n                }\r\n                if (name.equals(\"\u003cinit\u003e\") \u0026\u0026 opcode \u003d\u003d 183 \u0026\u0026 owner.equals(currentNewClass)) {\r\n                    // invokespecial_new_init\r\n                    opcode \u003d 232;\r\n                    bcInitRef.add(cpBands.getCPMethod(owner, name, desc));\r\n                } else {\r\n                    bcMethodRef.add(cpBands.getCPMethod(owner, name, desc));\r\n                }\r\n            }\r\n            bcCodes.add(opcode);\r\n            break;\r\n        case // invokeinterface\r\n        185:\r\n            byteCodeOffset +\u003d 2;\r\n            final CPMethodOrField cpIMethod \u003d cpBands.getCPIMethod(owner, name, desc);\r\n            bcIMethodRef.add(cpIMethod);\r\n            bcCodes.add(INVOKEINTERFACE);\r\n            break;\r\n    }\r\n    updateRenumbering();\r\n}",
    "nodes": 24,
    "edges": 37,
    "cc": 15,
    "flowSummary": [
      "B0 : If(switch-on i10) → B1 | else → B22",
      "B1 : If($i4 \u003c\u003d 0) → B2 | else → B4",
      "B2 : If($i7 !\u003d 42) → B3 | else → B4",
      "B4 : If($z6 \u003d\u003d false) → B5 | else → B9",
      "B5 : If($z4 \u003d\u003d false) → B6 | else → B8",
      "B6 : If(i10 !\u003d 207) → B7 | else → B8",
      "B9 : If($z0 \u003d\u003d false) → B10 | else → B14",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B13",
      "B11 : If(i10 !\u003d 221) → B12 | else → B13",
      "B14 : If(z5 \u003d\u003d false) → B15 | else → B16",
      "B16 : If($z1 \u003d\u003d false) → B17 | else → B20",
      "B17 : If(i10 !\u003d 183) → B18 | else → B20",
      "B18 : If($z2 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i10 :\u003d @parameter0: int\n  String\n  String\n  String\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $i1 \u003d $i0 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i1\n  BcBands: void updateRenumbering()\u003e(); }\n}",
      "B1 {\n  z5 \u003d 0\n  $r8 \u003d IntList bcCodes\u003e\n  $i4 \u003d $r8.size()\n  if ($i4 \u003c\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $r28 \u003d IntList bcCodes\u003e\n  $r27 \u003d IntList bcCodes\u003e\n  $i5 \u003d $r27.size()\n  $i6 \u003d $i5 - 1\n  $i7 \u003d $r28.get($i6)\n  if ($i7 !\u003d 42) goto B3 else B4\n}",
      "B3 {\n  $r30 \u003d IntList bcCodes\u003e\n  $r29 \u003d IntList bcCodes\u003e\n  $i8 \u003d $r29.size()\n  $i9 \u003d $i8 - 1\n  $r30.remove($i9)\n  z5 \u003d 1\n  i10 \u003d i10 + 7\n}",
      "B4 {\n  $r31 \u003d String currentClass\u003e\n  $z6 \u003d r1.equals($r31)\n  if ($z6 \u003d\u003d false) goto B5 else B9\n}",
      "B5 {\n  i10 \u003d i10 + 24\n  $z4 \u003d r2.equals(\"\u003cinit\u003e\")\n  if ($z4 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  if (i10 !\u003d 207) goto B7 else B8\n}",
      "B7 {\n  i10 \u003d 230\n  $r25 \u003d List bcInitRef\u003e\n  $r24 \u003d CpBands cpBands\u003e\n  $r26 \u003d $r24.getCPMethod(r1, r2, r3)\n  $r25.add($r26)\n  goto B21\n}",
      "B8 {\n  $r22 \u003d List bcThisMethod\u003e\n  $r21 \u003d CpBands cpBands\u003e\n  $r23 \u003d $r21.getCPMethod(r1, r2, r3)\n  $r22.add($r23)\n  goto B21\n}",
      "B9 {\n  $r9 \u003d String superClass\u003e\n  $z0 \u003d r1.equals($r9)\n  if ($z0 \u003d\u003d false) goto B10 else B14\n}",
      "B10 {\n  i10 \u003d i10 + 38\n  $z3 \u003d r2.equals(\"\u003cinit\u003e\")\n  if ($z3 \u003d\u003d false) goto B11 else B13\n}",
      "B11 {\n  if (i10 !\u003d 221) goto B12 else B13\n}",
      "B12 {\n  i10 \u003d 231\n  $r19 \u003d List bcInitRef\u003e\n  $r18 \u003d CpBands cpBands\u003e\n  $r20 \u003d $r18.getCPMethod(r1, r2, r3)\n  $r19.add($r20)\n  goto B21\n}",
      "B13 {\n  $r16 \u003d List bcSuperMethod\u003e\n  $r15 \u003d CpBands cpBands\u003e\n  $r17 \u003d $r15.getCPMethod(r1, r2, r3)\n  $r16.add($r17)\n  goto B21\n}",
      "B14 {\n  if (z5 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $i12 \u003d (int) -7\n  i10 \u003d i10 + $i12\n  $r14 \u003d IntList bcCodes\u003e\n  $r14.add(42)\n}",
      "B16 {\n  $z1 \u003d r2.equals(\"\u003cinit\u003e\")\n  if ($z1 \u003d\u003d false) goto B17 else B20\n}",
      "B17 {\n  if (i10 !\u003d 183) goto B18 else B20\n}",
      "B18 {\n  $r10 \u003d String currentNewClass\u003e\n  $z2 \u003d r1.equals($r10)\n  if ($z2 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  i10 \u003d 232\n  $r12 \u003d List bcInitRef\u003e\n  $r11 \u003d CpBands cpBands\u003e\n  $r13 \u003d $r11.getCPMethod(r1, r2, r3)\n  $r12.add($r13)\n  goto B21\n}",
      "B20 {\n  $r32 \u003d List bcMethodRef\u003e\n  $r33 \u003d CpBands cpBands\u003e\n  $r34 \u003d $r33.getCPMethod(r1, r2, r3)\n  $r32.add($r34)\n}",
      "B21 {\n  $r35 \u003d IntList bcCodes\u003e\n  $r35.add(i10)\n  goto B23\n}",
      "B22 {\n  $i2 \u003d BcBands: int byteCodeOffset\u003e\n  $i3 \u003d $i2 + 2\n  BcBands: int byteCodeOffset\u003e \u003d $i3\n  $r4 \u003d CpBands cpBands\u003e\n  r5 \u003d $r4.getCPIMethod(r1, r2, r3)\n  $r6 \u003d List bcIMethodRef\u003e\n  $r6.add(r5)\n  $r7 \u003d IntList bcCodes\u003e\n  $r7.add(185)\n}",
      "B23 {\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B22",
      "B0 --\u003e B23",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B21",
      "B8 --\u003e B21",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B21",
      "B13 --\u003e B21",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B20",
      "B17 --\u003e B18",
      "B17 --\u003e B20",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitTableSwitchInsn",
    "signature": "void visitTableSwitchInsn(int,int,org.objectweb.asm.Label,org.objectweb.asm.Label[])",
    "visibility": "public",
    "body": "{\r\n    bcCodes.add(TABLESWITCH);\r\n    bcLabel.add(dflt);\r\n    bcLabelRelativeOffsets.add(byteCodeOffset);\r\n    bcCaseValue.add(min);\r\n    final int count \u003d labels.length;\r\n    bcCaseCount.add(count);\r\n    for (int i \u003d 0; i \u003c count; i++) {\r\n        bcLabel.add(labels[i]);\r\n        bcLabelRelativeOffsets.add(byteCodeOffset);\r\n    }\r\n    final int padding \u003d byteCodeOffset % 4 \u003d\u003d 0 ? 0 : 4 - byteCodeOffset % 4;\r\n    byteCodeOffset +\u003d padding + 12 + 4 * labels.length;\r\n    updateRenumbering();\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i15 \u003e\u003d i2) → B2 | else → B3",
      "B3 : If($i4 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i1 :\u003d @parameter0: int\n  i14 :\u003d @parameter1: int\n  Label\n  Label[]\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(170)\n  $r3 \u003d List bcLabel\u003e\n  $r3.add(r2)\n  $r4 \u003d IntList bcLabelRelativeOffsets\u003e\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $r4.add($i0)\n  $r5 \u003d IntList bcCaseValue\u003e\n  $r5.add(i1)\n  i2 \u003d lengthof r6\n  $r7 \u003d IntList bcCaseCount\u003e\n  $r7.add(i2)\n  i15 \u003d 0\n}",
      "B1 {\n  if (i15 \u003e\u003d i2) goto B2 else B3\n}",
      "B2 {\n  $r9 \u003d List bcLabel\u003e\n  $r8 \u003d r6[i15]\n  $r9.add($r8)\n  $r10 \u003d IntList bcLabelRelativeOffsets\u003e\n  $i13 \u003d BcBands: int byteCodeOffset\u003e\n  $r10.add($i13)\n  i15 \u003d i15 + 1\n  goto B1\n}",
      "B3 {\n  $i3 \u003d BcBands: int byteCodeOffset\u003e\n  $i4 \u003d $i3 % 4\n  if ($i4 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i16 \u003d 0\n  goto B6\n}",
      "B5 {\n  $i5 \u003d BcBands: int byteCodeOffset\u003e\n  $i6 \u003d $i5 % 4\n  $i16 \u003d 4 - $i6\n}",
      "B6 {\n  $i11 \u003d BcBands: int byteCodeOffset\u003e\n  $i9 \u003d $i16 + 12\n  $i7 \u003d lengthof r6\n  $i8 \u003d 4 * $i7\n  $i10 \u003d $i9 + $i8\n  $i12 \u003d $i11 + $i10\n  BcBands: int byteCodeOffset\u003e \u003d $i12\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitTypeInsn",
    "signature": "void visitTypeInsn(int,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // NEW, ANEWARRAY, CHECKCAST or INSTANCEOF\r\n    byteCodeOffset +\u003d 3;\r\n    updateRenumbering();\r\n    bcCodes.add(opcode);\r\n    bcClassRef.add(cpBands.getCPClass(type));\r\n    if (opcode \u003d\u003d 187) {\r\n        // NEW\r\n        currentNewClass \u003d type;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 !\u003d 187) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i2 :\u003d @parameter0: int\n  String\n  $i0 \u003d BcBands: int byteCodeOffset\u003e\n  $i1 \u003d $i0 + 3\n  BcBands: int byteCodeOffset\u003e \u003d $i1\n  r0.updateRenumbering()\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(i2)\n  $r4 \u003d List bcClassRef\u003e\n  $r3 \u003d CpBands cpBands\u003e\n  $r5 \u003d $r3.getCPClass(r2)\n  $r4.add($r5)\n  if (i2 !\u003d 187) goto B1 else B2\n}",
      "B1 {\n  String currentNewClass\u003e \u003d r2\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BcBands",
    "methodName": "visitVarInsn",
    "signature": "void visitVarInsn(int,int)",
    "visibility": "public",
    "body": "{\r\n    // ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET\r\n    if (var \u003e 255) {\r\n        byteCodeOffset +\u003d 4;\r\n        bcCodes.add(WIDE);\r\n        bcCodes.add(opcode);\r\n        bcLocal.add(var);\r\n    } else if (var \u003e 3 || opcode \u003d\u003d 169) /* RET */\r\n    {\r\n        byteCodeOffset +\u003d 2;\r\n        bcCodes.add(opcode);\r\n        bcLocal.add(var);\r\n    } else {\r\n        byteCodeOffset +\u003d 1;\r\n        switch(opcode) {\r\n            // ILOAD\r\n            case 21:\r\n            case // ISTORE\r\n            54:\r\n                bcCodes.add(opcode + 5 + var);\r\n                break;\r\n            // LLOAD\r\n            case 22:\r\n            case // LSTORE\r\n            55:\r\n                bcCodes.add(opcode + 8 + var);\r\n                break;\r\n            // FLOAD\r\n            case 23:\r\n            case // FSTORE\r\n            56:\r\n                bcCodes.add(opcode + 11 + var);\r\n                break;\r\n            // DLOAD\r\n            case 24:\r\n            case // DSTORE\r\n            57:\r\n                bcCodes.add(opcode + 14 + var);\r\n                break;\r\n            // A_LOAD\r\n            case 25:\r\n            case // A_STORE\r\n            58:\r\n                bcCodes.add(opcode + 17 + var);\r\n                break;\r\n        }\r\n    }\r\n    updateRenumbering();\r\n}",
    "nodes": 12,
    "edges": 19,
    "cc": 9,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 255) → B1 | else → B2",
      "B2 : If(i0 \u003e 3) → B3 | else → B4",
      "B3 : If(i3 !\u003d 169) → B4 | else → B5",
      "B5 : If(switch-on i3) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  i3 :\u003d @parameter0: int\n  i0 :\u003d @parameter1: int\n  if (i0 \u003c\u003d 255) goto B1 else B2\n}",
      "B1 {\n  $i16 \u003d BcBands: int byteCodeOffset\u003e\n  $i17 \u003d $i16 + 4\n  BcBands: int byteCodeOffset\u003e \u003d $i17\n  $r8 \u003d IntList bcCodes\u003e\n  $r8.add(196)\n  $r9 \u003d IntList bcCodes\u003e\n  $r9.add(i3)\n  $r10 \u003d IntList bcLocal\u003e\n  $r10.add(i0)\n  goto B11\n}",
      "B2 {\n  if (i0 \u003e 3) goto B3 else B4\n}",
      "B3 {\n  if (i3 !\u003d 169) goto B4 else B5\n}",
      "B4 {\n  $i1 \u003d BcBands: int byteCodeOffset\u003e\n  $i2 \u003d $i1 + 2\n  BcBands: int byteCodeOffset\u003e \u003d $i2\n  $r1 \u003d IntList bcCodes\u003e\n  $r1.add(i3)\n  $r2 \u003d IntList bcLocal\u003e\n  $r2.add(i0)\n  goto B11\n}",
      "B5 {\n  $i4 \u003d BcBands: int byteCodeOffset\u003e\n  $i5 \u003d $i4 + 1\n  BcBands: int byteCodeOffset\u003e \u003d $i5\n  BcBands: void updateRenumbering()\u003e(); }\n}",
      "B6 {\n  $r7 \u003d IntList bcCodes\u003e\n  $i14 \u003d i3 + 5\n  $i15 \u003d $i14 + i0\n  $r7.add($i15)\n  goto B11\n}",
      "B7 {\n  $r6 \u003d IntList bcCodes\u003e\n  $i12 \u003d i3 + 8\n  $i13 \u003d $i12 + i0\n  $r6.add($i13)\n  goto B11\n}",
      "B8 {\n  $r5 \u003d IntList bcCodes\u003e\n  $i10 \u003d i3 + 11\n  $i11 \u003d $i10 + i0\n  $r5.add($i11)\n  goto B11\n}",
      "B9 {\n  $r4 \u003d IntList bcCodes\u003e\n  $i8 \u003d i3 + 14\n  $i9 \u003d $i8 + i0\n  $r4.add($i9)\n  goto B11\n}",
      "B10 {\n  $r3 \u003d IntList bcCodes\u003e\n  $i6 \u003d i3 + 17\n  $i7 \u003d $i6 + i0\n  $r3.add($i7)\n}",
      "B11 {\n  r0.updateRenumbering()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B11",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B5 --\u003e B8",
      "B5 --\u003e B9",
      "B5 --\u003e B10",
      "B5 --\u003e B11",
      "B6 --\u003e B11",
      "B7 --\u003e B11",
      "B8 --\u003e B11",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#updateRenumbering(...0)",
        "body": "{\r\n    if (bciRenumbering.isEmpty()) {\r\n        bciRenumbering.add(0);\r\n    }\r\n    renumberedOffset++;\r\n    for (int i \u003d bciRenumbering.size(); i \u003c byteCodeOffset; i++) {\r\n        bciRenumbering.add(-1);\r\n    }\r\n    bciRenumbering.add(renumberedOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "decode",
    "signature": "int decode(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    if (d !\u003d 0) {\r\n        throw new Pack200Exception(\"Delta encoding used without passing in last value; this is a coding error\");\r\n    }\r\n    return decode(in, 0);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  InputStream\n  $i0 \u003d BHSDCodec: int d\u003e\n  if ($i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Pack200Exception\n  new Pack200Exception(\"Delta encoding used without passing in last value; this is a coding error\")\n  throw $r2\n}",
      "B2 {\n  $i1 \u003d r0.decode(r1, 0L)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BHSDCodec#decode(...2)",
        "body": "{\r\n    int n \u003d 0;\r\n    long z \u003d 0;\r\n    long x \u003d 0;\r\n    do {\r\n        x \u003d in.read();\r\n        lastBandLength++;\r\n        z +\u003d x * powers[n];\r\n        n++;\r\n    } while (x \u003e\u003d l \u0026\u0026 n \u003c b);\r\n    if (x \u003d\u003d -1) {\r\n        throw new EOFException(\"End of stream reached whilst decoding\");\r\n    }\r\n    if (isSigned()) {\r\n        final int u \u003d (1 \u003c\u003c s) - 1;\r\n        if ((z \u0026 u) \u003d\u003d u) {\r\n            z \u003d z \u003e\u003e\u003e s ^ -1L;\r\n        } else {\r\n            z -\u003d z \u003e\u003e\u003e s;\r\n        }\r\n    }\r\n    // This algorithm does the same thing, but is probably slower. Leaving\r\n    // in for now for readability\r\n    // if (isSigned()) {\r\n    // long u \u003d z;\r\n    // long twoPowS \u003d (long) Math.pow(2, s);\r\n    // double twoPowSMinusOne \u003d twoPowS-1;\r\n    // if (u % twoPowS \u003c twoPowSMinusOne) {\r\n    // if (cardinality \u003c Math.pow(2, 32)) {\r\n    // z \u003d (long) (u - (Math.floor(u/ twoPowS)));\r\n    // } else {\r\n    // z \u003d cast32((long) (u - (Math.floor(u/ twoPowS))));\r\n    // }\r\n    // } else {\r\n    // z \u003d (long) (-Math.floor(u/ twoPowS) - 1);\r\n    // }\r\n    // }\r\n    if (isDelta()) {\r\n        z +\u003d last;\r\n    }\r\n    return (int) z;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "decode",
    "signature": "int decode(java.io.InputStream,long)",
    "visibility": "public",
    "body": "{\r\n    int n \u003d 0;\r\n    long z \u003d 0;\r\n    long x \u003d 0;\r\n    do {\r\n        x \u003d in.read();\r\n        lastBandLength++;\r\n        z +\u003d x * powers[n];\r\n        n++;\r\n    } while (x \u003e\u003d l \u0026\u0026 n \u003c b);\r\n    if (x \u003d\u003d -1) {\r\n        throw new EOFException(\"End of stream reached whilst decoding\");\r\n    }\r\n    if (isSigned()) {\r\n        final int u \u003d (1 \u003c\u003c s) - 1;\r\n        if ((z \u0026 u) \u003d\u003d u) {\r\n            z \u003d z \u003e\u003e\u003e s ^ -1L;\r\n        } else {\r\n            z -\u003d z \u003e\u003e\u003e s;\r\n        }\r\n    }\r\n    // This algorithm does the same thing, but is probably slower. Leaving\r\n    // in for now for readability\r\n    // if (isSigned()) {\r\n    // long u \u003d z;\r\n    // long twoPowS \u003d (long) Math.pow(2, s);\r\n    // double twoPowSMinusOne \u003d twoPowS-1;\r\n    // if (u % twoPowS \u003c twoPowSMinusOne) {\r\n    // if (cardinality \u003c Math.pow(2, 32)) {\r\n    // z \u003d (long) (u - (Math.floor(u/ twoPowS)));\r\n    // } else {\r\n    // z \u003d cast32((long) (u - (Math.floor(u/ twoPowS))));\r\n    // }\r\n    // } else {\r\n    // z \u003d (long) (-Math.floor(u/ twoPowS) - 1);\r\n    // }\r\n    // }\r\n    if (isDelta()) {\r\n        z +\u003d last;\r\n    }\r\n    return (int) z;\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B1 : If($i27 \u003c 0) → B2 | else → B3",
      "B2 : If(i25 \u003c $i22) → B3 | else → B1",
      "B3 : If($b8 !\u003d 0) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B9",
      "B6 : If($b17 !\u003d 0) → B7 | else → B8",
      "B9 : If($z1 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  InputStream\n  l10 :\u003d @parameter1: long\n  i25 \u003d 0\n  l26 \u003d 0L\n}",
      "B1 {\n  $i0 \u003d r0.read()\n  $l23 \u003d (long) $i0\n  $i1 \u003d BHSDCodec: int lastBandLength\u003e\n  $i2 \u003d $i1 + 1\n  BHSDCodec: int lastBandLength\u003e \u003d $i2\n  $r2 \u003d BHSDCodec: long[] powers\u003e\n  $l3 \u003d $r2[i25]\n  $l4 \u003d $l23 * $l3\n  $l24 \u003d l26 + $l4\n  l26 \u003d $l24\n  i25 \u003d i25 + 1\n  $i5 \u003d BHSDCodec: int l\u003e\n  $l6 \u003d (long) $i5\n  $b7 \u003d $l23 cmp $l6\n  $i27 \u003d (int) $b7\n  if ($i27 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $i22 \u003d BHSDCodec: int b\u003e\n  if (i25 \u003c $i22) goto B3 else B1\n}",
      "B3 {\n  $b8 \u003d $l23 cmp -1L\n  if ($b8 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r4 \u003d EOFException\n  new EOFException(\"End of stream reached whilst decoding\")\n  throw $r4\n}",
      "B5 {\n  $z0 \u003d r1.isSigned()\n  if ($z0 \u003d\u003d false) goto B6 else B9\n}",
      "B6 {\n  $i11 \u003d BHSDCodec: int s\u003e\n  $i12 \u003d 1 \u003c\u003c $i11\n  i13 \u003d $i12 - 1\n  $l14 \u003d (long) i13\n  $l16 \u003d $l24 \u0026 $l14\n  $l15 \u003d (long) i13\n  $b17 \u003d $l16 cmp $l15\n  if ($b17 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $i20 \u003d BHSDCodec: int s\u003e\n  $l21 \u003d $l24 \u003e\u003e\u003e $i20\n  l26 \u003d $l21 ^ -1L\n  goto B9\n}",
      "B8 {\n  $i18 \u003d BHSDCodec: int s\u003e\n  $l19 \u003d $l24 \u003e\u003e\u003e $i18\n  l26 \u003d $l24 - $l19\n}",
      "B9 {\n  $z1 \u003d r1.isDelta()\n  if ($z1 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  l26 \u003d l26 + l10\n}",
      "B11 {\n  $i9 \u003d (int) l26\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BHSDCodec#isDelta(...0)",
        "body": "{\r\n    return d !\u003d 0;\r\n}"
      },
      {
        "name": "BHSDCodec#isSigned(...0)",
        "body": "{\r\n    return s !\u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "decodeInts",
    "signature": "int[] decodeInts(int,java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final int[] band \u003d super.decodeInts(n, in);\r\n    if (isDelta()) {\r\n        for (int i \u003d 0; i \u003c band.length; i++) {\r\n            while (band[i] \u003e largest) {\r\n                band[i] -\u003d cardinality;\r\n            }\r\n            while (band[i] \u003c smallest) {\r\n                band[i] \u003d ExactMath.add(band[i], cardinality);\r\n            }\r\n        }\r\n    }\r\n    return band;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B2 : If(i18 \u003e\u003d $i1) → B3 | else → B8",
      "B3 : If($i19 \u003c\u003d 0) → B4 | else → B5",
      "B5 : If($i20 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  i0 :\u003d @parameter0: int\n  InputStream\n  r2 \u003d r0.decodeInts(i0, r1)\n  $z0 \u003d r0.isDelta()\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  i18 \u003d 0\n}",
      "B2 {\n  $i1 \u003d lengthof r2\n  if (i18 \u003e\u003d $i1) goto B3 else B8\n}",
      "B3 {\n  $i2 \u003d r2[i18]\n  $l4 \u003d (long) $i2\n  $l3 \u003d BHSDCodec: long largest\u003e\n  $b5 \u003d $l4 cmp $l3\n  $i19 \u003d (int) $b5\n  if ($i19 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i13 \u003d r2[i18]\n  $l15 \u003d (long) $i13\n  $l14 \u003d BHSDCodec: long cardinality\u003e\n  $l16 \u003d $l15 - $l14\n  $i17 \u003d (int) $l16\n  r2[i18] \u003d $i17\n  goto B3\n}",
      "B5 {\n  $i6 \u003d r2[i18]\n  $l8 \u003d (long) $i6\n  $l7 \u003d BHSDCodec: long smallest\u003e\n  $b9 \u003d $l8 cmp $l7\n  $i20 \u003d (int) $b9\n  if ($i20 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $i11 \u003d r2[i18]\n  $l10 \u003d BHSDCodec: long cardinality\u003e\n  $i12 \u003d ExactMath.add($i11, $l10)\n  r2[i18] \u003d $i12\n  goto B5\n}",
      "B7 {\n  i18 \u003d i18 + 1\n  goto B2\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B2",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BHSDCodec#isDelta(...0)",
        "body": "{\r\n    return d !\u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "decodeInts",
    "signature": "int[] decodeInts(int,java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    final int[] band \u003d super.decodeInts(n, in, firstValue);\r\n    if (isDelta()) {\r\n        for (int i \u003d 0; i \u003c band.length; i++) {\r\n            while (band[i] \u003e largest) {\r\n                band[i] -\u003d cardinality;\r\n            }\r\n            while (band[i] \u003c smallest) {\r\n                band[i] \u003d ExactMath.add(band[i], cardinality);\r\n            }\r\n        }\r\n    }\r\n    return band;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B2 : If(i19 \u003e\u003d $i2) → B3 | else → B8",
      "B3 : If($i20 \u003c\u003d 0) → B4 | else → B5",
      "B5 : If($i21 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  i0 :\u003d @parameter0: int\n  InputStream\n  i1 :\u003d @parameter2: int\n  r2 \u003d r0.decodeInts(i0, r1, i1)\n  $z0 \u003d r0.isDelta()\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  i19 \u003d 0\n}",
      "B2 {\n  $i2 \u003d lengthof r2\n  if (i19 \u003e\u003d $i2) goto B3 else B8\n}",
      "B3 {\n  $i3 \u003d r2[i19]\n  $l5 \u003d (long) $i3\n  $l4 \u003d BHSDCodec: long largest\u003e\n  $b6 \u003d $l5 cmp $l4\n  $i20 \u003d (int) $b6\n  if ($i20 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i14 \u003d r2[i19]\n  $l16 \u003d (long) $i14\n  $l15 \u003d BHSDCodec: long cardinality\u003e\n  $l17 \u003d $l16 - $l15\n  $i18 \u003d (int) $l17\n  r2[i19] \u003d $i18\n  goto B3\n}",
      "B5 {\n  $i7 \u003d r2[i19]\n  $l9 \u003d (long) $i7\n  $l8 \u003d BHSDCodec: long smallest\u003e\n  $b10 \u003d $l9 cmp $l8\n  $i21 \u003d (int) $b10\n  if ($i21 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $i12 \u003d r2[i19]\n  $l11 \u003d BHSDCodec: long cardinality\u003e\n  $i13 \u003d ExactMath.add($i12, $l11)\n  r2[i19] \u003d $i13\n  goto B5\n}",
      "B7 {\n  i19 \u003d i19 + 1\n  goto B2\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B2",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BHSDCodec#isDelta(...0)",
        "body": "{\r\n    return d !\u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "encode",
    "signature": "byte[] encode(int,int)",
    "visibility": "public",
    "body": "{\r\n    if (!encodes(value)) {\r\n        throw new Pack200Exception(\"The codec \" + this + \" does not encode the value \" + value);\r\n    }\r\n    long z \u003d value;\r\n    if (isDelta()) {\r\n        z -\u003d last;\r\n    }\r\n    if (isSigned()) {\r\n        if (z \u003c Integer.MIN_VALUE) {\r\n            z +\u003d 4294967296L;\r\n        } else if (z \u003e Integer.MAX_VALUE) {\r\n            z -\u003d 4294967296L;\r\n        }\r\n        if (z \u003c 0) {\r\n            z \u003d (-z \u003c\u003c s) - 1;\r\n        } else if (s \u003d\u003d 1) {\r\n            z \u003d z \u003c\u003c s;\r\n        } else {\r\n            z +\u003d (z - z % 3) / 3;\r\n        }\r\n    } else if (z \u003c 0) {\r\n        // Need to use integer overflow here to represent negatives.\r\n        // 4294967296L is the 1 \u003c\u003c 32.\r\n        z +\u003d Math.min(cardinality, 4294967296L);\r\n    }\r\n    if (z \u003c 0) {\r\n        throw new Pack200Exception(\"unable to encode\");\r\n    }\r\n    final List\u003cByte\u003e byteList \u003d new ArrayList\u003c\u003e();\r\n    for (int n \u003d 0; n \u003c b; n++) {\r\n        long byteN;\r\n        if (z \u003c l) {\r\n            byteN \u003d z;\r\n        } else {\r\n            byteN \u003d z % h;\r\n            while (byteN \u003c l) {\r\n                byteN +\u003d h;\r\n            }\r\n        }\r\n        byteList.add(Byte.valueOf((byte) byteN));\r\n        if (byteN \u003c l) {\r\n            break;\r\n        }\r\n        z -\u003d byteN;\r\n        z /\u003d h;\r\n    }\r\n    final byte[] bytes \u003d new byte[byteList.size()];\r\n    for (int i \u003d 0; i \u003c bytes.length; i++) {\r\n        bytes[i] \u003d byteList.get(i).byteValue();\r\n    }\r\n    return bytes;\r\n}",
    "nodes": 32,
    "edges": 43,
    "cc": 13,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B14",
      "B5 : If($i45 \u003e\u003d 0) → B6 | else → B7",
      "B7 : If($i46 \u003c\u003d 0) → B8 | else → B9",
      "B9 : If($i47 \u003e\u003d 0) → B10 | else → B11",
      "B11 : If($i27 !\u003d 1) → B12 | else → B13",
      "B14 : If($i48 \u003e\u003d 0) → B15 | else → B16",
      "B16 : If($i49 \u003e\u003d 0) → B17 | else → B18",
      "B19 : If(i40 \u003e\u003d $i3) → B20 | else → B28",
      "B20 : If($i50 \u003e\u003d 0) → B21 | else → B22",
      "B23 : If($i51 \u003e\u003d 0) → B24 | else → B25",
      "B25 : If($i52 \u003e\u003d 0) → B26 | else → B27",
      "B29 : If(i43 \u003e\u003d $i44) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  i0 :\u003d @parameter0: int\n  i35 :\u003d @parameter1: int\n  $l1 \u003d (long) i0\n  $z0 \u003d r0.encodes($l1)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d Pack200Exception\n  $r14 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r14.append(\"The codec \")\n  $r10 \u003d $r9.append(r0)\n  $r11 \u003d $r10.append(\" does not encode the value \")\n  $r12 \u003d $r11.append(i0)\n  $r13 \u003d $r12.toString()\n  new Pack200Exception($r13)\n  throw $r15\n}",
      "B2 {\n  l37 \u003d (long) i0\n  $z1 \u003d r0.isDelta()\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $l36 \u003d (long) i35\n  l37 \u003d l37 - $l36\n}",
      "B4 {\n  $z2 \u003d r0.isSigned()\n  if ($z2 \u003d\u003d false) goto B5 else B14\n}",
      "B5 {\n  $b25 \u003d l37 cmp -2147483648L\n  $i45 \u003d (int) $b25\n  if ($i45 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  l37 \u003d l37 + 4294967296L\n  goto B9\n}",
      "B7 {\n  $b26 \u003d l37 cmp 2147483647L\n  $i46 \u003d (int) $b26\n  if ($i46 \u003c\u003d 0) goto B8 else B9\n}",
      "B8 {\n  l37 \u003d l37 - 4294967296L\n}",
      "B9 {\n  $b38 \u003d l37 cmp 0L\n  $i47 \u003d (int) $b38\n  if ($i47 \u003e\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $l33 \u003d neg l37\n  $i32 \u003d BHSDCodec: int s\u003e\n  $l34 \u003d $l33 \u003c\u003c $i32\n  l37 \u003d $l34 - 1L\n  goto B16\n}",
      "B11 {\n  $i27 \u003d BHSDCodec: int s\u003e\n  if ($i27 !\u003d 1) goto B12 else B13\n}",
      "B12 {\n  $i31 \u003d BHSDCodec: int s\u003e\n  l37 \u003d l37 \u003c\u003c $i31\n  goto B16\n}",
      "B13 {\n  $l28 \u003d l37 % 3L\n  $l29 \u003d l37 - $l28\n  $l30 \u003d $l29 / 3L\n  l37 \u003d l37 + $l30\n  goto B16\n}",
      "B14 {\n  $b2 \u003d l37 cmp 0L\n  $i48 \u003d (int) $b2\n  if ($i48 \u003e\u003d 0) goto B15 else B16\n}",
      "B15 {\n  $l23 \u003d BHSDCodec: long cardinality\u003e\n  $l24 \u003d Math.min($l23, 4294967296L)\n  l37 \u003d l37 + $l24\n}",
      "B16 {\n  $b39 \u003d l37 cmp 0L\n  $i49 \u003d (int) $b39\n  if ($i49 \u003e\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r16 \u003d Pack200Exception\n  new Pack200Exception(\"unable to encode\")\n  throw $r16\n}",
      "B18 {\n  $r17 \u003d ArrayList\n  new ArrayList()\n  i40 \u003d 0\n}",
      "B19 {\n  $i3 \u003d BHSDCodec: int b\u003e\n  if (i40 \u003e\u003d $i3) goto B20 else B28\n}",
      "B20 {\n  $i6 \u003d BHSDCodec: int l\u003e\n  $l7 \u003d (long) $i6\n  $b8 \u003d l37 cmp $l7\n  $i50 \u003d (int) $b8\n  if ($i50 \u003e\u003d 0) goto B21 else B22\n}",
      "B21 {\n  l41 \u003d l37\n  goto B25\n}",
      "B22 {\n  $i9 \u003d BHSDCodec: int h\u003e\n  $l10 \u003d (long) $i9\n  l41 \u003d l37 % $l10\n}",
      "B23 {\n  $i11 \u003d BHSDCodec: int l\u003e\n  $l12 \u003d (long) $i11\n  $b13 \u003d l41 cmp $l12\n  $i51 \u003d (int) $b13\n  if ($i51 \u003e\u003d 0) goto B24 else B25\n}",
      "B24 {\n  $i21 \u003d BHSDCodec: int h\u003e\n  $l22 \u003d (long) $i21\n  l41 \u003d l41 + $l22\n  goto B23\n}",
      "B25 {\n  $i14 \u003d (int) l41\n  $b15 \u003d (byte) $i14\n  $r4 \u003d Byte.valueOf($b15)\n  $r17.add($r4)\n  $i16 \u003d BHSDCodec: int l\u003e\n  $l17 \u003d (long) $i16\n  $b18 \u003d l41 cmp $l17\n  $i52 \u003d (int) $b18\n  if ($i52 \u003e\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B28\n}",
      "B27 {\n  l42 \u003d l37 - l41\n  $i19 \u003d BHSDCodec: int h\u003e\n  $l20 \u003d (long) $i19\n  l37 \u003d l42 / $l20\n  i40 \u003d i40 + 1\n  goto B19\n}",
      "B28 {\n  $i4 \u003d $r17.size()\n  $r5 \u003d newarray (byte)[$i4]\n  i43 \u003d 0\n}",
      "B29 {\n  $i44 \u003d lengthof $r5\n  if (i43 \u003e\u003d $i44) goto B30 else B31\n}",
      "B30 {\n  $r2 \u003d $r17.get(i43)\n  $r3 \u003d Byte) $r2\n  $b5 \u003d $r3.byteValue()\n  $r5[i43] \u003d $b5\n  i43 \u003d i43 + 1\n  goto B29\n}",
      "B31 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B14",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B25",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B23",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B19",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B29",
      "B31 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BHSDCodec#isDelta(...0)",
        "body": "{\r\n    return d !\u003d 0;\r\n}"
      },
      {
        "name": "BHSDCodec#isSigned(...0)",
        "body": "{\r\n    return s !\u003d 0;\r\n}"
      },
      {
        "name": "BHSDCodec#encodes(...1)",
        "body": "{\r\n    return value \u003e\u003d smallest \u0026\u0026 value \u003c\u003d largest;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "encodes",
    "signature": "boolean encodes(long)",
    "visibility": "public",
    "body": "{\r\n    return value \u003e\u003d smallest \u0026\u0026 value \u003c\u003d largest;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i5 \u003c 0) → B1 | else → B3",
      "B1 : If($i6 \u003e 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  l0 :\u003d @parameter0: long\n  $l1 \u003d BHSDCodec: long smallest\u003e\n  $b2 \u003d l0 cmp $l1\n  $i5 \u003d (int) $b2\n  if ($i5 \u003c 0) goto B1 else B3\n}",
      "B1 {\n  $l3 \u003d BHSDCodec: long largest\u003e\n  $b4 \u003d l0 cmp $l3\n  $i6 \u003d (int) $b4\n  if ($i6 \u003e 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o instanceof BHSDCodec) {\r\n        final BHSDCodec codec \u003d (BHSDCodec) o;\r\n        return codec.b \u003d\u003d b \u0026\u0026 codec.h \u003d\u003d h \u0026\u0026 codec.s \u003d\u003d s \u0026\u0026 codec.d \u003d\u003d d;\r\n    }\r\n    return false;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B1 : If($i1 !\u003d $i0) → B2 | else → B6",
      "B2 : If($i3 !\u003d $i2) → B3 | else → B6",
      "B3 : If($i5 !\u003d $i4) → B4 | else → B6",
      "B4 : If($i7 !\u003d $i6) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  Object\n  $z0 \u003d BHSDCodec\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  r1 \u003d BHSDCodec) r0\n  $i1 \u003d BHSDCodec: int b\u003e\n  $i0 \u003d BHSDCodec: int b\u003e\n  if ($i1 !\u003d $i0) goto B2 else B6\n}",
      "B2 {\n  $i3 \u003d BHSDCodec: int h\u003e\n  $i2 \u003d BHSDCodec: int h\u003e\n  if ($i3 !\u003d $i2) goto B3 else B6\n}",
      "B3 {\n  $i5 \u003d BHSDCodec: int s\u003e\n  $i4 \u003d BHSDCodec: int s\u003e\n  if ($i5 !\u003d $i4) goto B4 else B6\n}",
      "B4 {\n  $i7 \u003d BHSDCodec: int d\u003e\n  $i6 \u003d BHSDCodec: int d\u003e\n  if ($i7 !\u003d $i6) goto B5 else B6\n}",
      "B5 {\n  $z1 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z1 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "isDelta",
    "signature": "boolean isDelta()",
    "visibility": "public",
    "body": "{\r\n    return d !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  $i0 \u003d BHSDCodec: int d\u003e\n  if ($i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "isSigned",
    "signature": "boolean isSigned()",
    "visibility": "public",
    "body": "{\r\n    return s !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  $i0 \u003d BHSDCodec: int s\u003e\n  if ($i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.BHSDCodec",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    final StringBuilder buffer \u003d new StringBuilder(11);\r\n    buffer.append(\u0027(\u0027);\r\n    buffer.append(b);\r\n    buffer.append(\u0027,\u0027);\r\n    buffer.append(h);\r\n    if (s !\u003d 0 || d !\u003d 0) {\r\n        buffer.append(\u0027,\u0027);\r\n        buffer.append(s);\r\n    }\r\n    if (d !\u003d 0) {\r\n        buffer.append(\u0027,\u0027);\r\n        buffer.append(d);\r\n    }\r\n    buffer.append(\u0027)\u0027);\r\n    return buffer.toString();\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i2 !\u003d 0) → B1 | else → B2",
      "B1 : If($i5 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($i6 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  BHSDCodec\n  $r0 \u003d StringBuilder\n  new StringBuilder(11)\n  $r0.append(40)\n  $i0 \u003d BHSDCodec: int b\u003e\n  $r0.append($i0)\n  $r0.append(44)\n  $i1 \u003d BHSDCodec: int h\u003e\n  $r0.append($i1)\n  $i2 \u003d BHSDCodec: int s\u003e\n  if ($i2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i5 \u003d BHSDCodec: int d\u003e\n  if ($i5 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r0.append(44)\n  $i3 \u003d BHSDCodec: int s\u003e\n  $r0.append($i3)\n}",
      "B3 {\n  $i6 \u003d BHSDCodec: int d\u003e\n  if ($i6 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r0.append(44)\n  $i4 \u003d BHSDCodec: int d\u003e\n  $r0.append($i4)\n}",
      "B5 {\n  $r0.append(41)\n  $r2 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addAnnotation",
    "signature": "void addAnnotation(int,java.lang.String,boolean,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    switch(context) {\r\n        case MetadataBandGroup.CONTEXT_CLASS:\r\n            if (visible) {\r\n                class_RVA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                if ((class_flags[index] \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n                    class_RVA_bands.incrementAnnoN();\r\n                } else {\r\n                    class_RVA_bands.newEntryInAnnoN();\r\n                    class_flags[index] \u003d class_flags[index] | 1 \u003c\u003c 21;\r\n                }\r\n            } else {\r\n                class_RIA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                if ((class_flags[index] \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n                    class_RIA_bands.incrementAnnoN();\r\n                } else {\r\n                    class_RIA_bands.newEntryInAnnoN();\r\n                    class_flags[index] \u003d class_flags[index] | 1 \u003c\u003c 22;\r\n                }\r\n            }\r\n            break;\r\n        case MetadataBandGroup.CONTEXT_FIELD:\r\n            if (visible) {\r\n                field_RVA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                final Long flag \u003d tempFieldFlags.remove(tempFieldFlags.size() - 1);\r\n                if ((flag.intValue() \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n                    field_RVA_bands.incrementAnnoN();\r\n                } else {\r\n                    field_RVA_bands.newEntryInAnnoN();\r\n                }\r\n                tempFieldFlags.add(Long.valueOf(flag.intValue() | 1 \u003c\u003c 21));\r\n            } else {\r\n                field_RIA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                final Long flag \u003d tempFieldFlags.remove(tempFieldFlags.size() - 1);\r\n                if ((flag.intValue() \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n                    field_RIA_bands.incrementAnnoN();\r\n                } else {\r\n                    field_RIA_bands.newEntryInAnnoN();\r\n                }\r\n                tempFieldFlags.add(Long.valueOf(flag.intValue() | 1 \u003c\u003c 22));\r\n            }\r\n            break;\r\n        case MetadataBandGroup.CONTEXT_METHOD:\r\n            if (visible) {\r\n                method_RVA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                final Long flag \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n                if ((flag.intValue() \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n                    method_RVA_bands.incrementAnnoN();\r\n                } else {\r\n                    method_RVA_bands.newEntryInAnnoN();\r\n                }\r\n                tempMethodFlags.add(Long.valueOf(flag.intValue() | 1 \u003c\u003c 21));\r\n            } else {\r\n                method_RIA_bands.addAnnotation(desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n                final Long flag \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n                if ((flag.intValue() \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n                    method_RIA_bands.incrementAnnoN();\r\n                } else {\r\n                    method_RIA_bands.newEntryInAnnoN();\r\n                }\r\n                tempMethodFlags.add(Long.valueOf(flag.intValue() | 1 \u003c\u003c 22));\r\n            }\r\n            break;\r\n    }\r\n}",
    "nodes": 27,
    "edges": 38,
    "cc": 13,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B8",
      "B1 : If(z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($b40 \u003d\u003d false) → B3 | else → B4",
      "B5 : If($b32 \u003d\u003d false) → B6 | else → B7",
      "B8 : If(z0 \u003d\u003d false) → B9 | else → B13",
      "B9 : If($i25 \u003d\u003d false) → B10 | else → B11",
      "B13 : If($i18 \u003d\u003d false) → B14 | else → B15",
      "B17 : If(z0 \u003d\u003d false) → B18 | else → B22",
      "B18 : If($i11 \u003d\u003d false) → B19 | else → B20",
      "B22 : If($i4 \u003d\u003d false) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i0 :\u003d @parameter0: int\n  String\n  z0 :\u003d @parameter2: boolean\n  List\n  List\n  List\n  List\n  List\n  List\n  List\n  MetadataBandGroup method_RIA_bands\u003e;     default: goto return; }\n}",
      "B1 {\n  if (z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r47 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $r47.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r48 \u003d ClassBands: long[] class_flags\u003e\n  $i37 \u003d ClassBands: int index\u003e\n  $l38 \u003d $r48[$i37]\n  $l39 \u003d $l38 \u0026 2097152L\n  $b40 \u003d $l39 cmp 0L\n  if ($b40 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r52 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $r52.incrementAnnoN()\n  goto B26\n}",
      "B4 {\n  $r49 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $r49.newEntryInAnnoN()\n  $r51 \u003d ClassBands: long[] class_flags\u003e\n  $i44 \u003d ClassBands: int index\u003e\n  $r50 \u003d ClassBands: long[] class_flags\u003e\n  $i41 \u003d ClassBands: int index\u003e\n  $l42 \u003d $r50[$i41]\n  $l43 \u003d $l42 | 2097152L\n  $r51[$i44] \u003d $l43\n  goto B26\n}",
      "B5 {\n  $r41 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $r41.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r42 \u003d ClassBands: long[] class_flags\u003e\n  $i29 \u003d ClassBands: int index\u003e\n  $l30 \u003d $r42[$i29]\n  $l31 \u003d $l30 \u0026 4194304L\n  $b32 \u003d $l31 cmp 0L\n  if ($b32 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r46 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $r46.incrementAnnoN()\n  goto B26\n}",
      "B7 {\n  $r43 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $r43.newEntryInAnnoN()\n  $r45 \u003d ClassBands: long[] class_flags\u003e\n  $i36 \u003d ClassBands: int index\u003e\n  $r44 \u003d ClassBands: long[] class_flags\u003e\n  $i33 \u003d ClassBands: int index\u003e\n  $l34 \u003d $r44[$i33]\n  $l35 \u003d $l34 | 4194304L\n  $r45[$i36] \u003d $l35\n  goto B26\n}",
      "B8 {\n  if (z0 \u003d\u003d false) goto B9 else B13\n}",
      "B9 {\n  $r33 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $r33.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r35 \u003d List tempFieldFlags\u003e\n  $r34 \u003d List tempFieldFlags\u003e\n  $i22 \u003d $r34.size()\n  $i23 \u003d $i22 - 1\n  $r36 \u003d $r35.remove($i23)\n  r53 \u003d Long) $r36\n  $i24 \u003d r53.intValue()\n  $i25 \u003d $i24 \u0026 2097152\n  if ($i25 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r40 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $r40.incrementAnnoN()\n  goto B12\n}",
      "B11 {\n  $r37 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $r37.newEntryInAnnoN()\n}",
      "B12 {\n  $r38 \u003d List tempFieldFlags\u003e\n  $i26 \u003d r53.intValue()\n  $i27 \u003d $i26 | 2097152\n  $l28 \u003d (long) $i27\n  $r39 \u003d Long.valueOf($l28)\n  $r38.add($r39)\n  goto B26\n}",
      "B13 {\n  $r25 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $r25.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r27 \u003d List tempFieldFlags\u003e\n  $r26 \u003d List tempFieldFlags\u003e\n  $i15 \u003d $r26.size()\n  $i16 \u003d $i15 - 1\n  $r28 \u003d $r27.remove($i16)\n  r54 \u003d Long) $r28\n  $i17 \u003d r54.intValue()\n  $i18 \u003d $i17 \u0026 4194304\n  if ($i18 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r32 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $r32.incrementAnnoN()\n  goto B16\n}",
      "B15 {\n  $r29 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $r29.newEntryInAnnoN()\n}",
      "B16 {\n  $r30 \u003d List tempFieldFlags\u003e\n  $i19 \u003d r54.intValue()\n  $i20 \u003d $i19 | 4194304\n  $l21 \u003d (long) $i20\n  $r31 \u003d Long.valueOf($l21)\n  $r30.add($r31)\n  goto B26\n}",
      "B17 {\n  if (z0 \u003d\u003d false) goto B18 else B22\n}",
      "B18 {\n  $r17 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $r17.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r19 \u003d List tempMethodFlags\u003e\n  $r18 \u003d List tempMethodFlags\u003e\n  $i8 \u003d $r18.size()\n  $i9 \u003d $i8 - 1\n  $r20 \u003d $r19.remove($i9)\n  r55 \u003d Long) $r20\n  $i10 \u003d r55.intValue()\n  $i11 \u003d $i10 \u0026 2097152\n  if ($i11 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r24 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $r24.incrementAnnoN()\n  goto B21\n}",
      "B20 {\n  $r21 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $r21.newEntryInAnnoN()\n}",
      "B21 {\n  $r22 \u003d List tempMethodFlags\u003e\n  $i12 \u003d r55.intValue()\n  $i13 \u003d $i12 | 2097152\n  $l14 \u003d (long) $i13\n  $r23 \u003d Long.valueOf($l14)\n  $r22.add($r23)\n  goto B26\n}",
      "B22 {\n  $r9 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $r9.addAnnotation(r1, r2, r3, r4, r5, r6, r7, r8)\n  $r11 \u003d List tempMethodFlags\u003e\n  $r10 \u003d List tempMethodFlags\u003e\n  $i1 \u003d $r10.size()\n  $i2 \u003d $i1 - 1\n  $r12 \u003d $r11.remove($i2)\n  r56 \u003d Long) $r12\n  $i3 \u003d r56.intValue()\n  $i4 \u003d $i3 \u0026 4194304\n  if ($i4 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r16 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $r16.incrementAnnoN()\n  goto B25\n}",
      "B24 {\n  $r13 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $r13.newEntryInAnnoN()\n}",
      "B25 {\n  $r14 \u003d List tempMethodFlags\u003e\n  $i5 \u003d r56.intValue()\n  $i6 \u003d $i5 | 4194304\n  $l7 \u003d (long) $i6\n  $r15 \u003d Long.valueOf($l7)\n  $r14.add($r15)\n}",
      "B26 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B0 --\u003e B17",
      "B0 --\u003e B26",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B26",
      "B4 --\u003e B26",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B26",
      "B7 --\u003e B26",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B26",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B26",
      "B17 --\u003e B18",
      "B17 --\u003e B22",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B26",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addClass",
    "signature": "void addClass(int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    class_this[index] \u003d cpBands.getCPClass(className);\r\n    class_super[index] \u003d cpBands.getCPClass(superName);\r\n    class_interface_count[index] \u003d interfaces.length;\r\n    class_interface[index] \u003d new CPClass[interfaces.length];\r\n    Arrays.setAll(class_interface[index], i -\u003e cpBands.getCPClass(interfaces[i]));\r\n    major_versions[index] \u003d major;\r\n    class_flags[index] \u003d flags;\r\n    if (!anySyntheticClasses \u0026\u0026 (flags \u0026 1 \u003c\u003c 12) !\u003d 0 \u0026\u0026 segment.getCurrentClassReader().hasSyntheticAttributes()) {\r\n        cpBands.addCPUtf8(\"Synthetic\");\r\n        anySyntheticClasses \u003d true;\r\n    }\r\n    //        if ((flags \u0026 Opcodes.ACC_DEPRECATED) !\u003d 0) { // ASM uses (1\u003c\u003c17) flag for deprecated\r\n    //            flags \u0026\u003d ~Opcodes.ACC_DEPRECATED;\r\n    //            flags |\u003d (1 \u003c\u003c 20);\r\n    //        }\r\n    if (signature !\u003d null) {\r\n        class_flags[index] |\u003d 1 \u003c\u003c 19;\r\n        classSignature.add(cpBands.getCPSignature(signature));\r\n    }\r\n}",
    "nodes": 7,
    "edges": 10,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($i15 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(r18 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i7 :\u003d @parameter0: int\n  i9 :\u003d @parameter1: int\n  String\n  String\n  String\n  String[]\n  $r3 \u003d CPClass[] class_this\u003e\n  $i0 \u003d ClassBands: int index\u003e\n  $r2 \u003d CpBands cpBands\u003e\n  $r4 \u003d $r2.getCPClass(r1)\n  $r3[$i0] \u003d $r4\n  $r7 \u003d CPClass[] class_super\u003e\n  $i1 \u003d ClassBands: int index\u003e\n  $r6 \u003d CpBands cpBands\u003e\n  $r8 \u003d $r6.getCPClass(r5)\n  $r7[$i1] \u003d $r8\n  $r10 \u003d ClassBands: int[] class_interface_count\u003e\n  $i3 \u003d ClassBands: int index\u003e\n  $i2 \u003d lengthof r9\n  $r10[$i3] \u003d $i2\n  $r12 \u003d CPClass[][] class_interface\u003e\n  $i5 \u003d ClassBands: int index\u003e\n  $i4 \u003d lengthof r9\n  $r11 \u003d CPClass)[$i4]\n  $r12[$i5] \u003d $r11\n  $r13 \u003d CPClass[][] class_interface\u003e\n  $i6 \u003d ClassBands: int index\u003e\n  $r14 \u003d $r13[$i6]\n  $r15 \u003d ClassBands$lambda_addClass_0__30.bootstrap$(r0, r9)\n  Arrays.setAll($r14, $r15)\n  $r16 \u003d ClassBands: int[] major_versions\u003e\n  $i8 \u003d ClassBands: int index\u003e\n  $r16[$i8] \u003d i7\n  $r17 \u003d ClassBands: long[] class_flags\u003e\n  $i11 \u003d ClassBands: int index\u003e\n  $l10 \u003d (long) i9\n  $r17[$i11] \u003d $l10\n  $z0 \u003d ClassBands: boolean anySyntheticClasses\u003e\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $i15 \u003d i9 \u0026 4096\n  if ($i15 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r23 \u003d Segment segment\u003e\n  $r24 \u003d $r23.getCurrentClassReader()\n  $z1 \u003d $r24.hasSyntheticAttributes()\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r25 \u003d CpBands cpBands\u003e\n  $r25.addCPUtf8(\"Synthetic\")\n  ClassBands: boolean anySyntheticClasses\u003e \u003d 1\n}",
      "B4 {\n  if (r18 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r19 \u003d ClassBands: long[] class_flags\u003e\n  $i12 \u003d ClassBands: int index\u003e\n  $l13 \u003d $r19[$i12]\n  $l14 \u003d $l13 | 524288L\n  $r19[$i12] \u003d $l14\n  $r21 \u003d List classSignature\u003e\n  $r20 \u003d CpBands cpBands\u003e\n  $r22 \u003d $r20.getCPSignature(r18)\n  $r21.add($r22)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addClassAttribute",
    "signature": "void addClassAttribute(org.apache.commons.compress.harmony.pack200.NewAttribute)",
    "visibility": "public",
    "body": "{\r\n    // TODO: backwards calls\r\n    final String attributeName \u003d attribute.type;\r\n    for (final NewAttributeBands bands : classAttributeBands) {\r\n        if (bands.getAttributeName().equals(attributeName)) {\r\n            bands.addAttribute(attribute);\r\n            final int flagIndex \u003d bands.getFlagIndex();\r\n            class_flags[index] |\u003d 1 \u003c\u003c flagIndex;\r\n            return;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No suitable definition for \" + attributeName);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  NewAttribute\n  r1 \u003d String type\u003e\n  $r3 \u003d List classAttributeBands\u003e\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r10 \u003d r4.next()\n  r11 \u003d NewAttributeBands) $r10\n  $r12 \u003d r11.getAttributeName()\n  $z1 \u003d $r12.equals(r1)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r11.addAttribute(r0)\n  i0 \u003d r11.getFlagIndex()\n  $r13 \u003d ClassBands: long[] class_flags\u003e\n  $i1 \u003d ClassBands: int index\u003e\n  $l4 \u003d $r13[$i1]\n  $i2 \u003d 1 \u003c\u003c i0\n  $l3 \u003d (long) $i2\n  $l5 \u003d $l4 | $l3\n  $r13[$i1] \u003d $l5\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"No suitable definition for \")\n  $r8 \u003d $r7.append(r1)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addCode",
    "signature": "void addCode()",
    "visibility": "public",
    "body": "{\r\n    codeHandlerCount.add(0);\r\n    if (!stripDebug) {\r\n        codeFlags.add(Long.valueOf(1 \u003c\u003c 2));\r\n        codeLocalVariableTableN.add(0);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d IntList codeHandlerCount\u003e\n  $r1.add(0)\n  $z0 \u003d ClassBands: boolean stripDebug\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d List codeFlags\u003e\n  $r3 \u003d Long.valueOf(4L)\n  $r2.add($r3)\n  $r4 \u003d IntList codeLocalVariableTableN\u003e\n  $r4.add(0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addCodeAttribute",
    "signature": "void addCodeAttribute(org.apache.commons.compress.harmony.pack200.NewAttribute)",
    "visibility": "public",
    "body": "{\r\n    final String attributeName \u003d attribute.type;\r\n    for (final NewAttributeBands bands : codeAttributeBands) {\r\n        if (bands.getAttributeName().equals(attributeName)) {\r\n            bands.addAttribute(attribute);\r\n            final int flagIndex \u003d bands.getFlagIndex();\r\n            final Long flags \u003d codeFlags.remove(codeFlags.size() - 1);\r\n            codeFlags.add(Long.valueOf(flags.longValue() | 1 \u003c\u003c flagIndex));\r\n            return;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No suitable definition for \" + attributeName);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  NewAttribute\n  r1 \u003d String type\u003e\n  $r3 \u003d List codeAttributeBands\u003e\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r10 \u003d r4.next()\n  r11 \u003d NewAttributeBands) $r10\n  $r12 \u003d r11.getAttributeName()\n  $z1 \u003d $r12.equals(r1)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r11.addAttribute(r0)\n  i0 \u003d r11.getFlagIndex()\n  $r14 \u003d List codeFlags\u003e\n  $r13 \u003d List codeFlags\u003e\n  $i1 \u003d $r13.size()\n  $i2 \u003d $i1 - 1\n  $r15 \u003d $r14.remove($i2)\n  r16 \u003d Long) $r15\n  $r17 \u003d List codeFlags\u003e\n  $l5 \u003d r16.longValue()\n  $i3 \u003d 1 \u003c\u003c i0\n  $l4 \u003d (long) $i3\n  $l6 \u003d $l5 | $l4\n  $r18 \u003d Long.valueOf($l6)\n  $r17.add($r18)\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"No suitable definition for \")\n  $r8 \u003d $r7.append(r1)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addEnclosingMethod",
    "signature": "void addEnclosingMethod(java.lang.String,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    class_flags[index] |\u003d 1 \u003c\u003c 18;\r\n    classEnclosingMethodClass.add(cpBands.getCPClass(ownerClassName));\r\n    classEnclosingMethodDesc.add(name \u003d\u003d null ? null : cpBands.getCPNameAndType(name, signature));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  String\n  String\n  String\n  $r1 \u003d ClassBands: long[] class_flags\u003e\n  $i0 \u003d ClassBands: int index\u003e\n  $l1 \u003d $r1[$i0]\n  $l2 \u003d $l1 | 262144L\n  $r1[$i0] \u003d $l2\n  $r4 \u003d List classEnclosingMethodClass\u003e\n  $r3 \u003d CpBands cpBands\u003e\n  $r5 \u003d $r3.getCPClass(r2)\n  $r4.add($r5)\n  $r9 \u003d List classEnclosingMethodDesc\u003e\n  if (r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d null\n  goto B3\n}",
      "B2 {\n  $r8 \u003d CpBands cpBands\u003e\n  $r10 \u003d $r8.getCPNameAndType(r6, r7)\n}",
      "B3 {\n  $r9.add($r10)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addField",
    "signature": "void addField(int,java.lang.String,java.lang.String,java.lang.String,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    flags \u0026\u003d 0xFFFF;\r\n    tempFieldDesc.add(cpBands.getCPNameAndType(name, desc));\r\n    if (signature !\u003d null) {\r\n        fieldSignature.add(cpBands.getCPSignature(signature));\r\n        flags |\u003d 1 \u003c\u003c 19;\r\n    }\r\n    if ((flags \u0026 Opcodes.ACC_DEPRECATED) !\u003d 0) {\r\n        // ASM uses (1\u003c\u003c17) flag for deprecated\r\n        flags \u0026\u003d ~Opcodes.ACC_DEPRECATED;\r\n        flags |\u003d 1 \u003c\u003c 20;\r\n    }\r\n    if (value !\u003d null) {\r\n        fieldConstantValueKQ.add(cpBands.getConstant(value));\r\n        flags |\u003d 1 \u003c\u003c 17;\r\n    }\r\n    if (!anySyntheticFields \u0026\u0026 (flags \u0026 1 \u003c\u003c 12) !\u003d 0 \u0026\u0026 segment.getCurrentClassReader().hasSyntheticAttributes()) {\r\n        cpBands.addCPUtf8(\"Synthetic\");\r\n        anySyntheticFields \u003d true;\r\n    }\r\n    tempFieldFlags.add(Long.valueOf(flags));\r\n}",
    "nodes": 11,
    "edges": 16,
    "cc": 7,
    "flowSummary": [
      "B0 : If(r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(r7 \u003d\u003d null) → B5 | else → B6",
      "B6 : If($z0 !\u003d 0) → B7 | else → B10",
      "B7 : If($i1 \u003d\u003d false) → B8 | else → B10",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i2 :\u003d @parameter0: int\n  String\n  String\n  String\n  Object\n  $i7 \u003d (int) 65535\n  i3 \u003d i2 \u0026 $i7\n  $r4 \u003d List tempFieldDesc\u003e\n  $r3 \u003d CpBands cpBands\u003e\n  $r5 \u003d $r3.getCPNameAndType(r1, r2)\n  $r4.add($r5)\n  if (r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d List fieldSignature\u003e\n  $r14 \u003d CpBands cpBands\u003e\n  $r16 \u003d $r14.getCPSignature(r6)\n  $r15.add($r16)\n  i3 \u003d i3 | 524288\n}",
      "B2 {\n  $i0 \u003d i3 \u0026 131072\n  if ($i0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i4 \u003d i3 \u0026 -131073\n  i3 \u003d i4 | 1048576\n}",
      "B4 {\n  if (r7 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r12 \u003d List fieldConstantValueKQ\u003e\n  $r11 \u003d CpBands cpBands\u003e\n  $r13 \u003d $r11.getConstant(r7)\n  $r12.add($r13)\n  i3 \u003d i3 | 131072\n}",
      "B6 {\n  $z0 \u003d ClassBands: boolean anySyntheticFields\u003e\n  if ($z0 !\u003d 0) goto B7 else B10\n}",
      "B7 {\n  $i1 \u003d i3 \u0026 4096\n  if ($i1 \u003d\u003d false) goto B8 else B10\n}",
      "B8 {\n  $r8 \u003d Segment segment\u003e\n  $r9 \u003d $r8.getCurrentClassReader()\n  $z1 \u003d $r9.hasSyntheticAttributes()\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r10 \u003d CpBands cpBands\u003e\n  $r10.addCPUtf8(\"Synthetic\")\n  ClassBands: boolean anySyntheticFields\u003e \u003d 1\n}",
      "B10 {\n  $r17 \u003d List tempFieldFlags\u003e\n  $l5 \u003d (long) i3\n  $r18 \u003d Long.valueOf($l5)\n  $r17.add($r18)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addFieldAttribute",
    "signature": "void addFieldAttribute(org.apache.commons.compress.harmony.pack200.NewAttribute)",
    "visibility": "public",
    "body": "{\r\n    final String attributeName \u003d attribute.type;\r\n    for (final NewAttributeBands bands : fieldAttributeBands) {\r\n        if (bands.getAttributeName().equals(attributeName)) {\r\n            bands.addAttribute(attribute);\r\n            final int flagIndex \u003d bands.getFlagIndex();\r\n            final Long flags \u003d tempFieldFlags.remove(tempFieldFlags.size() - 1);\r\n            tempFieldFlags.add(Long.valueOf(flags.longValue() | 1 \u003c\u003c flagIndex));\r\n            return;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No suitable definition for \" + attributeName);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  NewAttribute\n  r1 \u003d String type\u003e\n  $r3 \u003d List fieldAttributeBands\u003e\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r10 \u003d r4.next()\n  r11 \u003d NewAttributeBands) $r10\n  $r12 \u003d r11.getAttributeName()\n  $z1 \u003d $r12.equals(r1)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r11.addAttribute(r0)\n  i0 \u003d r11.getFlagIndex()\n  $r14 \u003d List tempFieldFlags\u003e\n  $r13 \u003d List tempFieldFlags\u003e\n  $i1 \u003d $r13.size()\n  $i2 \u003d $i1 - 1\n  $r15 \u003d $r14.remove($i2)\n  r16 \u003d Long) $r15\n  $r17 \u003d List tempFieldFlags\u003e\n  $l5 \u003d r16.longValue()\n  $i3 \u003d 1 \u003c\u003c i0\n  $l4 \u003d (long) $i3\n  $l6 \u003d $l5 | $l4\n  $r18 \u003d Long.valueOf($l6)\n  $r17.add($r18)\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"No suitable definition for \")\n  $r8 \u003d $r7.append(r1)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addHandler",
    "signature": "void addHandler(org.objectweb.asm.Label,org.objectweb.asm.Label,org.objectweb.asm.Label,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int handlers \u003d codeHandlerCount.remove(codeHandlerCount.size() - 1);\r\n    codeHandlerCount.add(handlers + 1);\r\n    codeHandlerStartP.add(start);\r\n    codeHandlerEndPO.add(end);\r\n    codeHandlerCatchPO.add(handler);\r\n    codeHandlerClass.add(type \u003d\u003d null ? null : cpBands.getCPClass(type));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r10 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  Label\n  Label\n  Label\n  String\n  $r2 \u003d IntList codeHandlerCount\u003e\n  $r1 \u003d IntList codeHandlerCount\u003e\n  $i0 \u003d $r1.size()\n  $i1 \u003d $i0 - 1\n  i2 \u003d $r2.remove($i1)\n  $r3 \u003d IntList codeHandlerCount\u003e\n  $i3 \u003d i2 + 1\n  $r3.add($i3)\n  $r5 \u003d List codeHandlerStartP\u003e\n  $r5.add(r4)\n  $r7 \u003d List codeHandlerEndPO\u003e\n  $r7.add(r6)\n  $r9 \u003d List codeHandlerCatchPO\u003e\n  $r9.add(r8)\n  $r12 \u003d List codeHandlerClass\u003e\n  if (r10 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d null\n  goto B3\n}",
      "B2 {\n  $r11 \u003d CpBands cpBands\u003e\n  $r13 \u003d $r11.getCPClass(r10)\n}",
      "B3 {\n  $r12.add($r13)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addLineNumber",
    "signature": "void addLineNumber(int,org.objectweb.asm.Label)",
    "visibility": "public",
    "body": "{\r\n    final Long latestCodeFlag \u003d codeFlags.get(codeFlags.size() - 1);\r\n    if ((latestCodeFlag.intValue() \u0026 1 \u003c\u003c 1) \u003d\u003d 0) {\r\n        codeFlags.remove(codeFlags.size() - 1);\r\n        codeFlags.add(Long.valueOf(latestCodeFlag.intValue() | 1 \u003c\u003c 1));\r\n        codeLineNumberTableN.add(1);\r\n    } else {\r\n        codeLineNumberTableN.increment(codeLineNumberTableN.size() - 1);\r\n    }\r\n    codeLineNumberTableLine.add(line);\r\n    codeLineNumberTableBciP.add(start);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i3 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i6 :\u003d @parameter0: int\n  Label\n  $r2 \u003d List codeFlags\u003e\n  $r1 \u003d List codeFlags\u003e\n  $i0 \u003d $r1.size()\n  $i1 \u003d $i0 - 1\n  $r3 \u003d $r2.get($i1)\n  r4 \u003d Long) $r3\n  $i2 \u003d r4.intValue()\n  $i3 \u003d $i2 \u0026 2\n  if ($i3 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d List codeFlags\u003e\n  $r10 \u003d List codeFlags\u003e\n  $i7 \u003d $r10.size()\n  $i8 \u003d $i7 - 1\n  $r11.remove($i8)\n  $r12 \u003d List codeFlags\u003e\n  $i9 \u003d r4.intValue()\n  $i10 \u003d $i9 | 2\n  $l11 \u003d (long) $i10\n  $r13 \u003d Long.valueOf($l11)\n  $r12.add($r13)\n  $r14 \u003d IntList codeLineNumberTableN\u003e\n  $r14.add(1)\n  goto B3\n}",
      "B2 {\n  $r6 \u003d IntList codeLineNumberTableN\u003e\n  $r5 \u003d IntList codeLineNumberTableN\u003e\n  $i4 \u003d $r5.size()\n  $i5 \u003d $i4 - 1\n  $r6.increment($i5)\n}",
      "B3 {\n  $r7 \u003d IntList codeLineNumberTableLine\u003e\n  $r7.add(i6)\n  $r9 \u003d List codeLineNumberTableBciP\u003e\n  $r9.add(r8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addLocalVariable",
    "signature": "void addLocalVariable(java.lang.String,java.lang.String,java.lang.String,org.objectweb.asm.Label,org.objectweb.asm.Label,int)",
    "visibility": "public",
    "body": "{\r\n    if (signature !\u003d null) {\r\n        // LocalVariableTypeTable attribute\r\n        final Long latestCodeFlag \u003d codeFlags.get(codeFlags.size() - 1);\r\n        if ((latestCodeFlag.intValue() \u0026 1 \u003c\u003c 3) \u003d\u003d 0) {\r\n            codeFlags.remove(codeFlags.size() - 1);\r\n            codeFlags.add(Long.valueOf(latestCodeFlag.intValue() | 1 \u003c\u003c 3));\r\n            codeLocalVariableTypeTableN.add(1);\r\n        } else {\r\n            codeLocalVariableTypeTableN.increment(codeLocalVariableTypeTableN.size() - 1);\r\n        }\r\n        codeLocalVariableTypeTableBciP.add(start);\r\n        codeLocalVariableTypeTableSpanO.add(end);\r\n        codeLocalVariableTypeTableNameRU.add(cpBands.getCPUtf8(name));\r\n        codeLocalVariableTypeTableTypeRS.add(cpBands.getCPSignature(signature));\r\n        codeLocalVariableTypeTableSlot.add(indx);\r\n    }\r\n    // LocalVariableTable attribute\r\n    codeLocalVariableTableN.increment(codeLocalVariableTableN.size() - 1);\r\n    codeLocalVariableTableBciP.add(start);\r\n    codeLocalVariableTableSpanO.add(end);\r\n    codeLocalVariableTableNameRU.add(cpBands.getCPUtf8(name));\r\n    codeLocalVariableTableTypeRS.add(cpBands.getCPSignature(desc));\r\n    codeLocalVariableTableSlot.add(indx);\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B5",
      "B1 : If($i4 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  String\n  String\n  String\n  Label\n  Label\n  i0 :\u003d @parameter5: int\n  if (r0 \u003d\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r7 \u003d List codeFlags\u003e\n  $r6 \u003d List codeFlags\u003e\n  $i1 \u003d $r6.size()\n  $i2 \u003d $i1 - 1\n  $r8 \u003d $r7.get($i2)\n  r9 \u003d Long) $r8\n  $i3 \u003d r9.intValue()\n  $i4 \u003d $i3 \u0026 8\n  if ($i4 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r22 \u003d List codeFlags\u003e\n  $r21 \u003d List codeFlags\u003e\n  $i7 \u003d $r21.size()\n  $i8 \u003d $i7 - 1\n  $r22.remove($i8)\n  $r23 \u003d List codeFlags\u003e\n  $i9 \u003d r9.intValue()\n  $i10 \u003d $i9 | 8\n  $l11 \u003d (long) $i10\n  $r24 \u003d Long.valueOf($l11)\n  $r23.add($r24)\n  $r25 \u003d IntList codeLocalVariableTypeTableN\u003e\n  $r25.add(1)\n  goto B4\n}",
      "B3 {\n  $r11 \u003d IntList codeLocalVariableTypeTableN\u003e\n  $r10 \u003d IntList codeLocalVariableTypeTableN\u003e\n  $i5 \u003d $r10.size()\n  $i6 \u003d $i5 - 1\n  $r11.increment($i6)\n}",
      "B4 {\n  $r12 \u003d List codeLocalVariableTypeTableBciP\u003e\n  $r12.add(r2)\n  $r13 \u003d List codeLocalVariableTypeTableSpanO\u003e\n  $r13.add(r3)\n  $r15 \u003d List codeLocalVariableTypeTableNameRU\u003e\n  $r14 \u003d CpBands cpBands\u003e\n  $r16 \u003d $r14.getCPUtf8(r4)\n  $r15.add($r16)\n  $r18 \u003d List codeLocalVariableTypeTableTypeRS\u003e\n  $r17 \u003d CpBands cpBands\u003e\n  $r19 \u003d $r17.getCPSignature(r0)\n  $r18.add($r19)\n  $r20 \u003d IntList codeLocalVariableTypeTableSlot\u003e\n  $r20.add(i0)\n}",
      "B5 {\n  $r26 \u003d IntList codeLocalVariableTableN\u003e\n  $r27 \u003d IntList codeLocalVariableTableN\u003e\n  $i12 \u003d $r27.size()\n  $i13 \u003d $i12 - 1\n  $r26.increment($i13)\n  $r28 \u003d List codeLocalVariableTableBciP\u003e\n  $r28.add(r2)\n  $r29 \u003d List codeLocalVariableTableSpanO\u003e\n  $r29.add(r3)\n  $r30 \u003d List codeLocalVariableTableNameRU\u003e\n  $r31 \u003d CpBands cpBands\u003e\n  $r32 \u003d $r31.getCPUtf8(r4)\n  $r30.add($r32)\n  $r33 \u003d List codeLocalVariableTableTypeRS\u003e\n  $r34 \u003d CpBands cpBands\u003e\n  $r35 \u003d $r34.getCPSignature(r5)\n  $r33.add($r35)\n  $r36 \u003d IntList codeLocalVariableTableSlot\u003e\n  $r36.add(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addMaxStack",
    "signature": "void addMaxStack(int,int)",
    "visibility": "public",
    "body": "{\r\n    final Long latestFlag \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n    final Long newFlag \u003d Long.valueOf(latestFlag.intValue() | 1 \u003c\u003c 17);\r\n    tempMethodFlags.add(newFlag);\r\n    codeMaxStack.add(maxStack);\r\n    if ((newFlag.longValue() \u0026 1 \u003c\u003c 3) \u003d\u003d 0) {\r\n        // not static\r\n        // minus \u0027this\u0027 local\r\n        maxLocals--;\r\n    }\r\n    maxLocals -\u003d numMethodArgs;\r\n    codeMaxLocals.add(maxLocals);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b8 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i5 :\u003d @parameter0: int\n  i11 :\u003d @parameter1: int\n  $r2 \u003d List tempMethodFlags\u003e\n  $r1 \u003d List tempMethodFlags\u003e\n  $i0 \u003d $r1.size()\n  $i1 \u003d $i0 - 1\n  $r3 \u003d $r2.remove($i1)\n  r4 \u003d Long) $r3\n  $i2 \u003d r4.intValue()\n  $i3 \u003d $i2 | 131072\n  $l4 \u003d (long) $i3\n  r5 \u003d Long.valueOf($l4)\n  $r6 \u003d List tempMethodFlags\u003e\n  $r6.add(r5)\n  $r7 \u003d IntList codeMaxStack\u003e\n  $r7.add(i5)\n  $l6 \u003d r5.longValue()\n  $l7 \u003d $l6 \u0026 8L\n  $b8 \u003d $l7 cmp 0L\n  if ($b8 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i13 \u003d (int) -1\n  i11 \u003d i11 + $i13\n}",
      "B2 {\n  $i9 \u003d ClassBands: int numMethodArgs\u003e\n  $i10 \u003d i11 - $i9\n  $r8 \u003d IntList codeMaxLocals\u003e\n  $r8.add($i10)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addMethod",
    "signature": "void addMethod(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    final CPNameAndType nt \u003d cpBands.getCPNameAndType(name, desc);\r\n    tempMethodDesc.add(nt);\r\n    if (signature !\u003d null) {\r\n        methodSignature.add(cpBands.getCPSignature(signature));\r\n        flags |\u003d 1 \u003c\u003c 19;\r\n    }\r\n    if (exceptions !\u003d null) {\r\n        methodExceptionNumber.add(exceptions.length);\r\n        for (final String exception : exceptions) {\r\n            methodExceptionClasses.add(cpBands.getCPClass(exception));\r\n        }\r\n        flags |\u003d 1 \u003c\u003c 18;\r\n    }\r\n    if ((flags \u0026 Opcodes.ACC_DEPRECATED) !\u003d 0) {\r\n        // ASM uses (1\u003c\u003c17) flag for deprecated\r\n        flags \u0026\u003d ~Opcodes.ACC_DEPRECATED;\r\n        flags |\u003d 1 \u003c\u003c 20;\r\n    }\r\n    tempMethodFlags.add(Long.valueOf(flags));\r\n    numMethodArgs \u003d countArgs(desc);\r\n    if (!anySyntheticMethods \u0026\u0026 (flags \u0026 1 \u003c\u003c 12) !\u003d 0 \u0026\u0026 segment.getCurrentClassReader().hasSyntheticAttributes()) {\r\n        cpBands.addCPUtf8(\"Synthetic\");\r\n        anySyntheticMethods \u003d true;\r\n    }\r\n}",
    "nodes": 14,
    "edges": 20,
    "cc": 8,
    "flowSummary": [
      "B0 : If(r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r7 \u003d\u003d null) → B3 | else → B7",
      "B4 : If(i7 \u003e\u003d i5) → B5 | else → B6",
      "B7 : If($i0 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($z0 !\u003d 0) → B10 | else → B13",
      "B10 : If($i3 \u003d\u003d false) → B11 | else → B13",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i6 :\u003d @parameter0: int\n  String\n  String\n  String\n  String[]\n  $r3 \u003d CpBands cpBands\u003e\n  r4 \u003d $r3.getCPNameAndType(r1, r2)\n  $r5 \u003d List tempMethodDesc\u003e\n  $r5.add(r4)\n  if (r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r19 \u003d List methodSignature\u003e\n  $r18 \u003d CpBands cpBands\u003e\n  $r20 \u003d $r18.getCPSignature(r6)\n  $r19.add($r20)\n  i6 \u003d i6 | 524288\n}",
      "B2 {\n  if (r7 \u003d\u003d null) goto B3 else B7\n}",
      "B3 {\n  $r13 \u003d IntList methodExceptionNumber\u003e\n  $i4 \u003d lengthof r7\n  $r13.add($i4)\n  i5 \u003d lengthof r7\n  i7 \u003d 0\n}",
      "B4 {\n  if (i7 \u003e\u003d i5) goto B5 else B6\n}",
      "B5 {\n  r14 \u003d r7[i7]\n  $r16 \u003d List methodExceptionClasses\u003e\n  $r15 \u003d CpBands cpBands\u003e\n  $r17 \u003d $r15.getCPClass(r14)\n  $r16.add($r17)\n  i7 \u003d i7 + 1\n  goto B4\n}",
      "B6 {\n  i6 \u003d i6 | 262144\n}",
      "B7 {\n  $i0 \u003d i6 \u0026 131072\n  if ($i0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  i8 \u003d i6 \u0026 -131073\n  i6 \u003d i8 | 1048576\n}",
      "B9 {\n  $r8 \u003d List tempMethodFlags\u003e\n  $l1 \u003d (long) i6\n  $r9 \u003d Long.valueOf($l1)\n  $r8.add($r9)\n  $i2 \u003d ClassBands.countArgs(r2)\n  ClassBands: int numMethodArgs\u003e \u003d $i2\n  $z0 \u003d ClassBands: boolean anySyntheticMethods\u003e\n  if ($z0 !\u003d 0) goto B10 else B13\n}",
      "B10 {\n  $i3 \u003d i6 \u0026 4096\n  if ($i3 \u003d\u003d false) goto B11 else B13\n}",
      "B11 {\n  $r10 \u003d Segment segment\u003e\n  $r11 \u003d $r10.getCurrentClassReader()\n  $z1 \u003d $r11.hasSyntheticAttributes()\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r12 \u003d CpBands cpBands\u003e\n  $r12.addCPUtf8(\"Synthetic\")\n  ClassBands: boolean anySyntheticMethods\u003e \u003d 1\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassBands#countArgs(...1)",
        "body": "{\r\n    final int bra \u003d descriptor.indexOf(\u0027(\u0027);\r\n    final int ket \u003d descriptor.indexOf(\u0027)\u0027);\r\n    if (bra \u003d\u003d -1 || ket \u003d\u003d -1 || ket \u003c bra) {\r\n        throw new IllegalArgumentException(\"No arguments\");\r\n    }\r\n    boolean inType \u003d false;\r\n    boolean consumingNextType \u003d false;\r\n    int count \u003d 0;\r\n    for (int i \u003d bra + 1; i \u003c ket; i++) {\r\n        final char charAt \u003d descriptor.charAt(i);\r\n        if (inType \u0026\u0026 charAt \u003d\u003d \u0027;\u0027) {\r\n            inType \u003d false;\r\n            consumingNextType \u003d false;\r\n        } else if (!inType \u0026\u0026 charAt \u003d\u003d \u0027L\u0027) {\r\n            inType \u003d true;\r\n            count++;\r\n        } else if (charAt \u003d\u003d \u0027[\u0027) {\r\n            consumingNextType \u003d true;\r\n        } else if (inType) {\r\n            // NOP\r\n        } else if (consumingNextType) {\r\n            count++;\r\n            consumingNextType \u003d false;\r\n        } else if (charAt \u003d\u003d \u0027D\u0027 || charAt \u003d\u003d \u0027J\u0027) {\r\n            count +\u003d 2;\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addMethodAttribute",
    "signature": "void addMethodAttribute(org.apache.commons.compress.harmony.pack200.NewAttribute)",
    "visibility": "public",
    "body": "{\r\n    final String attributeName \u003d attribute.type;\r\n    for (final NewAttributeBands bands : methodAttributeBands) {\r\n        if (bands.getAttributeName().equals(attributeName)) {\r\n            bands.addAttribute(attribute);\r\n            final int flagIndex \u003d bands.getFlagIndex();\r\n            final Long flags \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n            tempMethodFlags.add(Long.valueOf(flags.longValue() | 1 \u003c\u003c flagIndex));\r\n            return;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No suitable definition for \" + attributeName);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  NewAttribute\n  r1 \u003d String type\u003e\n  $r3 \u003d List methodAttributeBands\u003e\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r10 \u003d r4.next()\n  r11 \u003d NewAttributeBands) $r10\n  $r12 \u003d r11.getAttributeName()\n  $z1 \u003d $r12.equals(r1)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r11.addAttribute(r0)\n  i0 \u003d r11.getFlagIndex()\n  $r14 \u003d List tempMethodFlags\u003e\n  $r13 \u003d List tempMethodFlags\u003e\n  $i1 \u003d $r13.size()\n  $i2 \u003d $i1 - 1\n  $r15 \u003d $r14.remove($i2)\n  r16 \u003d Long) $r15\n  $r17 \u003d List tempMethodFlags\u003e\n  $l5 \u003d r16.longValue()\n  $i3 \u003d 1 \u003c\u003c i0\n  $l4 \u003d (long) $i3\n  $l6 \u003d $l5 | $l4\n  $r18 \u003d Long.valueOf($l6)\n  $r17.add($r18)\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"No suitable definition for \")\n  $r8 \u003d $r7.append(r1)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addParameterAnnotation",
    "signature": "void addParameterAnnotation(int,java.lang.String,boolean,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    if (visible) {\r\n        if (tempMethodRVPA \u003d\u003d null) {\r\n            tempMethodRVPA \u003d new TempParamAnnotation(numMethodArgs);\r\n            tempMethodRVPA.addParameterAnnotation(parameter, desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n        }\r\n        final Long flag \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n        tempMethodFlags.add(Long.valueOf(flag.longValue() | 1 \u003c\u003c 23));\r\n    } else {\r\n        if (tempMethodRIPA \u003d\u003d null) {\r\n            tempMethodRIPA \u003d new TempParamAnnotation(numMethodArgs);\r\n            tempMethodRIPA.addParameterAnnotation(parameter, desc, nameRU, tags, values, caseArrayN, nestTypeRS, nestNameRU, nestPairN);\r\n        }\r\n        final Long flag \u003d tempMethodFlags.remove(tempMethodFlags.size() - 1);\r\n        tempMethodFlags.add(Long.valueOf(flag.longValue() | 1 \u003c\u003c 24));\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B4",
      "B1 : If($r18 !\u003d null) → B2 | else → B3",
      "B4 : If($r1 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  i5 :\u003d @parameter0: int\n  String\n  z0 :\u003d @parameter2: boolean\n  List\n  List\n  List\n  List\n  List\n  List\n  List\n  if (z0 \u003d\u003d false) goto B1 else B4\n}",
      "B1 {\n  $r18 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  if ($r18 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r24 \u003d ClassBands$TempParamAnnotation\n  $i10 \u003d ClassBands: int numMethodArgs\u003e\n  new ClassBands$TempParamAnnotation($i10)\n  ClassBands$TempParamAnnotation tempMethodRVPA\u003e \u003d $r24\n  $r25 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r25.addParameterAnnotation(i5, r8, r9, r10, r11, r12, r13, r14, r15)\n}",
      "B3 {\n  $r20 \u003d List tempMethodFlags\u003e\n  $r19 \u003d List tempMethodFlags\u003e\n  $i6 \u003d $r19.size()\n  $i7 \u003d $i6 - 1\n  $r21 \u003d $r20.remove($i7)\n  $r26 \u003d Long) $r21\n  $r22 \u003d List tempMethodFlags\u003e\n  $l8 \u003d $r26.longValue()\n  $l9 \u003d $l8 | 8388608L\n  $r23 \u003d Long.valueOf($l9)\n  $r22.add($r23)\n  goto B7\n}",
      "B4 {\n  $r1 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  if ($r1 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d ClassBands$TempParamAnnotation\n  $i4 \u003d ClassBands: int numMethodArgs\u003e\n  new ClassBands$TempParamAnnotation($i4)\n  ClassBands$TempParamAnnotation tempMethodRIPA\u003e \u003d $r7\n  $r16 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r16.addParameterAnnotation(i5, r8, r9, r10, r11, r12, r13, r14, r15)\n}",
      "B6 {\n  $r3 \u003d List tempMethodFlags\u003e\n  $r2 \u003d List tempMethodFlags\u003e\n  $i0 \u003d $r2.size()\n  $i1 \u003d $i0 - 1\n  $r4 \u003d $r3.remove($i1)\n  $r17 \u003d Long) $r4\n  $r5 \u003d List tempMethodFlags\u003e\n  $l2 \u003d $r17.longValue()\n  $l3 \u003d $l2 | 16777216L\n  $r6 \u003d Long.valueOf($l3)\n  $r5.add($r6)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "addSourceFile",
    "signature": "void addSourceFile(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    String implicitSourceFileName \u003d class_this[index].toString();\r\n    if (implicitSourceFileName.indexOf(\u0027$\u0027) !\u003d -1) {\r\n        implicitSourceFileName \u003d implicitSourceFileName.substring(0, implicitSourceFileName.indexOf(\u0027$\u0027));\r\n    }\r\n    implicitSourceFileName \u003d implicitSourceFileName.substring(implicitSourceFileName.lastIndexOf(\u0027/\u0027) + 1) + \".java\";\r\n    if (source.equals(implicitSourceFileName)) {\r\n        classSourceFile.add(null);\r\n    } else {\r\n        classSourceFile.add(cpBands.getCPUtf8(source));\r\n    }\r\n    class_flags[index] |\u003d 1 \u003c\u003c 17;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d $i9) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  String\n  $r1 \u003d CPClass[] class_this\u003e\n  $i0 \u003d ClassBands: int index\u003e\n  $r2 \u003d $r1[$i0]\n  r14 \u003d $r2.toString()\n  $i1 \u003d r14.indexOf(36)\n  $i9 \u003d (int) -1\n  if ($i1 \u003d\u003d $i9) goto B1 else B2\n}",
      "B1 {\n  $i7 \u003d r14.indexOf(36)\n  r14 \u003d r14.substring(0, $i7)\n}",
      "B2 {\n  $r15 \u003d StringBuilder\n  new StringBuilder()\n  $i2 \u003d r14.lastIndexOf(47)\n  $i3 \u003d $i2 + 1\n  $r4 \u003d r14.substring($i3)\n  $r5 \u003d $r15.append($r4)\n  $r6 \u003d $r5.append(\".java\")\n  $r13 \u003d $r6.toString()\n  $z0 \u003d r7.equals($r13)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d List classSourceFile\u003e\n  $r12.add(null)\n  goto B5\n}",
      "B4 {\n  $r9 \u003d List classSourceFile\u003e\n  $r8 \u003d CpBands cpBands\u003e\n  $r10 \u003d $r8.getCPUtf8(r7)\n  $r9.add($r10)\n}",
      "B5 {\n  $r11 \u003d ClassBands: long[] class_flags\u003e\n  $i4 \u003d ClassBands: int index\u003e\n  $l5 \u003d $r11[$i4]\n  $l6 \u003d $l5 | 131072L\n  $r11[$i4] \u003d $l6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "currentClassReferencesInnerClass",
    "signature": "void currentClassReferencesInnerClass(org.apache.commons.compress.harmony.pack200.CPClass)",
    "visibility": "public",
    "body": "{\r\n    if (!(index \u003e\u003d class_this.length)) {\r\n        final CPClass currentClass \u003d class_this[index];\r\n        if (currentClass !\u003d null \u0026\u0026 !currentClass.equals(inner) \u0026\u0026 !isInnerClassOf(currentClass.toString(), inner)) {\r\n            classReferencesInnerClass.computeIfAbsent(currentClass, c -\u003e new HashSet\u003c\u003e()).add(inner);\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 9,
    "cc": 5,
    "flowSummary": [
      "B0 : If($i1 \u003e\u003d $i0) → B1 | else → B5",
      "B1 : If(r3 \u003d\u003d null) → B2 | else → B5",
      "B2 : If($z0 !\u003d 0) → B3 | else → B5",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  CPClass\n  $i1 \u003d ClassBands: int index\u003e\n  $r1 \u003d CPClass[] class_this\u003e\n  $i0 \u003d lengthof $r1\n  if ($i1 \u003e\u003d $i0) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d CPClass[] class_this\u003e\n  $i2 \u003d ClassBands: int index\u003e\n  r3 \u003d $r2[$i2]\n  if (r3 \u003d\u003d null) goto B2 else B5\n}",
      "B2 {\n  $z0 \u003d r3.equals(r4)\n  if ($z0 !\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $r5 \u003d r3.toString()\n  $z1 \u003d r0.isInnerClassOf($r5, r4)\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r6 \u003d Map classReferencesInnerClass\u003e\n  $r7 \u003d ClassBands$lambda_currentClassReferencesInnerClass_1__31.bootstrap$()\n  $r8 \u003d $r6.computeIfAbsent(r3, $r7)\n  $r9 \u003d Set) $r8\n  $r9.add(r4)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassBands#isInnerClassOf(...2)",
        "body": "{\r\n    if (isInnerClass(possibleInner)) {\r\n        final String superClassName \u003d possibleInner.substring(0, possibleInner.lastIndexOf(\u0027$\u0027));\r\n        if (superClassName.equals(possibleOuter.toString())) {\r\n            return true;\r\n        }\r\n        return isInnerClassOf(superClassName, possibleOuter);\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "doBciRenumbering",
    "signature": "void doBciRenumbering(org.apache.commons.compress.harmony.pack200.IntList,java.util.Map)",
    "visibility": "public",
    "body": "{\r\n    renumberBci(codeLineNumberTableBciP, bciRenumbering, labelsToOffsets);\r\n    renumberBci(codeLocalVariableTableBciP, bciRenumbering, labelsToOffsets);\r\n    renumberOffsetBci(codeLocalVariableTableBciP, codeLocalVariableTableSpanO, bciRenumbering, labelsToOffsets);\r\n    renumberBci(codeLocalVariableTypeTableBciP, bciRenumbering, labelsToOffsets);\r\n    renumberOffsetBci(codeLocalVariableTypeTableBciP, codeLocalVariableTypeTableSpanO, bciRenumbering, labelsToOffsets);\r\n    renumberBci(codeHandlerStartP, bciRenumbering, labelsToOffsets);\r\n    renumberOffsetBci(codeHandlerStartP, codeHandlerEndPO, bciRenumbering, labelsToOffsets);\r\n    renumberDoubleOffsetBci(codeHandlerStartP, codeHandlerEndPO, codeHandlerCatchPO, bciRenumbering, labelsToOffsets);\r\n    for (final NewAttributeBands newAttributeBandSet : classAttributeBands) {\r\n        newAttributeBandSet.renumberBci(bciRenumbering, labelsToOffsets);\r\n    }\r\n    for (final NewAttributeBands newAttributeBandSet : methodAttributeBands) {\r\n        newAttributeBandSet.renumberBci(bciRenumbering, labelsToOffsets);\r\n    }\r\n    for (final NewAttributeBands newAttributeBandSet : fieldAttributeBands) {\r\n        newAttributeBandSet.renumberBci(bciRenumbering, labelsToOffsets);\r\n    }\r\n    for (final NewAttributeBands newAttributeBandSet : codeAttributeBands) {\r\n        newAttributeBandSet.renumberBci(bciRenumbering, labelsToOffsets);\r\n    }\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  IntList\n  Map\n  $r3 \u003d List codeLineNumberTableBciP\u003e\n  r0.renumberBci($r3, r1, r2)\n  $r4 \u003d List codeLocalVariableTableBciP\u003e\n  r0.renumberBci($r4, r1, r2)\n  $r6 \u003d List codeLocalVariableTableBciP\u003e\n  $r5 \u003d List codeLocalVariableTableSpanO\u003e\n  r0.renumberOffsetBci($r6, $r5, r1, r2)\n  $r7 \u003d List codeLocalVariableTypeTableBciP\u003e\n  r0.renumberBci($r7, r1, r2)\n  $r9 \u003d List codeLocalVariableTypeTableBciP\u003e\n  $r8 \u003d List codeLocalVariableTypeTableSpanO\u003e\n  r0.renumberOffsetBci($r9, $r8, r1, r2)\n  $r10 \u003d List codeHandlerStartP\u003e\n  r0.renumberBci($r10, r1, r2)\n  $r12 \u003d List codeHandlerStartP\u003e\n  $r11 \u003d List codeHandlerEndPO\u003e\n  r0.renumberOffsetBci($r12, $r11, r1, r2)\n  $r15 \u003d List codeHandlerStartP\u003e\n  $r14 \u003d List codeHandlerEndPO\u003e\n  $r13 \u003d List codeHandlerCatchPO\u003e\n  r0.renumberDoubleOffsetBci($r15, $r14, $r13, r1, r2)\n  $r16 \u003d List classAttributeBands\u003e\n  r24 \u003d $r16.iterator()\n}",
      "B1 {\n  $z0 \u003d r24.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r23 \u003d r24.next()\n  r25 \u003d NewAttributeBands) $r23\n  r25.renumberBci(r1, r2)\n  goto B1\n}",
      "B3 {\n  $r17 \u003d List methodAttributeBands\u003e\n  r26 \u003d $r17.iterator()\n}",
      "B4 {\n  $z1 \u003d r26.hasNext()\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r22 \u003d r26.next()\n  r27 \u003d NewAttributeBands) $r22\n  r27.renumberBci(r1, r2)\n  goto B4\n}",
      "B6 {\n  $r18 \u003d List fieldAttributeBands\u003e\n  r28 \u003d $r18.iterator()\n}",
      "B7 {\n  $z2 \u003d r28.hasNext()\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r21 \u003d r28.next()\n  r29 \u003d NewAttributeBands) $r21\n  r29.renumberBci(r1, r2)\n  goto B7\n}",
      "B9 {\n  $r19 \u003d List codeAttributeBands\u003e\n  r30 \u003d $r19.iterator()\n}",
      "B10 {\n  $z3 \u003d r30.hasNext()\n  if ($z3 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r20 \u003d r30.next()\n  r31 \u003d NewAttributeBands) $r20\n  r31.renumberBci(r1, r2)\n  goto B10\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassBands#renumberBci(...3)",
        "body": "{\r\n    for (int i \u003d list.size() - 1; i \u003e\u003d 0; i--) {\r\n        final Object label \u003d list.get(i);\r\n        if (label instanceof Integer) {\r\n            break;\r\n        }\r\n        if (label instanceof Label) {\r\n            list.remove(i);\r\n            final Integer bytecodeIndex \u003d labelsToOffsets.get(label);\r\n            list.add(i, Integer.valueOf(bciRenumbering.get(bytecodeIndex.intValue())));\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "ClassBands#renumberDoubleOffsetBci(...5)",
        "body": "{\r\n    // TODO: There\u0027s probably a nicer way of doing this...\r\n    for (int i \u003d list.size() - 1; i \u003e\u003d 0; i--) {\r\n        final Object label \u003d list.get(i);\r\n        if (label instanceof Integer) {\r\n            break;\r\n        }\r\n        if (label instanceof Label) {\r\n            list.remove(i);\r\n            final Integer bytecodeIndex \u003d labelsToOffsets.get(label);\r\n            final Integer renumberedOffset \u003d Integer.valueOf(bciRenumbering.get(bytecodeIndex.intValue()) - relative.get(i).intValue() - firstOffset.get(i).intValue());\r\n            list.add(i, renumberedOffset);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "ClassBands#renumberOffsetBci(...4)",
        "body": "{\r\n    for (int i \u003d list.size() - 1; i \u003e\u003d 0; i--) {\r\n        final Object label \u003d list.get(i);\r\n        if (label instanceof Integer) {\r\n            break;\r\n        }\r\n        if (label instanceof Label) {\r\n            list.remove(i);\r\n            final Integer bytecodeIndex \u003d labelsToOffsets.get(label);\r\n            final Integer renumberedOffset \u003d Integer.valueOf(bciRenumbering.get(bytecodeIndex.intValue()) - relative.get(i).intValue());\r\n            list.add(i, renumberedOffset);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "endOfClass",
    "signature": "void endOfClass()",
    "visibility": "public",
    "body": "{\r\n    final int numFields \u003d tempFieldDesc.size();\r\n    class_field_count[index] \u003d numFields;\r\n    field_descr[index] \u003d new CPNameAndType[numFields];\r\n    field_flags[index] \u003d new long[numFields];\r\n    for (int i \u003d 0; i \u003c numFields; i++) {\r\n        field_descr[index][i] \u003d tempFieldDesc.get(i);\r\n        field_flags[index][i] \u003d tempFieldFlags.get(i).longValue();\r\n    }\r\n    final int numMethods \u003d tempMethodDesc.size();\r\n    class_method_count[index] \u003d numMethods;\r\n    method_descr[index] \u003d new CPNameAndType[numMethods];\r\n    method_flags[index] \u003d new long[numMethods];\r\n    for (int i \u003d 0; i \u003c numMethods; i++) {\r\n        method_descr[index][i] \u003d tempMethodDesc.get(i);\r\n        method_flags[index][i] \u003d tempMethodFlags.get(i).longValue();\r\n    }\r\n    tempFieldDesc.clear();\r\n    tempFieldFlags.clear();\r\n    tempMethodDesc.clear();\r\n    tempMethodFlags.clear();\r\n    index++;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i15 \u003e\u003d i0) → B2 | else → B3",
      "B4 : If(i17 \u003e\u003d i16) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d List tempFieldDesc\u003e\n  i0 \u003d $r1.size()\n  $r2 \u003d ClassBands: int[] class_field_count\u003e\n  $i1 \u003d ClassBands: int index\u003e\n  $r2[$i1] \u003d i0\n  $r4 \u003d CPNameAndType[][] field_descr\u003e\n  $i2 \u003d ClassBands: int index\u003e\n  $r3 \u003d CPNameAndType)[i0]\n  $r4[$i2] \u003d $r3\n  $r6 \u003d ClassBands: long[][] field_flags\u003e\n  $i3 \u003d ClassBands: int index\u003e\n  $r5 \u003d newarray (long)[i0]\n  $r6[$i3] \u003d $r5\n  i15 \u003d 0\n}",
      "B1 {\n  if (i15 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  $r27 \u003d CPNameAndType[][] field_descr\u003e\n  $i12 \u003d ClassBands: int index\u003e\n  $r29 \u003d $r27[$i12]\n  $r28 \u003d List tempFieldDesc\u003e\n  $r30 \u003d $r28.get(i15)\n  $r31 \u003d CPNameAndType) $r30\n  $r29[i15] \u003d $r31\n  $r32 \u003d ClassBands: long[][] field_flags\u003e\n  $i13 \u003d ClassBands: int index\u003e\n  $r34 \u003d $r32[$i13]\n  $r33 \u003d List tempFieldFlags\u003e\n  $r35 \u003d $r33.get(i15)\n  $r36 \u003d Long) $r35\n  $l14 \u003d $r36.longValue()\n  $r34[i15] \u003d $l14\n  i15 \u003d i15 + 1\n  goto B1\n}",
      "B3 {\n  $r7 \u003d List tempMethodDesc\u003e\n  i16 \u003d $r7.size()\n  $r8 \u003d ClassBands: int[] class_method_count\u003e\n  $i4 \u003d ClassBands: int index\u003e\n  $r8[$i4] \u003d i16\n  $r10 \u003d CPNameAndType[][] method_descr\u003e\n  $i5 \u003d ClassBands: int index\u003e\n  $r9 \u003d CPNameAndType)[i16]\n  $r10[$i5] \u003d $r9\n  $r12 \u003d ClassBands: long[][] method_flags\u003e\n  $i6 \u003d ClassBands: int index\u003e\n  $r11 \u003d newarray (long)[i16]\n  $r12[$i6] \u003d $r11\n  i17 \u003d 0\n}",
      "B4 {\n  if (i17 \u003e\u003d i16) goto B5 else B6\n}",
      "B5 {\n  $r17 \u003d CPNameAndType[][] method_descr\u003e\n  $i9 \u003d ClassBands: int index\u003e\n  $r19 \u003d $r17[$i9]\n  $r18 \u003d List tempMethodDesc\u003e\n  $r20 \u003d $r18.get(i17)\n  $r21 \u003d CPNameAndType) $r20\n  $r19[i17] \u003d $r21\n  $r22 \u003d ClassBands: long[][] method_flags\u003e\n  $i10 \u003d ClassBands: int index\u003e\n  $r24 \u003d $r22[$i10]\n  $r23 \u003d List tempMethodFlags\u003e\n  $r25 \u003d $r23.get(i17)\n  $r26 \u003d Long) $r25\n  $l11 \u003d $r26.longValue()\n  $r24[i17] \u003d $l11\n  i17 \u003d i17 + 1\n  goto B4\n}",
      "B6 {\n  $r13 \u003d List tempFieldDesc\u003e\n  $r13.clear()\n  $r14 \u003d List tempFieldFlags\u003e\n  $r14.clear()\n  $r15 \u003d List tempMethodDesc\u003e\n  $r15.clear()\n  $r16 \u003d List tempMethodFlags\u003e\n  $r16.clear()\n  $i7 \u003d ClassBands: int index\u003e\n  $i8 \u003d $i7 + 1\n  ClassBands: int index\u003e \u003d $i8\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "endOfMethod",
    "signature": "void endOfMethod()",
    "visibility": "public",
    "body": "{\r\n    if (tempMethodRVPA !\u003d null) {\r\n        method_RVPA_bands.addParameterAnnotation(tempMethodRVPA.numParams, tempMethodRVPA.annoN, tempMethodRVPA.pairN, tempMethodRVPA.typeRS, tempMethodRVPA.nameRU, tempMethodRVPA.tags, tempMethodRVPA.values, tempMethodRVPA.caseArrayN, tempMethodRVPA.nestTypeRS, tempMethodRVPA.nestNameRU, tempMethodRVPA.nestPairN);\r\n        tempMethodRVPA \u003d null;\r\n    }\r\n    if (tempMethodRIPA !\u003d null) {\r\n        method_RIPA_bands.addParameterAnnotation(tempMethodRIPA.numParams, tempMethodRIPA.annoN, tempMethodRIPA.pairN, tempMethodRIPA.typeRS, tempMethodRIPA.nameRU, tempMethodRIPA.tags, tempMethodRIPA.values, tempMethodRIPA.caseArrayN, tempMethodRIPA.nestTypeRS, tempMethodRIPA.nestNameRU, tempMethodRIPA.nestPairN);\r\n        tempMethodRIPA \u003d null;\r\n    }\r\n    if (codeFlags.size() \u003e 0) {\r\n        final long latestCodeFlag \u003d codeFlags.get(codeFlags.size() - 1).longValue();\r\n        final int latestLocalVariableTableN \u003d codeLocalVariableTableN.get(codeLocalVariableTableN.size() - 1);\r\n        if (latestCodeFlag \u003d\u003d 1 \u003c\u003c 2 \u0026\u0026 latestLocalVariableTableN \u003d\u003d 0) {\r\n            codeLocalVariableTableN.remove(codeLocalVariableTableN.size() - 1);\r\n            codeFlags.remove(codeFlags.size() - 1);\r\n            codeFlags.add(Long.valueOf(0));\r\n        }\r\n    }\r\n}",
    "nodes": 9,
    "edges": 13,
    "cc": 6,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i0 \u003c\u003d 0) → B5 | else → B8",
      "B5 : If($b7 !\u003d 0) → B6 | else → B8",
      "B6 : If(i6 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r59 \u003d MetadataBandGroup method_RVPA_bands\u003e\n  $r38 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $i13 \u003d ClassBands$TempParamAnnotation: int numParams\u003e\n  $r39 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r58 \u003d ClassBands$TempParamAnnotation: int[] annoN\u003e\n  $r40 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r57 \u003d IntList pairN\u003e\n  $r41 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r56 \u003d List typeRS\u003e\n  $r42 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r55 \u003d List nameRU\u003e\n  $r43 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r54 \u003d List tags\u003e\n  $r44 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r53 \u003d List values\u003e\n  $r45 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r52 \u003d List caseArrayN\u003e\n  $r46 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r51 \u003d List nestTypeRS\u003e\n  $r47 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r50 \u003d List nestNameRU\u003e\n  $r48 \u003d ClassBands$TempParamAnnotation tempMethodRVPA\u003e\n  $r49 \u003d List nestPairN\u003e\n  $r59.addParameterAnnotation($i13, $r58, $r57, $r56, $r55, $r54, $r53, $r52, $r51, $r50, $r49)\n  ClassBands$TempParamAnnotation tempMethodRVPA\u003e \u003d null\n}",
      "B2 {\n  $r2 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r37 \u003d MetadataBandGroup method_RIPA_bands\u003e\n  $r16 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $i12 \u003d ClassBands$TempParamAnnotation: int numParams\u003e\n  $r17 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r36 \u003d ClassBands$TempParamAnnotation: int[] annoN\u003e\n  $r18 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r35 \u003d IntList pairN\u003e\n  $r19 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r34 \u003d List typeRS\u003e\n  $r20 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r33 \u003d List nameRU\u003e\n  $r21 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r32 \u003d List tags\u003e\n  $r22 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r31 \u003d List values\u003e\n  $r23 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r30 \u003d List caseArrayN\u003e\n  $r24 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r29 \u003d List nestTypeRS\u003e\n  $r25 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r28 \u003d List nestNameRU\u003e\n  $r26 \u003d ClassBands$TempParamAnnotation tempMethodRIPA\u003e\n  $r27 \u003d List nestPairN\u003e\n  $r37.addParameterAnnotation($i12, $r36, $r35, $r34, $r33, $r32, $r31, $r30, $r29, $r28, $r27)\n  ClassBands$TempParamAnnotation tempMethodRIPA\u003e \u003d null\n}",
      "B4 {\n  $r3 \u003d List codeFlags\u003e\n  $i0 \u003d $r3.size()\n  if ($i0 \u003c\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $r5 \u003d List codeFlags\u003e\n  $r4 \u003d List codeFlags\u003e\n  $i1 \u003d $r4.size()\n  $i2 \u003d $i1 - 1\n  $r6 \u003d $r5.get($i2)\n  $r7 \u003d Long) $r6\n  l3 \u003d $r7.longValue()\n  $r9 \u003d IntList codeLocalVariableTableN\u003e\n  $r8 \u003d IntList codeLocalVariableTableN\u003e\n  $i4 \u003d $r8.size()\n  $i5 \u003d $i4 - 1\n  i6 \u003d $r9.get($i5)\n  $b7 \u003d l3 cmp 4L\n  if ($b7 !\u003d 0) goto B6 else B8\n}",
      "B6 {\n  if (i6 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $r11 \u003d IntList codeLocalVariableTableN\u003e\n  $r10 \u003d IntList codeLocalVariableTableN\u003e\n  $i8 \u003d $r10.size()\n  $i9 \u003d $i8 - 1\n  $r11.remove($i9)\n  $r13 \u003d List codeFlags\u003e\n  $r12 \u003d List codeFlags\u003e\n  $i10 \u003d $r12.size()\n  $i11 \u003d $i10 - 1\n  $r13.remove($i11)\n  $r14 \u003d List codeFlags\u003e\n  $r15 \u003d Long.valueOf(0L)\n  $r14.add($r15)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "finaliseBands",
    "signature": "void finaliseBands()",
    "visibility": "public",
    "body": "{\r\n    final int defaultMajorVersion \u003d segmentHeader.getDefaultMajorVersion();\r\n    for (int i \u003d 0; i \u003c class_flags.length; i++) {\r\n        final int major \u003d major_versions[i];\r\n        if (major !\u003d defaultMajorVersion) {\r\n            class_flags[i] |\u003d 1 \u003c\u003c 24;\r\n            classFileVersionMajor.add(major);\r\n            classFileVersionMinor.add(0);\r\n        }\r\n    }\r\n    // Calculate code headers\r\n    codeHeaders \u003d new int[codeHandlerCount.size()];\r\n    int removed \u003d 0;\r\n    for (int i \u003d 0; i \u003c codeHeaders.length; i++) {\r\n        final int numHandlers \u003d codeHandlerCount.get(i - removed);\r\n        final int maxLocals \u003d codeMaxLocals.get(i - removed);\r\n        final int maxStack \u003d codeMaxStack.get(i - removed);\r\n        switch(numHandlers) {\r\n            case 0:\r\n                {\r\n                    final int header \u003d maxLocals * 12 + maxStack + 1;\r\n                    if (header \u003c 145 \u0026\u0026 maxStack \u003c 12) {\r\n                        codeHeaders[i] \u003d header;\r\n                    }\r\n                    break;\r\n                }\r\n            case 1:\r\n                {\r\n                    final int header \u003d maxLocals * 8 + maxStack + 145;\r\n                    if (header \u003c 209 \u0026\u0026 maxStack \u003c 8) {\r\n                        codeHeaders[i] \u003d header;\r\n                    }\r\n                    break;\r\n                }\r\n            case 2:\r\n                {\r\n                    final int header \u003d maxLocals * 7 + maxStack + 209;\r\n                    if (header \u003c 256 \u0026\u0026 maxStack \u003c 7) {\r\n                        codeHeaders[i] \u003d header;\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n        if (codeHeaders[i] !\u003d 0) {\r\n            // Remove the redundant values from\r\n            // codeHandlerCount, codeMaxLocals and\r\n            // codeMaxStack\r\n            codeHandlerCount.remove(i - removed);\r\n            codeMaxLocals.remove(i - removed);\r\n            codeMaxStack.remove(i - removed);\r\n            removed++;\r\n        } else if (!segment.getSegmentHeader().have_all_code_flags()) {\r\n            codeFlags.add(Long.valueOf(0));\r\n        }\r\n    }\r\n    // Compute any required IcLocals\r\n    final IntList innerClassesN \u003d new IntList();\r\n    final List\u003cIcTuple\u003e icLocal \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c class_this.length; i++) {\r\n        final CPClass cpClass \u003d class_this[i];\r\n        final Set\u003cCPClass\u003e referencedInnerClasses \u003d classReferencesInnerClass.get(cpClass);\r\n        if (referencedInnerClasses !\u003d null) {\r\n            int innerN \u003d 0;\r\n            final List\u003cIcTuple\u003e innerClasses \u003d segment.getIcBands().getInnerClassesForOuter(cpClass.toString());\r\n            if (innerClasses !\u003d null) {\r\n                for (final IcTuple element : innerClasses) {\r\n                    referencedInnerClasses.remove(element.C);\r\n                }\r\n            }\r\n            for (final CPClass inner : referencedInnerClasses) {\r\n                final IcTuple icTuple \u003d segment.getIcBands().getIcTuple(inner);\r\n                if (icTuple !\u003d null \u0026\u0026 !icTuple.isAnonymous()) {\r\n                    // should transmit an icLocal entry\r\n                    icLocal.add(icTuple);\r\n                    innerN++;\r\n                }\r\n            }\r\n            if (innerN !\u003d 0) {\r\n                innerClassesN.add(innerN);\r\n                class_flags[i] |\u003d 1 \u003c\u003c 23;\r\n            }\r\n        }\r\n    }\r\n    class_InnerClasses_N \u003d innerClassesN.toArray();\r\n    class_InnerClasses_RC \u003d new CPClass[icLocal.size()];\r\n    class_InnerClasses_F \u003d new int[icLocal.size()];\r\n    classInnerClassesOuterRCN \u003d new ArrayList\u003c\u003e();\r\n    classInnerClassesNameRUN \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c class_InnerClasses_RC.length; i++) {\r\n        final IcTuple icTuple \u003d icLocal.get(i);\r\n        class_InnerClasses_RC[i] \u003d icTuple.C;\r\n        if (icTuple.C2 \u003d\u003d null \u0026\u0026 icTuple.N \u003d\u003d null) {\r\n            class_InnerClasses_F[i] \u003d 0;\r\n        } else {\r\n            if (icTuple.F \u003d\u003d 0) {\r\n                class_InnerClasses_F[i] \u003d 0x00010000;\r\n            } else {\r\n                class_InnerClasses_F[i] \u003d icTuple.F;\r\n            }\r\n            classInnerClassesOuterRCN.add(icTuple.C2);\r\n            classInnerClassesNameRUN.add(icTuple.N);\r\n        }\r\n    }\r\n    // Calculate any backwards calls from metadata bands\r\n    final IntList classAttrCalls \u003d new IntList();\r\n    final IntList fieldAttrCalls \u003d new IntList();\r\n    final IntList methodAttrCalls \u003d new IntList();\r\n    final IntList codeAttrCalls \u003d new IntList();\r\n    if (class_RVA_bands.hasContent()) {\r\n        classAttrCalls.add(class_RVA_bands.numBackwardsCalls());\r\n    }\r\n    if (class_RIA_bands.hasContent()) {\r\n        classAttrCalls.add(class_RIA_bands.numBackwardsCalls());\r\n    }\r\n    if (field_RVA_bands.hasContent()) {\r\n        fieldAttrCalls.add(field_RVA_bands.numBackwardsCalls());\r\n    }\r\n    if (field_RIA_bands.hasContent()) {\r\n        fieldAttrCalls.add(field_RIA_bands.numBackwardsCalls());\r\n    }\r\n    if (method_RVA_bands.hasContent()) {\r\n        methodAttrCalls.add(method_RVA_bands.numBackwardsCalls());\r\n    }\r\n    if (method_RIA_bands.hasContent()) {\r\n        methodAttrCalls.add(method_RIA_bands.numBackwardsCalls());\r\n    }\r\n    if (method_RVPA_bands.hasContent()) {\r\n        methodAttrCalls.add(method_RVPA_bands.numBackwardsCalls());\r\n    }\r\n    if (method_RIPA_bands.hasContent()) {\r\n        methodAttrCalls.add(method_RIPA_bands.numBackwardsCalls());\r\n    }\r\n    if (method_AD_bands.hasContent()) {\r\n        methodAttrCalls.add(method_AD_bands.numBackwardsCalls());\r\n    }\r\n    // Sort non-predefined attribute bands\r\n    final Comparator\u003cNewAttributeBands\u003e comparator \u003d (arg0, arg1) -\u003e arg0.getFlagIndex() - arg1.getFlagIndex();\r\n    classAttributeBands.sort(comparator);\r\n    methodAttributeBands.sort(comparator);\r\n    fieldAttributeBands.sort(comparator);\r\n    codeAttributeBands.sort(comparator);\r\n    for (final NewAttributeBands bands : classAttributeBands) {\r\n        if (bands.isUsedAtLeastOnce()) {\r\n            for (final int backwardsCallCount : bands.numBackwardsCalls()) {\r\n                classAttrCalls.add(backwardsCallCount);\r\n            }\r\n        }\r\n    }\r\n    for (final NewAttributeBands bands : methodAttributeBands) {\r\n        if (bands.isUsedAtLeastOnce()) {\r\n            for (final int backwardsCallCount : bands.numBackwardsCalls()) {\r\n                methodAttrCalls.add(backwardsCallCount);\r\n            }\r\n        }\r\n    }\r\n    for (final NewAttributeBands bands : fieldAttributeBands) {\r\n        if (bands.isUsedAtLeastOnce()) {\r\n            for (final int backwardsCallCount : bands.numBackwardsCalls()) {\r\n                fieldAttrCalls.add(backwardsCallCount);\r\n            }\r\n        }\r\n    }\r\n    for (final NewAttributeBands bands : codeAttributeBands) {\r\n        if (bands.isUsedAtLeastOnce()) {\r\n            for (final int backwardsCallCount : bands.numBackwardsCalls()) {\r\n                codeAttrCalls.add(backwardsCallCount);\r\n            }\r\n        }\r\n    }\r\n    class_attr_calls \u003d classAttrCalls.toArray();\r\n    field_attr_calls \u003d fieldAttrCalls.toArray();\r\n    method_attr_calls \u003d methodAttrCalls.toArray();\r\n    code_attr_calls \u003d codeAttrCalls.toArray();\r\n}",
    "nodes": 95,
    "edges": 141,
    "cc": 48,
    "flowSummary": [
      "B1 : If(i35 \u003e\u003d $i1) → B2 | else → B5",
      "B2 : If(i36 \u003d\u003d i0) → B3 | else → B4",
      "B6 : If(i38 \u003e\u003d $i3) → B7 | else → B22",
      "B7 : If(switch-on i39) → B8 | else → B11",
      "B8 : If(i42 \u003e\u003d 145) → B9 | else → B17",
      "B9 : If(i41 \u003e\u003d 12) → B10 | else → B17",
      "B11 : If(i43 \u003e\u003d 209) → B12 | else → B17",
      "B12 : If(i41 \u003e\u003d 8) → B13 | else → B17",
      "B14 : If(i44 \u003e\u003d 256) → B15 | else → B17",
      "B15 : If(i41 \u003e\u003d 7) → B16 | else → B17",
      "B17 : If($i45 \u003d\u003d false) → B18 | else → B19",
      "B19 : If($z18 !\u003d 0) → B20 | else → B21",
      "B23 : If(i46 \u003e\u003d $i4) → B24 | else → B38",
      "B24 : If(r99 \u003d\u003d null) → B25 | else → B37",
      "B25 : If(r100 \u003d\u003d null) → B26 | else → B29",
      "B27 : If($z17 \u003d\u003d false) → B28 | else → B29",
      "B30 : If($z19 \u003d\u003d false) → B31 | else → B35",
      "B31 : If(r104 \u003d\u003d null) → B32 | else → B34",
      "B32 : If($z16 !\u003d 0) → B33 | else → B34",
      "B35 : If(i47 \u003d\u003d false) → B36 | else → B37",
      "B39 : If(i48 \u003e\u003d $i7) → B40 | else → B48",
      "B40 : If($r58 !\u003d null) → B41 | else → B43",
      "B41 : If($r65 !\u003d null) → B42 | else → B43",
      "B43 : If($i17 !\u003d 0) → B44 | else → B45",
      "B48 : If($z0 \u003d\u003d false) → B49 | else → B50",
      "B50 : If($z1 \u003d\u003d false) → B51 | else → B52",
      "B52 : If($z2 \u003d\u003d false) → B53 | else → B54",
      "B54 : If($z3 \u003d\u003d false) → B55 | else → B56",
      "B56 : If($z4 \u003d\u003d false) → B57 | else → B58",
      "B58 : If($z5 \u003d\u003d false) → B59 | else → B60",
      "B60 : If($z6 \u003d\u003d false) → B61 | else → B62",
      "B62 : If($z7 \u003d\u003d false) → B63 | else → B64",
      "B64 : If($z8 \u003d\u003d false) → B65 | else → B66",
      "B67 : If($z20 \u003d\u003d false) → B68 | else → B73",
      "B68 : If($z15 \u003d\u003d false) → B69 | else → B72",
      "B70 : If(i50 \u003e\u003d i49) → B71 | else → B72",
      "B74 : If($z9 \u003d\u003d false) → B75 | else → B80",
      "B75 : If($z14 \u003d\u003d false) → B76 | else → B79",
      "B77 : If(i53 \u003e\u003d i52) → B78 | else → B79",
      "B81 : If($z10 \u003d\u003d false) → B82 | else → B87",
      "B82 : If($z13 \u003d\u003d false) → B83 | else → B86",
      "B84 : If(i56 \u003e\u003d i55) → B85 | else → B86",
      "B88 : If($z11 \u003d\u003d false) → B89 | else → B94",
      "B89 : If($z12 \u003d\u003d false) → B90 | else → B93",
      "B91 : If(i59 \u003e\u003d i58) → B92 | else → B93"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d SegmentHeader segmentHeader\u003e\n  i0 \u003d $r1.getDefaultMajorVersion()\n  i35 \u003d 0\n}",
      "B1 {\n  $r2 \u003d ClassBands: long[] class_flags\u003e\n  $i1 \u003d lengthof $r2\n  if (i35 \u003e\u003d $i1) goto B2 else B5\n}",
      "B2 {\n  $r93 \u003d ClassBands: int[] major_versions\u003e\n  i36 \u003d $r93[i35]\n  if (i36 \u003d\u003d i0) goto B3 else B4\n}",
      "B3 {\n  $r94 \u003d ClassBands: long[] class_flags\u003e\n  $l33 \u003d $r94[i35]\n  $l34 \u003d $l33 | 16777216L\n  $r94[i35] \u003d $l34\n  $r95 \u003d IntList classFileVersionMajor\u003e\n  $r95.add(i36)\n  $r96 \u003d IntList classFileVersionMinor\u003e\n  $r96.add(0)\n}",
      "B4 {\n  i35 \u003d i35 + 1\n  goto B1\n}",
      "B5 {\n  $r3 \u003d IntList codeHandlerCount\u003e\n  $i2 \u003d $r3.size()\n  $r4 \u003d newarray (int)[$i2]\n  ClassBands: int[] codeHeaders\u003e \u003d $r4\n  i37 \u003d 0\n  i38 \u003d 0\n}",
      "B6 {\n  $r5 \u003d ClassBands: int[] codeHeaders\u003e\n  $i3 \u003d lengthof $r5\n  if (i38 \u003e\u003d $i3) goto B7 else B22\n}",
      "B7 {\n  $r80 \u003d IntList codeHandlerCount\u003e\n  $i21 \u003d i38 - i37\n  i39 \u003d $r80.get($i21)\n  $r81 \u003d IntList codeMaxLocals\u003e\n  $i22 \u003d i38 - i37\n  i40 \u003d $r81.get($i22)\n  $r82 \u003d IntList codeMaxStack\u003e\n  $i23 \u003d i38 - i37\n  i41 \u003d $r82.get($i23)\n  ClassBands: int[] codeHeaders\u003e; }\n}",
      "B8 {\n  $i31 \u003d i40 * 12\n  $i32 \u003d $i31 + i41\n  i42 \u003d $i32 + 1\n  if (i42 \u003e\u003d 145) goto B9 else B17\n}",
      "B9 {\n  if (i41 \u003e\u003d 12) goto B10 else B17\n}",
      "B10 {\n  $r92 \u003d ClassBands: int[] codeHeaders\u003e\n  $r92[i38] \u003d i42\n  goto B17\n}",
      "B11 {\n  $i29 \u003d i40 * 8\n  $i30 \u003d $i29 + i41\n  i43 \u003d $i30 + 145\n  if (i43 \u003e\u003d 209) goto B12 else B17\n}",
      "B12 {\n  if (i41 \u003e\u003d 8) goto B13 else B17\n}",
      "B13 {\n  $r91 \u003d ClassBands: int[] codeHeaders\u003e\n  $r91[i38] \u003d i43\n  goto B17\n}",
      "B14 {\n  $i24 \u003d i40 * 7\n  $i25 \u003d $i24 + i41\n  i44 \u003d $i25 + 209\n  if (i44 \u003e\u003d 256) goto B15 else B17\n}",
      "B15 {\n  if (i41 \u003e\u003d 7) goto B16 else B17\n}",
      "B16 {\n  $r90 \u003d ClassBands: int[] codeHeaders\u003e\n  $r90[i38] \u003d i44\n  goto B17\n}",
      "B17 {\n  $r97 \u003d ClassBands: int[] codeHeaders\u003e\n  $i45 \u003d $r97[i38]\n  if ($i45 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r87 \u003d IntList codeHandlerCount\u003e\n  $i26 \u003d i38 - i37\n  $r87.remove($i26)\n  $r88 \u003d IntList codeMaxLocals\u003e\n  $i27 \u003d i38 - i37\n  $r88.remove($i27)\n  $r89 \u003d IntList codeMaxStack\u003e\n  $i28 \u003d i38 - i37\n  $r89.remove($i28)\n  i37 \u003d i37 + 1\n  goto B21\n}",
      "B19 {\n  $r83 \u003d Segment segment\u003e\n  $r84 \u003d $r83.getSegmentHeader()\n  $z18 \u003d $r84.have_all_code_flags()\n  if ($z18 !\u003d 0) goto B20 else B21\n}",
      "B20 {\n  $r85 \u003d List codeFlags\u003e\n  $r86 \u003d Long.valueOf(0L)\n  $r85.add($r86)\n}",
      "B21 {\n  i38 \u003d i38 + 1\n  goto B6\n}",
      "B22 {\n  $r6 \u003d IntList\n  new IntList()\n  $r7 \u003d ArrayList\n  new ArrayList()\n  i46 \u003d 0\n}",
      "B23 {\n  $r8 \u003d CPClass[] class_this\u003e\n  $i4 \u003d lengthof $r8\n  if (i46 \u003e\u003d $i4) goto B24 else B38\n}",
      "B24 {\n  $r67 \u003d CPClass[] class_this\u003e\n  r98 \u003d $r67[i46]\n  $r68 \u003d Map classReferencesInnerClass\u003e\n  $r69 \u003d $r68.get(r98)\n  r99 \u003d Set) $r69\n  if (r99 \u003d\u003d null) goto B25 else B37\n}",
      "B25 {\n  i47 \u003d 0\n  $r70 \u003d Segment segment\u003e\n  $r72 \u003d $r70.getIcBands()\n  $r71 \u003d r98.toString()\n  r100 \u003d $r72.getInnerClassesForOuter($r71)\n  if (r100 \u003d\u003d null) goto B26 else B29\n}",
      "B26 {\n  r101 \u003d r100.iterator()\n}",
      "B27 {\n  $z17 \u003d r101.hasNext()\n  if ($z17 \u003d\u003d false) goto B28 else B29\n}",
      "B28 {\n  $r78 \u003d r101.next()\n  r102 \u003d IcBands$IcTuple) $r78\n  $r79 \u003d CPClass C\u003e\n  r99.remove($r79)\n  goto B27\n}",
      "B29 {\n  $r77 \u003d r99.iterator()\n}",
      "B30 {\n  $z19 \u003d $r77.hasNext()\n  if ($z19 \u003d\u003d false) goto B31 else B35\n}",
      "B31 {\n  $r74 \u003d $r77.next()\n  r103 \u003d CPClass) $r74\n  $r75 \u003d Segment segment\u003e\n  $r76 \u003d $r75.getIcBands()\n  r104 \u003d $r76.getIcTuple(r103)\n  if (r104 \u003d\u003d null) goto B32 else B34\n}",
      "B32 {\n  $z16 \u003d r104.isAnonymous()\n  if ($z16 !\u003d 0) goto B33 else B34\n}",
      "B33 {\n  $r7.add(r104)\n  i47 \u003d i47 + 1\n}",
      "B34 {\n  goto B30\n}",
      "B35 {\n  if (i47 \u003d\u003d false) goto B36 else B37\n}",
      "B36 {\n  $r6.add(i47)\n  $r73 \u003d ClassBands: long[] class_flags\u003e\n  $l19 \u003d $r73[i46]\n  $l20 \u003d $l19 | 8388608L\n  $r73[i46] \u003d $l20\n}",
      "B37 {\n  i46 \u003d i46 + 1\n  goto B23\n}",
      "B38 {\n  $r9 \u003d $r6.toArray()\n  ClassBands: int[] class_InnerClasses_N\u003e \u003d $r9\n  $i5 \u003d $r7.size()\n  $r10 \u003d CPClass)[$i5]\n  CPClass[] class_InnerClasses_RC\u003e \u003d $r10\n  $i6 \u003d $r7.size()\n  $r11 \u003d newarray (int)[$i6]\n  ClassBands: int[] class_InnerClasses_F\u003e \u003d $r11\n  $r12 \u003d ArrayList\n  new ArrayList()\n  List classInnerClassesOuterRCN\u003e \u003d $r12\n  $r13 \u003d ArrayList\n  new ArrayList()\n  List classInnerClassesNameRUN\u003e \u003d $r13\n  i48 \u003d 0\n}",
      "B39 {\n  $r14 \u003d CPClass[] class_InnerClasses_RC\u003e\n  $i7 \u003d lengthof $r14\n  if (i48 \u003e\u003d $i7) goto B40 else B48\n}",
      "B40 {\n  $r55 \u003d $r7.get(i48)\n  r105 \u003d IcBands$IcTuple) $r55\n  $r57 \u003d CPClass[] class_InnerClasses_RC\u003e\n  $r56 \u003d CPClass C\u003e\n  $r57[i48] \u003d $r56\n  $r58 \u003d CPClass C2\u003e\n  if ($r58 !\u003d null) goto B41 else B43\n}",
      "B41 {\n  $r65 \u003d CPUTF8 N\u003e\n  if ($r65 !\u003d null) goto B42 else B43\n}",
      "B42 {\n  $r66 \u003d ClassBands: int[] class_InnerClasses_F\u003e\n  $r66[i48] \u003d 0\n  goto B47\n}",
      "B43 {\n  $i17 \u003d IcBands$IcTuple: int F\u003e\n  if ($i17 !\u003d 0) goto B44 else B45\n}",
      "B44 {\n  $r64 \u003d ClassBands: int[] class_InnerClasses_F\u003e\n  $r64[i48] \u003d 65536\n  goto B46\n}",
      "B45 {\n  $r59 \u003d ClassBands: int[] class_InnerClasses_F\u003e\n  $i18 \u003d IcBands$IcTuple: int F\u003e\n  $r59[i48] \u003d $i18\n}",
      "B46 {\n  $r61 \u003d List classInnerClassesOuterRCN\u003e\n  $r60 \u003d CPClass C2\u003e\n  $r61.add($r60)\n  $r63 \u003d List classInnerClassesNameRUN\u003e\n  $r62 \u003d CPUTF8 N\u003e\n  $r63.add($r62)\n}",
      "B47 {\n  i48 \u003d i48 + 1\n  goto B39\n}",
      "B48 {\n  $r15 \u003d IntList\n  new IntList()\n  $r16 \u003d IntList\n  new IntList()\n  $r17 \u003d IntList\n  new IntList()\n  $r18 \u003d IntList\n  new IntList()\n  $r19 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $z0 \u003d $r19.hasContent()\n  if ($z0 \u003d\u003d false) goto B49 else B50\n}",
      "B49 {\n  $r54 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $i16 \u003d $r54.numBackwardsCalls()\n  $r15.add($i16)\n}",
      "B50 {\n  $r20 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $z1 \u003d $r20.hasContent()\n  if ($z1 \u003d\u003d false) goto B51 else B52\n}",
      "B51 {\n  $r53 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $i15 \u003d $r53.numBackwardsCalls()\n  $r15.add($i15)\n}",
      "B52 {\n  $r21 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $z2 \u003d $r21.hasContent()\n  if ($z2 \u003d\u003d false) goto B53 else B54\n}",
      "B53 {\n  $r52 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $i14 \u003d $r52.numBackwardsCalls()\n  $r16.add($i14)\n}",
      "B54 {\n  $r22 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $z3 \u003d $r22.hasContent()\n  if ($z3 \u003d\u003d false) goto B55 else B56\n}",
      "B55 {\n  $r51 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $i13 \u003d $r51.numBackwardsCalls()\n  $r16.add($i13)\n}",
      "B56 {\n  $r23 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $z4 \u003d $r23.hasContent()\n  if ($z4 \u003d\u003d false) goto B57 else B58\n}",
      "B57 {\n  $r50 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $i12 \u003d $r50.numBackwardsCalls()\n  $r17.add($i12)\n}",
      "B58 {\n  $r24 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $z5 \u003d $r24.hasContent()\n  if ($z5 \u003d\u003d false) goto B59 else B60\n}",
      "B59 {\n  $r49 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $i11 \u003d $r49.numBackwardsCalls()\n  $r17.add($i11)\n}",
      "B60 {\n  $r25 \u003d MetadataBandGroup method_RVPA_bands\u003e\n  $z6 \u003d $r25.hasContent()\n  if ($z6 \u003d\u003d false) goto B61 else B62\n}",
      "B61 {\n  $r48 \u003d MetadataBandGroup method_RVPA_bands\u003e\n  $i10 \u003d $r48.numBackwardsCalls()\n  $r17.add($i10)\n}",
      "B62 {\n  $r26 \u003d MetadataBandGroup method_RIPA_bands\u003e\n  $z7 \u003d $r26.hasContent()\n  if ($z7 \u003d\u003d false) goto B63 else B64\n}",
      "B63 {\n  $r47 \u003d MetadataBandGroup method_RIPA_bands\u003e\n  $i9 \u003d $r47.numBackwardsCalls()\n  $r17.add($i9)\n}",
      "B64 {\n  $r27 \u003d MetadataBandGroup method_AD_bands\u003e\n  $z8 \u003d $r27.hasContent()\n  if ($z8 \u003d\u003d false) goto B65 else B66\n}",
      "B65 {\n  $r44 \u003d MetadataBandGroup method_AD_bands\u003e\n  $i8 \u003d $r44.numBackwardsCalls()\n  $r17.add($i8)\n}",
      "B66 {\n  $r45 \u003d ClassBands$lambda_finaliseBands_2__32.bootstrap$()\n  $r28 \u003d List classAttributeBands\u003e\n  $r28.sort($r45)\n  $r29 \u003d List methodAttributeBands\u003e\n  $r29.sort($r45)\n  $r30 \u003d List fieldAttributeBands\u003e\n  $r30.sort($r45)\n  $r31 \u003d List codeAttributeBands\u003e\n  $r31.sort($r45)\n  $r32 \u003d List classAttributeBands\u003e\n  $r46 \u003d $r32.iterator()\n}",
      "B67 {\n  $z20 \u003d $r46.hasNext()\n  if ($z20 \u003d\u003d false) goto B68 else B73\n}",
      "B68 {\n  $r43 \u003d $r46.next()\n  r106 \u003d NewAttributeBands) $r43\n  $z15 \u003d r106.isUsedAtLeastOnce()\n  if ($z15 \u003d\u003d false) goto B69 else B72\n}",
      "B69 {\n  r107 \u003d r106.numBackwardsCalls()\n  i49 \u003d lengthof r107\n  i50 \u003d 0\n}",
      "B70 {\n  if (i50 \u003e\u003d i49) goto B71 else B72\n}",
      "B71 {\n  i51 \u003d r107[i50]\n  $r15.add(i51)\n  i50 \u003d i50 + 1\n  goto B70\n}",
      "B72 {\n  goto B67\n}",
      "B73 {\n  $r33 \u003d List methodAttributeBands\u003e\n  r108 \u003d $r33.iterator()\n}",
      "B74 {\n  $z9 \u003d r108.hasNext()\n  if ($z9 \u003d\u003d false) goto B75 else B80\n}",
      "B75 {\n  $r42 \u003d r108.next()\n  r109 \u003d NewAttributeBands) $r42\n  $z14 \u003d r109.isUsedAtLeastOnce()\n  if ($z14 \u003d\u003d false) goto B76 else B79\n}",
      "B76 {\n  r110 \u003d r109.numBackwardsCalls()\n  i52 \u003d lengthof r110\n  i53 \u003d 0\n}",
      "B77 {\n  if (i53 \u003e\u003d i52) goto B78 else B79\n}",
      "B78 {\n  i54 \u003d r110[i53]\n  $r17.add(i54)\n  i53 \u003d i53 + 1\n  goto B77\n}",
      "B79 {\n  goto B74\n}",
      "B80 {\n  $r34 \u003d List fieldAttributeBands\u003e\n  r111 \u003d $r34.iterator()\n}",
      "B81 {\n  $z10 \u003d r111.hasNext()\n  if ($z10 \u003d\u003d false) goto B82 else B87\n}",
      "B82 {\n  $r41 \u003d r111.next()\n  r112 \u003d NewAttributeBands) $r41\n  $z13 \u003d r112.isUsedAtLeastOnce()\n  if ($z13 \u003d\u003d false) goto B83 else B86\n}",
      "B83 {\n  r113 \u003d r112.numBackwardsCalls()\n  i55 \u003d lengthof r113\n  i56 \u003d 0\n}",
      "B84 {\n  if (i56 \u003e\u003d i55) goto B85 else B86\n}",
      "B85 {\n  i57 \u003d r113[i56]\n  $r16.add(i57)\n  i56 \u003d i56 + 1\n  goto B84\n}",
      "B86 {\n  goto B81\n}",
      "B87 {\n  $r35 \u003d List codeAttributeBands\u003e\n  r114 \u003d $r35.iterator()\n}",
      "B88 {\n  $z11 \u003d r114.hasNext()\n  if ($z11 \u003d\u003d false) goto B89 else B94\n}",
      "B89 {\n  $r40 \u003d r114.next()\n  r115 \u003d NewAttributeBands) $r40\n  $z12 \u003d r115.isUsedAtLeastOnce()\n  if ($z12 \u003d\u003d false) goto B90 else B93\n}",
      "B90 {\n  r116 \u003d r115.numBackwardsCalls()\n  i58 \u003d lengthof r116\n  i59 \u003d 0\n}",
      "B91 {\n  if (i59 \u003e\u003d i58) goto B92 else B93\n}",
      "B92 {\n  i60 \u003d r116[i59]\n  $r18.add(i60)\n  i59 \u003d i59 + 1\n  goto B91\n}",
      "B93 {\n  goto B88\n}",
      "B94 {\n  $r36 \u003d $r15.toArray()\n  ClassBands: int[] class_attr_calls\u003e \u003d $r36\n  $r37 \u003d $r16.toArray()\n  ClassBands: int[] field_attr_calls\u003e \u003d $r37\n  $r38 \u003d $r17.toArray()\n  ClassBands: int[] method_attr_calls\u003e \u003d $r38\n  $r39 \u003d $r18.toArray()\n  ClassBands: int[] code_attr_calls\u003e \u003d $r39\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B22",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B7 --\u003e B14",
      "B7 --\u003e B17",
      "B8 --\u003e B9",
      "B8 --\u003e B17",
      "B9 --\u003e B10",
      "B9 --\u003e B17",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B17",
      "B12 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B21",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B6",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B38",
      "B24 --\u003e B25",
      "B24 --\u003e B37",
      "B25 --\u003e B26",
      "B25 --\u003e B29",
      "B26 --\u003e B27",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B27",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B30 --\u003e B35",
      "B31 --\u003e B32",
      "B31 --\u003e B34",
      "B32 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e B30",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e B37",
      "B37 --\u003e B23",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B39 --\u003e B48",
      "B40 --\u003e B41",
      "B40 --\u003e B43",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B47",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B46",
      "B46 --\u003e B47",
      "B47 --\u003e B39",
      "B48 --\u003e B49",
      "B48 --\u003e B50",
      "B49 --\u003e B50",
      "B50 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B54",
      "B54 --\u003e B55",
      "B54 --\u003e B56",
      "B55 --\u003e B56",
      "B56 --\u003e B57",
      "B56 --\u003e B58",
      "B57 --\u003e B58",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B62",
      "B61 --\u003e B62",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B65",
      "B64 --\u003e B66",
      "B65 --\u003e B66",
      "B66 --\u003e B67",
      "B67 --\u003e B68",
      "B67 --\u003e B73",
      "B68 --\u003e B69",
      "B68 --\u003e B72",
      "B69 --\u003e B70",
      "B70 --\u003e B71",
      "B70 --\u003e B72",
      "B71 --\u003e B70",
      "B72 --\u003e B67",
      "B73 --\u003e B74",
      "B74 --\u003e B75",
      "B74 --\u003e B80",
      "B75 --\u003e B76",
      "B75 --\u003e B79",
      "B76 --\u003e B77",
      "B77 --\u003e B78",
      "B77 --\u003e B79",
      "B78 --\u003e B77",
      "B79 --\u003e B74",
      "B80 --\u003e B81",
      "B81 --\u003e B82",
      "B81 --\u003e B87",
      "B82 --\u003e B83",
      "B82 --\u003e B86",
      "B83 --\u003e B84",
      "B84 --\u003e B85",
      "B84 --\u003e B86",
      "B85 --\u003e B84",
      "B86 --\u003e B81",
      "B87 --\u003e B88",
      "B88 --\u003e B89",
      "B88 --\u003e B94",
      "B89 --\u003e B90",
      "B89 --\u003e B93",
      "B90 --\u003e B91",
      "B91 --\u003e B92",
      "B91 --\u003e B93",
      "B92 --\u003e B91",
      "B93 --\u003e B88",
      "B94 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    PackingUtils.log(\"Writing class bands...\");\r\n    byte[] encodedBand \u003d encodeBandInt(\"class_this\", getInts(class_this), Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_this[\" + class_this.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_super\", getInts(class_super), Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_super[\" + class_super.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_interface_count\", class_interface_count, Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_interface_count[\" + class_interface_count.length + \"]\");\r\n    final int totalInterfaces \u003d sum(class_interface_count);\r\n    final int[] classInterface \u003d new int[totalInterfaces];\r\n    int k \u003d 0;\r\n    for (final CPClass[] element : class_interface) {\r\n        if (element !\u003d null) {\r\n            for (final CPClass cpClass : element) {\r\n                classInterface[k] \u003d cpClass.getIndex();\r\n                k++;\r\n            }\r\n        }\r\n    }\r\n    encodedBand \u003d encodeBandInt(\"class_interface\", classInterface, Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_interface[\" + classInterface.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_field_count\", class_field_count, Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_field_count[\" + class_field_count.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_method_count\", class_method_count, Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_method_count[\" + class_method_count.length + \"]\");\r\n    final int totalFields \u003d sum(class_field_count);\r\n    final int[] fieldDescr \u003d new int[totalFields];\r\n    k \u003d 0;\r\n    for (int i \u003d 0; i \u003c index; i++) {\r\n        for (int j \u003d 0; j \u003c field_descr[i].length; j++) {\r\n            final CPNameAndType descr \u003d field_descr[i][j];\r\n            fieldDescr[k] \u003d descr.getIndex();\r\n            k++;\r\n        }\r\n    }\r\n    encodedBand \u003d encodeBandInt(\"field_descr\", fieldDescr, Codec.DELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from field_descr[\" + fieldDescr.length + \"]\");\r\n    writeFieldAttributeBands(out);\r\n    final int totalMethods \u003d sum(class_method_count);\r\n    final int[] methodDescr \u003d new int[totalMethods];\r\n    k \u003d 0;\r\n    for (int i \u003d 0; i \u003c index; i++) {\r\n        for (int j \u003d 0; j \u003c method_descr[i].length; j++) {\r\n            final CPNameAndType descr \u003d method_descr[i][j];\r\n            methodDescr[k] \u003d descr.getIndex();\r\n            k++;\r\n        }\r\n    }\r\n    encodedBand \u003d encodeBandInt(\"method_descr\", methodDescr, Codec.MDELTA5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from method_descr[\" + methodDescr.length + \"]\");\r\n    writeMethodAttributeBands(out);\r\n    writeClassAttributeBands(out);\r\n    writeCodeBands(out);\r\n}",
    "nodes": 20,
    "edges": 26,
    "cc": 8,
    "flowSummary": [
      "B1 : If(i26 \u003e\u003d i25) → B2 | else → B7",
      "B2 : If(r95 \u003d\u003d null) → B3 | else → B6",
      "B4 : If(i28 \u003e\u003d i27) → B5 | else → B6",
      "B8 : If(i31 \u003e\u003d $i13) → B9 | else → B13",
      "B10 : If(i32 \u003e\u003d $i21) → B11 | else → B12",
      "B14 : If(i35 \u003e\u003d $i16) → B15 | else → B19",
      "B16 : If(i36 \u003e\u003d $i19) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  OutputStream\n  PackingUtils.log(\"Writing class bands...\")\n  $r1 \u003d CPClass[] class_this\u003e\n  $r3 \u003d r0.getInts($r1)\n  $r2 \u003d BHSDCodec DELTA5\u003e\n  r91 \u003d r0.encodeBandInt(\"class_this\", $r3, $r2)\n  r4.write(r91)\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r5.append(\"Wrote \")\n  $i0 \u003d lengthof r91\n  $r7 \u003d $r6.append($i0)\n  $r9 \u003d $r7.append(\" bytes from class_this\")\n  $r8 \u003d CPClass[] class_this\u003e\n  $i1 \u003d lengthof $r8\n  $r10 \u003d $r9.append($i1)\n  $r11 \u003d $r10.append(\"\")\n  $r12 \u003d $r11.toString()\n  PackingUtils.log($r12)\n  $r13 \u003d CPClass[] class_super\u003e\n  $r15 \u003d r0.getInts($r13)\n  $r14 \u003d BHSDCodec DELTA5\u003e\n  r92 \u003d r0.encodeBandInt(\"class_super\", $r15, $r14)\n  r4.write(r92)\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r17 \u003d $r16.append(\"Wrote \")\n  $i2 \u003d lengthof r92\n  $r18 \u003d $r17.append($i2)\n  $r20 \u003d $r18.append(\" bytes from class_super\")\n  $r19 \u003d CPClass[] class_super\u003e\n  $i3 \u003d lengthof $r19\n  $r21 \u003d $r20.append($i3)\n  $r22 \u003d $r21.append(\"\")\n  $r23 \u003d $r22.toString()\n  PackingUtils.log($r23)\n  $r25 \u003d ClassBands: int[] class_interface_count\u003e\n  $r24 \u003d BHSDCodec DELTA5\u003e\n  r93 \u003d r0.encodeBandInt(\"class_interface_count\", $r25, $r24)\n  r4.write(r93)\n  $r26 \u003d StringBuilder\n  new StringBuilder()\n  $r27 \u003d $r26.append(\"Wrote \")\n  $i4 \u003d lengthof r93\n  $r28 \u003d $r27.append($i4)\n  $r30 \u003d $r28.append(\" bytes from class_interface_count\")\n  $r29 \u003d ClassBands: int[] class_interface_count\u003e\n  $i5 \u003d lengthof $r29\n  $r31 \u003d $r30.append($i5)\n  $r32 \u003d $r31.append(\"\")\n  $r33 \u003d $r32.toString()\n  PackingUtils.log($r33)\n  $r34 \u003d ClassBands: int[] class_interface_count\u003e\n  i6 \u003d r0.sum($r34)\n  r35 \u003d newarray (int)[i6]\n  i24 \u003d 0\n  r94 \u003d CPClass[][] class_interface\u003e\n  i25 \u003d lengthof r94\n  i26 \u003d 0\n}",
      "B1 {\n  if (i26 \u003e\u003d i25) goto B2 else B7\n}",
      "B2 {\n  r95 \u003d r94[i26]\n  if (r95 \u003d\u003d null) goto B3 else B6\n}",
      "B3 {\n  i27 \u003d lengthof r95\n  i28 \u003d 0\n}",
      "B4 {\n  if (i28 \u003e\u003d i27) goto B5 else B6\n}",
      "B5 {\n  r90 \u003d r95[i28]\n  $i23 \u003d r90.getIndex()\n  r35[i24] \u003d $i23\n  i24 \u003d i24 + 1\n  i28 \u003d i28 + 1\n  goto B4\n}",
      "B6 {\n  i26 \u003d i26 + 1\n  goto B1\n}",
      "B7 {\n  $r36 \u003d BHSDCodec DELTA5\u003e\n  r96 \u003d r0.encodeBandInt(\"class_interface\", r35, $r36)\n  r4.write(r96)\n  $r37 \u003d StringBuilder\n  new StringBuilder()\n  $r38 \u003d $r37.append(\"Wrote \")\n  $i7 \u003d lengthof r96\n  $r39 \u003d $r38.append($i7)\n  $r40 \u003d $r39.append(\" bytes from class_interface\")\n  $i8 \u003d lengthof r35\n  $r41 \u003d $r40.append($i8)\n  $r42 \u003d $r41.append(\"\")\n  $r43 \u003d $r42.toString()\n  PackingUtils.log($r43)\n  $r45 \u003d ClassBands: int[] class_field_count\u003e\n  $r44 \u003d BHSDCodec DELTA5\u003e\n  r97 \u003d r0.encodeBandInt(\"class_field_count\", $r45, $r44)\n  r4.write(r97)\n  $r46 \u003d StringBuilder\n  new StringBuilder()\n  $r47 \u003d $r46.append(\"Wrote \")\n  $i9 \u003d lengthof r97\n  $r48 \u003d $r47.append($i9)\n  $r50 \u003d $r48.append(\" bytes from class_field_count\")\n  $r49 \u003d ClassBands: int[] class_field_count\u003e\n  $i10 \u003d lengthof $r49\n  $r51 \u003d $r50.append($i10)\n  $r52 \u003d $r51.append(\"\")\n  $r53 \u003d $r52.toString()\n  PackingUtils.log($r53)\n  $r55 \u003d ClassBands: int[] class_method_count\u003e\n  $r54 \u003d BHSDCodec DELTA5\u003e\n  r98 \u003d r0.encodeBandInt(\"class_method_count\", $r55, $r54)\n  r4.write(r98)\n  $r56 \u003d StringBuilder\n  new StringBuilder()\n  $r57 \u003d $r56.append(\"Wrote \")\n  $i11 \u003d lengthof r98\n  $r58 \u003d $r57.append($i11)\n  $r60 \u003d $r58.append(\" bytes from class_method_count\")\n  $r59 \u003d ClassBands: int[] class_method_count\u003e\n  $i12 \u003d lengthof $r59\n  $r61 \u003d $r60.append($i12)\n  $r62 \u003d $r61.append(\"\")\n  $r63 \u003d $r62.toString()\n  PackingUtils.log($r63)\n  $r64 \u003d ClassBands: int[] class_field_count\u003e\n  i29 \u003d r0.sum($r64)\n  r99 \u003d newarray (int)[i29]\n  i30 \u003d 0\n  i31 \u003d 0\n}",
      "B8 {\n  $i13 \u003d ClassBands: int index\u003e\n  if (i31 \u003e\u003d $i13) goto B9 else B13\n}",
      "B9 {\n  i32 \u003d 0\n}",
      "B10 {\n  $r86 \u003d CPNameAndType[][] field_descr\u003e\n  $r87 \u003d $r86[i31]\n  $i21 \u003d lengthof $r87\n  if (i32 \u003e\u003d $i21) goto B11 else B12\n}",
      "B11 {\n  $r88 \u003d CPNameAndType[][] field_descr\u003e\n  $r89 \u003d $r88[i31]\n  r100 \u003d $r89[i32]\n  $i22 \u003d r100.getIndex()\n  r99[i30] \u003d $i22\n  i30 \u003d i30 + 1\n  i32 \u003d i32 + 1\n  goto B10\n}",
      "B12 {\n  i31 \u003d i31 + 1\n  goto B8\n}",
      "B13 {\n  $r65 \u003d BHSDCodec DELTA5\u003e\n  r101 \u003d r0.encodeBandInt(\"field_descr\", r99, $r65)\n  r4.write(r101)\n  $r66 \u003d StringBuilder\n  new StringBuilder()\n  $r67 \u003d $r66.append(\"Wrote \")\n  $i14 \u003d lengthof r101\n  $r68 \u003d $r67.append($i14)\n  $r69 \u003d $r68.append(\" bytes from field_descr\")\n  $i15 \u003d lengthof r99\n  $r70 \u003d $r69.append($i15)\n  $r71 \u003d $r70.append(\"\")\n  $r72 \u003d $r71.toString()\n  PackingUtils.log($r72)\n  r0.writeFieldAttributeBands(r4)\n  $r73 \u003d ClassBands: int[] class_method_count\u003e\n  i33 \u003d r0.sum($r73)\n  r102 \u003d newarray (int)[i33]\n  i34 \u003d 0\n  i35 \u003d 0\n}",
      "B14 {\n  $i16 \u003d ClassBands: int index\u003e\n  if (i35 \u003e\u003d $i16) goto B15 else B19\n}",
      "B15 {\n  i36 \u003d 0\n}",
      "B16 {\n  $r82 \u003d CPNameAndType[][] method_descr\u003e\n  $r83 \u003d $r82[i35]\n  $i19 \u003d lengthof $r83\n  if (i36 \u003e\u003d $i19) goto B17 else B18\n}",
      "B17 {\n  $r84 \u003d CPNameAndType[][] method_descr\u003e\n  $r85 \u003d $r84[i35]\n  r103 \u003d $r85[i36]\n  $i20 \u003d r103.getIndex()\n  r102[i34] \u003d $i20\n  i34 \u003d i34 + 1\n  i36 \u003d i36 + 1\n  goto B16\n}",
      "B18 {\n  i35 \u003d i35 + 1\n  goto B14\n}",
      "B19 {\n  $r74 \u003d BHSDCodec MDELTA5\u003e\n  r104 \u003d r0.encodeBandInt(\"method_descr\", r102, $r74)\n  r4.write(r104)\n  $r75 \u003d StringBuilder\n  new StringBuilder()\n  $r76 \u003d $r75.append(\"Wrote \")\n  $i17 \u003d lengthof r104\n  $r77 \u003d $r76.append($i17)\n  $r78 \u003d $r77.append(\" bytes from method_descr\")\n  $i18 \u003d lengthof r102\n  $r79 \u003d $r78.append($i18)\n  $r80 \u003d $r79.append(\"\")\n  $r81 \u003d $r80.toString()\n  PackingUtils.log($r81)\n  r0.writeMethodAttributeBands(r4)\n  r0.writeClassAttributeBands(r4)\n  r0.writeCodeBands(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e B1",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B8",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B19",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B16",
      "B18 --\u003e B14",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassBands#getInts(...1)",
        "body": "{\r\n    final int[] ints \u003d new int[cpClasses.length];\r\n    for (int i \u003d 0; i \u003c ints.length; i++) {\r\n        if (cpClasses[i] !\u003d null) {\r\n            ints[i] \u003d cpClasses[i].getIndex();\r\n        }\r\n    }\r\n    return ints;\r\n}"
      },
      {
        "name": "ClassBands#sum(...1)",
        "body": "{\r\n    int sum \u003d 0;\r\n    for (final int j : ints) {\r\n        sum +\u003d j;\r\n    }\r\n    return sum;\r\n}"
      },
      {
        "name": "ClassBands#writeCodeBands(...1)",
        "body": "{\r\n    byte[] encodedBand \u003d encodeBandInt(\"codeHeaders\", codeHeaders, Codec.BYTE1);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHeaders[\" + codeHeaders.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeMaxStack\", codeMaxStack.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeMaxStack[\" + codeMaxStack.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeMaxLocals\", codeMaxLocals.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeMaxLocals[\" + codeMaxLocals.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeHandlerCount\", codeHandlerCount.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHandlerCount[\" + codeHandlerCount.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeHandlerStartP\", integerListToArray(codeHandlerStartP), Codec.BCI5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHandlerStartP[\" + codeHandlerStartP.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeHandlerEndPO\", integerListToArray(codeHandlerEndPO), Codec.BRANCH5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHandlerEndPO[\" + codeHandlerEndPO.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeHandlerCatchPO\", integerListToArray(codeHandlerCatchPO), Codec.BRANCH5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHandlerCatchPO[\" + codeHandlerCatchPO.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"codeHandlerClass\", cpEntryOrNullListToArray(codeHandlerClass), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from codeHandlerClass[\" + codeHandlerClass.size() + \"]\");\r\n    writeCodeAttributeBands(out);\r\n}"
      },
      {
        "name": "ClassBands#writeMethodAttributeBands(...1)",
        "body": "{\r\n    byte[] encodedBand \u003d encodeFlags(\"method_flags\", method_flags, Codec.UNSIGNED5, Codec.UNSIGNED5, segmentHeader.have_method_flags_hi());\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from method_flags[\" + method_flags.length + \"]\");\r\n    // *method_attr_count :UNSIGNED5 [COUNT(1\u003c\u003c16,...)]\r\n    // *method_attr_indexes :UNSIGNED5 [SUM(*method_attr_count)]\r\n    encodedBand \u003d encodeBandInt(\"method_attr_calls\", method_attr_calls, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from method_attr_calls[\" + method_attr_calls.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"methodExceptionNumber\", methodExceptionNumber.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from methodExceptionNumber[\" + methodExceptionNumber.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"methodExceptionClasses\", cpEntryListToArray(methodExceptionClasses), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from methodExceptionClasses[\" + methodExceptionClasses.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"methodSignature\", cpEntryListToArray(methodSignature), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from methodSignature[\" + methodSignature.size() + \"]\");\r\n    method_RVA_bands.pack(out);\r\n    method_RIA_bands.pack(out);\r\n    method_RVPA_bands.pack(out);\r\n    method_RIPA_bands.pack(out);\r\n    method_AD_bands.pack(out);\r\n    for (final NewAttributeBands bands : methodAttributeBands) {\r\n        bands.pack(out);\r\n    }\r\n}"
      },
      {
        "name": "ClassBands#writeClassAttributeBands(...1)",
        "body": "{\r\n    byte[] encodedBand \u003d encodeFlags(\"class_flags\", class_flags, Codec.UNSIGNED5, Codec.UNSIGNED5, segmentHeader.have_class_flags_hi());\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_flags[\" + class_flags.length + \"]\");\r\n    // These bands are not needed, but could be used to reduce the size of\r\n    // the archive if there are enough different non-standard attributes\r\n    // defined that segmentHeader.have_class_flags_hi() is true. The same\r\n    // applies to method_attr_count, field_attr_count, code_attr_count etc.\r\n    // *class_attr_count :UNSIGNED5 [COUNT(1\u003c\u003c16,...)]\r\n    // *class_attr_indexes :UNSIGNED5 [SUM(*class_attr_count)]\r\n    encodedBand \u003d encodeBandInt(\"class_attr_calls\", class_attr_calls, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_attr_calls[\" + class_attr_calls.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"classSourceFile\", cpEntryOrNullListToArray(classSourceFile), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from classSourceFile[\" + classSourceFile.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_enclosing_method_RC\", cpEntryListToArray(classEnclosingMethodClass), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_enclosing_method_RC[\" + classEnclosingMethodClass.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_EnclosingMethod_RDN\", cpEntryOrNullListToArray(classEnclosingMethodDesc), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_EnclosingMethod_RDN[\" + classEnclosingMethodDesc.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_Signature_RS\", cpEntryListToArray(classSignature), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_Signature_RS[\" + classSignature.size() + \"]\");\r\n    class_RVA_bands.pack(out);\r\n    class_RIA_bands.pack(out);\r\n    encodedBand \u003d encodeBandInt(\"class_InnerClasses_N\", class_InnerClasses_N, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_InnerClasses_N[\" + class_InnerClasses_N.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_InnerClasses_RC\", getInts(class_InnerClasses_RC), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_InnerClasses_RC[\" + class_InnerClasses_RC.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_InnerClasses_F\", class_InnerClasses_F, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_InnerClasses_F[\" + class_InnerClasses_F.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_InnerClasses_outer_RCN\", cpEntryOrNullListToArray(classInnerClassesOuterRCN), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_InnerClasses_outer_RCN[\" + classInnerClassesOuterRCN.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"class_InnerClasses_name_RUN\", cpEntryOrNullListToArray(classInnerClassesNameRUN), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from class_InnerClasses_name_RUN[\" + classInnerClassesNameRUN.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"classFileVersionMinor\", classFileVersionMinor.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from classFileVersionMinor[\" + classFileVersionMinor.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"classFileVersionMajor\", classFileVersionMajor.toArray(), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from classFileVersionMajor[\" + classFileVersionMajor.size() + \"]\");\r\n    for (final NewAttributeBands classAttributeBand : classAttributeBands) {\r\n        classAttributeBand.pack(out);\r\n    }\r\n}"
      },
      {
        "name": "ClassBands#writeFieldAttributeBands(...1)",
        "body": "{\r\n    byte[] encodedBand \u003d encodeFlags(\"field_flags\", field_flags, Codec.UNSIGNED5, Codec.UNSIGNED5, segmentHeader.have_field_flags_hi());\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from field_flags[\" + field_flags.length + \"]\");\r\n    // *field_attr_count :UNSIGNED5 [COUNT(1\u003c\u003c16,...)]\r\n    // *field_attr_indexes :UNSIGNED5 [SUM(*field_attr_count)]\r\n    encodedBand \u003d encodeBandInt(\"field_attr_calls\", field_attr_calls, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from field_attr_calls[\" + field_attr_calls.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"fieldConstantValueKQ\", cpEntryListToArray(fieldConstantValueKQ), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from fieldConstantValueKQ[\" + fieldConstantValueKQ.size() + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"fieldSignature\", cpEntryListToArray(fieldSignature), Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from fieldSignature[\" + fieldSignature.size() + \"]\");\r\n    field_RVA_bands.pack(out);\r\n    field_RIA_bands.pack(out);\r\n    for (final NewAttributeBands bands : fieldAttributeBands) {\r\n        bands.pack(out);\r\n    }\r\n}"
      },
      {
        "name": "ClassBands#encodeBandInt(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.ClassBands",
    "methodName": "removeCurrentClass",
    "signature": "void removeCurrentClass()",
    "visibility": "public",
    "body": "{\r\n    // Note - this doesn\u0027t remove any entries added to the constant pool but\r\n    // that shouldn\u0027t be a problem\r\n    if ((class_flags[index] \u0026 1 \u003c\u003c 17) !\u003d 0) {\r\n        classSourceFile.remove(classSourceFile.size() - 1);\r\n    }\r\n    if ((class_flags[index] \u0026 1 \u003c\u003c 18) !\u003d 0) {\r\n        classEnclosingMethodClass.remove(classEnclosingMethodClass.size() - 1);\r\n        classEnclosingMethodDesc.remove(classEnclosingMethodDesc.size() - 1);\r\n    }\r\n    if ((class_flags[index] \u0026 1 \u003c\u003c 19) !\u003d 0) {\r\n        classSignature.remove(classSignature.size() - 1);\r\n    }\r\n    if ((class_flags[index] \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n        class_RVA_bands.removeLatest();\r\n    }\r\n    if ((class_flags[index] \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n        class_RIA_bands.removeLatest();\r\n    }\r\n    for (final Long flagsL : tempFieldFlags) {\r\n        final long flags \u003d flagsL.longValue();\r\n        if ((flags \u0026 1 \u003c\u003c 19) !\u003d 0) {\r\n            fieldSignature.remove(fieldSignature.size() - 1);\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 17) !\u003d 0) {\r\n            fieldConstantValueKQ.remove(fieldConstantValueKQ.size() - 1);\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n            field_RVA_bands.removeLatest();\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n            field_RIA_bands.removeLatest();\r\n        }\r\n    }\r\n    for (final Long flagsL : tempMethodFlags) {\r\n        final long flags \u003d flagsL.longValue();\r\n        if ((flags \u0026 1 \u003c\u003c 19) !\u003d 0) {\r\n            methodSignature.remove(methodSignature.size() - 1);\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 18) !\u003d 0) {\r\n            final int exceptions \u003d methodExceptionNumber.remove(methodExceptionNumber.size() - 1);\r\n            for (int i \u003d 0; i \u003c exceptions; i++) {\r\n                methodExceptionClasses.remove(methodExceptionClasses.size() - 1);\r\n            }\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 17) !\u003d 0) {\r\n            // has code attribute\r\n            codeMaxLocals.remove(codeMaxLocals.size() - 1);\r\n            codeMaxStack.remove(codeMaxStack.size() - 1);\r\n            final int handlers \u003d codeHandlerCount.remove(codeHandlerCount.size() - 1);\r\n            for (int i \u003d 0; i \u003c handlers; i++) {\r\n                final int index \u003d codeHandlerStartP.size() - 1;\r\n                codeHandlerStartP.remove(index);\r\n                codeHandlerEndPO.remove(index);\r\n                codeHandlerCatchPO.remove(index);\r\n                codeHandlerClass.remove(index);\r\n            }\r\n            if (!stripDebug) {\r\n                final long cdeFlags \u003d codeFlags.remove(codeFlags.size() - 1).longValue();\r\n                final int numLocalVariables \u003d codeLocalVariableTableN.remove(codeLocalVariableTableN.size() - 1);\r\n                for (int i \u003d 0; i \u003c numLocalVariables; i++) {\r\n                    final int location \u003d codeLocalVariableTableBciP.size() - 1;\r\n                    codeLocalVariableTableBciP.remove(location);\r\n                    codeLocalVariableTableSpanO.remove(location);\r\n                    codeLocalVariableTableNameRU.remove(location);\r\n                    codeLocalVariableTableTypeRS.remove(location);\r\n                    codeLocalVariableTableSlot.remove(location);\r\n                }\r\n                if ((cdeFlags \u0026 1 \u003c\u003c 3) !\u003d 0) {\r\n                    final int numLocalVariablesInTypeTable \u003d codeLocalVariableTypeTableN.remove(codeLocalVariableTypeTableN.size() - 1);\r\n                    for (int i \u003d 0; i \u003c numLocalVariablesInTypeTable; i++) {\r\n                        final int location \u003d codeLocalVariableTypeTableBciP.size() - 1;\r\n                        codeLocalVariableTypeTableBciP.remove(location);\r\n                        codeLocalVariableTypeTableSpanO.remove(location);\r\n                        codeLocalVariableTypeTableNameRU.remove(location);\r\n                        codeLocalVariableTypeTableTypeRS.remove(location);\r\n                        codeLocalVariableTypeTableSlot.remove(location);\r\n                    }\r\n                }\r\n                if ((cdeFlags \u0026 1 \u003c\u003c 1) !\u003d 0) {\r\n                    final int numLineNumbers \u003d codeLineNumberTableN.remove(codeLineNumberTableN.size() - 1);\r\n                    for (int i \u003d 0; i \u003c numLineNumbers; i++) {\r\n                        final int location \u003d codeLineNumberTableBciP.size() - 1;\r\n                        codeLineNumberTableBciP.remove(location);\r\n                        codeLineNumberTableLine.remove(location);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 21) !\u003d 0) {\r\n            method_RVA_bands.removeLatest();\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 22) !\u003d 0) {\r\n            method_RIA_bands.removeLatest();\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 23) !\u003d 0) {\r\n            method_RVPA_bands.removeLatest();\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 24) !\u003d 0) {\r\n            method_RIPA_bands.removeLatest();\r\n        }\r\n        if ((flags \u0026 1 \u003c\u003c 25) !\u003d 0) {\r\n            method_AD_bands.removeLatest();\r\n        }\r\n    }\r\n    class_this[index] \u003d null;\r\n    class_super[index] \u003d null;\r\n    class_interface_count[index] \u003d 0;\r\n    class_interface[index] \u003d null;\r\n    major_versions[index] \u003d 0;\r\n    class_flags[index] \u003d 0;\r\n    tempFieldDesc.clear();\r\n    tempFieldFlags.clear();\r\n    tempMethodDesc.clear();\r\n    tempMethodFlags.clear();\r\n    if (index \u003e 0) {\r\n        index--;\r\n    }\r\n}",
    "nodes": 59,
    "edges": 86,
    "cc": 29,
    "flowSummary": [
      "B0 : If($b3 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($b7 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($b11 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($b15 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($b19 \u003d\u003d false) → B9 | else → B10",
      "B11 : If($z2 \u003d\u003d false) → B12 | else → B21",
      "B12 : If($b74 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($b76 \u003d\u003d false) → B15 | else → B16",
      "B16 : If($b78 \u003d\u003d false) → B17 | else → B18",
      "B18 : If($b80 \u003d\u003d false) → B19 | else → B20",
      "B22 : If($z0 \u003d\u003d false) → B23 | else → B56",
      "B23 : If($b30 \u003d\u003d false) → B24 | else → B25",
      "B25 : If($b32 \u003d\u003d false) → B26 | else → B29",
      "B27 : If(i96 \u003e\u003d i95) → B28 | else → B29",
      "B29 : If($b34 \u003d\u003d false) → B30 | else → B45",
      "B31 : If(i98 \u003e\u003d i97) → B32 | else → B33",
      "B33 : If($z1 !\u003d 0) → B34 | else → B45",
      "B35 : If(i100 \u003e\u003d i53) → B36 | else → B37",
      "B37 : If($b55 \u003d\u003d false) → B38 | else → B41",
      "B39 : If(i103 \u003e\u003d i102) → B40 | else → B41",
      "B41 : If($b57 \u003d\u003d false) → B42 | else → B45",
      "B43 : If(i106 \u003e\u003d i105) → B44 | else → B45",
      "B45 : If($b109 \u003d\u003d false) → B46 | else → B47",
      "B47 : If($b36 \u003d\u003d false) → B48 | else → B49",
      "B49 : If($b38 \u003d\u003d false) → B50 | else → B51",
      "B51 : If($b40 \u003d\u003d false) → B52 | else → B53",
      "B53 : If($b42 \u003d\u003d false) → B54 | else → B55",
      "B56 : If($i26 \u003c\u003d 0) → B57 | else → B58"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d ClassBands: long[] class_flags\u003e\n  $i0 \u003d ClassBands: int index\u003e\n  $l1 \u003d $r1[$i0]\n  $l2 \u003d $l1 \u0026 131072L\n  $b3 \u003d $l2 cmp 0L\n  if ($b3 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r83 \u003d List classSourceFile\u003e\n  $r82 \u003d List classSourceFile\u003e\n  $i91 \u003d $r82.size()\n  $i92 \u003d $i91 - 1\n  $r83.remove($i92)\n}",
      "B2 {\n  $r2 \u003d ClassBands: long[] class_flags\u003e\n  $i4 \u003d ClassBands: int index\u003e\n  $l5 \u003d $r2[$i4]\n  $l6 \u003d $l5 \u0026 262144L\n  $b7 \u003d $l6 cmp 0L\n  if ($b7 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r79 \u003d List classEnclosingMethodClass\u003e\n  $r78 \u003d List classEnclosingMethodClass\u003e\n  $i87 \u003d $r78.size()\n  $i88 \u003d $i87 - 1\n  $r79.remove($i88)\n  $r81 \u003d List classEnclosingMethodDesc\u003e\n  $r80 \u003d List classEnclosingMethodDesc\u003e\n  $i89 \u003d $r80.size()\n  $i90 \u003d $i89 - 1\n  $r81.remove($i90)\n}",
      "B4 {\n  $r3 \u003d ClassBands: long[] class_flags\u003e\n  $i8 \u003d ClassBands: int index\u003e\n  $l9 \u003d $r3[$i8]\n  $l10 \u003d $l9 \u0026 524288L\n  $b11 \u003d $l10 cmp 0L\n  if ($b11 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r77 \u003d List classSignature\u003e\n  $r76 \u003d List classSignature\u003e\n  $i85 \u003d $r76.size()\n  $i86 \u003d $i85 - 1\n  $r77.remove($i86)\n}",
      "B6 {\n  $r4 \u003d ClassBands: long[] class_flags\u003e\n  $i12 \u003d ClassBands: int index\u003e\n  $l13 \u003d $r4[$i12]\n  $l14 \u003d $l13 \u0026 2097152L\n  $b15 \u003d $l14 cmp 0L\n  if ($b15 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r75 \u003d MetadataBandGroup class_RVA_bands\u003e\n  $r75.removeLatest()\n}",
      "B8 {\n  $r5 \u003d ClassBands: long[] class_flags\u003e\n  $i16 \u003d ClassBands: int index\u003e\n  $l17 \u003d $r5[$i16]\n  $l18 \u003d $l17 \u0026 4194304L\n  $b19 \u003d $l18 cmp 0L\n  if ($b19 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r73 \u003d MetadataBandGroup class_RIA_bands\u003e\n  $r73.removeLatest()\n}",
      "B10 {\n  $r6 \u003d List tempFieldFlags\u003e\n  $r74 \u003d $r6.iterator()\n}",
      "B11 {\n  $z2 \u003d $r74.hasNext()\n  if ($z2 \u003d\u003d false) goto B12 else B21\n}",
      "B12 {\n  $r66 \u003d $r74.next()\n  r84 \u003d Long) $r66\n  l93 \u003d r84.longValue()\n  $l73 \u003d l93 \u0026 524288L\n  $b74 \u003d $l73 cmp 0L\n  if ($b74 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  $r72 \u003d List fieldSignature\u003e\n  $r71 \u003d List fieldSignature\u003e\n  $i83 \u003d $r71.size()\n  $i84 \u003d $i83 - 1\n  $r72.remove($i84)\n}",
      "B14 {\n  $l75 \u003d l93 \u0026 131072L\n  $b76 \u003d $l75 cmp 0L\n  if ($b76 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $r70 \u003d List fieldConstantValueKQ\u003e\n  $r69 \u003d List fieldConstantValueKQ\u003e\n  $i81 \u003d $r69.size()\n  $i82 \u003d $i81 - 1\n  $r70.remove($i82)\n}",
      "B16 {\n  $l77 \u003d l93 \u0026 2097152L\n  $b78 \u003d $l77 cmp 0L\n  if ($b78 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r68 \u003d MetadataBandGroup field_RVA_bands\u003e\n  $r68.removeLatest()\n}",
      "B18 {\n  $l79 \u003d l93 \u0026 4194304L\n  $b80 \u003d $l79 cmp 0L\n  if ($b80 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r67 \u003d MetadataBandGroup field_RIA_bands\u003e\n  $r67.removeLatest()\n}",
      "B20 {\n  goto B11\n}",
      "B21 {\n  $r7 \u003d List tempMethodFlags\u003e\n  r85 \u003d $r7.iterator()\n}",
      "B22 {\n  $z0 \u003d r85.hasNext()\n  if ($z0 \u003d\u003d false) goto B23 else B56\n}",
      "B23 {\n  $r18 \u003d r85.next()\n  r86 \u003d Long) $r18\n  l94 \u003d r86.longValue()\n  $l29 \u003d l94 \u0026 524288L\n  $b30 \u003d $l29 cmp 0L\n  if ($b30 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $r65 \u003d List methodSignature\u003e\n  $r64 \u003d List methodSignature\u003e\n  $i71 \u003d $r64.size()\n  $i72 \u003d $i71 - 1\n  $r65.remove($i72)\n}",
      "B25 {\n  $l31 \u003d l94 \u0026 262144L\n  $b32 \u003d $l31 cmp 0L\n  if ($b32 \u003d\u003d false) goto B26 else B29\n}",
      "B26 {\n  $r61 \u003d IntList methodExceptionNumber\u003e\n  $r60 \u003d IntList methodExceptionNumber\u003e\n  $i67 \u003d $r60.size()\n  $i68 \u003d $i67 - 1\n  i95 \u003d $r61.remove($i68)\n  i96 \u003d 0\n}",
      "B27 {\n  if (i96 \u003e\u003d i95) goto B28 else B29\n}",
      "B28 {\n  $r63 \u003d List methodExceptionClasses\u003e\n  $r62 \u003d List methodExceptionClasses\u003e\n  $i69 \u003d $r62.size()\n  $i70 \u003d $i69 - 1\n  $r63.remove($i70)\n  i96 \u003d i96 + 1\n  goto B27\n}",
      "B29 {\n  $l33 \u003d l94 \u0026 131072L\n  $b34 \u003d $l33 cmp 0L\n  if ($b34 \u003d\u003d false) goto B30 else B45\n}",
      "B30 {\n  $r25 \u003d IntList codeMaxLocals\u003e\n  $r24 \u003d IntList codeMaxLocals\u003e\n  $i43 \u003d $r24.size()\n  $i44 \u003d $i43 - 1\n  $r25.remove($i44)\n  $r27 \u003d IntList codeMaxStack\u003e\n  $r26 \u003d IntList codeMaxStack\u003e\n  $i45 \u003d $r26.size()\n  $i46 \u003d $i45 - 1\n  $r27.remove($i46)\n  $r29 \u003d IntList codeHandlerCount\u003e\n  $r28 \u003d IntList codeHandlerCount\u003e\n  $i47 \u003d $r28.size()\n  $i48 \u003d $i47 - 1\n  i97 \u003d $r29.remove($i48)\n  i98 \u003d 0\n}",
      "B31 {\n  if (i98 \u003e\u003d i97) goto B32 else B33\n}",
      "B32 {\n  $r55 \u003d List codeHandlerStartP\u003e\n  $i65 \u003d $r55.size()\n  i66 \u003d $i65 - 1\n  $r56 \u003d List codeHandlerStartP\u003e\n  $r56.remove(i66)\n  $r57 \u003d List codeHandlerEndPO\u003e\n  $r57.remove(i66)\n  $r58 \u003d List codeHandlerCatchPO\u003e\n  $r58.remove(i66)\n  $r59 \u003d List codeHandlerClass\u003e\n  $r59.remove(i66)\n  i98 \u003d i98 + 1\n  goto B31\n}",
      "B33 {\n  $z1 \u003d ClassBands: boolean stripDebug\u003e\n  if ($z1 !\u003d 0) goto B34 else B45\n}",
      "B34 {\n  $r31 \u003d List codeFlags\u003e\n  $r30 \u003d List codeFlags\u003e\n  $i49 \u003d $r30.size()\n  $i50 \u003d $i49 - 1\n  $r32 \u003d $r31.remove($i50)\n  $r33 \u003d Long) $r32\n  l99 \u003d $r33.longValue()\n  $r35 \u003d IntList codeLocalVariableTableN\u003e\n  $r34 \u003d IntList codeLocalVariableTableN\u003e\n  $i51 \u003d $r34.size()\n  $i52 \u003d $i51 - 1\n  i53 \u003d $r35.remove($i52)\n  i100 \u003d 0\n}",
      "B35 {\n  if (i100 \u003e\u003d i53) goto B36 else B37\n}",
      "B36 {\n  $r49 \u003d List codeLocalVariableTableBciP\u003e\n  $i64 \u003d $r49.size()\n  i101 \u003d $i64 - 1\n  $r50 \u003d List codeLocalVariableTableBciP\u003e\n  $r50.remove(i101)\n  $r51 \u003d List codeLocalVariableTableSpanO\u003e\n  $r51.remove(i101)\n  $r52 \u003d List codeLocalVariableTableNameRU\u003e\n  $r52.remove(i101)\n  $r53 \u003d List codeLocalVariableTableTypeRS\u003e\n  $r53.remove(i101)\n  $r54 \u003d IntList codeLocalVariableTableSlot\u003e\n  $r54.remove(i101)\n  i100 \u003d i100 + 1\n  goto B35\n}",
      "B37 {\n  $l54 \u003d l99 \u0026 8L\n  $b55 \u003d $l54 cmp 0L\n  if ($b55 \u003d\u003d false) goto B38 else B41\n}",
      "B38 {\n  $r42 \u003d IntList codeLocalVariableTypeTableN\u003e\n  $r41 \u003d IntList codeLocalVariableTypeTableN\u003e\n  $i61 \u003d $r41.size()\n  $i62 \u003d $i61 - 1\n  i102 \u003d $r42.remove($i62)\n  i103 \u003d 0\n}",
      "B39 {\n  if (i103 \u003e\u003d i102) goto B40 else B41\n}",
      "B40 {\n  $r43 \u003d List codeLocalVariableTypeTableBciP\u003e\n  $i63 \u003d $r43.size()\n  i104 \u003d $i63 - 1\n  $r44 \u003d List codeLocalVariableTypeTableBciP\u003e\n  $r44.remove(i104)\n  $r45 \u003d List codeLocalVariableTypeTableSpanO\u003e\n  $r45.remove(i104)\n  $r46 \u003d List codeLocalVariableTypeTableNameRU\u003e\n  $r46.remove(i104)\n  $r47 \u003d List codeLocalVariableTypeTableTypeRS\u003e\n  $r47.remove(i104)\n  $r48 \u003d IntList codeLocalVariableTypeTableSlot\u003e\n  $r48.remove(i104)\n  i103 \u003d i103 + 1\n  goto B39\n}",
      "B41 {\n  $l56 \u003d l99 \u0026 2L\n  $b57 \u003d $l56 cmp 0L\n  if ($b57 \u003d\u003d false) goto B42 else B45\n}",
      "B42 {\n  $r37 \u003d IntList codeLineNumberTableN\u003e\n  $r36 \u003d IntList codeLineNumberTableN\u003e\n  $i58 \u003d $r36.size()\n  $i59 \u003d $i58 - 1\n  i105 \u003d $r37.remove($i59)\n  i106 \u003d 0\n}",
      "B43 {\n  if (i106 \u003e\u003d i105) goto B44 else B45\n}",
      "B44 {\n  $r38 \u003d List codeLineNumberTableBciP\u003e\n  $i60 \u003d $r38.size()\n  i107 \u003d $i60 - 1\n  $r39 \u003d List codeLineNumberTableBciP\u003e\n  $r39.remove(i107)\n  $r40 \u003d IntList codeLineNumberTableLine\u003e\n  $r40.remove(i107)\n  i106 \u003d i106 + 1\n  goto B43\n}",
      "B45 {\n  $l108 \u003d l94 \u0026 2097152L\n  $b109 \u003d $l108 cmp 0L\n  if ($b109 \u003d\u003d false) goto B46 else B47\n}",
      "B46 {\n  $r23 \u003d MetadataBandGroup method_RVA_bands\u003e\n  $r23.removeLatest()\n}",
      "B47 {\n  $l35 \u003d l94 \u0026 4194304L\n  $b36 \u003d $l35 cmp 0L\n  if ($b36 \u003d\u003d false) goto B48 else B49\n}",
      "B48 {\n  $r22 \u003d MetadataBandGroup method_RIA_bands\u003e\n  $r22.removeLatest()\n}",
      "B49 {\n  $l37 \u003d l94 \u0026 8388608L\n  $b38 \u003d $l37 cmp 0L\n  if ($b38 \u003d\u003d false) goto B50 else B51\n}",
      "B50 {\n  $r21 \u003d MetadataBandGroup method_RVPA_bands\u003e\n  $r21.removeLatest()\n}",
      "B51 {\n  $l39 \u003d l94 \u0026 16777216L\n  $b40 \u003d $l39 cmp 0L\n  if ($b40 \u003d\u003d false) goto B52 else B53\n}",
      "B52 {\n  $r20 \u003d MetadataBandGroup method_RIPA_bands\u003e\n  $r20.removeLatest()\n}",
      "B53 {\n  $l41 \u003d l94 \u0026 33554432L\n  $b42 \u003d $l41 cmp 0L\n  if ($b42 \u003d\u003d false) goto B54 else B55\n}",
      "B54 {\n  $r19 \u003d MetadataBandGroup method_AD_bands\u003e\n  $r19.removeLatest()\n}",
      "B55 {\n  goto B22\n}",
      "B56 {\n  $r8 \u003d CPClass[] class_this\u003e\n  $i20 \u003d ClassBands: int index\u003e\n  $r8[$i20] \u003d null\n  $r9 \u003d CPClass[] class_super\u003e\n  $i21 \u003d ClassBands: int index\u003e\n  $r9[$i21] \u003d null\n  $r10 \u003d ClassBands: int[] class_interface_count\u003e\n  $i22 \u003d ClassBands: int index\u003e\n  $r10[$i22] \u003d 0\n  $r11 \u003d CPClass[][] class_interface\u003e\n  $i23 \u003d ClassBands: int index\u003e\n  $r11[$i23] \u003d null\n  $r12 \u003d ClassBands: int[] major_versions\u003e\n  $i24 \u003d ClassBands: int index\u003e\n  $r12[$i24] \u003d 0\n  $r13 \u003d ClassBands: long[] class_flags\u003e\n  $i25 \u003d ClassBands: int index\u003e\n  $r13[$i25] \u003d 0L\n  $r14 \u003d List tempFieldDesc\u003e\n  $r14.clear()\n  $r15 \u003d List tempFieldFlags\u003e\n  $r15.clear()\n  $r16 \u003d List tempMethodDesc\u003e\n  $r16.clear()\n  $r17 \u003d List tempMethodFlags\u003e\n  $r17.clear()\n  $i26 \u003d ClassBands: int index\u003e\n  if ($i26 \u003c\u003d 0) goto B57 else B58\n}",
      "B57 {\n  $i27 \u003d ClassBands: int index\u003e\n  $i28 \u003d $i27 - 1\n  ClassBands: int index\u003e \u003d $i28\n}",
      "B58 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B21",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B11",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B56",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B25 --\u003e B29",
      "B26 --\u003e B27",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B27",
      "B29 --\u003e B30",
      "B29 --\u003e B45",
      "B30 --\u003e B31",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B31",
      "B33 --\u003e B34",
      "B33 --\u003e B45",
      "B34 --\u003e B35",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e B35",
      "B37 --\u003e B38",
      "B37 --\u003e B41",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e B39",
      "B41 --\u003e B42",
      "B41 --\u003e B45",
      "B42 --\u003e B43",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e B43",
      "B45 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B51",
      "B51 --\u003e B52",
      "B51 --\u003e B53",
      "B52 --\u003e B53",
      "B53 --\u003e B54",
      "B53 --\u003e B55",
      "B54 --\u003e B55",
      "B55 --\u003e B22",
      "B56 --\u003e B57",
      "B56 --\u003e B58",
      "B57 --\u003e B58",
      "B58 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CodecEncoding",
    "methodName": "getCodec",
    "signature": "org.apache.commons.compress.harmony.pack200.Codec getCodec(int,java.io.InputStream,org.apache.commons.compress.harmony.pack200.Codec)",
    "visibility": "public",
    "body": "{\r\n    // Sanity check to make sure that no-one has changed\r\n    // the canonical codecs, which would really cause havoc\r\n    if (canonicalCodec.length !\u003d 116) {\r\n        throw new Error(\"Canonical encodings have been incorrectly modified\");\r\n    }\r\n    if (value \u003c 0) {\r\n        throw new IllegalArgumentException(\"Encoding cannot be less than zero\");\r\n    }\r\n    if (value \u003d\u003d 0) {\r\n        return defaultCodec;\r\n    }\r\n    if (value \u003c\u003d 115) {\r\n        return canonicalCodec[value];\r\n    }\r\n    if (value \u003d\u003d 116) {\r\n        int code \u003d in.read();\r\n        if (code \u003d\u003d -1) {\r\n            throw new EOFException(\"End of buffer read whilst trying to decode codec\");\r\n        }\r\n        final int d \u003d code \u0026 0x01;\r\n        final int s \u003d code \u003e\u003e 1 \u0026 0x03;\r\n        // this might result in an invalid\r\n        final int b \u003d (code \u003e\u003e 3 \u0026 0x07) + 1;\r\n        // number, but it\u0027s checked in the\r\n        // Codec constructor\r\n        code \u003d in.read();\r\n        if (code \u003d\u003d -1) {\r\n            throw new EOFException(\"End of buffer read whilst trying to decode codec\");\r\n        }\r\n        final int h \u003d code + 1;\r\n        // This handles the special cases for invalid combinations of data.\r\n        return new BHSDCodec(b, h, s, d);\r\n    }\r\n    if (value \u003e\u003d 117 \u0026\u0026 value \u003c\u003d 140) {\r\n        // Run codec\r\n        final int offset \u003d value - 117;\r\n        final int kx \u003d offset \u0026 3;\r\n        final boolean kbflag \u003d (offset \u003e\u003e 2 \u0026 1) \u003d\u003d 1;\r\n        final boolean adef \u003d (offset \u003e\u003e 3 \u0026 1) \u003d\u003d 1;\r\n        final boolean bdef \u003d (offset \u003e\u003e 4 \u0026 1) \u003d\u003d 1;\r\n        // If both A and B use the default encoding, what\u0027s the point of\r\n        // having a run of default values followed by default values\r\n        if (adef \u0026\u0026 bdef) {\r\n            throw new Pack200Exception(\"ADef and BDef should never both be true\");\r\n        }\r\n        final int kb \u003d kbflag ? in.read() : 3;\r\n        final int k \u003d (kb + 1) * (int) Math.pow(16, kx);\r\n        final Codec aCodec;\r\n        final Codec bCodec;\r\n        if (adef) {\r\n            aCodec \u003d defaultCodec;\r\n        } else {\r\n            aCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n        }\r\n        if (bdef) {\r\n            bCodec \u003d defaultCodec;\r\n        } else {\r\n            bCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n        }\r\n        return new RunCodec(k, aCodec, bCodec);\r\n    }\r\n    if (value \u003c 141 || value \u003e 188) {\r\n        throw new Pack200Exception(\"Invalid codec encoding byte (\" + value + \") found\");\r\n    }\r\n    final int offset \u003d value - 141;\r\n    final boolean fdef \u003d (offset \u0026 1) \u003d\u003d 1;\r\n    final boolean udef \u003d (offset \u003e\u003e 1 \u0026 1) \u003d\u003d 1;\r\n    final int tdefl \u003d offset \u003e\u003e 2;\r\n    final boolean tdef \u003d tdefl !\u003d 0;\r\n    // From section 6.7.3 of spec\r\n    final int[] tdefToL \u003d { 0, 4, 8, 16, 32, 64, 128, 192, 224, 240, 248, 252 };\r\n    final int l \u003d tdefToL[tdefl];\r\n    // NOTE: Do not re-factor this to bring out uCodec; the order in\r\n    // which\r\n    // they are read from the stream is important\r\n    if (tdef) {\r\n        final Codec fCodec \u003d fdef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n        final Codec uCodec \u003d udef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n        // Unfortunately, if tdef, then tCodec depends both on l and\r\n        // also on k, the\r\n        // number of items read from the fCodec. So we don\u0027t know in\r\n        // advance what\r\n        // the codec will be.\r\n        return new PopulationCodec(fCodec, l, uCodec);\r\n    }\r\n    final Codec fCodec \u003d fdef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n    final Codec tCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n    final Codec uCodec \u003d udef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n    return new PopulationCodec(fCodec, tCodec, uCodec);\r\n}",
    "nodes": 65,
    "edges": 80,
    "cc": 17,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d 116) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(i1 !\u003d 0) → B5 | else → B6",
      "B6 : If(i1 \u003e 115) → B7 | else → B8",
      "B8 : If(i1 !\u003d 116) → B9 | else → B14",
      "B9 : If(i26 !\u003d $i37) → B10 | else → B11",
      "B11 : If(i30 !\u003d $i39) → B12 | else → B13",
      "B14 : If(i1 \u003c 117) → B15 | else → B38",
      "B15 : If(i1 \u003e 140) → B16 | else → B38",
      "B16 : If($i13 !\u003d 1) → B17 | else → B18",
      "B19 : If($i15 !\u003d 1) → B20 | else → B21",
      "B22 : If($i17 !\u003d 1) → B23 | else → B24",
      "B25 : If(z3 \u003d\u003d false) → B26 | else → B28",
      "B26 : If($z12 \u003d\u003d false) → B27 | else → B28",
      "B28 : If(z1 \u003d\u003d false) → B29 | else → B30",
      "B31 : If(z3 \u003d\u003d false) → B32 | else → B33",
      "B34 : If(z5 \u003d\u003d false) → B35 | else → B36",
      "B38 : If(i1 \u003c 141) → B39 | else → B40",
      "B39 : If(i1 \u003c\u003d 188) → B40 | else → B41",
      "B41 : If($i2 !\u003d 1) → B42 | else → B43",
      "B44 : If($i4 !\u003d 1) → B45 | else → B46",
      "B47 : If($i11 \u003d\u003d false) → B48 | else → B49",
      "B50 : If($z10 \u003d\u003d false) → B51 | else → B58",
      "B51 : If(z7 \u003d\u003d false) → B52 | else → B53",
      "B54 : If(z9 \u003d\u003d false) → B55 | else → B56",
      "B58 : If(z7 \u003d\u003d false) → B59 | else → B60",
      "B61 : If(z9 \u003d\u003d false) → B62 | else → B63"
    ],
    "blockList": [
      "B0 {\n  i1 :\u003d @parameter0: int\n  InputStream\n  Codec\n  $r0 \u003d BHSDCodec[] canonicalCodec\u003e\n  $i0 \u003d lengthof $r0\n  if ($i0 \u003d\u003d 116) goto B1 else B2\n}",
      "B1 {\n  $r30 \u003d Error\n  new Error(\"Canonical encodings have been incorrectly modified\")\n  throw $r30\n}",
      "B2 {\n  if (i1 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r31 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Encoding cannot be less than zero\")\n  throw $r31\n}",
      "B4 {\n  if (i1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  if (i1 \u003e 115) goto B7 else B8\n}",
      "B7 {\n  $r18 \u003d BHSDCodec[] canonicalCodec\u003e\n  $r19 \u003d $r18[i1]\n  return\n}",
      "B8 {\n  if (i1 !\u003d 116) goto B9 else B14\n}",
      "B9 {\n  i26 \u003d r8.read()\n  $i37 \u003d (int) -1\n  if (i26 !\u003d $i37) goto B10 else B11\n}",
      "B10 {\n  $r32 \u003d EOFException\n  new EOFException(\"End of buffer read whilst trying to decode codec\")\n  throw $r32\n}",
      "B11 {\n  i27 \u003d i26 \u0026 1\n  $i23 \u003d i26 \u003e\u003e 1\n  i28 \u003d $i23 \u0026 3\n  $i24 \u003d i26 \u003e\u003e 3\n  $i25 \u003d $i24 \u0026 7\n  i29 \u003d $i25 + 1\n  i30 \u003d r8.read()\n  $i39 \u003d (int) -1\n  if (i30 !\u003d $i39) goto B12 else B13\n}",
      "B12 {\n  $r33 \u003d EOFException\n  new EOFException(\"End of buffer read whilst trying to decode codec\")\n  throw $r33\n}",
      "B13 {\n  i31 \u003d i30 + 1\n  $r34 \u003d BHSDCodec\n  new BHSDCodec(i29, i31, i28, i27)\n  return\n}",
      "B14 {\n  if (i1 \u003c 117) goto B15 else B38\n}",
      "B15 {\n  if (i1 \u003e 140) goto B16 else B38\n}",
      "B16 {\n  i32 \u003d i1 - 117\n  i33 \u003d i32 \u0026 3\n  $i12 \u003d i32 \u003e\u003e 2\n  $i13 \u003d $i12 \u0026 1\n  if ($i13 !\u003d 1) goto B17 else B18\n}",
      "B17 {\n  $z0 \u003d 1\n  goto B19\n}",
      "B18 {\n  $z0 \u003d 0\n}",
      "B19 {\n  z1 \u003d $z0\n  $i14 \u003d i32 \u003e\u003e 3\n  $i15 \u003d $i14 \u0026 1\n  if ($i15 !\u003d 1) goto B20 else B21\n}",
      "B20 {\n  $z2 \u003d 1\n  goto B22\n}",
      "B21 {\n  $z2 \u003d 0\n}",
      "B22 {\n  z3 \u003d $z2\n  $i16 \u003d i32 \u003e\u003e 4\n  $i17 \u003d $i16 \u0026 1\n  if ($i17 !\u003d 1) goto B23 else B24\n}",
      "B23 {\n  $z12 \u003d 1\n  $z11 \u003d 1\n  goto B25\n}",
      "B24 {\n  $z12 \u003d 0\n  $z11 \u003d 0\n}",
      "B25 {\n  z5 \u003d $z11\n  if (z3 \u003d\u003d false) goto B26 else B28\n}",
      "B26 {\n  if ($z12 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  $r35 \u003d Pack200Exception\n  new Pack200Exception(\"ADef and BDef should never both be true\")\n  throw $r35\n}",
      "B28 {\n  if (z1 \u003d\u003d false) goto B29 else B30\n}",
      "B29 {\n  $i34 \u003d r8.read()\n  goto B31\n}",
      "B30 {\n  $i34 \u003d 3\n}",
      "B31 {\n  $i19 \u003d $i34 + 1\n  $d0 \u003d (double) i33\n  $d1 \u003d Math.pow(16.0, $d0)\n  $i18 \u003d (int) $d1\n  $i22 \u003d $i19 * $i18\n  if (z3 \u003d\u003d false) goto B32 else B33\n}",
      "B32 {\n  r22 \u003d r9\n  goto B34\n}",
      "B33 {\n  $i20 \u003d r8.read()\n  r22 \u003d CodecEncoding.getCodec($i20, r8, r9)\n}",
      "B34 {\n  if (z5 \u003d\u003d false) goto B35 else B36\n}",
      "B35 {\n  r23 \u003d r9\n  goto B37\n}",
      "B36 {\n  $i21 \u003d r8.read()\n  r23 \u003d CodecEncoding.getCodec($i21, r8, r9)\n}",
      "B37 {\n  $r36 \u003d RunCodec\n  new RunCodec($i22, r22, r23)\n  return\n}",
      "B38 {\n  if (i1 \u003c 141) goto B39 else B40\n}",
      "B39 {\n  if (i1 \u003c\u003d 188) goto B40 else B41\n}",
      "B40 {\n  $r38 \u003d Pack200Exception\n  $r37 \u003d StringBuilder\n  new StringBuilder()\n  $r3 \u003d $r37.append(\"Invalid codec encoding byte (\")\n  $r4 \u003d $r3.append(i1)\n  $r5 \u003d $r4.append(\") found\")\n  $r6 \u003d $r5.toString()\n  new Pack200Exception($r6)\n  throw $r38\n}",
      "B41 {\n  i35 \u003d i1 - 141\n  $i2 \u003d i35 \u0026 1\n  if ($i2 !\u003d 1) goto B42 else B43\n}",
      "B42 {\n  $z6 \u003d 1\n  goto B44\n}",
      "B43 {\n  $z6 \u003d 0\n}",
      "B44 {\n  z7 \u003d $z6\n  $i3 \u003d i35 \u003e\u003e 1\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 1) goto B45 else B46\n}",
      "B45 {\n  $z8 \u003d 1\n  goto B47\n}",
      "B46 {\n  $z8 \u003d 0\n}",
      "B47 {\n  z9 \u003d $z8\n  $i11 \u003d i35 \u003e\u003e 2\n  if ($i11 \u003d\u003d false) goto B48 else B49\n}",
      "B48 {\n  $z10 \u003d 1\n  goto B50\n}",
      "B49 {\n  $z10 \u003d 0\n}",
      "B50 {\n  $r7 \u003d newarray (int)[12]\n  $r7[0] \u003d 0\n  $r7[1] \u003d 4\n  $r7[2] \u003d 8\n  $r7[3] \u003d 16\n  $r7[4] \u003d 32\n  $r7[5] \u003d 64\n  $r7[6] \u003d 128\n  $r7[7] \u003d 192\n  $r7[8] \u003d 224\n  $r7[9] \u003d 240\n  $r7[10] \u003d 248\n  $r7[11] \u003d 252\n  $i10 \u003d $r7[$i11]\n  if ($z10 \u003d\u003d false) goto B51 else B58\n}",
      "B51 {\n  if (z7 \u003d\u003d false) goto B52 else B53\n}",
      "B52 {\n  $r24 \u003d r9\n  goto B54\n}",
      "B53 {\n  $i8 \u003d r8.read()\n  $r24 \u003d CodecEncoding.getCodec($i8, r8, r9)\n}",
      "B54 {\n  r25 \u003d $r24\n  if (z9 \u003d\u003d false) goto B55 else B56\n}",
      "B55 {\n  $r26 \u003d r9\n  goto B57\n}",
      "B56 {\n  $i9 \u003d r8.read()\n  $r26 \u003d CodecEncoding.getCodec($i9, r8, r9)\n}",
      "B57 {\n  $r39 \u003d PopulationCodec\n  new PopulationCodec(r25, $i10, $r26)\n  return\n}",
      "B58 {\n  if (z7 \u003d\u003d false) goto B59 else B60\n}",
      "B59 {\n  $r27 \u003d r9\n  goto B61\n}",
      "B60 {\n  $i5 \u003d r8.read()\n  $r27 \u003d CodecEncoding.getCodec($i5, r8, r9)\n}",
      "B61 {\n  r28 \u003d $r27\n  $i6 \u003d r8.read()\n  $r11 \u003d CodecEncoding.getCodec($i6, r8, r9)\n  if (z9 \u003d\u003d false) goto B62 else B63\n}",
      "B62 {\n  $r29 \u003d r9\n  goto B64\n}",
      "B63 {\n  $i7 \u003d r8.read()\n  $r29 \u003d CodecEncoding.getCodec($i7, r8, r9)\n}",
      "B64 {\n  $r40 \u003d PopulationCodec\n  new PopulationCodec(r28, $r11, $r29)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B38",
      "B15 --\u003e B16",
      "B15 --\u003e B38",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B25 --\u003e B28",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e [EXIT]",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B31",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e B35",
      "B34 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e B37",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e [EXIT]",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B50",
      "B49 --\u003e B50",
      "B50 --\u003e B51",
      "B50 --\u003e B58",
      "B51 --\u003e B52",
      "B51 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B54",
      "B54 --\u003e B55",
      "B54 --\u003e B56",
      "B55 --\u003e B57",
      "B56 --\u003e B57",
      "B57 --\u003e [EXIT]",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B61",
      "B60 --\u003e B61",
      "B61 --\u003e B62",
      "B61 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CodecEncoding#getCodec(...3)",
        "body": "{\r\n    // Sanity check to make sure that no-one has changed\r\n    // the canonical codecs, which would really cause havoc\r\n    if (canonicalCodec.length !\u003d 116) {\r\n        throw new Error(\"Canonical encodings have been incorrectly modified\");\r\n    }\r\n    if (value \u003c 0) {\r\n        throw new IllegalArgumentException(\"Encoding cannot be less than zero\");\r\n    }\r\n    if (value \u003d\u003d 0) {\r\n        return defaultCodec;\r\n    }\r\n    if (value \u003c\u003d 115) {\r\n        return canonicalCodec[value];\r\n    }\r\n    if (value \u003d\u003d 116) {\r\n        int code \u003d in.read();\r\n        if (code \u003d\u003d -1) {\r\n            throw new EOFException(\"End of buffer read whilst trying to decode codec\");\r\n        }\r\n        final int d \u003d code \u0026 0x01;\r\n        final int s \u003d code \u003e\u003e 1 \u0026 0x03;\r\n        // this might result in an invalid\r\n        final int b \u003d (code \u003e\u003e 3 \u0026 0x07) + 1;\r\n        // number, but it\u0027s checked in the\r\n        // Codec constructor\r\n        code \u003d in.read();\r\n        if (code \u003d\u003d -1) {\r\n            throw new EOFException(\"End of buffer read whilst trying to decode codec\");\r\n        }\r\n        final int h \u003d code + 1;\r\n        // This handles the special cases for invalid combinations of data.\r\n        return new BHSDCodec(b, h, s, d);\r\n    }\r\n    if (value \u003e\u003d 117 \u0026\u0026 value \u003c\u003d 140) {\r\n        // Run codec\r\n        final int offset \u003d value - 117;\r\n        final int kx \u003d offset \u0026 3;\r\n        final boolean kbflag \u003d (offset \u003e\u003e 2 \u0026 1) \u003d\u003d 1;\r\n        final boolean adef \u003d (offset \u003e\u003e 3 \u0026 1) \u003d\u003d 1;\r\n        final boolean bdef \u003d (offset \u003e\u003e 4 \u0026 1) \u003d\u003d 1;\r\n        // If both A and B use the default encoding, what\u0027s the point of\r\n        // having a run of default values followed by default values\r\n        if (adef \u0026\u0026 bdef) {\r\n            throw new Pack200Exception(\"ADef and BDef should never both be true\");\r\n        }\r\n        final int kb \u003d kbflag ? in.read() : 3;\r\n        final int k \u003d (kb + 1) * (int) Math.pow(16, kx);\r\n        final Codec aCodec;\r\n        final Codec bCodec;\r\n        if (adef) {\r\n            aCodec \u003d defaultCodec;\r\n        } else {\r\n            aCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n        }\r\n        if (bdef) {\r\n            bCodec \u003d defaultCodec;\r\n        } else {\r\n            bCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n        }\r\n        return new RunCodec(k, aCodec, bCodec);\r\n    }\r\n    if (value \u003c 141 || value \u003e 188) {\r\n        throw new Pack200Exception(\"Invalid codec encoding byte (\" + value + \") found\");\r\n    }\r\n    final int offset \u003d value - 141;\r\n    final boolean fdef \u003d (offset \u0026 1) \u003d\u003d 1;\r\n    final boolean udef \u003d (offset \u003e\u003e 1 \u0026 1) \u003d\u003d 1;\r\n    final int tdefl \u003d offset \u003e\u003e 2;\r\n    final boolean tdef \u003d tdefl !\u003d 0;\r\n    // From section 6.7.3 of spec\r\n    final int[] tdefToL \u003d { 0, 4, 8, 16, 32, 64, 128, 192, 224, 240, 248, 252 };\r\n    final int l \u003d tdefToL[tdefl];\r\n    // NOTE: Do not re-factor this to bring out uCodec; the order in\r\n    // which\r\n    // they are read from the stream is important\r\n    if (tdef) {\r\n        final Codec fCodec \u003d fdef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n        final Codec uCodec \u003d udef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n        // Unfortunately, if tdef, then tCodec depends both on l and\r\n        // also on k, the\r\n        // number of items read from the fCodec. So we don\u0027t know in\r\n        // advance what\r\n        // the codec will be.\r\n        return new PopulationCodec(fCodec, l, uCodec);\r\n    }\r\n    final Codec fCodec \u003d fdef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n    final Codec tCodec \u003d getCodec(in.read(), in, defaultCodec);\r\n    final Codec uCodec \u003d udef ? defaultCodec : getCodec(in.read(), in, defaultCodec);\r\n    return new PopulationCodec(fCodec, tCodec, uCodec);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CodecEncoding",
    "methodName": "getSpecifier",
    "signature": "int[] getSpecifier(org.apache.commons.compress.harmony.pack200.Codec,org.apache.commons.compress.harmony.pack200.Codec)",
    "visibility": "public",
    "body": "{\r\n    if (canonicalCodecsToSpecifiers.containsKey(codec)) {\r\n        return new int[] { canonicalCodecsToSpecifiers.get(codec).intValue() };\r\n    }\r\n    if (codec instanceof BHSDCodec) {\r\n        // Cache these?\r\n        final BHSDCodec bhsdCodec \u003d (BHSDCodec) codec;\r\n        final int[] specifiers \u003d new int[3];\r\n        specifiers[0] \u003d 116;\r\n        specifiers[1] \u003d (bhsdCodec.isDelta() ? 1 : 0) + 2 * bhsdCodec.getS() + 8 * (bhsdCodec.getB() - 1);\r\n        specifiers[2] \u003d bhsdCodec.getH() - 1;\r\n        return specifiers;\r\n    }\r\n    if (codec instanceof RunCodec) {\r\n        final RunCodec runCodec \u003d (RunCodec) codec;\r\n        final int k \u003d runCodec.getK();\r\n        final int kb;\r\n        final int kx;\r\n        if (k \u003c\u003d 256) {\r\n            kb \u003d 0;\r\n            kx \u003d k - 1;\r\n        } else if (k \u003c\u003d 4096) {\r\n            kb \u003d 1;\r\n            kx \u003d k / 16 - 1;\r\n        } else if (k \u003c\u003d 65536) {\r\n            kb \u003d 2;\r\n            kx \u003d k / 256 - 1;\r\n        } else {\r\n            kb \u003d 3;\r\n            kx \u003d k / 4096 - 1;\r\n        }\r\n        final Codec aCodec \u003d runCodec.getACodec();\r\n        final Codec bCodec \u003d runCodec.getBCodec();\r\n        int abDef \u003d 0;\r\n        if (aCodec.equals(defaultForBand)) {\r\n            abDef \u003d 1;\r\n        } else if (bCodec.equals(defaultForBand)) {\r\n            abDef \u003d 2;\r\n        }\r\n        final int first \u003d 117 + kb + (kx \u003d\u003d 3 ? 0 : 4) + 8 * abDef;\r\n        final int[] aSpecifier \u003d abDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(aCodec, defaultForBand);\r\n        final int[] bSpecifier \u003d abDef \u003d\u003d 2 ? EMPTY_INT_ARRAY : getSpecifier(bCodec, defaultForBand);\r\n        final int[] specifier \u003d new int[1 + (kx \u003d\u003d 3 ? 0 : 1) + aSpecifier.length + bSpecifier.length];\r\n        specifier[0] \u003d first;\r\n        int index \u003d 1;\r\n        if (kx !\u003d 3) {\r\n            specifier[1] \u003d kx;\r\n            index++;\r\n        }\r\n        for (final int element : aSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : bSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        return specifier;\r\n    }\r\n    if (codec instanceof PopulationCodec) {\r\n        final PopulationCodec populationCodec \u003d (PopulationCodec) codec;\r\n        final Codec tokenCodec \u003d populationCodec.getTokenCodec();\r\n        final Codec favouredCodec \u003d populationCodec.getFavouredCodec();\r\n        final Codec unfavouredCodec \u003d populationCodec.getUnfavouredCodec();\r\n        final int fDef \u003d favouredCodec.equals(defaultForBand) ? 1 : 0;\r\n        final int uDef \u003d unfavouredCodec.equals(defaultForBand) ? 1 : 0;\r\n        int tDefL \u003d 0;\r\n        final int[] favoured \u003d populationCodec.getFavoured();\r\n        if (favoured !\u003d null) {\r\n            if (tokenCodec \u003d\u003d Codec.BYTE1) {\r\n                tDefL \u003d 1;\r\n            } else if (tokenCodec instanceof BHSDCodec) {\r\n                final BHSDCodec tokenBHSD \u003d (BHSDCodec) tokenCodec;\r\n                if (tokenBHSD.getS() \u003d\u003d 0) {\r\n                    final int[] possibleLValues \u003d { 4, 8, 16, 32, 64, 128, 192, 224, 240, 248, 252 };\r\n                    final int l \u003d 256 - tokenBHSD.getH();\r\n                    int index \u003d Arrays.binarySearch(possibleLValues, l);\r\n                    if (index !\u003d -1) {\r\n                        // TODO: check range is ok for ks\r\n                        tDefL \u003d index++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        final int first \u003d 141 + fDef + 2 * uDef + 4 * tDefL;\r\n        final int[] favouredSpecifier \u003d fDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(favouredCodec, defaultForBand);\r\n        final int[] tokenSpecifier \u003d tDefL !\u003d 0 ? EMPTY_INT_ARRAY : getSpecifier(tokenCodec, defaultForBand);\r\n        final int[] unfavouredSpecifier \u003d uDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(unfavouredCodec, defaultForBand);\r\n        final int[] specifier \u003d new int[1 + favouredSpecifier.length + unfavouredSpecifier.length + tokenSpecifier.length];\r\n        specifier[0] \u003d first;\r\n        int index \u003d 1;\r\n        for (final int element : favouredSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : tokenSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : unfavouredSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        return specifier;\r\n    }\r\n    return null;\r\n}",
    "nodes": 74,
    "edges": 99,
    "cc": 27,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B7",
      "B3 : If($z8 \u003d\u003d false) → B4 | else → B5",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B40",
      "B8 : If(i32 \u003e 256) → B9 | else → B10",
      "B10 : If(i32 \u003e 4096) → B11 | else → B12",
      "B12 : If(i32 \u003e 65536) → B13 | else → B14",
      "B15 : If($z10 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($z7 \u003d\u003d false) → B18 | else → B19",
      "B19 : If(i34 !\u003d 3) → B20 | else → B21",
      "B22 : If(b61 !\u003d 1) → B23 | else → B24",
      "B25 : If(b62 !\u003d 2) → B26 | else → B27",
      "B28 : If(i34 !\u003d 3) → B29 | else → B30",
      "B31 : If(i34 \u003d\u003d 3) → B32 | else → B33",
      "B34 : If(i38 \u003e\u003d $i18) → B35 | else → B36",
      "B37 : If(i41 \u003e\u003d i40) → B38 | else → B39",
      "B40 : If($z3 \u003d\u003d false) → B41 | else → B73",
      "B41 : If($z4 \u003d\u003d false) → B42 | else → B43",
      "B44 : If($z5 \u003d\u003d false) → B45 | else → B46",
      "B47 : If($r6 \u003d\u003d null) → B48 | else → B54",
      "B48 : If(r22 !\u003d $r4) → B49 | else → B50",
      "B50 : If($z6 \u003d\u003d false) → B51 | else → B54",
      "B51 : If($i7 !\u003d 0) → B52 | else → B54",
      "B52 : If(i45 \u003d\u003d $i64) → B53 | else → B54",
      "B54 : If(z13 !\u003d 1) → B55 | else → B56",
      "B57 : If(i43 \u003d\u003d false) → B58 | else → B59",
      "B60 : If(z15 !\u003d 1) → B61 | else → B62",
      "B64 : If(i52 \u003e\u003d $i6) → B65 | else → B66",
      "B67 : If(i55 \u003e\u003d i54) → B68 | else → B69",
      "B70 : If(i58 \u003e\u003d i57) → B71 | else → B72"
    ],
    "blockList": [
      "B0 {\n  Codec\n  Codec\n  $r1 \u003d Map canonicalCodecsToSpecifiers\u003e\n  $z0 \u003d $r1.containsKey(r0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d newarray (int)[1]\n  $r9 \u003d Map canonicalCodecsToSpecifiers\u003e\n  $r10 \u003d $r9.get(r0)\n  $r11 \u003d Integer) $r10\n  $i31 \u003d $r11.intValue()\n  $r8[0] \u003d $i31\n  return\n}",
      "B2 {\n  $z1 \u003d BHSDCodec\n  if ($z1 \u003d\u003d false) goto B3 else B7\n}",
      "B3 {\n  r12 \u003d BHSDCodec) r0\n  r13 \u003d newarray (int)[3]\n  r13[0] \u003d 116\n  $z8 \u003d r12.isDelta()\n  if ($z8 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z9 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z9 \u003d 0\n}",
      "B6 {\n  $i22 \u003d r12.getS()\n  $i23 \u003d 2 * $i22\n  $i27 \u003d $z9 + $i23\n  $i24 \u003d r12.getB()\n  $i25 \u003d $i24 - 1\n  $i26 \u003d 8 * $i25\n  $i28 \u003d $i27 + $i26\n  r13[1] \u003d $i28\n  $i29 \u003d r12.getH()\n  $i30 \u003d $i29 - 1\n  r13[2] \u003d $i30\n  return\n}",
      "B7 {\n  $z2 \u003d RunCodec\n  if ($z2 \u003d\u003d false) goto B8 else B40\n}",
      "B8 {\n  r14 \u003d RunCodec) r0\n  i32 \u003d r14.getK()\n  if (i32 \u003e 256) goto B9 else B10\n}",
      "B9 {\n  b33 \u003d 0\n  i34 \u003d i32 - 1\n  goto B15\n}",
      "B10 {\n  if (i32 \u003e 4096) goto B11 else B12\n}",
      "B11 {\n  b33 \u003d 1\n  $i21 \u003d i32 / 16\n  i34 \u003d $i21 - 1\n  goto B15\n}",
      "B12 {\n  if (i32 \u003e 65536) goto B13 else B14\n}",
      "B13 {\n  b33 \u003d 2\n  $i20 \u003d i32 / 256\n  i34 \u003d $i20 - 1\n  goto B15\n}",
      "B14 {\n  b33 \u003d 3\n  $i9 \u003d i32 / 4096\n  i34 \u003d $i9 - 1\n}",
      "B15 {\n  $r15 \u003d r14.getACodec()\n  $r16 \u003d r14.getBCodec()\n  b35 \u003d 0\n  b62 \u003d 0\n  b61 \u003d 0\n  b60 \u003d 0\n  $z10 \u003d $r15.equals(r2)\n  if ($z10 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  b35 \u003d 1\n  b62 \u003d 1\n  b61 \u003d 1\n  b60 \u003d 1\n  goto B19\n}",
      "B17 {\n  $z7 \u003d $r16.equals(r2)\n  if ($z7 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  b35 \u003d 2\n  b62 \u003d 2\n  b61 \u003d 2\n  b60 \u003d 2\n}",
      "B19 {\n  $i10 \u003d 117 + b33\n  if (i34 !\u003d 3) goto B20 else B21\n}",
      "B20 {\n  $b36 \u003d 0\n  goto B22\n}",
      "B21 {\n  $b36 \u003d 4\n}",
      "B22 {\n  $i12 \u003d $i10 + $b36\n  $i11 \u003d 8 * b60\n  $i19 \u003d $i12 + $i11\n  if (b61 !\u003d 1) goto B23 else B24\n}",
      "B23 {\n  $r17 \u003d CodecEncoding: int[] EMPTY_INT_ARRAY\u003e\n  goto B25\n}",
      "B24 {\n  $r17 \u003d CodecEncoding.getSpecifier($r15, r2)\n}",
      "B25 {\n  r18 \u003d $r17\n  if (b62 !\u003d 2) goto B26 else B27\n}",
      "B26 {\n  $r19 \u003d CodecEncoding: int[] EMPTY_INT_ARRAY\u003e\n  goto B28\n}",
      "B27 {\n  $r19 \u003d CodecEncoding.getSpecifier($r16, r2)\n}",
      "B28 {\n  r20 \u003d $r19\n  if (i34 !\u003d 3) goto B29 else B30\n}",
      "B29 {\n  $z11 \u003d 0\n  goto B31\n}",
      "B30 {\n  $z11 \u003d 1\n}",
      "B31 {\n  $i14 \u003d 1 + $z11\n  $i13 \u003d lengthof r18\n  $i16 \u003d $i14 + $i13\n  $i15 \u003d lengthof r20\n  $i17 \u003d $i16 + $i15\n  $r7 \u003d newarray (int)[$i17]\n  $r7[0] \u003d $i19\n  i37 \u003d 1\n  if (i34 \u003d\u003d 3) goto B32 else B33\n}",
      "B32 {\n  $r7[1] \u003d i34\n  i37 \u003d 2\n}",
      "B33 {\n  $i18 \u003d lengthof r18\n  i38 \u003d 0\n}",
      "B34 {\n  if (i38 \u003e\u003d $i18) goto B35 else B36\n}",
      "B35 {\n  i39 \u003d r18[i38]\n  $r7[i37] \u003d i39\n  i37 \u003d i37 + 1\n  i38 \u003d i38 + 1\n  goto B34\n}",
      "B36 {\n  i40 \u003d lengthof r20\n  i41 \u003d 0\n}",
      "B37 {\n  if (i41 \u003e\u003d i40) goto B38 else B39\n}",
      "B38 {\n  i42 \u003d r20[i41]\n  $r7[i37] \u003d i42\n  i37 \u003d i37 + 1\n  i41 \u003d i41 + 1\n  goto B37\n}",
      "B39 {\n  return\n}",
      "B40 {\n  $z3 \u003d PopulationCodec\n  if ($z3 \u003d\u003d false) goto B41 else B73\n}",
      "B41 {\n  r21 \u003d PopulationCodec) r0\n  r22 \u003d r21.getTokenCodec()\n  r23 \u003d r21.getFavouredCodec()\n  r24 \u003d r21.getUnfavouredCodec()\n  $z4 \u003d r23.equals(r2)\n  if ($z4 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $z12 \u003d 1\n  goto B44\n}",
      "B43 {\n  $z12 \u003d 0\n}",
      "B44 {\n  z13 \u003d $z12\n  $z5 \u003d r24.equals(r2)\n  if ($z5 \u003d\u003d false) goto B45 else B46\n}",
      "B45 {\n  $z14 \u003d 1\n  goto B47\n}",
      "B46 {\n  $z14 \u003d 0\n}",
      "B47 {\n  z15 \u003d $z14\n  i43 \u003d 0\n  $r6 \u003d r21.getFavoured()\n  if ($r6 \u003d\u003d null) goto B48 else B54\n}",
      "B48 {\n  $r4 \u003d BHSDCodec BYTE1\u003e\n  if (r22 !\u003d $r4) goto B49 else B50\n}",
      "B49 {\n  i43 \u003d 1\n  goto B54\n}",
      "B50 {\n  $z6 \u003d BHSDCodec\n  if ($z6 \u003d\u003d false) goto B51 else B54\n}",
      "B51 {\n  r25 \u003d BHSDCodec) r22\n  $i7 \u003d r25.getS()\n  if ($i7 !\u003d 0) goto B52 else B54\n}",
      "B52 {\n  $r5 \u003d newarray (int)[11]\n  $r5[0] \u003d 4\n  $r5[1] \u003d 8\n  $r5[2] \u003d 16\n  $r5[3] \u003d 32\n  $r5[4] \u003d 64\n  $r5[5] \u003d 128\n  $r5[6] \u003d 192\n  $r5[7] \u003d 224\n  $r5[8] \u003d 240\n  $r5[9] \u003d 248\n  $r5[10] \u003d 252\n  $i8 \u003d r25.getH()\n  i44 \u003d 256 - $i8\n  i45 \u003d Arrays.binarySearch($r5, i44)\n  $i64 \u003d (int) -1\n  if (i45 \u003d\u003d $i64) goto B53 else B54\n}",
      "B53 {\n  i43 \u003d i45\n}",
      "B54 {\n  $i46 \u003d 141 + z13\n  $i47 \u003d 2 * z15\n  $i48 \u003d $i46 + $i47\n  $i49 \u003d 4 * i43\n  $i50 \u003d $i48 + $i49\n  if (z13 !\u003d 1) goto B55 else B56\n}",
      "B55 {\n  $r26 \u003d CodecEncoding: int[] EMPTY_INT_ARRAY\u003e\n  goto B57\n}",
      "B56 {\n  $r26 \u003d CodecEncoding.getSpecifier(r23, r2)\n}",
      "B57 {\n  r27 \u003d $r26\n  if (i43 \u003d\u003d false) goto B58 else B59\n}",
      "B58 {\n  $r28 \u003d CodecEncoding: int[] EMPTY_INT_ARRAY\u003e\n  goto B60\n}",
      "B59 {\n  $r28 \u003d CodecEncoding.getSpecifier(r22, r2)\n}",
      "B60 {\n  r29 \u003d $r28\n  if (z15 !\u003d 1) goto B61 else B62\n}",
      "B61 {\n  $r30 \u003d CodecEncoding: int[] EMPTY_INT_ARRAY\u003e\n  goto B63\n}",
      "B62 {\n  $r30 \u003d CodecEncoding.getSpecifier(r24, r2)\n}",
      "B63 {\n  r31 \u003d $r30\n  $i0 \u003d lengthof r27\n  $i2 \u003d 1 + $i0\n  $i1 \u003d lengthof $r30\n  $i4 \u003d $i2 + $i1\n  $i3 \u003d lengthof r29\n  $i5 \u003d $i4 + $i3\n  $r3 \u003d newarray (int)[$i5]\n  $r3[0] \u003d $i50\n  i51 \u003d 1\n  $i6 \u003d lengthof r27\n  i52 \u003d 0\n}",
      "B64 {\n  if (i52 \u003e\u003d $i6) goto B65 else B66\n}",
      "B65 {\n  i53 \u003d r27[i52]\n  $r3[i51] \u003d i53\n  i51 \u003d i51 + 1\n  i52 \u003d i52 + 1\n  goto B64\n}",
      "B66 {\n  i54 \u003d lengthof r29\n  i55 \u003d 0\n}",
      "B67 {\n  if (i55 \u003e\u003d i54) goto B68 else B69\n}",
      "B68 {\n  i56 \u003d r29[i55]\n  $r3[i51] \u003d i56\n  i51 \u003d i51 + 1\n  i55 \u003d i55 + 1\n  goto B67\n}",
      "B69 {\n  i57 \u003d lengthof r31\n  i58 \u003d 0\n}",
      "B70 {\n  if (i58 \u003e\u003d i57) goto B71 else B72\n}",
      "B71 {\n  i59 \u003d r31[i58]\n  $r3[i51] \u003d i59\n  i51 \u003d i51 + 1\n  i58 \u003d i58 + 1\n  goto B70\n}",
      "B72 {\n  return\n}",
      "B73 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B40",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B19",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B31",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B34",
      "B34 --\u003e B35",
      "B34 --\u003e B36",
      "B35 --\u003e B34",
      "B36 --\u003e B37",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B37",
      "B39 --\u003e [EXIT]",
      "B40 --\u003e B41",
      "B40 --\u003e B73",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B54",
      "B48 --\u003e B49",
      "B48 --\u003e B50",
      "B49 --\u003e B54",
      "B50 --\u003e B51",
      "B50 --\u003e B54",
      "B51 --\u003e B52",
      "B51 --\u003e B54",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B54",
      "B54 --\u003e B55",
      "B54 --\u003e B56",
      "B55 --\u003e B57",
      "B56 --\u003e B57",
      "B57 --\u003e B58",
      "B57 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B62",
      "B61 --\u003e B63",
      "B62 --\u003e B63",
      "B63 --\u003e B64",
      "B64 --\u003e B65",
      "B64 --\u003e B66",
      "B65 --\u003e B64",
      "B66 --\u003e B67",
      "B67 --\u003e B68",
      "B67 --\u003e B69",
      "B68 --\u003e B67",
      "B69 --\u003e B70",
      "B70 --\u003e B71",
      "B70 --\u003e B72",
      "B71 --\u003e B70",
      "B72 --\u003e [EXIT]",
      "B73 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CodecEncoding#getSpecifier(...2)",
        "body": "{\r\n    if (canonicalCodecsToSpecifiers.containsKey(codec)) {\r\n        return new int[] { canonicalCodecsToSpecifiers.get(codec).intValue() };\r\n    }\r\n    if (codec instanceof BHSDCodec) {\r\n        // Cache these?\r\n        final BHSDCodec bhsdCodec \u003d (BHSDCodec) codec;\r\n        final int[] specifiers \u003d new int[3];\r\n        specifiers[0] \u003d 116;\r\n        specifiers[1] \u003d (bhsdCodec.isDelta() ? 1 : 0) + 2 * bhsdCodec.getS() + 8 * (bhsdCodec.getB() - 1);\r\n        specifiers[2] \u003d bhsdCodec.getH() - 1;\r\n        return specifiers;\r\n    }\r\n    if (codec instanceof RunCodec) {\r\n        final RunCodec runCodec \u003d (RunCodec) codec;\r\n        final int k \u003d runCodec.getK();\r\n        final int kb;\r\n        final int kx;\r\n        if (k \u003c\u003d 256) {\r\n            kb \u003d 0;\r\n            kx \u003d k - 1;\r\n        } else if (k \u003c\u003d 4096) {\r\n            kb \u003d 1;\r\n            kx \u003d k / 16 - 1;\r\n        } else if (k \u003c\u003d 65536) {\r\n            kb \u003d 2;\r\n            kx \u003d k / 256 - 1;\r\n        } else {\r\n            kb \u003d 3;\r\n            kx \u003d k / 4096 - 1;\r\n        }\r\n        final Codec aCodec \u003d runCodec.getACodec();\r\n        final Codec bCodec \u003d runCodec.getBCodec();\r\n        int abDef \u003d 0;\r\n        if (aCodec.equals(defaultForBand)) {\r\n            abDef \u003d 1;\r\n        } else if (bCodec.equals(defaultForBand)) {\r\n            abDef \u003d 2;\r\n        }\r\n        final int first \u003d 117 + kb + (kx \u003d\u003d 3 ? 0 : 4) + 8 * abDef;\r\n        final int[] aSpecifier \u003d abDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(aCodec, defaultForBand);\r\n        final int[] bSpecifier \u003d abDef \u003d\u003d 2 ? EMPTY_INT_ARRAY : getSpecifier(bCodec, defaultForBand);\r\n        final int[] specifier \u003d new int[1 + (kx \u003d\u003d 3 ? 0 : 1) + aSpecifier.length + bSpecifier.length];\r\n        specifier[0] \u003d first;\r\n        int index \u003d 1;\r\n        if (kx !\u003d 3) {\r\n            specifier[1] \u003d kx;\r\n            index++;\r\n        }\r\n        for (final int element : aSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : bSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        return specifier;\r\n    }\r\n    if (codec instanceof PopulationCodec) {\r\n        final PopulationCodec populationCodec \u003d (PopulationCodec) codec;\r\n        final Codec tokenCodec \u003d populationCodec.getTokenCodec();\r\n        final Codec favouredCodec \u003d populationCodec.getFavouredCodec();\r\n        final Codec unfavouredCodec \u003d populationCodec.getUnfavouredCodec();\r\n        final int fDef \u003d favouredCodec.equals(defaultForBand) ? 1 : 0;\r\n        final int uDef \u003d unfavouredCodec.equals(defaultForBand) ? 1 : 0;\r\n        int tDefL \u003d 0;\r\n        final int[] favoured \u003d populationCodec.getFavoured();\r\n        if (favoured !\u003d null) {\r\n            if (tokenCodec \u003d\u003d Codec.BYTE1) {\r\n                tDefL \u003d 1;\r\n            } else if (tokenCodec instanceof BHSDCodec) {\r\n                final BHSDCodec tokenBHSD \u003d (BHSDCodec) tokenCodec;\r\n                if (tokenBHSD.getS() \u003d\u003d 0) {\r\n                    final int[] possibleLValues \u003d { 4, 8, 16, 32, 64, 128, 192, 224, 240, 248, 252 };\r\n                    final int l \u003d 256 - tokenBHSD.getH();\r\n                    int index \u003d Arrays.binarySearch(possibleLValues, l);\r\n                    if (index !\u003d -1) {\r\n                        // TODO: check range is ok for ks\r\n                        tDefL \u003d index++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        final int first \u003d 141 + fDef + 2 * uDef + 4 * tDefL;\r\n        final int[] favouredSpecifier \u003d fDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(favouredCodec, defaultForBand);\r\n        final int[] tokenSpecifier \u003d tDefL !\u003d 0 ? EMPTY_INT_ARRAY : getSpecifier(tokenCodec, defaultForBand);\r\n        final int[] unfavouredSpecifier \u003d uDef \u003d\u003d 1 ? EMPTY_INT_ARRAY : getSpecifier(unfavouredCodec, defaultForBand);\r\n        final int[] specifier \u003d new int[1 + favouredSpecifier.length + unfavouredSpecifier.length + tokenSpecifier.length];\r\n        specifier[0] \u003d first;\r\n        int index \u003d 1;\r\n        for (final int element : favouredSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : tokenSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        for (final int element : unfavouredSpecifier) {\r\n            specifier[index] \u003d element;\r\n            index++;\r\n        }\r\n        return specifier;\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getConstant",
    "signature": "org.apache.commons.compress.harmony.pack200.CPConstant getConstant(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    CPConstant\u003c?\u003e constant \u003d objectsToCPConstant.get(value);\r\n    if (constant \u003d\u003d null) {\r\n        if (value instanceof Integer) {\r\n            constant \u003d new CPInt(((Integer) value).intValue());\r\n            cp_Int.add((CPInt) constant);\r\n        } else if (value instanceof Long) {\r\n            constant \u003d new CPLong(((Long) value).longValue());\r\n            cp_Long.add((CPLong) constant);\r\n        } else if (value instanceof Float) {\r\n            constant \u003d new CPFloat(((Float) value).floatValue());\r\n            cp_Float.add((CPFloat) constant);\r\n        } else if (value instanceof Double) {\r\n            constant \u003d new CPDouble(((Double) value).doubleValue());\r\n            cp_Double.add((CPDouble) constant);\r\n        } else if (value instanceof String) {\r\n            constant \u003d new CPString(getCPUtf8((String) value));\r\n            cp_String.add((CPString) constant);\r\n        } else if (value instanceof Type) {\r\n            String className \u003d ((Type) value).getClassName();\r\n            if (className.endsWith(\"[]\")) {\r\n                className \u003d \"[L\" + className.substring(0, className.length() - 2);\r\n                while (className.endsWith(\"[]\")) {\r\n                    className \u003d \"[\" + className.substring(0, className.length() - 2);\r\n                }\r\n                className +\u003d \";\";\r\n            }\r\n            constant \u003d getCPClass(className);\r\n        }\r\n        objectsToCPConstant.put(value, constant);\r\n    }\r\n    return constant;\r\n}",
    "nodes": 20,
    "edges": 28,
    "cc": 10,
    "flowSummary": [
      "B0 : If(r37 !\u003d null) → B1 | else → B19",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z3 \u003d\u003d false) → B8 | else → B9",
      "B9 : If($z4 \u003d\u003d false) → B10 | else → B11",
      "B11 : If($z5 \u003d\u003d false) → B12 | else → B18",
      "B12 : If($z6 \u003d\u003d false) → B13 | else → B17",
      "B14 : If($z7 \u003d\u003d false) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  Object\n  $r2 \u003d Map objectsToCPConstant\u003e\n  $r3 \u003d $r2.get(r1)\n  r37 \u003d CPConstant) $r3\n  if (r37 !\u003d null) goto B1 else B19\n}",
      "B1 {\n  $z0 \u003d Integer\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r33 \u003d CPInt\n  $r34 \u003d Integer) r1\n  $i5 \u003d $r34.intValue()\n  new CPInt($i5)\n  r37 \u003d $r33\n  $r36 \u003d Set cp_Int\u003e\n  $r35 \u003d CPInt) $r33\n  $r36.add($r35)\n  goto B18\n}",
      "B3 {\n  $z1 \u003d Long\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r29 \u003d CPLong\n  $r30 \u003d Long) r1\n  $l4 \u003d $r30.longValue()\n  new CPLong($l4)\n  r37 \u003d $r29\n  $r32 \u003d Set cp_Long\u003e\n  $r31 \u003d CPLong) $r29\n  $r32.add($r31)\n  goto B18\n}",
      "B5 {\n  $z2 \u003d Float\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r25 \u003d CPFloat\n  $r26 \u003d Float) r1\n  $f0 \u003d $r26.floatValue()\n  new CPFloat($f0)\n  r37 \u003d $r25\n  $r28 \u003d Set cp_Float\u003e\n  $r27 \u003d CPFloat) $r25\n  $r28.add($r27)\n  goto B18\n}",
      "B7 {\n  $z3 \u003d Double\n  if ($z3 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r21 \u003d CPDouble\n  $r22 \u003d Double) r1\n  $d0 \u003d $r22.doubleValue()\n  new CPDouble($d0)\n  r37 \u003d $r21\n  $r24 \u003d Set cp_Double\u003e\n  $r23 \u003d CPDouble) $r21\n  $r24.add($r23)\n  goto B18\n}",
      "B9 {\n  $z4 \u003d String\n  if ($z4 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r16 \u003d CPString\n  $r17 \u003d String) r1\n  $r18 \u003d r0.getCPUtf8($r17)\n  new CPString($r18)\n  r37 \u003d $r16\n  $r20 \u003d Set cp_String\u003e\n  $r19 \u003d CPString) $r16\n  $r20.add($r19)\n  goto B18\n}",
      "B11 {\n  $z5 \u003d Type\n  if ($z5 \u003d\u003d false) goto B12 else B18\n}",
      "B12 {\n  $r4 \u003d Type) r1\n  r38 \u003d $r4.getClassName()\n  $z6 \u003d r38.endsWith(\"\")\n  if ($z6 \u003d\u003d false) goto B13 else B17\n}",
      "B13 {\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r5.append(\"L\")\n  $i0 \u003d r38.length()\n  $i1 \u003d $i0 - 2\n  $r6 \u003d r38.substring(0, $i1)\n  $r8 \u003d $r7.append($r6)\n  r39 \u003d $r8.toString()\n}",
      "B14 {\n  $z7 \u003d r39.endsWith(\"\")\n  if ($z7 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $r12 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r12.append(\"\")\n  $i2 \u003d r39.length()\n  $i3 \u003d $i2 - 2\n  $r13 \u003d r39.substring(0, $i3)\n  $r15 \u003d $r14.append($r13)\n  r39 \u003d $r15.toString()\n  goto B14\n}",
      "B16 {\n  $r9 \u003d StringBuilder\n  new StringBuilder()\n  $r10 \u003d $r9.append(r39)\n  $r11 \u003d $r10.append(\";\")\n  r38 \u003d $r11.toString()\n}",
      "B17 {\n  r37 \u003d r0.getCPClass(r38)\n}",
      "B18 {\n  $r40 \u003d Map objectsToCPConstant\u003e\n  $r40.put(r1, r37)\n}",
      "B19 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B19",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B18",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B18",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B18",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B18",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B18",
      "B11 --\u003e B12",
      "B11 --\u003e B18",
      "B12 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B14",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPUtf8(...1)",
        "body": "{\r\n    if (utf8 \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPUTF8 cpUtf8 \u003d stringsToCpUtf8.get(utf8);\r\n    if (cpUtf8 \u003d\u003d null) {\r\n        cpUtf8 \u003d new CPUTF8(utf8);\r\n        cp_Utf8.add(cpUtf8);\r\n        stringsToCpUtf8.put(utf8, cpUtf8);\r\n    }\r\n    return cpUtf8;\r\n}"
      },
      {
        "name": "CpBands#getCPClass(...1)",
        "body": "{\r\n    if (className \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    className \u003d className.replace(\u0027.\u0027, \u0027/\u0027);\r\n    CPClass cpClass \u003d stringsToCpClass.get(className);\r\n    if (cpClass \u003d\u003d null) {\r\n        final CPUTF8 cpUtf8 \u003d getCPUtf8(className);\r\n        cpClass \u003d new CPClass(cpUtf8);\r\n        cp_Class.add(cpClass);\r\n        stringsToCpClass.put(className, cpClass);\r\n    }\r\n    if (cpClass.isInnerClass()) {\r\n        segment.getClassBands().currentClassReferencesInnerClass(cpClass);\r\n    }\r\n    return cpClass;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPClass",
    "signature": "org.apache.commons.compress.harmony.pack200.CPClass getCPClass(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (className \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    className \u003d className.replace(\u0027.\u0027, \u0027/\u0027);\r\n    CPClass cpClass \u003d stringsToCpClass.get(className);\r\n    if (cpClass \u003d\u003d null) {\r\n        final CPUTF8 cpUtf8 \u003d getCPUtf8(className);\r\n        cpClass \u003d new CPClass(cpUtf8);\r\n        cp_Class.add(cpClass);\r\n        stringsToCpClass.put(className, cpClass);\r\n    }\r\n    if (cpClass.isInnerClass()) {\r\n        segment.getClassBands().currentClassReferencesInnerClass(cpClass);\r\n    }\r\n    return cpClass;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r9 !\u003d null) → B1 | else → B2",
      "B2 : If(r11 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  if (r9 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r10 \u003d r9.replace(46, 47)\n  $r1 \u003d Map stringsToCpClass\u003e\n  $r2 \u003d $r1.get(r10)\n  r11 \u003d CPClass) $r2\n  if (r11 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r5 \u003d r0.getCPUtf8(r10)\n  $r6 \u003d CPClass\n  new CPClass(r5)\n  r11 \u003d $r6\n  $r7 \u003d Set cp_Class\u003e\n  $r7.add($r6)\n  $r8 \u003d Map stringsToCpClass\u003e\n  $r8.put(r10, $r6)\n}",
      "B4 {\n  $z0 \u003d r11.isInnerClass()\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d Segment segment\u003e\n  $r4 \u003d $r3.getClassBands()\n  $r4.currentClassReferencesInnerClass(r11)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPUtf8(...1)",
        "body": "{\r\n    if (utf8 \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPUTF8 cpUtf8 \u003d stringsToCpUtf8.get(utf8);\r\n    if (cpUtf8 \u003d\u003d null) {\r\n        cpUtf8 \u003d new CPUTF8(utf8);\r\n        cp_Utf8.add(cpUtf8);\r\n        stringsToCpUtf8.put(utf8, cpUtf8);\r\n    }\r\n    return cpUtf8;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPField",
    "signature": "org.apache.commons.compress.harmony.pack200.CPMethodOrField getCPField(org.apache.commons.compress.harmony.pack200.CPClass,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String key \u003d cpClass.toString() + \":\" + name + \":\" + desc;\r\n    CPMethodOrField cpF \u003d stringsToCpField.get(key);\r\n    if (cpF \u003d\u003d null) {\r\n        final CPNameAndType nAndT \u003d getCPNameAndType(name, desc);\r\n        cpF \u003d new CPMethodOrField(cpClass, nAndT);\r\n        cp_Field.add(cpF);\r\n        stringsToCpField.put(key, cpF);\r\n    }\r\n    return cpF;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r18 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  CPClass\n  String\n  String\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d r1.toString()\n  $r3 \u003d $r0.append($r2)\n  $r5 \u003d $r3.append(\":\")\n  $r6 \u003d $r5.append(r4)\n  $r8 \u003d $r6.append(\":\")\n  $r9 \u003d $r8.append(r7)\n  r10 \u003d $r9.toString()\n  $r12 \u003d Map stringsToCpField\u003e\n  $r13 \u003d $r12.get(r10)\n  r18 \u003d CPMethodOrField) $r13\n  if (r18 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d r11.getCPNameAndType(r4, r7)\n  $r15 \u003d CPMethodOrField\n  new CPMethodOrField(r1, r14)\n  r18 \u003d $r15\n  $r16 \u003d Set cp_Field\u003e\n  $r16.add($r15)\n  $r17 \u003d Map stringsToCpField\u003e\n  $r17.put(r10, $r15)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPNameAndType(...2)",
        "body": "{\r\n    final String descr \u003d name + \":\" + signature;\r\n    CPNameAndType nameAndType \u003d stringsToCpNameAndType.get(descr);\r\n    if (nameAndType \u003d\u003d null) {\r\n        nameAndType \u003d new CPNameAndType(getCPUtf8(name), getCPSignature(signature));\r\n        stringsToCpNameAndType.put(descr, nameAndType);\r\n        cp_Descr.add(nameAndType);\r\n    }\r\n    return nameAndType;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPIMethod",
    "signature": "org.apache.commons.compress.harmony.pack200.CPMethodOrField getCPIMethod(org.apache.commons.compress.harmony.pack200.CPClass,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String key \u003d cpClass.toString() + \":\" + name + \":\" + desc;\r\n    CPMethodOrField cpIM \u003d stringsToCpIMethod.get(key);\r\n    if (cpIM \u003d\u003d null) {\r\n        final CPNameAndType nAndT \u003d getCPNameAndType(name, desc);\r\n        cpIM \u003d new CPMethodOrField(cpClass, nAndT);\r\n        cp_Imethod.add(cpIM);\r\n        stringsToCpIMethod.put(key, cpIM);\r\n    }\r\n    return cpIM;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r18 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  CPClass\n  String\n  String\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d r1.toString()\n  $r3 \u003d $r0.append($r2)\n  $r5 \u003d $r3.append(\":\")\n  $r6 \u003d $r5.append(r4)\n  $r8 \u003d $r6.append(\":\")\n  $r9 \u003d $r8.append(r7)\n  r10 \u003d $r9.toString()\n  $r12 \u003d Map stringsToCpIMethod\u003e\n  $r13 \u003d $r12.get(r10)\n  r18 \u003d CPMethodOrField) $r13\n  if (r18 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d r11.getCPNameAndType(r4, r7)\n  $r15 \u003d CPMethodOrField\n  new CPMethodOrField(r1, r14)\n  r18 \u003d $r15\n  $r16 \u003d Set cp_Imethod\u003e\n  $r16.add($r15)\n  $r17 \u003d Map stringsToCpIMethod\u003e\n  $r17.put(r10, $r15)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPNameAndType(...2)",
        "body": "{\r\n    final String descr \u003d name + \":\" + signature;\r\n    CPNameAndType nameAndType \u003d stringsToCpNameAndType.get(descr);\r\n    if (nameAndType \u003d\u003d null) {\r\n        nameAndType \u003d new CPNameAndType(getCPUtf8(name), getCPSignature(signature));\r\n        stringsToCpNameAndType.put(descr, nameAndType);\r\n        cp_Descr.add(nameAndType);\r\n    }\r\n    return nameAndType;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPMethod",
    "signature": "org.apache.commons.compress.harmony.pack200.CPMethodOrField getCPMethod(org.apache.commons.compress.harmony.pack200.CPClass,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String key \u003d cpClass.toString() + \":\" + name + \":\" + desc;\r\n    CPMethodOrField cpM \u003d stringsToCpMethod.get(key);\r\n    if (cpM \u003d\u003d null) {\r\n        final CPNameAndType nAndT \u003d getCPNameAndType(name, desc);\r\n        cpM \u003d new CPMethodOrField(cpClass, nAndT);\r\n        cp_Method.add(cpM);\r\n        stringsToCpMethod.put(key, cpM);\r\n    }\r\n    return cpM;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r18 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  CPClass\n  String\n  String\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d r1.toString()\n  $r3 \u003d $r0.append($r2)\n  $r5 \u003d $r3.append(\":\")\n  $r6 \u003d $r5.append(r4)\n  $r8 \u003d $r6.append(\":\")\n  $r9 \u003d $r8.append(r7)\n  r10 \u003d $r9.toString()\n  $r12 \u003d Map stringsToCpMethod\u003e\n  $r13 \u003d $r12.get(r10)\n  r18 \u003d CPMethodOrField) $r13\n  if (r18 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d r11.getCPNameAndType(r4, r7)\n  $r15 \u003d CPMethodOrField\n  new CPMethodOrField(r1, r14)\n  r18 \u003d $r15\n  $r16 \u003d Set cp_Method\u003e\n  $r16.add($r15)\n  $r17 \u003d Map stringsToCpMethod\u003e\n  $r17.put(r10, $r15)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPNameAndType(...2)",
        "body": "{\r\n    final String descr \u003d name + \":\" + signature;\r\n    CPNameAndType nameAndType \u003d stringsToCpNameAndType.get(descr);\r\n    if (nameAndType \u003d\u003d null) {\r\n        nameAndType \u003d new CPNameAndType(getCPUtf8(name), getCPSignature(signature));\r\n        stringsToCpNameAndType.put(descr, nameAndType);\r\n        cp_Descr.add(nameAndType);\r\n    }\r\n    return nameAndType;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPNameAndType",
    "signature": "org.apache.commons.compress.harmony.pack200.CPNameAndType getCPNameAndType(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String descr \u003d name + \":\" + signature;\r\n    CPNameAndType nameAndType \u003d stringsToCpNameAndType.get(descr);\r\n    if (nameAndType \u003d\u003d null) {\r\n        nameAndType \u003d new CPNameAndType(getCPUtf8(name), getCPSignature(signature));\r\n        stringsToCpNameAndType.put(descr, nameAndType);\r\n        cp_Descr.add(nameAndType);\r\n    }\r\n    return nameAndType;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r15 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  String\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r0.append(r1)\n  $r4 \u003d $r2.append(\":\")\n  $r5 \u003d $r4.append(r3)\n  r6 \u003d $r5.toString()\n  $r8 \u003d Map stringsToCpNameAndType\u003e\n  $r9 \u003d $r8.get(r6)\n  r15 \u003d CPNameAndType) $r9\n  if (r15 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d CPNameAndType\n  $r12 \u003d r7.getCPUtf8(r1)\n  $r11 \u003d r7.getCPSignature(r3)\n  new CPNameAndType($r12, $r11)\n  r15 \u003d $r10\n  $r13 \u003d Map stringsToCpNameAndType\u003e\n  $r13.put(r6, $r10)\n  $r14 \u003d Set cp_Descr\u003e\n  $r14.add($r10)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPUtf8(...1)",
        "body": "{\r\n    if (utf8 \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPUTF8 cpUtf8 \u003d stringsToCpUtf8.get(utf8);\r\n    if (cpUtf8 \u003d\u003d null) {\r\n        cpUtf8 \u003d new CPUTF8(utf8);\r\n        cp_Utf8.add(cpUtf8);\r\n        stringsToCpUtf8.put(utf8, cpUtf8);\r\n    }\r\n    return cpUtf8;\r\n}"
      },
      {
        "name": "CpBands#getCPSignature(...1)",
        "body": "{\r\n    if (signature \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPSignature cpS \u003d stringsToCpSignature.get(signature);\r\n    if (cpS \u003d\u003d null) {\r\n        final List\u003cCPClass\u003e cpClasses \u003d new ArrayList\u003c\u003e();\r\n        final CPUTF8 signatureUTF8;\r\n        if (signature.length() \u003e 1 \u0026\u0026 signature.indexOf(\u0027L\u0027) !\u003d -1) {\r\n            final List\u003cString\u003e classes \u003d new ArrayList\u003c\u003e();\r\n            final char[] chars \u003d signature.toCharArray();\r\n            final StringBuilder signatureString \u003d new StringBuilder();\r\n            for (int i \u003d 0; i \u003c chars.length; i++) {\r\n                signatureString.append(chars[i]);\r\n                if (chars[i] \u003d\u003d \u0027L\u0027) {\r\n                    final StringBuilder className \u003d new StringBuilder();\r\n                    for (int j \u003d i + 1; j \u003c chars.length; j++) {\r\n                        final char c \u003d chars[j];\r\n                        if (!Character.isLetter(c) \u0026\u0026 !Character.isDigit(c) \u0026\u0026 c !\u003d \u0027/\u0027 \u0026\u0026 c !\u003d \u0027$\u0027 \u0026\u0026 c !\u003d \u0027_\u0027) {\r\n                            classes.add(className.toString());\r\n                            i \u003d j - 1;\r\n                            break;\r\n                        }\r\n                        className.append(c);\r\n                    }\r\n                }\r\n            }\r\n            removeCpUtf8(signature);\r\n            for (String className : classes) {\r\n                CPClass cpClass \u003d null;\r\n                if (className !\u003d null) {\r\n                    className \u003d className.replace(\u0027.\u0027, \u0027/\u0027);\r\n                    cpClass \u003d stringsToCpClass.get(className);\r\n                    if (cpClass \u003d\u003d null) {\r\n                        final CPUTF8 cpUtf8 \u003d getCPUtf8(className);\r\n                        cpClass \u003d new CPClass(cpUtf8);\r\n                        cp_Class.add(cpClass);\r\n                        stringsToCpClass.put(className, cpClass);\r\n                    }\r\n                }\r\n                cpClasses.add(cpClass);\r\n            }\r\n            signatureUTF8 \u003d getCPUtf8(signatureString.toString());\r\n        } else {\r\n            signatureUTF8 \u003d getCPUtf8(signature);\r\n        }\r\n        cpS \u003d new CPSignature(signature, signatureUTF8, cpClasses);\r\n        cp_Signature.add(cpS);\r\n        stringsToCpSignature.put(signature, cpS);\r\n    }\r\n    return cpS;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPSignature",
    "signature": "org.apache.commons.compress.harmony.pack200.CPSignature getCPSignature(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (signature \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPSignature cpS \u003d stringsToCpSignature.get(signature);\r\n    if (cpS \u003d\u003d null) {\r\n        final List\u003cCPClass\u003e cpClasses \u003d new ArrayList\u003c\u003e();\r\n        final CPUTF8 signatureUTF8;\r\n        if (signature.length() \u003e 1 \u0026\u0026 signature.indexOf(\u0027L\u0027) !\u003d -1) {\r\n            final List\u003cString\u003e classes \u003d new ArrayList\u003c\u003e();\r\n            final char[] chars \u003d signature.toCharArray();\r\n            final StringBuilder signatureString \u003d new StringBuilder();\r\n            for (int i \u003d 0; i \u003c chars.length; i++) {\r\n                signatureString.append(chars[i]);\r\n                if (chars[i] \u003d\u003d \u0027L\u0027) {\r\n                    final StringBuilder className \u003d new StringBuilder();\r\n                    for (int j \u003d i + 1; j \u003c chars.length; j++) {\r\n                        final char c \u003d chars[j];\r\n                        if (!Character.isLetter(c) \u0026\u0026 !Character.isDigit(c) \u0026\u0026 c !\u003d \u0027/\u0027 \u0026\u0026 c !\u003d \u0027$\u0027 \u0026\u0026 c !\u003d \u0027_\u0027) {\r\n                            classes.add(className.toString());\r\n                            i \u003d j - 1;\r\n                            break;\r\n                        }\r\n                        className.append(c);\r\n                    }\r\n                }\r\n            }\r\n            removeCpUtf8(signature);\r\n            for (String className : classes) {\r\n                CPClass cpClass \u003d null;\r\n                if (className !\u003d null) {\r\n                    className \u003d className.replace(\u0027.\u0027, \u0027/\u0027);\r\n                    cpClass \u003d stringsToCpClass.get(className);\r\n                    if (cpClass \u003d\u003d null) {\r\n                        final CPUTF8 cpUtf8 \u003d getCPUtf8(className);\r\n                        cpClass \u003d new CPClass(cpUtf8);\r\n                        cp_Class.add(cpClass);\r\n                        stringsToCpClass.put(className, cpClass);\r\n                    }\r\n                }\r\n                cpClasses.add(cpClass);\r\n            }\r\n            signatureUTF8 \u003d getCPUtf8(signatureString.toString());\r\n        } else {\r\n            signatureUTF8 \u003d getCPUtf8(signature);\r\n        }\r\n        cpS \u003d new CPSignature(signature, signatureUTF8, cpClasses);\r\n        cp_Signature.add(cpS);\r\n        stringsToCpSignature.put(signature, cpS);\r\n    }\r\n    return cpS;\r\n}",
    "nodes": 28,
    "edges": 41,
    "cc": 15,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r17 !\u003d null) → B3 | else → B27",
      "B3 : If($i0 \u003c\u003d 1) → B4 | else → B25",
      "B4 : If($i1 \u003d\u003d $i10) → B5 | else → B25",
      "B6 : If(i6 \u003e\u003d $i2) → B7 | else → B18",
      "B7 : If($i11 !\u003d 76) → B8 | else → B17",
      "B9 : If(i7 \u003e\u003d $i5) → B10 | else → B17",
      "B10 : If($z1 !\u003d 0) → B11 | else → B16",
      "B11 : If($z2 !\u003d 0) → B12 | else → B16",
      "B12 : If($i12 \u003d\u003d 47) → B13 | else → B16",
      "B13 : If($i13 \u003d\u003d 36) → B14 | else → B16",
      "B14 : If($i14 \u003d\u003d 95) → B15 | else → B16",
      "B19 : If($z0 \u003d\u003d false) → B20 | else → B24",
      "B20 : If(r19 \u003d\u003d null) → B21 | else → B23",
      "B21 : If(r20 !\u003d null) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Map stringsToCpSignature\u003e\n  $r3 \u003d $r2.get(r0)\n  r17 \u003d CPSignature) $r3\n  if (r17 !\u003d null) goto B3 else B27\n}",
      "B3 {\n  $r27 \u003d ArrayList\n  new ArrayList()\n  $i0 \u003d r0.length()\n  if ($i0 \u003c\u003d 1) goto B4 else B25\n}",
      "B4 {\n  $i1 \u003d r0.indexOf(76)\n  $i10 \u003d (int) -1\n  if ($i1 \u003d\u003d $i10) goto B5 else B25\n}",
      "B5 {\n  $r28 \u003d ArrayList\n  new ArrayList()\n  r6 \u003d r0.toCharArray()\n  $r29 \u003d StringBuilder\n  new StringBuilder()\n  i6 \u003d 0\n}",
      "B6 {\n  $i2 \u003d lengthof r6\n  if (i6 \u003e\u003d $i2) goto B7 else B18\n}",
      "B7 {\n  $c3 \u003d r6[i6]\n  $r29.append($c3)\n  $c4 \u003d r6[i6]\n  $i11 \u003d (int) $c4\n  if ($i11 !\u003d 76) goto B8 else B17\n}",
      "B8 {\n  $r30 \u003d StringBuilder\n  new StringBuilder()\n  i7 \u003d i6 + 1\n}",
      "B9 {\n  $i5 \u003d lengthof r6\n  if (i7 \u003e\u003d $i5) goto B10 else B17\n}",
      "B10 {\n  c8 \u003d r6[i7]\n  $z1 \u003d Character.isLetter(c8)\n  if ($z1 !\u003d 0) goto B11 else B16\n}",
      "B11 {\n  $z2 \u003d Character.isDigit(c8)\n  if ($z2 !\u003d 0) goto B12 else B16\n}",
      "B12 {\n  $i12 \u003d (int) c8\n  if ($i12 \u003d\u003d 47) goto B13 else B16\n}",
      "B13 {\n  $i13 \u003d (int) c8\n  if ($i13 \u003d\u003d 36) goto B14 else B16\n}",
      "B14 {\n  $i14 \u003d (int) c8\n  if ($i14 \u003d\u003d 95) goto B15 else B16\n}",
      "B15 {\n  $r16 \u003d $r30.toString()\n  $r28.add($r16)\n  i6 \u003d i7 - 1\n  goto B17\n}",
      "B16 {\n  $r30.append(c8)\n  i7 \u003d i7 + 1\n  goto B9\n}",
      "B17 {\n  i6 \u003d i6 + 1\n  goto B6\n}",
      "B18 {\n  r1.removeCpUtf8(r0)\n  r18 \u003d $r28.iterator()\n}",
      "B19 {\n  $z0 \u003d r18.hasNext()\n  if ($z0 \u003d\u003d false) goto B20 else B24\n}",
      "B20 {\n  $r9 \u003d r18.next()\n  r19 \u003d String) $r9\n  r20 \u003d null\n  if (r19 \u003d\u003d null) goto B21 else B23\n}",
      "B21 {\n  r21 \u003d r19.replace(46, 47)\n  $r10 \u003d Map stringsToCpClass\u003e\n  $r11 \u003d $r10.get(r21)\n  r20 \u003d CPClass) $r11\n  if (r20 !\u003d null) goto B22 else B23\n}",
      "B22 {\n  r22 \u003d r1.getCPUtf8(r21)\n  $r31 \u003d CPClass\n  new CPClass(r22)\n  r20 \u003d $r31\n  $r13 \u003d Set cp_Class\u003e\n  $r13.add($r31)\n  $r14 \u003d Map stringsToCpClass\u003e\n  $r14.put(r21, $r31)\n}",
      "B23 {\n  $r27.add(r20)\n  goto B19\n}",
      "B24 {\n  $r8 \u003d $r29.toString()\n  r23 \u003d r1.getCPUtf8($r8)\n  goto B26\n}",
      "B25 {\n  r23 \u003d r1.getCPUtf8(r0)\n}",
      "B26 {\n  $r32 \u003d CPSignature\n  new CPSignature(r0, r23, $r27)\n  r17 \u003d $r32\n  $r25 \u003d Set cp_Signature\u003e\n  $r25.add($r32)\n  $r26 \u003d Map stringsToCpSignature\u003e\n  $r26.put(r0, $r32)\n}",
      "B27 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B27",
      "B3 --\u003e B4",
      "B3 --\u003e B25",
      "B4 --\u003e B5",
      "B4 --\u003e B25",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B18",
      "B7 --\u003e B8",
      "B7 --\u003e B17",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B17",
      "B10 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B9",
      "B17 --\u003e B6",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B24",
      "B20 --\u003e B21",
      "B20 --\u003e B23",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B19",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B27 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#getCPUtf8(...1)",
        "body": "{\r\n    if (utf8 \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPUTF8 cpUtf8 \u003d stringsToCpUtf8.get(utf8);\r\n    if (cpUtf8 \u003d\u003d null) {\r\n        cpUtf8 \u003d new CPUTF8(utf8);\r\n        cp_Utf8.add(cpUtf8);\r\n        stringsToCpUtf8.put(utf8, cpUtf8);\r\n    }\r\n    return cpUtf8;\r\n}"
      },
      {
        "name": "CpBands#removeCpUtf8(...1)",
        "body": "{\r\n    final CPUTF8 utf8 \u003d stringsToCpUtf8.get(string);\r\n    if (utf8 !\u003d null \u0026\u0026 stringsToCpClass.get(string) \u003d\u003d null) {\r\n        // don\u0027t remove if strings are also in cpclass\r\n        stringsToCpUtf8.remove(string);\r\n        cp_Utf8.remove(utf8);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CpBands",
    "methodName": "getCPUtf8",
    "signature": "org.apache.commons.compress.harmony.pack200.CPUTF8 getCPUtf8(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (utf8 \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    CPUTF8 cpUtf8 \u003d stringsToCpUtf8.get(utf8);\r\n    if (cpUtf8 \u003d\u003d null) {\r\n        cpUtf8 \u003d new CPUTF8(utf8);\r\n        cp_Utf8.add(cpUtf8);\r\n        stringsToCpUtf8.put(utf8, cpUtf8);\r\n    }\r\n    return cpUtf8;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r7 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Map stringsToCpUtf8\u003e\n  $r3 \u003d $r2.get(r0)\n  r7 \u003d CPUTF8) $r3\n  if (r7 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d CPUTF8\n  new CPUTF8(r0)\n  r7 \u003d $r4\n  $r5 \u003d Set cp_Utf8\u003e\n  $r5.add($r4)\n  $r6 \u003d Map stringsToCpUtf8\u003e\n  $r6.put(r0, $r4)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CPMethodOrField",
    "methodName": "compareTo",
    "signature": "int compareTo(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (obj instanceof CPMethodOrField) {\r\n        final CPMethodOrField mof \u003d (CPMethodOrField) obj;\r\n        final int compareName \u003d className.compareTo(mof.className);\r\n        if (compareName \u003d\u003d 0) {\r\n            return nameAndType.compareTo(mof.nameAndType);\r\n        }\r\n        return compareName;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B4",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CPMethodOrField\n  Object\n  $z0 \u003d CPMethodOrField\n  if ($z0 \u003d\u003d false) goto B1 else B4\n}",
      "B1 {\n  r1 \u003d CPMethodOrField) r0\n  $r4 \u003d CPClass className\u003e\n  $r3 \u003d CPClass className\u003e\n  i0 \u003d $r4.compareTo($r3)\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d CPNameAndType nameAndType\u003e\n  $r5 \u003d CPNameAndType nameAndType\u003e\n  $i1 \u003d $r6.compareTo($r5)\n  return\n}",
      "B3 {\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CPNameAndType",
    "methodName": "compareTo",
    "signature": "int compareTo(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (obj instanceof CPNameAndType) {\r\n        final CPNameAndType nat \u003d (CPNameAndType) obj;\r\n        final int compareSignature \u003d signature.compareTo(nat.signature);\r\n        if (compareSignature \u003d\u003d 0) {\r\n            return name.compareTo(nat.name);\r\n        }\r\n        return compareSignature;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B4",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CPNameAndType\n  Object\n  $z0 \u003d CPNameAndType\n  if ($z0 \u003d\u003d false) goto B1 else B4\n}",
      "B1 {\n  r1 \u003d CPNameAndType) r0\n  $r4 \u003d CPSignature signature\u003e\n  $r3 \u003d CPSignature signature\u003e\n  i0 \u003d $r4.compareTo($r3)\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d CPUTF8 name\u003e\n  $r5 \u003d CPUTF8 name\u003e\n  $i1 \u003d $r6.compareTo($r5)\n  return\n}",
      "B3 {\n  return\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.CPSignature",
    "methodName": "compareTo",
    "signature": "int compareTo(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (signature.equals(((CPSignature) arg0).signature)) {\r\n        return 0;\r\n    }\r\n    if (formStartsWithBracket \u0026\u0026 !((CPSignature) arg0).formStartsWithBracket) {\r\n        return 1;\r\n    }\r\n    if (((CPSignature) arg0).formStartsWithBracket \u0026\u0026 !formStartsWithBracket) {\r\n        return -1;\r\n    }\r\n    if (classes.size() - ((CPSignature) arg0).classes.size() !\u003d 0) {\r\n        return classes.size() - ((CPSignature) arg0).classes.size();\r\n    }\r\n    if (classes.size() \u003e 0) {\r\n        for (int i \u003d classes.size() - 1; i \u003e\u003d 0; i--) {\r\n            final CPClass cpClass \u003d classes.get(i);\r\n            final CPClass compareClass \u003d ((CPSignature) arg0).classes.get(i);\r\n            final int classComp \u003d cpClass.compareTo(compareClass);\r\n            if (classComp !\u003d 0) {\r\n                return classComp;\r\n            }\r\n        }\r\n    }\r\n    return signature.compareTo(((CPSignature) arg0).signature);\r\n}",
    "nodes": 17,
    "edges": 20,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z4 !\u003d 0) → B4 | else → B5",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z3 !\u003d 0) → B7 | else → B8",
      "B8 : If($i2 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($i3 \u003c\u003d 0) → B11 | else → B16",
      "B12 : If(i10 \u003c 0) → B13 | else → B16",
      "B13 : If(i6 \u003d\u003d false) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  CPSignature\n  Object\n  $r4 \u003d String signature\u003e\n  $r2 \u003d CPSignature) r1\n  $r3 \u003d String signature\u003e\n  $z0 \u003d $r4.equals($r3)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z1 \u003d CPSignature: boolean formStartsWithBracket\u003e\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r24 \u003d CPSignature) r1\n  $z4 \u003d CPSignature: boolean formStartsWithBracket\u003e\n  if ($z4 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r5 \u003d CPSignature) r1\n  $z2 \u003d CPSignature: boolean formStartsWithBracket\u003e\n  if ($z2 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $z3 \u003d CPSignature: boolean formStartsWithBracket\u003e\n  if ($z3 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $i12 \u003d (int) -1\n  return\n}",
      "B8 {\n  $r6 \u003d List classes\u003e\n  $i1 \u003d $r6.size()\n  $r7 \u003d CPSignature) r1\n  $r8 \u003d List classes\u003e\n  $i0 \u003d $r8.size()\n  $i2 \u003d $i1 - $i0\n  if ($i2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r21 \u003d List classes\u003e\n  $i8 \u003d $r21.size()\n  $r22 \u003d CPSignature) r1\n  $r23 \u003d List classes\u003e\n  $i7 \u003d $r23.size()\n  $i9 \u003d $i8 - $i7\n  return\n}",
      "B10 {\n  $r9 \u003d List classes\u003e\n  $i3 \u003d $r9.size()\n  if ($i3 \u003c\u003d 0) goto B11 else B16\n}",
      "B11 {\n  $r13 \u003d List classes\u003e\n  $i5 \u003d $r13.size()\n  i10 \u003d $i5 - 1\n}",
      "B12 {\n  if (i10 \u003c 0) goto B13 else B16\n}",
      "B13 {\n  $r14 \u003d List classes\u003e\n  $r15 \u003d $r14.get(i10)\n  r16 \u003d CPClass) $r15\n  $r17 \u003d CPSignature) r1\n  $r18 \u003d List classes\u003e\n  $r19 \u003d $r18.get(i10)\n  r20 \u003d CPClass) $r19\n  i6 \u003d r16.compareTo(r20)\n  if (i6 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  return\n}",
      "B15 {\n  $i14 \u003d (int) -1\n  i10 \u003d i10 + $i14\n  goto B12\n}",
      "B16 {\n  $r12 \u003d String signature\u003e\n  $r10 \u003d CPSignature) r1\n  $r11 \u003d String signature\u003e\n  $i4 \u003d $r12.compareTo($r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B12",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.FileBands",
    "methodName": "finaliseBands",
    "signature": "void finaliseBands()",
    "visibility": "public",
    "body": "{\r\n    file_name \u003d new int[fileName.length];\r\n    for (int i \u003d 0; i \u003c file_name.length; i++) {\r\n        if (fileName[i].equals(cpBands.getCPUtf8(\"\"))) {\r\n            final PackingFile packingFile \u003d fileList.get(i);\r\n            final String name \u003d packingFile.getName();\r\n            if (options.isPassFile(name)) {\r\n                fileName[i] \u003d cpBands.getCPUtf8(name);\r\n                file_options[i] \u0026\u003d 1 \u003c\u003c 1 ^ 0xFFFFFFFF;\r\n            }\r\n        }\r\n        file_name[i] \u003d fileName[i].getIndex();\r\n    }\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d $i1) → B2 | else → B6",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileBands\n  $r1 \u003d CPUTF8[] fileName\u003e\n  $i0 \u003d lengthof $r1\n  $r2 \u003d newarray (int)[$i0]\n  FileBands: int[] file_name\u003e \u003d $r2\n  i4 \u003d 0\n}",
      "B1 {\n  $r3 \u003d FileBands: int[] file_name\u003e\n  $i1 \u003d lengthof $r3\n  if (i4 \u003e\u003d $i1) goto B2 else B6\n}",
      "B2 {\n  $r4 \u003d CPUTF8[] fileName\u003e\n  $r6 \u003d $r4[i4]\n  $r5 \u003d CpBands cpBands\u003e\n  $r7 \u003d $r5.getCPUtf8(\"\")\n  $z0 \u003d $r6.equals($r7)\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r8 \u003d List fileList\u003e\n  $r9 \u003d $r8.get(i4)\n  r10 \u003d Archive$PackingFile) $r9\n  r11 \u003d r10.getName()\n  $r12 \u003d PackingOptions options\u003e\n  $z1 \u003d $r12.isPassFile(r11)\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r14 \u003d CPUTF8[] fileName\u003e\n  $r13 \u003d CpBands cpBands\u003e\n  $r15 \u003d $r13.getCPUtf8(r11)\n  $r14[i4] \u003d $r15\n  $r16 \u003d FileBands: int[] file_options\u003e\n  $i2 \u003d $r16[i4]\n  $i7 \u003d (int) -3\n  $i3 \u003d $i2 \u0026 $i7\n  $r16[i4] \u003d $i3\n}",
      "B5 {\n  $r17 \u003d FileBands: int[] file_name\u003e\n  $r18 \u003d CPUTF8[] fileName\u003e\n  $r19 \u003d $r18[i4]\n  $i5 \u003d $r19.getIndex()\n  $r17[i4] \u003d $i5\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.FileBands",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    PackingUtils.log(\"Writing file bands...\");\r\n    byte[] encodedBand \u003d encodeBandInt(\"file_name\", file_name, Codec.UNSIGNED5);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from file_name[\" + file_name.length + \"]\");\r\n    encodedBand \u003d encodeFlags(\"file_size\", file_size, Codec.UNSIGNED5, Codec.UNSIGNED5, segmentHeader.have_file_size_hi());\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from file_size[\" + file_size.length + \"]\");\r\n    if (segmentHeader.have_file_modtime()) {\r\n        encodedBand \u003d encodeBandInt(\"file_modtime\", file_modtime, Codec.DELTA5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from file_modtime[\" + file_modtime.length + \"]\");\r\n    }\r\n    if (segmentHeader.have_file_options()) {\r\n        encodedBand \u003d encodeBandInt(\"file_options\", file_options, Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from file_options[\" + file_options.length + \"]\");\r\n    }\r\n    encodedBand \u003d encodeBandInt(\"file_bits\", flatten(file_bits), Codec.BYTE1);\r\n    out.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from file_bits[\" + file_bits.length + \"]\");\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z1 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FileBands\n  OutputStream\n  PackingUtils.log(\"Writing file bands...\")\n  $r2 \u003d FileBands: int[] file_name\u003e\n  $r1 \u003d BHSDCodec UNSIGNED5\u003e\n  r58 \u003d r0.encodeBandInt(\"file_name\", $r2, $r1)\n  r3.write(r58)\n  $r4 \u003d StringBuilder\n  new StringBuilder()\n  $r5 \u003d $r4.append(\"Wrote \")\n  $i0 \u003d lengthof r58\n  $r6 \u003d $r5.append($i0)\n  $r8 \u003d $r6.append(\" bytes from file_name\")\n  $r7 \u003d FileBands: int[] file_name\u003e\n  $i1 \u003d lengthof $r7\n  $r9 \u003d $r8.append($i1)\n  $r10 \u003d $r9.append(\"\")\n  $r11 \u003d $r10.toString()\n  PackingUtils.log($r11)\n  $r13 \u003d FileBands: long[] file_size\u003e\n  $r14 \u003d BHSDCodec UNSIGNED5\u003e\n  $r15 \u003d BHSDCodec UNSIGNED5\u003e\n  $r12 \u003d SegmentHeader segmentHeader\u003e\n  $z0 \u003d $r12.have_file_size_hi()\n  r59 \u003d r0.encodeFlags(\"file_size\", $r13, $r14, $r15, $z0)\n  r3.write(r59)\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r17 \u003d $r16.append(\"Wrote \")\n  $i2 \u003d lengthof r59\n  $r18 \u003d $r17.append($i2)\n  $r20 \u003d $r18.append(\" bytes from file_size\")\n  $r19 \u003d FileBands: long[] file_size\u003e\n  $i3 \u003d lengthof $r19\n  $r21 \u003d $r20.append($i3)\n  $r22 \u003d $r21.append(\"\")\n  $r23 \u003d $r22.toString()\n  PackingUtils.log($r23)\n  $r24 \u003d SegmentHeader segmentHeader\u003e\n  $z1 \u003d $r24.have_file_modtime()\n  if ($z1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r49 \u003d FileBands: int[] file_modtime\u003e\n  $r48 \u003d BHSDCodec DELTA5\u003e\n  r60 \u003d r0.encodeBandInt(\"file_modtime\", $r49, $r48)\n  r3.write(r60)\n  $r50 \u003d StringBuilder\n  new StringBuilder()\n  $r51 \u003d $r50.append(\"Wrote \")\n  $i8 \u003d lengthof r60\n  $r52 \u003d $r51.append($i8)\n  $r54 \u003d $r52.append(\" bytes from file_modtime\")\n  $r53 \u003d FileBands: int[] file_modtime\u003e\n  $i9 \u003d lengthof $r53\n  $r55 \u003d $r54.append($i9)\n  $r56 \u003d $r55.append(\"\")\n  $r57 \u003d $r56.toString()\n  PackingUtils.log($r57)\n}",
      "B2 {\n  $r25 \u003d SegmentHeader segmentHeader\u003e\n  $z2 \u003d $r25.have_file_options()\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r38 \u003d FileBands: int[] file_options\u003e\n  $r37 \u003d BHSDCodec UNSIGNED5\u003e\n  r61 \u003d r0.encodeBandInt(\"file_options\", $r38, $r37)\n  r3.write(r61)\n  $r39 \u003d StringBuilder\n  new StringBuilder()\n  $r40 \u003d $r39.append(\"Wrote \")\n  $i6 \u003d lengthof r61\n  $r41 \u003d $r40.append($i6)\n  $r43 \u003d $r41.append(\" bytes from file_options\")\n  $r42 \u003d FileBands: int[] file_options\u003e\n  $i7 \u003d lengthof $r42\n  $r44 \u003d $r43.append($i7)\n  $r45 \u003d $r44.append(\"\")\n  $r46 \u003d $r45.toString()\n  PackingUtils.log($r46)\n}",
      "B4 {\n  $r26 \u003d FileBands: byte[][] file_bits\u003e\n  $r28 \u003d r0.flatten($r26)\n  $r27 \u003d BHSDCodec BYTE1\u003e\n  $r47 \u003d r0.encodeBandInt(\"file_bits\", $r28, $r27)\n  r3.write($r47)\n  $r29 \u003d StringBuilder\n  new StringBuilder()\n  $r30 \u003d $r29.append(\"Wrote \")\n  $i4 \u003d lengthof $r47\n  $r31 \u003d $r30.append($i4)\n  $r33 \u003d $r31.append(\" bytes from file_bits\")\n  $r32 \u003d FileBands: byte[][] file_bits\u003e\n  $i5 \u003d lengthof $r32\n  $r34 \u003d $r33.append($i5)\n  $r35 \u003d $r34.append(\"\")\n  $r36 \u003d $r35.toString()\n  PackingUtils.log($r36)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FileBands#flatten(...1)",
        "body": "{\r\n    int total \u003d 0;\r\n    for (final byte[] element : bytes) {\r\n        total +\u003d element.length;\r\n    }\r\n    final int[] band \u003d new int[total];\r\n    int index \u003d 0;\r\n    for (final byte[] element : bytes) {\r\n        for (final byte element2 : element) {\r\n            band[index++] \u003d element2 \u0026 0xFF;\r\n        }\r\n    }\r\n    return band;\r\n}"
      },
      {
        "name": "FileBands#encodeBandInt(...3)",
        "body": "(source not found)"
      },
      {
        "name": "FileBands#encodeFlags(...5)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IcBands",
    "methodName": "addInnerClass",
    "signature": "void addInnerClass(java.lang.String,java.lang.String,java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    if (outerName !\u003d null || innerName !\u003d null) {\r\n        if (namesArePredictable(name, outerName, innerName)) {\r\n            final IcTuple innerClass \u003d new IcTuple(cpBands.getCPClass(name), flags, null, null);\r\n            addToMap(outerName, innerClass);\r\n            innerClasses.add(innerClass);\r\n        } else {\r\n            flags |\u003d 1 \u003c\u003c 16;\r\n            final IcTuple icTuple \u003d new IcTuple(cpBands.getCPClass(name), flags, cpBands.getCPClass(outerName), cpBands.getCPUtf8(innerName));\r\n            final boolean added \u003d innerClasses.add(icTuple);\r\n            if (added) {\r\n                bit16Count++;\r\n                addToMap(outerName, icTuple);\r\n            }\r\n        }\r\n    } else {\r\n        final IcTuple innerClass \u003d new IcTuple(cpBands.getCPClass(name), flags, null, null);\r\n        addToMap(getOuter(name), innerClass);\r\n        innerClasses.add(innerClass);\r\n    }\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B1 : If(r3 \u003d\u003d null) → B2 | else → B7",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  String\n  String\n  String\n  i2 :\u003d @parameter3: int\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r3 \u003d\u003d null) goto B2 else B7\n}",
      "B2 {\n  $z0 \u003d r1.namesArePredictable(r2, r0, r3)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d IcBands$IcTuple\n  $r13 \u003d CpBands cpBands\u003e\n  $r14 \u003d $r13.getCPClass(r2)\n  new IcBands$IcTuple($r14, i2, null, null)\n  r1.addToMap(r0, $r12)\n  $r15 \u003d Set innerClasses\u003e\n  $r15.add($r12)\n  goto B8\n}",
      "B4 {\n  i3 \u003d i2 | 65536\n  $r4 \u003d IcBands$IcTuple\n  $r5 \u003d CpBands cpBands\u003e\n  $r10 \u003d $r5.getCPClass(r2)\n  $r6 \u003d CpBands cpBands\u003e\n  $r9 \u003d $r6.getCPClass(r0)\n  $r7 \u003d CpBands cpBands\u003e\n  $r8 \u003d $r7.getCPUtf8(r3)\n  new IcBands$IcTuple($r10, i3, $r9, $r8)\n  $r11 \u003d Set innerClasses\u003e\n  z1 \u003d $r11.add($r4)\n  if (z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $i0 \u003d IcBands: int bit16Count\u003e\n  $i1 \u003d $i0 + 1\n  IcBands: int bit16Count\u003e \u003d $i1\n  r1.addToMap(r0, $r4)\n}",
      "B6 {\n  goto B8\n}",
      "B7 {\n  $r16 \u003d IcBands$IcTuple\n  $r17 \u003d CpBands cpBands\u003e\n  $r18 \u003d $r17.getCPClass(r2)\n  new IcBands$IcTuple($r18, i2, null, null)\n  $r19 \u003d r1.getOuter(r2)\n  r1.addToMap($r19, $r16)\n  $r20 \u003d Set innerClasses\u003e\n  $r20.add($r16)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcBands#namesArePredictable(...3)",
        "body": "{\r\n    // TODO: Could be multiple characters, not just $\r\n    return name.equals(outerName + \u0027$\u0027 + innerName) \u0026\u0026 innerName.indexOf(\u0027$\u0027) \u003d\u003d -1;\r\n}"
      },
      {
        "name": "IcBands#getOuter(...1)",
        "body": "{\r\n    return name.substring(0, name.lastIndexOf(\u0027$\u0027));\r\n}"
      },
      {
        "name": "IcBands#addToMap(...2)",
        "body": "{\r\n    List\u003cIcTuple\u003e tuples \u003d outerToInner.get(outerName);\r\n    if (tuples \u003d\u003d null) {\r\n        tuples \u003d new ArrayList\u003c\u003e();\r\n        outerToInner.put(outerName, tuples);\r\n    } else {\r\n        for (final IcTuple tuple : tuples) {\r\n            if (icTuple.equals(tuple)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    tuples.add(icTuple);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IcBands",
    "methodName": "getIcTuple",
    "signature": "org.apache.commons.compress.harmony.pack200.IcBands$IcTuple getIcTuple(org.apache.commons.compress.harmony.pack200.CPClass)",
    "visibility": "public",
    "body": "{\r\n    for (final IcTuple icTuple : innerClasses) {\r\n        if (icTuple.C.equals(inner)) {\r\n            return icTuple;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  CPClass\n  $r1 \u003d Set innerClasses\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d IcBands$IcTuple) $r3\n  $r6 \u003d CPClass C\u003e\n  $z1 \u003d $r6.equals(r5)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IcBands",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    PackingUtils.log(\"Writing internal class bands...\");\r\n    final int[] ic_this_class \u003d new int[innerClasses.size()];\r\n    final int[] ic_flags \u003d new int[innerClasses.size()];\r\n    final int[] ic_outer_class \u003d new int[bit16Count];\r\n    final int[] ic_name \u003d new int[bit16Count];\r\n    int index2 \u003d 0;\r\n    final List\u003cIcTuple\u003e innerClassesList \u003d new ArrayList\u003c\u003e(innerClasses);\r\n    for (int i \u003d 0; i \u003c ic_this_class.length; i++) {\r\n        final IcTuple icTuple \u003d innerClassesList.get(i);\r\n        ic_this_class[i] \u003d icTuple.C.getIndex();\r\n        ic_flags[i] \u003d icTuple.F;\r\n        if ((icTuple.F \u0026 1 \u003c\u003c 16) !\u003d 0) {\r\n            ic_outer_class[index2] \u003d icTuple.C2 \u003d\u003d null ? 0 : icTuple.C2.getIndex() + 1;\r\n            ic_name[index2] \u003d icTuple.N \u003d\u003d null ? 0 : icTuple.N.getIndex() + 1;\r\n            index2++;\r\n        }\r\n    }\r\n    byte[] encodedBand \u003d encodeBandInt(\"ic_this_class\", ic_this_class, Codec.UDELTA5);\r\n    outputStream.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from ic_this_class[\" + ic_this_class.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"ic_flags\", ic_flags, Codec.UNSIGNED5);\r\n    outputStream.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from ic_flags[\" + ic_flags.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"ic_outer_class\", ic_outer_class, Codec.DELTA5);\r\n    outputStream.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from ic_outer_class[\" + ic_outer_class.length + \"]\");\r\n    encodedBand \u003d encodeBandInt(\"ic_name\", ic_name, Codec.DELTA5);\r\n    outputStream.write(encodedBand);\r\n    PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from ic_name[\" + ic_name.length + \"]\");\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B1 : If(i22 \u003e\u003d $i4) → B2 | else → B11",
      "B2 : If($i16 \u003d\u003d false) → B3 | else → B10",
      "B3 : If($r45 !\u003d null) → B4 | else → B5",
      "B6 : If($r47 !\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  OutputStream\n  PackingUtils.log(\"Writing internal class bands...\")\n  $r1 \u003d Set innerClasses\u003e\n  $i0 \u003d $r1.size()\n  r2 \u003d newarray (int)[$i0]\n  $r3 \u003d Set innerClasses\u003e\n  $i1 \u003d $r3.size()\n  r4 \u003d newarray (int)[$i1]\n  $i2 \u003d IcBands: int bit16Count\u003e\n  r5 \u003d newarray (int)[$i2]\n  $i3 \u003d IcBands: int bit16Count\u003e\n  r6 \u003d newarray (int)[$i3]\n  i21 \u003d 0\n  $r7 \u003d ArrayList\n  $r8 \u003d Set innerClasses\u003e\n  new ArrayList($r8)\n  i22 \u003d 0\n}",
      "B1 {\n  $i4 \u003d lengthof r2\n  if (i22 \u003e\u003d $i4) goto B2 else B11\n}",
      "B2 {\n  $r42 \u003d $r7.get(i22)\n  r43 \u003d IcBands$IcTuple) $r42\n  $r44 \u003d CPClass C\u003e\n  $i13 \u003d $r44.getIndex()\n  r2[i22] \u003d $i13\n  $i14 \u003d IcBands$IcTuple: int F\u003e\n  r4[i22] \u003d $i14\n  $i15 \u003d IcBands$IcTuple: int F\u003e\n  $i16 \u003d $i15 \u0026 65536\n  if ($i16 \u003d\u003d false) goto B3 else B10\n}",
      "B3 {\n  $i20 \u003d i21\n  $r45 \u003d CPClass C2\u003e\n  if ($r45 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $i23 \u003d 0\n  goto B6\n}",
      "B5 {\n  $r46 \u003d CPClass C2\u003e\n  $i17 \u003d $r46.getIndex()\n  $i23 \u003d $i17 + 1\n}",
      "B6 {\n  r5[$i20] \u003d $i23\n  $i19 \u003d i21\n  $r47 \u003d CPUTF8 N\u003e\n  if ($r47 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $i24 \u003d 0\n  goto B9\n}",
      "B8 {\n  $r48 \u003d CPUTF8 N\u003e\n  $i18 \u003d $r48.getIndex()\n  $i24 \u003d $i18 + 1\n}",
      "B9 {\n  r6[$i19] \u003d $i24\n  i21 \u003d i21 + 1\n}",
      "B10 {\n  i22 \u003d i22 + 1\n  goto B1\n}",
      "B11 {\n  $r9 \u003d BHSDCodec UDELTA5\u003e\n  r49 \u003d r0.encodeBandInt(\"ic_this_class\", r2, $r9)\n  r10.write(r49)\n  $r11 \u003d StringBuilder\n  new StringBuilder()\n  $r12 \u003d $r11.append(\"Wrote \")\n  $i5 \u003d lengthof r49\n  $r13 \u003d $r12.append($i5)\n  $r14 \u003d $r13.append(\" bytes from ic_this_class\")\n  $i6 \u003d lengthof r2\n  $r15 \u003d $r14.append($i6)\n  $r16 \u003d $r15.append(\"\")\n  $r17 \u003d $r16.toString()\n  PackingUtils.log($r17)\n  $r18 \u003d BHSDCodec UNSIGNED5\u003e\n  r50 \u003d r0.encodeBandInt(\"ic_flags\", r4, $r18)\n  r10.write(r50)\n  $r19 \u003d StringBuilder\n  new StringBuilder()\n  $r20 \u003d $r19.append(\"Wrote \")\n  $i7 \u003d lengthof r50\n  $r21 \u003d $r20.append($i7)\n  $r22 \u003d $r21.append(\" bytes from ic_flags\")\n  $i8 \u003d lengthof r4\n  $r23 \u003d $r22.append($i8)\n  $r24 \u003d $r23.append(\"\")\n  $r25 \u003d $r24.toString()\n  PackingUtils.log($r25)\n  $r26 \u003d BHSDCodec DELTA5\u003e\n  r51 \u003d r0.encodeBandInt(\"ic_outer_class\", r5, $r26)\n  r10.write(r51)\n  $r27 \u003d StringBuilder\n  new StringBuilder()\n  $r28 \u003d $r27.append(\"Wrote \")\n  $i9 \u003d lengthof r51\n  $r29 \u003d $r28.append($i9)\n  $r30 \u003d $r29.append(\" bytes from ic_outer_class\")\n  $i10 \u003d lengthof r5\n  $r31 \u003d $r30.append($i10)\n  $r32 \u003d $r31.append(\"\")\n  $r33 \u003d $r32.toString()\n  PackingUtils.log($r33)\n  $r34 \u003d BHSDCodec DELTA5\u003e\n  r52 \u003d r0.encodeBandInt(\"ic_name\", r6, $r34)\n  r10.write(r52)\n  $r35 \u003d StringBuilder\n  new StringBuilder()\n  $r36 \u003d $r35.append(\"Wrote \")\n  $i11 \u003d lengthof r52\n  $r37 \u003d $r36.append($i11)\n  $r38 \u003d $r37.append(\" bytes from ic_name\")\n  $i12 \u003d lengthof r6\n  $r39 \u003d $r38.append($i12)\n  $r40 \u003d $r39.append(\"\")\n  $r41 \u003d $r40.toString()\n  PackingUtils.log($r41)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B10 --\u003e B1",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcBands#encodeBandInt(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "add",
    "signature": "boolean add(int)",
    "visibility": "public",
    "body": "{\r\n    if (lastIndex \u003d\u003d array.length) {\r\n        growAtEnd(1);\r\n    }\r\n    array[lastIndex++] \u003d object;\r\n    modCount++;\r\n    return true;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IntList\n  i4 :\u003d @parameter0: int\n  $i1 \u003d IntList: int lastIndex\u003e\n  $r1 \u003d IntList: int[] array\u003e\n  $i0 \u003d lengthof $r1\n  if ($i1 !\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  r0.growAtEnd(1)\n}",
      "B2 {\n  $r2 \u003d IntList: int[] array\u003e\n  $i2 \u003d IntList: int lastIndex\u003e\n  $i3 \u003d $i2 + 1\n  IntList: int lastIndex\u003e \u003d $i3\n  $r2[$i2] \u003d i4\n  $i5 \u003d IntList: int modCount\u003e\n  $i6 \u003d $i5 + 1\n  IntList: int modCount\u003e \u003d $i6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IntList#growAtEnd(...1)",
        "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (firstIndex \u003e\u003d required - (array.length - lastIndex)) {\r\n        final int newLast \u003d lastIndex - firstIndex;\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, array, 0, size);\r\n        }\r\n        firstIndex \u003d 0;\r\n        lastIndex \u003d newLast;\r\n    } else {\r\n        int increment \u003d size / 2;\r\n        if (required \u003e increment) {\r\n            increment \u003d required;\r\n        }\r\n        if (increment \u003c 12) {\r\n            increment \u003d 12;\r\n        }\r\n        final int[] newArray \u003d new int[size + increment];\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, newArray, 0, size);\r\n            firstIndex \u003d 0;\r\n            lastIndex \u003d size;\r\n        }\r\n        array \u003d newArray;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "add",
    "signature": "void add(int,int)",
    "visibility": "public",
    "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (0 \u003c location \u0026\u0026 location \u003c size) {\r\n        if (firstIndex \u003d\u003d 0 \u0026\u0026 lastIndex \u003d\u003d array.length) {\r\n            growForInsert(location, 1);\r\n        } else if (location \u003c size / 2 \u0026\u0026 firstIndex \u003e 0 || lastIndex \u003d\u003d array.length) {\r\n            System.arraycopy(array, firstIndex, array, --firstIndex, location);\r\n        } else {\r\n            final int index \u003d location + firstIndex;\r\n            System.arraycopy(array, index, array, index + 1, size - location);\r\n            lastIndex++;\r\n        }\r\n        array[location + firstIndex] \u003d object;\r\n    } else if (location \u003d\u003d 0) {\r\n        if (firstIndex \u003d\u003d 0) {\r\n            growAtFront(1);\r\n        }\r\n        array[--firstIndex] \u003d object;\r\n    } else if (location \u003d\u003d size) {\r\n        if (lastIndex \u003d\u003d array.length) {\r\n            growAtEnd(1);\r\n        }\r\n        array[lastIndex++] \u003d object;\r\n    } else {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    modCount++;\r\n}",
    "nodes": 21,
    "edges": 30,
    "cc": 11,
    "flowSummary": [
      "B0 : If(0 \u003e\u003d i3) → B1 | else → B11",
      "B1 : If(i3 \u003e\u003d i2) → B2 | else → B11",
      "B2 : If($i12 !\u003d 0) → B3 | else → B5",
      "B3 : If($i27 !\u003d $i26) → B4 | else → B5",
      "B5 : If(i3 \u003e\u003d $i13) → B6 | else → B7",
      "B6 : If($i25 \u003e 0) → B7 | else → B8",
      "B7 : If($i15 !\u003d $i14) → B8 | else → B9",
      "B11 : If(i3 !\u003d 0) → B12 | else → B15",
      "B12 : If($i9 !\u003d 0) → B13 | else → B14",
      "B15 : If(i3 !\u003d i2) → B16 | else → B19",
      "B16 : If($i5 !\u003d $i4) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  IntList\n  i3 :\u003d @parameter0: int\n  i8 :\u003d @parameter1: int\n  $i1 \u003d IntList: int lastIndex\u003e\n  $i0 \u003d IntList: int firstIndex\u003e\n  i2 \u003d $i1 - $i0\n  if (0 \u003e\u003d i3) goto B1 else B11\n}",
      "B1 {\n  if (i3 \u003e\u003d i2) goto B2 else B11\n}",
      "B2 {\n  $i12 \u003d IntList: int firstIndex\u003e\n  if ($i12 !\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $i27 \u003d IntList: int lastIndex\u003e\n  $r10 \u003d IntList: int[] array\u003e\n  $i26 \u003d lengthof $r10\n  if ($i27 !\u003d $i26) goto B4 else B5\n}",
      "B4 {\n  r0.growForInsert(i3, 1)\n  goto B10\n}",
      "B5 {\n  $i13 \u003d i2 / 2\n  if (i3 \u003e\u003d $i13) goto B6 else B7\n}",
      "B6 {\n  $i25 \u003d IntList: int firstIndex\u003e\n  if ($i25 \u003e 0) goto B7 else B8\n}",
      "B7 {\n  $i15 \u003d IntList: int lastIndex\u003e\n  $r5 \u003d IntList: int[] array\u003e\n  $i14 \u003d lengthof $r5\n  if ($i15 !\u003d $i14) goto B8 else B9\n}",
      "B8 {\n  $r8 \u003d IntList: int[] array\u003e\n  $i24 \u003d IntList: int firstIndex\u003e\n  $r9 \u003d IntList: int[] array\u003e\n  $i22 \u003d IntList: int firstIndex\u003e\n  $i23 \u003d $i22 - 1\n  IntList: int firstIndex\u003e \u003d $i23\n  System.arraycopy($r8, $i24, $r9, $i23, i3)\n  goto B10\n}",
      "B9 {\n  $i16 \u003d IntList: int firstIndex\u003e\n  i17 \u003d i3 + $i16\n  $r7 \u003d IntList: int[] array\u003e\n  $r6 \u003d IntList: int[] array\u003e\n  $i19 \u003d i17 + 1\n  $i18 \u003d i2 - i3\n  System.arraycopy($r7, i17, $r6, $i19, $i18)\n  $i20 \u003d IntList: int lastIndex\u003e\n  $i21 \u003d $i20 + 1\n  IntList: int lastIndex\u003e \u003d $i21\n}",
      "B10 {\n  $r11 \u003d IntList: int[] array\u003e\n  $i28 \u003d IntList: int firstIndex\u003e\n  $i29 \u003d i3 + $i28\n  $r11[$i29] \u003d i8\n  goto B20\n}",
      "B11 {\n  if (i3 !\u003d 0) goto B12 else B15\n}",
      "B12 {\n  $i9 \u003d IntList: int firstIndex\u003e\n  if ($i9 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  r0.growAtFront(1)\n}",
      "B14 {\n  $r4 \u003d IntList: int[] array\u003e\n  $i10 \u003d IntList: int firstIndex\u003e\n  $i11 \u003d $i10 - 1\n  IntList: int firstIndex\u003e \u003d $i11\n  $r4[$i11] \u003d i8\n  goto B20\n}",
      "B15 {\n  if (i3 !\u003d i2) goto B16 else B19\n}",
      "B16 {\n  $i5 \u003d IntList: int lastIndex\u003e\n  $r2 \u003d IntList: int[] array\u003e\n  $i4 \u003d lengthof $r2\n  if ($i5 !\u003d $i4) goto B17 else B18\n}",
      "B17 {\n  r0.growAtEnd(1)\n}",
      "B18 {\n  $r3 \u003d IntList: int[] array\u003e\n  $i6 \u003d IntList: int lastIndex\u003e\n  $i7 \u003d $i6 + 1\n  IntList: int lastIndex\u003e \u003d $i7\n  $r3[$i6] \u003d i8\n  goto B20\n}",
      "B19 {\n  $r1 \u003d IndexOutOfBoundsException\n  new IndexOutOfBoundsException()\n  throw $r1\n}",
      "B20 {\n  $i30 \u003d IntList: int modCount\u003e\n  $i31 \u003d $i30 + 1\n  IntList: int modCount\u003e \u003d $i31\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B11",
      "B1 --\u003e B2",
      "B1 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B20",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B20",
      "B15 --\u003e B16",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IntList#growAtEnd(...1)",
        "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (firstIndex \u003e\u003d required - (array.length - lastIndex)) {\r\n        final int newLast \u003d lastIndex - firstIndex;\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, array, 0, size);\r\n        }\r\n        firstIndex \u003d 0;\r\n        lastIndex \u003d newLast;\r\n    } else {\r\n        int increment \u003d size / 2;\r\n        if (required \u003e increment) {\r\n            increment \u003d required;\r\n        }\r\n        if (increment \u003c 12) {\r\n            increment \u003d 12;\r\n        }\r\n        final int[] newArray \u003d new int[size + increment];\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, newArray, 0, size);\r\n            firstIndex \u003d 0;\r\n            lastIndex \u003d size;\r\n        }\r\n        array \u003d newArray;\r\n    }\r\n}"
      },
      {
        "name": "IntList#growForInsert(...2)",
        "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    int increment \u003d size / 2;\r\n    if (required \u003e increment) {\r\n        increment \u003d required;\r\n    }\r\n    if (increment \u003c 12) {\r\n        increment \u003d 12;\r\n    }\r\n    final int[] newArray \u003d new int[size + increment];\r\n    final int newFirst \u003d increment - required;\r\n    // Copy elements after location to the new array skipping inserted\r\n    // elements\r\n    System.arraycopy(array, location + firstIndex, newArray, newFirst + location + required, size - location);\r\n    // Copy elements before location to the new array from firstIndex\r\n    System.arraycopy(array, firstIndex, newArray, newFirst, location);\r\n    firstIndex \u003d newFirst;\r\n    lastIndex \u003d size + increment;\r\n    array \u003d newArray;\r\n}"
      },
      {
        "name": "IntList#growAtFront(...1)",
        "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (array.length - lastIndex + firstIndex \u003e\u003d required) {\r\n        final int newFirst \u003d array.length - size;\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, array, newFirst, size);\r\n        }\r\n        firstIndex \u003d newFirst;\r\n        lastIndex \u003d array.length;\r\n    } else {\r\n        int increment \u003d size / 2;\r\n        if (required \u003e increment) {\r\n            increment \u003d required;\r\n        }\r\n        if (increment \u003c 12) {\r\n            increment \u003d 12;\r\n        }\r\n        final int[] newArray \u003d new int[size + increment];\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, newArray, newArray.length - size, size);\r\n        }\r\n        firstIndex \u003d newArray.length - size;\r\n        lastIndex \u003d newArray.length;\r\n        array \u003d newArray;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "addAll",
    "signature": "void addAll(org.apache.commons.compress.harmony.pack200.IntList)",
    "visibility": "public",
    "body": "{\r\n    growAtEnd(list.size());\r\n    for (int i \u003d 0; i \u003c list.size(); i++) {\r\n        add(list.get(i));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d $i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IntList\n  IntList\n  $i0 \u003d r1.size()\n  r0.growAtEnd($i0)\n  i3 \u003d 0\n}",
      "B1 {\n  $i1 \u003d r1.size()\n  if (i3 \u003e\u003d $i1) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d r1.get(i3)\n  r0.add($i2)\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IntList#growAtEnd(...1)",
        "body": "{\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (firstIndex \u003e\u003d required - (array.length - lastIndex)) {\r\n        final int newLast \u003d lastIndex - firstIndex;\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, array, 0, size);\r\n        }\r\n        firstIndex \u003d 0;\r\n        lastIndex \u003d newLast;\r\n    } else {\r\n        int increment \u003d size / 2;\r\n        if (required \u003e increment) {\r\n            increment \u003d required;\r\n        }\r\n        if (increment \u003c 12) {\r\n            increment \u003d 12;\r\n        }\r\n        final int[] newArray \u003d new int[size + increment];\r\n        if (size \u003e 0) {\r\n            System.arraycopy(array, firstIndex, newArray, 0, size);\r\n            firstIndex \u003d 0;\r\n            lastIndex \u003d size;\r\n        }\r\n        array \u003d newArray;\r\n    }\r\n}"
      },
      {
        "name": "IntList#add(...1)",
        "body": "{\r\n    if (lastIndex \u003d\u003d array.length) {\r\n        growAtEnd(1);\r\n    }\r\n    array[lastIndex++] \u003d object;\r\n    modCount++;\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "clear",
    "signature": "void clear()",
    "visibility": "public",
    "body": "{\r\n    if (firstIndex !\u003d lastIndex) {\r\n        Arrays.fill(array, firstIndex, lastIndex, -1);\r\n        firstIndex \u003d lastIndex \u003d 0;\r\n        modCount++;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IntList\n  $i1 \u003d IntList: int firstIndex\u003e\n  $i0 \u003d IntList: int lastIndex\u003e\n  if ($i1 \u003d\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d IntList: int[] array\u003e\n  $i3 \u003d IntList: int firstIndex\u003e\n  $i2 \u003d IntList: int lastIndex\u003e\n  $i7 \u003d (int) -1\n  Arrays.fill($r1, $i3, $i2, $i7)\n  IntList: int lastIndex\u003e \u003d 0\n  IntList: int firstIndex\u003e \u003d 0\n  $i4 \u003d IntList: int modCount\u003e\n  $i5 \u003d $i4 + 1\n  IntList: int modCount\u003e \u003d $i5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "get",
    "signature": "int get(int)",
    "visibility": "public",
    "body": "{\r\n    if (0 \u003c\u003d location \u0026\u0026 location \u003c lastIndex - firstIndex) {\r\n        return array[firstIndex + location];\r\n    }\r\n    throw new IndexOutOfBoundsException(\"\" + location);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(0 \u003e i0) → B1 | else → B3",
      "B1 : If(i0 \u003e\u003d $i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IntList\n  i0 :\u003d @parameter0: int\n  if (0 \u003e i0) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d IntList: int lastIndex\u003e\n  $i1 \u003d IntList: int firstIndex\u003e\n  $i3 \u003d $i2 - $i1\n  if (i0 \u003e\u003d $i3) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d IntList: int[] array\u003e\n  $i4 \u003d IntList: int firstIndex\u003e\n  $i5 \u003d $i4 + i0\n  $i6 \u003d $r6[$i5]\n  return\n}",
      "B3 {\n  $r0 \u003d IndexOutOfBoundsException\n  $r1 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r1.append(\"\")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IndexOutOfBoundsException($r4)\n  throw $r0\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "increment",
    "signature": "void increment(int)",
    "visibility": "public",
    "body": "{\r\n    if (0 \u003e location || location \u003e\u003d lastIndex - firstIndex) {\r\n        throw new IndexOutOfBoundsException(\"\" + location);\r\n    }\r\n    array[firstIndex + location]++;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(0 \u003e i0) → B1 | else → B2",
      "B1 : If(i0 \u003c $i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IntList\n  i0 :\u003d @parameter0: int\n  if (0 \u003e i0) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d IntList: int lastIndex\u003e\n  $i1 \u003d IntList: int firstIndex\u003e\n  $i3 \u003d $i2 - $i1\n  if (i0 \u003c $i3) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IndexOutOfBoundsException\n  $r1 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d $r1.append(\"\")\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  new IndexOutOfBoundsException($r4)\n  throw $r0\n}",
      "B3 {\n  $r6 \u003d IntList: int[] array\u003e\n  $i4 \u003d IntList: int firstIndex\u003e\n  $i5 \u003d $i4 + i0\n  $i6 \u003d $r6[$i5]\n  $i7 \u003d $i6 + 1\n  $r6[$i5] \u003d $i7\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "isEmpty",
    "signature": "boolean isEmpty()",
    "visibility": "public",
    "body": "{\r\n    return lastIndex \u003d\u003d firstIndex;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IntList\n  $i1 \u003d IntList: int lastIndex\u003e\n  $i0 \u003d IntList: int firstIndex\u003e\n  if ($i1 !\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.IntList",
    "methodName": "remove",
    "signature": "int remove(int)",
    "visibility": "public",
    "body": "{\r\n    final int result;\r\n    final int size \u003d lastIndex - firstIndex;\r\n    if (0 \u003e location || location \u003e\u003d size) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (location \u003d\u003d size - 1) {\r\n        result \u003d array[--lastIndex];\r\n        array[lastIndex] \u003d 0;\r\n    } else if (location \u003d\u003d 0) {\r\n        result \u003d array[firstIndex];\r\n        array[firstIndex++] \u003d 0;\r\n    } else {\r\n        final int elementIndex \u003d firstIndex + location;\r\n        result \u003d array[elementIndex];\r\n        if (location \u003c size / 2) {\r\n            System.arraycopy(array, firstIndex, array, firstIndex + 1, location);\r\n            array[firstIndex++] \u003d 0;\r\n        } else {\r\n            System.arraycopy(array, elementIndex + 1, array, elementIndex, size - location - 1);\r\n            array[--lastIndex] \u003d 0;\r\n        }\r\n    }\r\n    if (firstIndex \u003d\u003d lastIndex) {\r\n        firstIndex \u003d lastIndex \u003d 0;\r\n    }\r\n    modCount++;\r\n    return result;\r\n}",
    "nodes": 13,
    "edges": 17,
    "cc": 6,
    "flowSummary": [
      "B0 : If(0 \u003e i3) → B1 | else → B2",
      "B1 : If(i3 \u003c i2) → B2 | else → B3",
      "B3 : If(i3 !\u003d $i4) → B4 | else → B5",
      "B5 : If(i3 !\u003d 0) → B6 | else → B7",
      "B7 : If(i3 \u003e\u003d $i7) → B8 | else → B9",
      "B10 : If($i27 !\u003d $i28) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  IntList\n  i3 :\u003d @parameter0: int\n  $i1 \u003d IntList: int lastIndex\u003e\n  $i0 \u003d IntList: int firstIndex\u003e\n  i2 \u003d $i1 - $i0\n  if (0 \u003e i3) goto B1 else B2\n}",
      "B1 {\n  if (i3 \u003c i2) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IndexOutOfBoundsException\n  new IndexOutOfBoundsException()\n  throw $r1\n}",
      "B3 {\n  $i4 \u003d i2 - 1\n  if (i3 !\u003d $i4) goto B4 else B5\n}",
      "B4 {\n  $r11 \u003d IntList: int[] array\u003e\n  $i23 \u003d IntList: int lastIndex\u003e\n  $i24 \u003d $i23 - 1\n  IntList: int lastIndex\u003e \u003d $i24\n  i26 \u003d $r11[$i24]\n  $r12 \u003d IntList: int[] array\u003e\n  $i25 \u003d IntList: int lastIndex\u003e\n  $r12[$i25] \u003d 0\n  goto B10\n}",
      "B5 {\n  if (i3 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d IntList: int[] array\u003e\n  $i20 \u003d IntList: int firstIndex\u003e\n  i26 \u003d $r9[$i20]\n  $r10 \u003d IntList: int[] array\u003e\n  $i21 \u003d IntList: int firstIndex\u003e\n  $i22 \u003d $i21 + 1\n  IntList: int firstIndex\u003e \u003d $i22\n  $r10[$i21] \u003d 0\n  goto B10\n}",
      "B7 {\n  $i5 \u003d IntList: int firstIndex\u003e\n  i6 \u003d $i5 + i3\n  $r2 \u003d IntList: int[] array\u003e\n  i26 \u003d $r2[i6]\n  $i7 \u003d i2 / 2\n  if (i3 \u003e\u003d $i7) goto B8 else B9\n}",
      "B8 {\n  $r7 \u003d IntList: int[] array\u003e\n  $i17 \u003d IntList: int firstIndex\u003e\n  $r6 \u003d IntList: int[] array\u003e\n  $i15 \u003d IntList: int firstIndex\u003e\n  $i16 \u003d $i15 + 1\n  System.arraycopy($r7, $i17, $r6, $i16, i3)\n  $r8 \u003d IntList: int[] array\u003e\n  $i18 \u003d IntList: int firstIndex\u003e\n  $i19 \u003d $i18 + 1\n  IntList: int firstIndex\u003e \u003d $i19\n  $r8[$i18] \u003d 0\n  goto B10\n}",
      "B9 {\n  $r4 \u003d IntList: int[] array\u003e\n  $i10 \u003d i6 + 1\n  $r3 \u003d IntList: int[] array\u003e\n  $i8 \u003d i2 - i3\n  $i9 \u003d $i8 - 1\n  System.arraycopy($r4, $i10, $r3, i6, $i9)\n  $r5 \u003d IntList: int[] array\u003e\n  $i11 \u003d IntList: int lastIndex\u003e\n  $i12 \u003d $i11 - 1\n  IntList: int lastIndex\u003e \u003d $i12\n  $r5[$i12] \u003d 0\n}",
      "B10 {\n  $i27 \u003d IntList: int firstIndex\u003e\n  $i28 \u003d IntList: int lastIndex\u003e\n  if ($i27 !\u003d $i28) goto B11 else B12\n}",
      "B11 {\n  IntList: int lastIndex\u003e \u003d 0\n  IntList: int firstIndex\u003e \u003d 0\n}",
      "B12 {\n  $i13 \u003d IntList: int modCount\u003e\n  $i14 \u003d $i13 + 1\n  IntList: int modCount\u003e \u003d $i14\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.MetadataBandGroup",
    "methodName": "addAnnotation",
    "signature": "void addAnnotation(java.lang.String,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    type_RS.add(cpBands.getCPSignature(desc));\r\n    pair_N.add(nameRU.size());\r\n    nameRU.forEach(name -\u003e name_RU.add(cpBands.getCPUtf8(name)));\r\n    final Iterator\u003cObject\u003e valuesIterator \u003d values.iterator();\r\n    for (final String tag : tags) {\r\n        T.add(tag);\r\n        switch(tag) {\r\n            case \"B\":\r\n            case \"C\":\r\n            case \"I\":\r\n            case \"S\":\r\n            case \"Z\":\r\n                {\r\n                    caseI_KI.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"D\":\r\n                {\r\n                    caseD_KD.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"F\":\r\n                {\r\n                    caseF_KF.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"J\":\r\n                {\r\n                    caseJ_KJ.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"c\":\r\n                {\r\n                    casec_RS.add(cpBands.getCPSignature(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n            case \"e\":\r\n                {\r\n                    caseet_RS.add(cpBands.getCPSignature(nextString(valuesIterator)));\r\n                    caseec_RU.add(cpBands.getCPUtf8(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n            case \"s\":\r\n                {\r\n                    cases_RU.add(cpBands.getCPUtf8(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n        }\r\n        // do nothing here for [ or @ (handled below)\r\n    }\r\n    for (final Integer element : caseArrayN) {\r\n        final int arraySize \u003d element.intValue();\r\n        casearray_N.add(arraySize);\r\n        numBackwardsCalls +\u003d arraySize;\r\n    }\r\n    nestTypeRS.forEach(element -\u003e nesttype_RS.add(cpBands.getCPSignature(element)));\r\n    nestNameRU.forEach(element -\u003e nestname_RU.add(cpBands.getCPUtf8(element)));\r\n    for (final Integer numPairs : nestPairN) {\r\n        nestpair_N.add(numPairs.intValue());\r\n        numBackwardsCalls +\u003d numPairs.intValue();\r\n    }\r\n}",
    "nodes": 41,
    "edges": 72,
    "cc": 33,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B34",
      "B2 : If(switch-on $i7) → B3 | else → B5",
      "B3 : If($z13 \u003d\u003d false) → B4 | else → B25",
      "B5 : If($z12 \u003d\u003d false) → B6 | else → B25",
      "B7 : If($z9 \u003d\u003d false) → B8 | else → B25",
      "B9 : If($z7 \u003d\u003d false) → B10 | else → B25",
      "B11 : If($z6 \u003d\u003d false) → B12 | else → B25",
      "B13 : If($z11 \u003d\u003d false) → B14 | else → B25",
      "B15 : If($z10 \u003d\u003d false) → B16 | else → B25",
      "B17 : If($z8 \u003d\u003d false) → B18 | else → B25",
      "B19 : If($z5 \u003d\u003d false) → B20 | else → B25",
      "B21 : If($z4 \u003d\u003d false) → B22 | else → B25",
      "B23 : If($z3 \u003d\u003d false) → B24 | else → B25",
      "B25 : If(switch-on b8) → B26 | else → B27",
      "B35 : If($z1 \u003d\u003d false) → B36 | else → B37",
      "B38 : If($z2 \u003d\u003d false) → B39 | else → B40"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  String\n  List\n  List\n  List\n  List\n  List\n  List\n  List\n  $r3 \u003d List type_RS\u003e\n  $r2 \u003d CpBands cpBands\u003e\n  $r4 \u003d $r2.getCPSignature(r1)\n  $r3.add($r4)\n  $r6 \u003d IntList pair_N\u003e\n  $i0 \u003d r5.size()\n  $r6.add($i0)\n  $r7 \u003d MetadataBandGroup$lambda_addAnnotation_0__33.bootstrap$(r0)\n  r5.forEach($r7)\n  r9 \u003d r8.iterator()\n  r55 \u003d r10.iterator()\n}",
      "B1 {\n  $z0 \u003d r55.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B34\n}",
      "B2 {\n  $r21 \u003d r55.next()\n  r56 \u003d String) $r21\n  $r22 \u003d List T\u003e\n  $r22.add(r56)\n  b8 \u003d -1\n  $i7 \u003d r56.hashCode()\n  Iterator: boolean hasNext()\u003e()]; }; }\n}",
      "B3 {\n  $z13 \u003d r56.equals(\"B\")\n  if ($z13 \u003d\u003d false) goto B4 else B25\n}",
      "B4 {\n  b8 \u003d 0\n  goto B25\n}",
      "B5 {\n  $z12 \u003d r56.equals(\"C\")\n  if ($z12 \u003d\u003d false) goto B6 else B25\n}",
      "B6 {\n  b8 \u003d 1\n  goto B25\n}",
      "B7 {\n  $z9 \u003d r56.equals(\"I\")\n  if ($z9 \u003d\u003d false) goto B8 else B25\n}",
      "B8 {\n  b8 \u003d 2\n  goto B25\n}",
      "B9 {\n  $z7 \u003d r56.equals(\"S\")\n  if ($z7 \u003d\u003d false) goto B10 else B25\n}",
      "B10 {\n  b8 \u003d 3\n  goto B25\n}",
      "B11 {\n  $z6 \u003d r56.equals(\"Z\")\n  if ($z6 \u003d\u003d false) goto B12 else B25\n}",
      "B12 {\n  b8 \u003d 4\n  goto B25\n}",
      "B13 {\n  $z11 \u003d r56.equals(\"D\")\n  if ($z11 \u003d\u003d false) goto B14 else B25\n}",
      "B14 {\n  b8 \u003d 5\n  goto B25\n}",
      "B15 {\n  $z10 \u003d r56.equals(\"F\")\n  if ($z10 \u003d\u003d false) goto B16 else B25\n}",
      "B16 {\n  b8 \u003d 6\n  goto B25\n}",
      "B17 {\n  $z8 \u003d r56.equals(\"J\")\n  if ($z8 \u003d\u003d false) goto B18 else B25\n}",
      "B18 {\n  b8 \u003d 7\n  goto B25\n}",
      "B19 {\n  $z5 \u003d r56.equals(\"c\")\n  if ($z5 \u003d\u003d false) goto B20 else B25\n}",
      "B20 {\n  b8 \u003d 8\n  goto B25\n}",
      "B21 {\n  $z4 \u003d r56.equals(\"e\")\n  if ($z4 \u003d\u003d false) goto B22 else B25\n}",
      "B22 {\n  b8 \u003d 9\n  goto B25\n}",
      "B23 {\n  $z3 \u003d r56.equals(\"s\")\n  if ($z3 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  b8 \u003d 10\n}",
      "B25 {\n  Iterator: boolean hasNext()\u003e()]; }\n}",
      "B26 {\n  $r51 \u003d List caseI_KI\u003e\n  $r52 \u003d CpBands cpBands\u003e\n  $r53 \u003d r9.next()\n  $r54 \u003d $r52.getConstant($r53)\n  $r51.add($r54)\n  goto B33\n}",
      "B27 {\n  $r47 \u003d List caseD_KD\u003e\n  $r48 \u003d CpBands cpBands\u003e\n  $r49 \u003d r9.next()\n  $r50 \u003d $r48.getConstant($r49)\n  $r47.add($r50)\n  goto B33\n}",
      "B28 {\n  $r43 \u003d List caseF_KF\u003e\n  $r44 \u003d CpBands cpBands\u003e\n  $r45 \u003d r9.next()\n  $r46 \u003d $r44.getConstant($r45)\n  $r43.add($r46)\n  goto B33\n}",
      "B29 {\n  $r39 \u003d List caseJ_KJ\u003e\n  $r40 \u003d CpBands cpBands\u003e\n  $r41 \u003d r9.next()\n  $r42 \u003d $r40.getConstant($r41)\n  $r39.add($r42)\n  goto B33\n}",
      "B30 {\n  $r35 \u003d List casec_RS\u003e\n  $r36 \u003d CpBands cpBands\u003e\n  $r37 \u003d r0.nextString(r9)\n  $r38 \u003d $r36.getCPSignature($r37)\n  $r35.add($r38)\n  goto B33\n}",
      "B31 {\n  $r27 \u003d List caseet_RS\u003e\n  $r28 \u003d CpBands cpBands\u003e\n  $r29 \u003d r0.nextString(r9)\n  $r30 \u003d $r28.getCPSignature($r29)\n  $r27.add($r30)\n  $r31 \u003d List caseec_RU\u003e\n  $r32 \u003d CpBands cpBands\u003e\n  $r33 \u003d r0.nextString(r9)\n  $r34 \u003d $r32.getCPUtf8($r33)\n  $r31.add($r34)\n  goto B33\n}",
      "B32 {\n  $r23 \u003d List cases_RU\u003e\n  $r24 \u003d CpBands cpBands\u003e\n  $r25 \u003d r0.nextString(r9)\n  $r26 \u003d $r24.getCPUtf8($r25)\n  $r23.add($r26)\n}",
      "B33 {\n  goto B1\n}",
      "B34 {\n  r57 \u003d r11.iterator()\n}",
      "B35 {\n  $z1 \u003d r57.hasNext()\n  if ($z1 \u003d\u003d false) goto B36 else B37\n}",
      "B36 {\n  $r19 \u003d r57.next()\n  r58 \u003d Integer) $r19\n  i9 \u003d r58.intValue()\n  $r20 \u003d IntList casearray_N\u003e\n  $r20.add(i9)\n  $i5 \u003d MetadataBandGroup: int numBackwardsCalls\u003e\n  $i6 \u003d $i5 + i9\n  MetadataBandGroup: int numBackwardsCalls\u003e \u003d $i6\n  goto B35\n}",
      "B37 {\n  $r13 \u003d MetadataBandGroup$lambda_addAnnotation_1__34.bootstrap$(r0)\n  r12.forEach($r13)\n  $r15 \u003d MetadataBandGroup$lambda_addAnnotation_2__35.bootstrap$(r0)\n  r14.forEach($r15)\n  r59 \u003d r16.iterator()\n}",
      "B38 {\n  $z2 \u003d r59.hasNext()\n  if ($z2 \u003d\u003d false) goto B39 else B40\n}",
      "B39 {\n  $r17 \u003d r59.next()\n  r60 \u003d Integer) $r17\n  $r18 \u003d IntList nestpair_N\u003e\n  $i1 \u003d r60.intValue()\n  $r18.add($i1)\n  $i2 \u003d MetadataBandGroup: int numBackwardsCalls\u003e\n  $i3 \u003d r60.intValue()\n  $i4 \u003d $i2 + $i3\n  MetadataBandGroup: int numBackwardsCalls\u003e \u003d $i4\n  goto B38\n}",
      "B40 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B34",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B2 --\u003e B13",
      "B2 --\u003e B15",
      "B2 --\u003e B7",
      "B2 --\u003e B17",
      "B2 --\u003e B9",
      "B2 --\u003e B11",
      "B2 --\u003e B19",
      "B2 --\u003e B21",
      "B2 --\u003e B23",
      "B2 --\u003e B25",
      "B3 --\u003e B4",
      "B3 --\u003e B25",
      "B4 --\u003e B25",
      "B5 --\u003e B6",
      "B5 --\u003e B25",
      "B6 --\u003e B25",
      "B7 --\u003e B8",
      "B7 --\u003e B25",
      "B8 --\u003e B25",
      "B9 --\u003e B10",
      "B9 --\u003e B25",
      "B10 --\u003e B25",
      "B11 --\u003e B12",
      "B11 --\u003e B25",
      "B12 --\u003e B25",
      "B13 --\u003e B14",
      "B13 --\u003e B25",
      "B14 --\u003e B25",
      "B15 --\u003e B16",
      "B15 --\u003e B25",
      "B16 --\u003e B25",
      "B17 --\u003e B18",
      "B17 --\u003e B25",
      "B18 --\u003e B25",
      "B19 --\u003e B20",
      "B19 --\u003e B25",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B25",
      "B22 --\u003e B25",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B25 --\u003e B28",
      "B25 --\u003e B29",
      "B25 --\u003e B30",
      "B25 --\u003e B31",
      "B25 --\u003e B32",
      "B25 --\u003e B33",
      "B26 --\u003e B33",
      "B27 --\u003e B33",
      "B28 --\u003e B33",
      "B29 --\u003e B33",
      "B30 --\u003e B33",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B1",
      "B34 --\u003e B35",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e B35",
      "B37 --\u003e B38",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e B38",
      "B40 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MetadataBandGroup#nextString(...1)",
        "body": "{\r\n    return (String) valuesIterator.next();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.MetadataBandGroup",
    "methodName": "addParameterAnnotation",
    "signature": "void addParameterAnnotation(int,int[],org.apache.commons.compress.harmony.pack200.IntList,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List,java.util.List)",
    "visibility": "public",
    "body": "{\r\n    param_NB.add(numParams);\r\n    for (final int element : annoN) {\r\n        anno_N.add(element);\r\n    }\r\n    pair_N.addAll(pairN);\r\n    typeRS.forEach(desc -\u003e type_RS.add(cpBands.getCPSignature(desc)));\r\n    nameRU.forEach(name -\u003e name_RU.add(cpBands.getCPUtf8(name)));\r\n    final Iterator\u003cObject\u003e valuesIterator \u003d values.iterator();\r\n    for (final String tag : tags) {\r\n        T.add(tag);\r\n        switch(tag) {\r\n            case \"B\":\r\n            case \"C\":\r\n            case \"I\":\r\n            case \"S\":\r\n            case \"Z\":\r\n                {\r\n                    caseI_KI.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"D\":\r\n                {\r\n                    caseD_KD.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"F\":\r\n                {\r\n                    caseF_KF.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"J\":\r\n                {\r\n                    caseJ_KJ.add(cpBands.getConstant(valuesIterator.next()));\r\n                    break;\r\n                }\r\n            case \"c\":\r\n                {\r\n                    casec_RS.add(cpBands.getCPSignature(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n            case \"e\":\r\n                {\r\n                    caseet_RS.add(cpBands.getCPSignature(nextString(valuesIterator)));\r\n                    caseec_RU.add(cpBands.getCPUtf8(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n            case \"s\":\r\n                {\r\n                    cases_RU.add(cpBands.getCPUtf8(nextString(valuesIterator)));\r\n                    break;\r\n                }\r\n        }\r\n        // do nothing here for [ or @ (handled below)\r\n    }\r\n    for (final Integer element : caseArrayN) {\r\n        final int arraySize \u003d element.intValue();\r\n        casearray_N.add(arraySize);\r\n        numBackwardsCalls +\u003d arraySize;\r\n    }\r\n    nestTypeRS.forEach(type -\u003e nesttype_RS.add(cpBands.getCPSignature(type)));\r\n    nestNameRU.forEach(name -\u003e nestname_RU.add(cpBands.getCPUtf8(name)));\r\n    for (final Integer numPairs : nestPairN) {\r\n        nestpair_N.add(numPairs.intValue());\r\n        numBackwardsCalls +\u003d numPairs.intValue();\r\n    }\r\n}",
    "nodes": 44,
    "edges": 76,
    "cc": 34,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d i8) → B2 | else → B3",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B37",
      "B5 : If(switch-on $i7) → B6 | else → B8",
      "B6 : If($z13 \u003d\u003d false) → B7 | else → B28",
      "B8 : If($z12 \u003d\u003d false) → B9 | else → B28",
      "B10 : If($z9 \u003d\u003d false) → B11 | else → B28",
      "B12 : If($z7 \u003d\u003d false) → B13 | else → B28",
      "B14 : If($z6 \u003d\u003d false) → B15 | else → B28",
      "B16 : If($z11 \u003d\u003d false) → B17 | else → B28",
      "B18 : If($z10 \u003d\u003d false) → B19 | else → B28",
      "B20 : If($z8 \u003d\u003d false) → B21 | else → B28",
      "B22 : If($z5 \u003d\u003d false) → B23 | else → B28",
      "B24 : If($z4 \u003d\u003d false) → B25 | else → B28",
      "B26 : If($z3 \u003d\u003d false) → B27 | else → B28",
      "B28 : If(switch-on b11) → B29 | else → B30",
      "B38 : If($z1 \u003d\u003d false) → B39 | else → B40",
      "B41 : If($z2 \u003d\u003d false) → B42 | else → B43"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  i0 :\u003d @parameter0: int\n  r2 :\u003d @parameter1: int[]\n  IntList\n  List\n  List\n  List\n  List\n  List\n  List\n  List\n  List\n  $r1 \u003d IntList param_NB\u003e\n  $r1.add(i0)\n  i8 \u003d lengthof r2\n  i9 \u003d 0\n}",
      "B1 {\n  if (i9 \u003e\u003d i8) goto B2 else B3\n}",
      "B2 {\n  i10 \u003d r2[i9]\n  $r55 \u003d IntList anno_N\u003e\n  $r55.add(i10)\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B3 {\n  $r4 \u003d IntList pair_N\u003e\n  $r4.addAll(r3)\n  $r6 \u003d MetadataBandGroup$lambda_addParameterAnnotation_3__36.bootstrap$(r0)\n  r5.forEach($r6)\n  $r8 \u003d MetadataBandGroup$lambda_addParameterAnnotation_4__37.bootstrap$(r0)\n  r7.forEach($r8)\n  r56 \u003d r9.iterator()\n  r57 \u003d r10.iterator()\n}",
      "B4 {\n  $z0 \u003d r57.hasNext()\n  if ($z0 \u003d\u003d false) goto B5 else B37\n}",
      "B5 {\n  $r21 \u003d r57.next()\n  r58 \u003d String) $r21\n  $r22 \u003d List T\u003e\n  $r22.add(r58)\n  b11 \u003d -1\n  $i7 \u003d r58.hashCode()\n  Iterator: boolean hasNext()\u003e()]; }; }\n}",
      "B6 {\n  $z13 \u003d r58.equals(\"B\")\n  if ($z13 \u003d\u003d false) goto B7 else B28\n}",
      "B7 {\n  b11 \u003d 0\n  goto B28\n}",
      "B8 {\n  $z12 \u003d r58.equals(\"C\")\n  if ($z12 \u003d\u003d false) goto B9 else B28\n}",
      "B9 {\n  b11 \u003d 1\n  goto B28\n}",
      "B10 {\n  $z9 \u003d r58.equals(\"I\")\n  if ($z9 \u003d\u003d false) goto B11 else B28\n}",
      "B11 {\n  b11 \u003d 2\n  goto B28\n}",
      "B12 {\n  $z7 \u003d r58.equals(\"S\")\n  if ($z7 \u003d\u003d false) goto B13 else B28\n}",
      "B13 {\n  b11 \u003d 3\n  goto B28\n}",
      "B14 {\n  $z6 \u003d r58.equals(\"Z\")\n  if ($z6 \u003d\u003d false) goto B15 else B28\n}",
      "B15 {\n  b11 \u003d 4\n  goto B28\n}",
      "B16 {\n  $z11 \u003d r58.equals(\"D\")\n  if ($z11 \u003d\u003d false) goto B17 else B28\n}",
      "B17 {\n  b11 \u003d 5\n  goto B28\n}",
      "B18 {\n  $z10 \u003d r58.equals(\"F\")\n  if ($z10 \u003d\u003d false) goto B19 else B28\n}",
      "B19 {\n  b11 \u003d 6\n  goto B28\n}",
      "B20 {\n  $z8 \u003d r58.equals(\"J\")\n  if ($z8 \u003d\u003d false) goto B21 else B28\n}",
      "B21 {\n  b11 \u003d 7\n  goto B28\n}",
      "B22 {\n  $z5 \u003d r58.equals(\"c\")\n  if ($z5 \u003d\u003d false) goto B23 else B28\n}",
      "B23 {\n  b11 \u003d 8\n  goto B28\n}",
      "B24 {\n  $z4 \u003d r58.equals(\"e\")\n  if ($z4 \u003d\u003d false) goto B25 else B28\n}",
      "B25 {\n  b11 \u003d 9\n  goto B28\n}",
      "B26 {\n  $z3 \u003d r58.equals(\"s\")\n  if ($z3 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  b11 \u003d 10\n}",
      "B28 {\n  Iterator: boolean hasNext()\u003e()]; }\n}",
      "B29 {\n  $r51 \u003d List caseI_KI\u003e\n  $r52 \u003d CpBands cpBands\u003e\n  $r53 \u003d r56.next()\n  $r54 \u003d $r52.getConstant($r53)\n  $r51.add($r54)\n  goto B36\n}",
      "B30 {\n  $r47 \u003d List caseD_KD\u003e\n  $r48 \u003d CpBands cpBands\u003e\n  $r49 \u003d r56.next()\n  $r50 \u003d $r48.getConstant($r49)\n  $r47.add($r50)\n  goto B36\n}",
      "B31 {\n  $r43 \u003d List caseF_KF\u003e\n  $r44 \u003d CpBands cpBands\u003e\n  $r45 \u003d r56.next()\n  $r46 \u003d $r44.getConstant($r45)\n  $r43.add($r46)\n  goto B36\n}",
      "B32 {\n  $r39 \u003d List caseJ_KJ\u003e\n  $r40 \u003d CpBands cpBands\u003e\n  $r41 \u003d r56.next()\n  $r42 \u003d $r40.getConstant($r41)\n  $r39.add($r42)\n  goto B36\n}",
      "B33 {\n  $r35 \u003d List casec_RS\u003e\n  $r36 \u003d CpBands cpBands\u003e\n  $r37 \u003d r0.nextString(r56)\n  $r38 \u003d $r36.getCPSignature($r37)\n  $r35.add($r38)\n  goto B36\n}",
      "B34 {\n  $r27 \u003d List caseet_RS\u003e\n  $r28 \u003d CpBands cpBands\u003e\n  $r29 \u003d r0.nextString(r56)\n  $r30 \u003d $r28.getCPSignature($r29)\n  $r27.add($r30)\n  $r31 \u003d List caseec_RU\u003e\n  $r32 \u003d CpBands cpBands\u003e\n  $r33 \u003d r0.nextString(r56)\n  $r34 \u003d $r32.getCPUtf8($r33)\n  $r31.add($r34)\n  goto B36\n}",
      "B35 {\n  $r23 \u003d List cases_RU\u003e\n  $r24 \u003d CpBands cpBands\u003e\n  $r25 \u003d r0.nextString(r56)\n  $r26 \u003d $r24.getCPUtf8($r25)\n  $r23.add($r26)\n}",
      "B36 {\n  goto B4\n}",
      "B37 {\n  r59 \u003d r11.iterator()\n}",
      "B38 {\n  $z1 \u003d r59.hasNext()\n  if ($z1 \u003d\u003d false) goto B39 else B40\n}",
      "B39 {\n  $r19 \u003d r59.next()\n  r60 \u003d Integer) $r19\n  i12 \u003d r60.intValue()\n  $r20 \u003d IntList casearray_N\u003e\n  $r20.add(i12)\n  $i5 \u003d MetadataBandGroup: int numBackwardsCalls\u003e\n  $i6 \u003d $i5 + i12\n  MetadataBandGroup: int numBackwardsCalls\u003e \u003d $i6\n  goto B38\n}",
      "B40 {\n  $r13 \u003d MetadataBandGroup$lambda_addParameterAnnotation_5__38.bootstrap$(r0)\n  r12.forEach($r13)\n  $r15 \u003d MetadataBandGroup$lambda_addParameterAnnotation_6__39.bootstrap$(r0)\n  r14.forEach($r15)\n  r61 \u003d r16.iterator()\n}",
      "B41 {\n  $z2 \u003d r61.hasNext()\n  if ($z2 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $r17 \u003d r61.next()\n  r62 \u003d Integer) $r17\n  $r18 \u003d IntList nestpair_N\u003e\n  $i1 \u003d r62.intValue()\n  $r18.add($i1)\n  $i2 \u003d MetadataBandGroup: int numBackwardsCalls\u003e\n  $i3 \u003d r62.intValue()\n  $i4 \u003d $i2 + $i3\n  MetadataBandGroup: int numBackwardsCalls\u003e \u003d $i4\n  goto B41\n}",
      "B43 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B37",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B5 --\u003e B16",
      "B5 --\u003e B18",
      "B5 --\u003e B10",
      "B5 --\u003e B20",
      "B5 --\u003e B12",
      "B5 --\u003e B14",
      "B5 --\u003e B22",
      "B5 --\u003e B24",
      "B5 --\u003e B26",
      "B5 --\u003e B28",
      "B6 --\u003e B7",
      "B6 --\u003e B28",
      "B7 --\u003e B28",
      "B8 --\u003e B9",
      "B8 --\u003e B28",
      "B9 --\u003e B28",
      "B10 --\u003e B11",
      "B10 --\u003e B28",
      "B11 --\u003e B28",
      "B12 --\u003e B13",
      "B12 --\u003e B28",
      "B13 --\u003e B28",
      "B14 --\u003e B15",
      "B14 --\u003e B28",
      "B15 --\u003e B28",
      "B16 --\u003e B17",
      "B16 --\u003e B28",
      "B17 --\u003e B28",
      "B18 --\u003e B19",
      "B18 --\u003e B28",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B28",
      "B21 --\u003e B28",
      "B22 --\u003e B23",
      "B22 --\u003e B28",
      "B23 --\u003e B28",
      "B24 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B28",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B28 --\u003e B31",
      "B28 --\u003e B32",
      "B28 --\u003e B33",
      "B28 --\u003e B34",
      "B28 --\u003e B35",
      "B28 --\u003e B36",
      "B29 --\u003e B36",
      "B30 --\u003e B36",
      "B31 --\u003e B36",
      "B32 --\u003e B36",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B4",
      "B37 --\u003e B38",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e B38",
      "B40 --\u003e B41",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B41",
      "B43 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MetadataBandGroup#nextString(...1)",
        "body": "{\r\n    return (String) valuesIterator.next();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.MetadataBandGroup",
    "methodName": "hasContent",
    "signature": "boolean hasContent()",
    "visibility": "public",
    "body": "{\r\n    return type_RS.size() \u003e 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  $r1 \u003d List type_RS\u003e\n  $i0 \u003d $r1.size()\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.MetadataBandGroup",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    PackingUtils.log(\"Writing metadata band group...\");\r\n    if (hasContent()) {\r\n        final String contextStr;\r\n        if (context \u003d\u003d CONTEXT_CLASS) {\r\n            contextStr \u003d \"Class\";\r\n        } else if (context \u003d\u003d CONTEXT_FIELD) {\r\n            contextStr \u003d \"Field\";\r\n        } else {\r\n            contextStr \u003d \"Method\";\r\n        }\r\n        byte[] encodedBand;\r\n        if (!type.equals(\"AD\")) {\r\n            if (type.indexOf(\u0027P\u0027) !\u003d -1) {\r\n                // Parameter annotation so we need to transmit param_NB\r\n                encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" param_NB\", param_NB.toArray(), Codec.BYTE1);\r\n                out.write(encodedBand);\r\n                PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" anno_N[\" + param_NB.size() + \"]\");\r\n            }\r\n            encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" anno_N\", anno_N.toArray(), Codec.UNSIGNED5);\r\n            out.write(encodedBand);\r\n            PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" anno_N[\" + anno_N.size() + \"]\");\r\n            encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" type_RS\", cpEntryListToArray(type_RS), Codec.UNSIGNED5);\r\n            out.write(encodedBand);\r\n            PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" type_RS[\" + type_RS.size() + \"]\");\r\n            encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" pair_N\", pair_N.toArray(), Codec.UNSIGNED5);\r\n            out.write(encodedBand);\r\n            PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" pair_N[\" + pair_N.size() + \"]\");\r\n            encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" name_RU\", cpEntryListToArray(name_RU), Codec.UNSIGNED5);\r\n            out.write(encodedBand);\r\n            PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" name_RU[\" + name_RU.size() + \"]\");\r\n        }\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" T\", tagListToArray(T), Codec.BYTE1);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" T[\" + T.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseI_KI\", cpEntryListToArray(caseI_KI), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseI_KI[\" + caseI_KI.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseD_KD\", cpEntryListToArray(caseD_KD), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseD_KD[\" + caseD_KD.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseF_KF\", cpEntryListToArray(caseF_KF), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseF_KF[\" + caseF_KF.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseJ_KJ\", cpEntryListToArray(caseJ_KJ), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseJ_KJ[\" + caseJ_KJ.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" casec_RS\", cpEntryListToArray(casec_RS), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" casec_RS[\" + casec_RS.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseet_RS\", cpEntryListToArray(caseet_RS), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseet_RS[\" + caseet_RS.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" caseec_RU\", cpEntryListToArray(caseec_RU), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" caseec_RU[\" + caseec_RU.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" cases_RU\", cpEntryListToArray(cases_RU), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" cases_RU[\" + cases_RU.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" casearray_N\", casearray_N.toArray(), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" casearray_N[\" + casearray_N.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" nesttype_RS\", cpEntryListToArray(nesttype_RS), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" nesttype_RS[\" + nesttype_RS.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" nestpair_N\", nestpair_N.toArray(), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" nestpair_N[\" + nestpair_N.size() + \"]\");\r\n        encodedBand \u003d encodeBandInt(contextStr + \"_\" + type + \" nestname_RU\", cpEntryListToArray(nestname_RU), Codec.UNSIGNED5);\r\n        out.write(encodedBand);\r\n        PackingUtils.log(\"Wrote \" + encodedBand.length + \" bytes from \" + contextStr + \"_\" + type + \" nestname_RU[\" + nestname_RU.size() + \"]\");\r\n    }\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B11",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3",
      "B3 : If($i1 !\u003d 1) → B4 | else → B5",
      "B6 : If($z1 !\u003d 0) → B7 | else → B10",
      "B7 : If($i2 \u003d\u003d $i40) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  OutputStream\n  PackingUtils.log(\"Writing metadata band group...\")\n  $z0 \u003d r0.hasContent()\n  if ($z0 \u003d\u003d false) goto B1 else B11\n}",
      "B1 {\n  $i0 \u003d MetadataBandGroup: int context\u003e\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r122 \u003d \"Class\"\n  r472 \u003d \"Class\"\n  r471 \u003d \"Class\"\n  r470 \u003d \"Class\"\n  r469 \u003d \"Class\"\n  r468 \u003d \"Class\"\n  r467 \u003d \"Class\"\n  r466 \u003d \"Class\"\n  r465 \u003d \"Class\"\n  r464 \u003d \"Class\"\n  r463 \u003d \"Class\"\n  r462 \u003d \"Class\"\n  r461 \u003d \"Class\"\n  r460 \u003d \"Class\"\n  r459 \u003d \"Class\"\n  r458 \u003d \"Class\"\n  r457 \u003d \"Class\"\n  r456 \u003d \"Class\"\n  r455 \u003d \"Class\"\n  r454 \u003d \"Class\"\n  r453 \u003d \"Class\"\n  r452 \u003d \"Class\"\n  r451 \u003d \"Class\"\n  r450 \u003d \"Class\"\n  r449 \u003d \"Class\"\n  r448 \u003d \"Class\"\n  r447 \u003d \"Class\"\n  r446 \u003d \"Class\"\n  r445 \u003d \"Class\"\n  r444 \u003d \"Class\"\n  r443 \u003d \"Class\"\n  r442 \u003d \"Class\"\n  r441 \u003d \"Class\"\n  r440 \u003d \"Class\"\n  r439 \u003d \"Class\"\n  r438 \u003d \"Class\"\n  r437 \u003d \"Class\"\n  goto B6\n}",
      "B3 {\n  $i1 \u003d MetadataBandGroup: int context\u003e\n  if ($i1 !\u003d 1) goto B4 else B5\n}",
      "B4 {\n  r122 \u003d \"Field\"\n  r472 \u003d \"Field\"\n  r471 \u003d \"Field\"\n  r470 \u003d \"Field\"\n  r469 \u003d \"Field\"\n  r468 \u003d \"Field\"\n  r467 \u003d \"Field\"\n  r466 \u003d \"Field\"\n  r465 \u003d \"Field\"\n  r464 \u003d \"Field\"\n  r463 \u003d \"Field\"\n  r462 \u003d \"Field\"\n  r461 \u003d \"Field\"\n  r460 \u003d \"Field\"\n  r459 \u003d \"Field\"\n  r458 \u003d \"Field\"\n  r457 \u003d \"Field\"\n  r456 \u003d \"Field\"\n  r455 \u003d \"Field\"\n  r454 \u003d \"Field\"\n  r453 \u003d \"Field\"\n  r452 \u003d \"Field\"\n  r451 \u003d \"Field\"\n  r450 \u003d \"Field\"\n  r449 \u003d \"Field\"\n  r448 \u003d \"Field\"\n  r447 \u003d \"Field\"\n  r446 \u003d \"Field\"\n  r445 \u003d \"Field\"\n  r444 \u003d \"Field\"\n  r443 \u003d \"Field\"\n  r442 \u003d \"Field\"\n  r441 \u003d \"Field\"\n  r440 \u003d \"Field\"\n  r439 \u003d \"Field\"\n  r438 \u003d \"Field\"\n  r437 \u003d \"Field\"\n  goto B6\n}",
      "B5 {\n  r122 \u003d \"Method\"\n  r472 \u003d \"Method\"\n  r471 \u003d \"Method\"\n  r470 \u003d \"Method\"\n  r469 \u003d \"Method\"\n  r468 \u003d \"Method\"\n  r467 \u003d \"Method\"\n  r466 \u003d \"Method\"\n  r465 \u003d \"Method\"\n  r464 \u003d \"Method\"\n  r463 \u003d \"Method\"\n  r462 \u003d \"Method\"\n  r461 \u003d \"Method\"\n  r460 \u003d \"Method\"\n  r459 \u003d \"Method\"\n  r458 \u003d \"Method\"\n  r457 \u003d \"Method\"\n  r456 \u003d \"Method\"\n  r455 \u003d \"Method\"\n  r454 \u003d \"Method\"\n  r453 \u003d \"Method\"\n  r452 \u003d \"Method\"\n  r451 \u003d \"Method\"\n  r450 \u003d \"Method\"\n  r449 \u003d \"Method\"\n  r448 \u003d \"Method\"\n  r447 \u003d \"Method\"\n  r446 \u003d \"Method\"\n  r445 \u003d \"Method\"\n  r444 \u003d \"Method\"\n  r443 \u003d \"Method\"\n  r442 \u003d \"Method\"\n  r441 \u003d \"Method\"\n  r440 \u003d \"Method\"\n  r439 \u003d \"Method\"\n  r438 \u003d \"Method\"\n  r437 \u003d \"Method\"\n}",
      "B6 {\n  $r123 \u003d String type\u003e\n  $z1 \u003d $r123.equals(\"AD\")\n  if ($z1 !\u003d 0) goto B7 else B10\n}",
      "B7 {\n  $r2 \u003d String type\u003e\n  $i2 \u003d $r2.indexOf(80)\n  $i40 \u003d (int) -1\n  if ($i2 \u003d\u003d $i40) goto B8 else B9\n}",
      "B8 {\n  $r473 \u003d StringBuilder\n  new StringBuilder()\n  $r96 \u003d $r473.append(r449)\n  $r98 \u003d $r96.append(\"_\")\n  $r97 \u003d String type\u003e\n  $r99 \u003d $r98.append($r97)\n  $r100 \u003d $r99.append(\" param_NB\")\n  $r104 \u003d $r100.toString()\n  $r101 \u003d IntList param_NB\u003e\n  $r103 \u003d $r101.toArray()\n  $r102 \u003d BHSDCodec BYTE1\u003e\n  r124 \u003d r0.encodeBandInt($r104, $r103, $r102)\n  r1.write(r124)\n  $r474 \u003d StringBuilder\n  new StringBuilder()\n  $r106 \u003d $r474.append(\"Wrote \")\n  $i11 \u003d lengthof r124\n  $r107 \u003d $r106.append($i11)\n  $r108 \u003d $r107.append(\" bytes from \")\n  $r109 \u003d $r108.append(r466)\n  $r111 \u003d $r109.append(\"_\")\n  $r110 \u003d String type\u003e\n  $r112 \u003d $r111.append($r110)\n  $r114 \u003d $r112.append(\" anno_N\")\n  $r113 \u003d IntList param_NB\u003e\n  $i12 \u003d $r113.size()\n  $r115 \u003d $r114.append($i12)\n  $r116 \u003d $r115.append(\"\")\n  $r117 \u003d $r116.toString()\n  PackingUtils.log($r117)\n}",
      "B9 {\n  $r475 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r475.append(r455)\n  $r6 \u003d $r4.append(\"_\")\n  $r5 \u003d String type\u003e\n  $r7 \u003d $r6.append($r5)\n  $r8 \u003d $r7.append(\" anno_N\")\n  $r12 \u003d $r8.toString()\n  $r9 \u003d IntList anno_N\u003e\n  $r11 \u003d $r9.toArray()\n  $r10 \u003d BHSDCodec UNSIGNED5\u003e\n  $r118 \u003d r0.encodeBandInt($r12, $r11, $r10)\n  r1.write($r118)\n  $r476 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r476.append(\"Wrote \")\n  $i3 \u003d lengthof $r118\n  $r15 \u003d $r14.append($i3)\n  $r16 \u003d $r15.append(\" bytes from \")\n  $r17 \u003d $r16.append(r437)\n  $r19 \u003d $r17.append(\"_\")\n  $r18 \u003d String type\u003e\n  $r20 \u003d $r19.append($r18)\n  $r22 \u003d $r20.append(\" anno_N\")\n  $r21 \u003d IntList anno_N\u003e\n  $i4 \u003d $r21.size()\n  $r23 \u003d $r22.append($i4)\n  $r24 \u003d $r23.append(\"\")\n  $r25 \u003d $r24.toString()\n  PackingUtils.log($r25)\n  $r477 \u003d StringBuilder\n  new StringBuilder()\n  $r27 \u003d $r477.append(r445)\n  $r29 \u003d $r27.append(\"_\")\n  $r28 \u003d String type\u003e\n  $r30 \u003d $r29.append($r28)\n  $r31 \u003d $r30.append(\" type_RS\")\n  $r35 \u003d $r31.toString()\n  $r32 \u003d List type_RS\u003e\n  $r34 \u003d r0.cpEntryListToArray($r32)\n  $r33 \u003d BHSDCodec UNSIGNED5\u003e\n  $r119 \u003d r0.encodeBandInt($r35, $r34, $r33)\n  r1.write($r119)\n  $r478 \u003d StringBuilder\n  new StringBuilder()\n  $r37 \u003d $r478.append(\"Wrote \")\n  $i5 \u003d lengthof $r119\n  $r38 \u003d $r37.append($i5)\n  $r39 \u003d $r38.append(\" bytes from \")\n  $r40 \u003d $r39.append(r452)\n  $r42 \u003d $r40.append(\"_\")\n  $r41 \u003d String type\u003e\n  $r43 \u003d $r42.append($r41)\n  $r45 \u003d $r43.append(\" type_RS\")\n  $r44 \u003d List type_RS\u003e\n  $i6 \u003d $r44.size()\n  $r46 \u003d $r45.append($i6)\n  $r47 \u003d $r46.append(\"\")\n  $r48 \u003d $r47.toString()\n  PackingUtils.log($r48)\n  $r479 \u003d StringBuilder\n  new StringBuilder()\n  $r50 \u003d $r479.append(r458)\n  $r52 \u003d $r50.append(\"_\")\n  $r51 \u003d String type\u003e\n  $r53 \u003d $r52.append($r51)\n  $r54 \u003d $r53.append(\" pair_N\")\n  $r58 \u003d $r54.toString()\n  $r55 \u003d IntList pair_N\u003e\n  $r57 \u003d $r55.toArray()\n  $r56 \u003d BHSDCodec UNSIGNED5\u003e\n  $r120 \u003d r0.encodeBandInt($r58, $r57, $r56)\n  r1.write($r120)\n  $r480 \u003d StringBuilder\n  new StringBuilder()\n  $r60 \u003d $r480.append(\"Wrote \")\n  $i7 \u003d lengthof $r120\n  $r61 \u003d $r60.append($i7)\n  $r62 \u003d $r61.append(\" bytes from \")\n  $r63 \u003d $r62.append(r471)\n  $r65 \u003d $r63.append(\"_\")\n  $r64 \u003d String type\u003e\n  $r66 \u003d $r65.append($r64)\n  $r68 \u003d $r66.append(\" pair_N\")\n  $r67 \u003d IntList pair_N\u003e\n  $i8 \u003d $r67.size()\n  $r69 \u003d $r68.append($i8)\n  $r70 \u003d $r69.append(\"\")\n  $r71 \u003d $r70.toString()\n  PackingUtils.log($r71)\n  $r481 \u003d StringBuilder\n  new StringBuilder()\n  $r73 \u003d $r481.append(r439)\n  $r75 \u003d $r73.append(\"_\")\n  $r74 \u003d String type\u003e\n  $r76 \u003d $r75.append($r74)\n  $r77 \u003d $r76.append(\" name_RU\")\n  $r81 \u003d $r77.toString()\n  $r78 \u003d List name_RU\u003e\n  $r80 \u003d r0.cpEntryListToArray($r78)\n  $r79 \u003d BHSDCodec UNSIGNED5\u003e\n  $r121 \u003d r0.encodeBandInt($r81, $r80, $r79)\n  r1.write($r121)\n  $r482 \u003d StringBuilder\n  new StringBuilder()\n  $r83 \u003d $r482.append(\"Wrote \")\n  $i9 \u003d lengthof $r121\n  $r84 \u003d $r83.append($i9)\n  $r85 \u003d $r84.append(\" bytes from \")\n  $r86 \u003d $r85.append(r461)\n  $r88 \u003d $r86.append(\"_\")\n  $r87 \u003d String type\u003e\n  $r89 \u003d $r88.append($r87)\n  $r91 \u003d $r89.append(\" name_RU\")\n  $r90 \u003d List name_RU\u003e\n  $i10 \u003d $r90.size()\n  $r92 \u003d $r91.append($i10)\n  $r93 \u003d $r92.append(\"\")\n  $r94 \u003d $r93.toString()\n  PackingUtils.log($r94)\n}",
      "B10 {\n  $r483 \u003d StringBuilder\n  new StringBuilder()\n  $r126 \u003d $r483.append(r459)\n  $r127 \u003d $r126.append(\"_\")\n  $r128 \u003d String type\u003e\n  $r129 \u003d $r127.append($r128)\n  $r130 \u003d $r129.append(\" T\")\n  $r131 \u003d $r130.toString()\n  $r132 \u003d List T\u003e\n  $r133 \u003d r0.tagListToArray($r132)\n  $r134 \u003d BHSDCodec BYTE1\u003e\n  $r135 \u003d r0.encodeBandInt($r131, $r133, $r134)\n  r1.write($r135)\n  $r484 \u003d StringBuilder\n  new StringBuilder()\n  $r137 \u003d $r484.append(\"Wrote \")\n  $i13 \u003d lengthof $r135\n  $r138 \u003d $r137.append($i13)\n  $r139 \u003d $r138.append(\" bytes from \")\n  $r140 \u003d $r139.append(r447)\n  $r141 \u003d $r140.append(\"_\")\n  $r142 \u003d String type\u003e\n  $r143 \u003d $r141.append($r142)\n  $r144 \u003d $r143.append(\" T\")\n  $r145 \u003d List T\u003e\n  $i14 \u003d $r145.size()\n  $r146 \u003d $r144.append($i14)\n  $r147 \u003d $r146.append(\"\")\n  $r148 \u003d $r147.toString()\n  PackingUtils.log($r148)\n  $r485 \u003d StringBuilder\n  new StringBuilder()\n  $r150 \u003d $r485.append(r453)\n  $r151 \u003d $r150.append(\"_\")\n  $r152 \u003d String type\u003e\n  $r153 \u003d $r151.append($r152)\n  $r154 \u003d $r153.append(\" caseI_KI\")\n  $r155 \u003d $r154.toString()\n  $r156 \u003d List caseI_KI\u003e\n  $r157 \u003d r0.cpEntryListToArray($r156)\n  $r158 \u003d BHSDCodec UNSIGNED5\u003e\n  $r159 \u003d r0.encodeBandInt($r155, $r157, $r158)\n  r1.write($r159)\n  $r486 \u003d StringBuilder\n  new StringBuilder()\n  $r161 \u003d $r486.append(\"Wrote \")\n  $i15 \u003d lengthof $r159\n  $r162 \u003d $r161.append($i15)\n  $r163 \u003d $r162.append(\" bytes from \")\n  $r164 \u003d $r163.append(r467)\n  $r165 \u003d $r164.append(\"_\")\n  $r166 \u003d String type\u003e\n  $r167 \u003d $r165.append($r166)\n  $r168 \u003d $r167.append(\" caseI_KI\")\n  $r169 \u003d List caseI_KI\u003e\n  $i16 \u003d $r169.size()\n  $r170 \u003d $r168.append($i16)\n  $r171 \u003d $r170.append(\"\")\n  $r172 \u003d $r171.toString()\n  PackingUtils.log($r172)\n  $r487 \u003d StringBuilder\n  new StringBuilder()\n  $r174 \u003d $r487.append(r469)\n  $r175 \u003d $r174.append(\"_\")\n  $r176 \u003d String type\u003e\n  $r177 \u003d $r175.append($r176)\n  $r178 \u003d $r177.append(\" caseD_KD\")\n  $r179 \u003d $r178.toString()\n  $r180 \u003d List caseD_KD\u003e\n  $r181 \u003d r0.cpEntryListToArray($r180)\n  $r182 \u003d BHSDCodec UNSIGNED5\u003e\n  $r183 \u003d r0.encodeBandInt($r179, $r181, $r182)\n  r1.write($r183)\n  $r488 \u003d StringBuilder\n  new StringBuilder()\n  $r185 \u003d $r488.append(\"Wrote \")\n  $i17 \u003d lengthof $r183\n  $r186 \u003d $r185.append($i17)\n  $r187 \u003d $r186.append(\" bytes from \")\n  $r188 \u003d $r187.append(r446)\n  $r189 \u003d $r188.append(\"_\")\n  $r190 \u003d String type\u003e\n  $r191 \u003d $r189.append($r190)\n  $r192 \u003d $r191.append(\" caseD_KD\")\n  $r193 \u003d List caseD_KD\u003e\n  $i18 \u003d $r193.size()\n  $r194 \u003d $r192.append($i18)\n  $r195 \u003d $r194.append(\"\")\n  $r196 \u003d $r195.toString()\n  PackingUtils.log($r196)\n  $r489 \u003d StringBuilder\n  new StringBuilder()\n  $r198 \u003d $r489.append(r443)\n  $r199 \u003d $r198.append(\"_\")\n  $r200 \u003d String type\u003e\n  $r201 \u003d $r199.append($r200)\n  $r202 \u003d $r201.append(\" caseF_KF\")\n  $r203 \u003d $r202.toString()\n  $r204 \u003d List caseF_KF\u003e\n  $r205 \u003d r0.cpEntryListToArray($r204)\n  $r206 \u003d BHSDCodec UNSIGNED5\u003e\n  $r207 \u003d r0.encodeBandInt($r203, $r205, $r206)\n  r1.write($r207)\n  $r490 \u003d StringBuilder\n  new StringBuilder()\n  $r209 \u003d $r490.append(\"Wrote \")\n  $i19 \u003d lengthof $r207\n  $r210 \u003d $r209.append($i19)\n  $r211 \u003d $r210.append(\" bytes from \")\n  $r212 \u003d $r211.append(r440)\n  $r213 \u003d $r212.append(\"_\")\n  $r214 \u003d String type\u003e\n  $r215 \u003d $r213.append($r214)\n  $r216 \u003d $r215.append(\" caseF_KF\")\n  $r217 \u003d List caseF_KF\u003e\n  $i20 \u003d $r217.size()\n  $r218 \u003d $r216.append($i20)\n  $r219 \u003d $r218.append(\"\")\n  $r220 \u003d $r219.toString()\n  PackingUtils.log($r220)\n  $r491 \u003d StringBuilder\n  new StringBuilder()\n  $r222 \u003d $r491.append(r450)\n  $r223 \u003d $r222.append(\"_\")\n  $r224 \u003d String type\u003e\n  $r225 \u003d $r223.append($r224)\n  $r226 \u003d $r225.append(\" caseJ_KJ\")\n  $r227 \u003d $r226.toString()\n  $r228 \u003d List caseJ_KJ\u003e\n  $r229 \u003d r0.cpEntryListToArray($r228)\n  $r230 \u003d BHSDCodec UNSIGNED5\u003e\n  $r231 \u003d r0.encodeBandInt($r227, $r229, $r230)\n  r1.write($r231)\n  $r492 \u003d StringBuilder\n  new StringBuilder()\n  $r233 \u003d $r492.append(\"Wrote \")\n  $i21 \u003d lengthof $r231\n  $r234 \u003d $r233.append($i21)\n  $r235 \u003d $r234.append(\" bytes from \")\n  $r236 \u003d $r235.append(r454)\n  $r237 \u003d $r236.append(\"_\")\n  $r238 \u003d String type\u003e\n  $r239 \u003d $r237.append($r238)\n  $r240 \u003d $r239.append(\" caseJ_KJ\")\n  $r241 \u003d List caseJ_KJ\u003e\n  $i22 \u003d $r241.size()\n  $r242 \u003d $r240.append($i22)\n  $r243 \u003d $r242.append(\"\")\n  $r244 \u003d $r243.toString()\n  PackingUtils.log($r244)\n  $r493 \u003d StringBuilder\n  new StringBuilder()\n  $r246 \u003d $r493.append(r438)\n  $r247 \u003d $r246.append(\"_\")\n  $r248 \u003d String type\u003e\n  $r249 \u003d $r247.append($r248)\n  $r250 \u003d $r249.append(\" casec_RS\")\n  $r251 \u003d $r250.toString()\n  $r252 \u003d List casec_RS\u003e\n  $r253 \u003d r0.cpEntryListToArray($r252)\n  $r254 \u003d BHSDCodec UNSIGNED5\u003e\n  $r255 \u003d r0.encodeBandInt($r251, $r253, $r254)\n  r1.write($r255)\n  $r494 \u003d StringBuilder\n  new StringBuilder()\n  $r257 \u003d $r494.append(\"Wrote \")\n  $i23 \u003d lengthof $r255\n  $r258 \u003d $r257.append($i23)\n  $r259 \u003d $r258.append(\" bytes from \")\n  $r260 \u003d $r259.append(r470)\n  $r261 \u003d $r260.append(\"_\")\n  $r262 \u003d String type\u003e\n  $r263 \u003d $r261.append($r262)\n  $r264 \u003d $r263.append(\" casec_RS\")\n  $r265 \u003d List casec_RS\u003e\n  $i24 \u003d $r265.size()\n  $r266 \u003d $r264.append($i24)\n  $r267 \u003d $r266.append(\"\")\n  $r268 \u003d $r267.toString()\n  PackingUtils.log($r268)\n  $r495 \u003d StringBuilder\n  new StringBuilder()\n  $r270 \u003d $r495.append(r465)\n  $r271 \u003d $r270.append(\"_\")\n  $r272 \u003d String type\u003e\n  $r273 \u003d $r271.append($r272)\n  $r274 \u003d $r273.append(\" caseet_RS\")\n  $r275 \u003d $r274.toString()\n  $r276 \u003d List caseet_RS\u003e\n  $r277 \u003d r0.cpEntryListToArray($r276)\n  $r278 \u003d BHSDCodec UNSIGNED5\u003e\n  $r279 \u003d r0.encodeBandInt($r275, $r277, $r278)\n  r1.write($r279)\n  $r496 \u003d StringBuilder\n  new StringBuilder()\n  $r281 \u003d $r496.append(\"Wrote \")\n  $i25 \u003d lengthof $r279\n  $r282 \u003d $r281.append($i25)\n  $r283 \u003d $r282.append(\" bytes from \")\n  $r284 \u003d $r283.append(r472)\n  $r285 \u003d $r284.append(\"_\")\n  $r286 \u003d String type\u003e\n  $r287 \u003d $r285.append($r286)\n  $r288 \u003d $r287.append(\" caseet_RS\")\n  $r289 \u003d List caseet_RS\u003e\n  $i26 \u003d $r289.size()\n  $r290 \u003d $r288.append($i26)\n  $r291 \u003d $r290.append(\"\")\n  $r292 \u003d $r291.toString()\n  PackingUtils.log($r292)\n  $r497 \u003d StringBuilder\n  new StringBuilder()\n  $r294 \u003d $r497.append(r448)\n  $r295 \u003d $r294.append(\"_\")\n  $r296 \u003d String type\u003e\n  $r297 \u003d $r295.append($r296)\n  $r298 \u003d $r297.append(\" caseec_RU\")\n  $r299 \u003d $r298.toString()\n  $r300 \u003d List caseec_RU\u003e\n  $r301 \u003d r0.cpEntryListToArray($r300)\n  $r302 \u003d BHSDCodec UNSIGNED5\u003e\n  $r303 \u003d r0.encodeBandInt($r299, $r301, $r302)\n  r1.write($r303)\n  $r498 \u003d StringBuilder\n  new StringBuilder()\n  $r305 \u003d $r498.append(\"Wrote \")\n  $i27 \u003d lengthof $r303\n  $r306 \u003d $r305.append($i27)\n  $r307 \u003d $r306.append(\" bytes from \")\n  $r308 \u003d $r307.append(r460)\n  $r309 \u003d $r308.append(\"_\")\n  $r310 \u003d String type\u003e\n  $r311 \u003d $r309.append($r310)\n  $r312 \u003d $r311.append(\" caseec_RU\")\n  $r313 \u003d List caseec_RU\u003e\n  $i28 \u003d $r313.size()\n  $r314 \u003d $r312.append($i28)\n  $r315 \u003d $r314.append(\"\")\n  $r316 \u003d $r315.toString()\n  PackingUtils.log($r316)\n  $r499 \u003d StringBuilder\n  new StringBuilder()\n  $r318 \u003d $r499.append(r464)\n  $r319 \u003d $r318.append(\"_\")\n  $r320 \u003d String type\u003e\n  $r321 \u003d $r319.append($r320)\n  $r322 \u003d $r321.append(\" cases_RU\")\n  $r323 \u003d $r322.toString()\n  $r324 \u003d List cases_RU\u003e\n  $r325 \u003d r0.cpEntryListToArray($r324)\n  $r326 \u003d BHSDCodec UNSIGNED5\u003e\n  $r327 \u003d r0.encodeBandInt($r323, $r325, $r326)\n  r1.write($r327)\n  $r500 \u003d StringBuilder\n  new StringBuilder()\n  $r329 \u003d $r500.append(\"Wrote \")\n  $i29 \u003d lengthof $r327\n  $r330 \u003d $r329.append($i29)\n  $r331 \u003d $r330.append(\" bytes from \")\n  $r332 \u003d $r331.append(r441)\n  $r333 \u003d $r332.append(\"_\")\n  $r334 \u003d String type\u003e\n  $r335 \u003d $r333.append($r334)\n  $r336 \u003d $r335.append(\" cases_RU\")\n  $r337 \u003d List cases_RU\u003e\n  $i30 \u003d $r337.size()\n  $r338 \u003d $r336.append($i30)\n  $r339 \u003d $r338.append(\"\")\n  $r340 \u003d $r339.toString()\n  PackingUtils.log($r340)\n  $r501 \u003d StringBuilder\n  new StringBuilder()\n  $r342 \u003d $r501.append(r442)\n  $r343 \u003d $r342.append(\"_\")\n  $r344 \u003d String type\u003e\n  $r345 \u003d $r343.append($r344)\n  $r346 \u003d $r345.append(\" casearray_N\")\n  $r347 \u003d $r346.toString()\n  $r348 \u003d IntList casearray_N\u003e\n  $r349 \u003d $r348.toArray()\n  $r350 \u003d BHSDCodec UNSIGNED5\u003e\n  $r351 \u003d r0.encodeBandInt($r347, $r349, $r350)\n  r1.write($r351)\n  $r502 \u003d StringBuilder\n  new StringBuilder()\n  $r353 \u003d $r502.append(\"Wrote \")\n  $i31 \u003d lengthof $r351\n  $r354 \u003d $r353.append($i31)\n  $r355 \u003d $r354.append(\" bytes from \")\n  $r356 \u003d $r355.append(r463)\n  $r357 \u003d $r356.append(\"_\")\n  $r358 \u003d String type\u003e\n  $r359 \u003d $r357.append($r358)\n  $r360 \u003d $r359.append(\" casearray_N\")\n  $r361 \u003d IntList casearray_N\u003e\n  $i32 \u003d $r361.size()\n  $r362 \u003d $r360.append($i32)\n  $r363 \u003d $r362.append(\"\")\n  $r364 \u003d $r363.toString()\n  PackingUtils.log($r364)\n  $r503 \u003d StringBuilder\n  new StringBuilder()\n  $r366 \u003d $r503.append(r468)\n  $r367 \u003d $r366.append(\"_\")\n  $r368 \u003d String type\u003e\n  $r369 \u003d $r367.append($r368)\n  $r370 \u003d $r369.append(\" nesttype_RS\")\n  $r371 \u003d $r370.toString()\n  $r372 \u003d List nesttype_RS\u003e\n  $r373 \u003d r0.cpEntryListToArray($r372)\n  $r374 \u003d BHSDCodec UNSIGNED5\u003e\n  $r375 \u003d r0.encodeBandInt($r371, $r373, $r374)\n  r1.write($r375)\n  $r504 \u003d StringBuilder\n  new StringBuilder()\n  $r377 \u003d $r504.append(\"Wrote \")\n  $i33 \u003d lengthof $r375\n  $r378 \u003d $r377.append($i33)\n  $r379 \u003d $r378.append(\" bytes from \")\n  $r380 \u003d $r379.append(r451)\n  $r381 \u003d $r380.append(\"_\")\n  $r382 \u003d String type\u003e\n  $r383 \u003d $r381.append($r382)\n  $r384 \u003d $r383.append(\" nesttype_RS\")\n  $r385 \u003d List nesttype_RS\u003e\n  $i34 \u003d $r385.size()\n  $r386 \u003d $r384.append($i34)\n  $r387 \u003d $r386.append(\"\")\n  $r388 \u003d $r387.toString()\n  PackingUtils.log($r388)\n  $r505 \u003d StringBuilder\n  new StringBuilder()\n  $r390 \u003d $r505.append(r462)\n  $r391 \u003d $r390.append(\"_\")\n  $r392 \u003d String type\u003e\n  $r393 \u003d $r391.append($r392)\n  $r394 \u003d $r393.append(\" nestpair_N\")\n  $r395 \u003d $r394.toString()\n  $r396 \u003d IntList nestpair_N\u003e\n  $r397 \u003d $r396.toArray()\n  $r398 \u003d BHSDCodec UNSIGNED5\u003e\n  $r399 \u003d r0.encodeBandInt($r395, $r397, $r398)\n  r1.write($r399)\n  $r506 \u003d StringBuilder\n  new StringBuilder()\n  $r401 \u003d $r506.append(\"Wrote \")\n  $i35 \u003d lengthof $r399\n  $r402 \u003d $r401.append($i35)\n  $r403 \u003d $r402.append(\" bytes from \")\n  $r404 \u003d $r403.append(r457)\n  $r405 \u003d $r404.append(\"_\")\n  $r406 \u003d String type\u003e\n  $r407 \u003d $r405.append($r406)\n  $r408 \u003d $r407.append(\" nestpair_N\")\n  $r409 \u003d IntList nestpair_N\u003e\n  $i36 \u003d $r409.size()\n  $r410 \u003d $r408.append($i36)\n  $r411 \u003d $r410.append(\"\")\n  $r412 \u003d $r411.toString()\n  PackingUtils.log($r412)\n  $r507 \u003d StringBuilder\n  new StringBuilder()\n  $r414 \u003d $r507.append(r456)\n  $r415 \u003d $r414.append(\"_\")\n  $r416 \u003d String type\u003e\n  $r417 \u003d $r415.append($r416)\n  $r418 \u003d $r417.append(\" nestname_RU\")\n  $r419 \u003d $r418.toString()\n  $r420 \u003d List nestname_RU\u003e\n  $r421 \u003d r0.cpEntryListToArray($r420)\n  $r422 \u003d BHSDCodec UNSIGNED5\u003e\n  $r423 \u003d r0.encodeBandInt($r419, $r421, $r422)\n  r1.write($r423)\n  $r508 \u003d StringBuilder\n  new StringBuilder()\n  $r425 \u003d $r508.append(\"Wrote \")\n  $i37 \u003d lengthof $r423\n  $r426 \u003d $r425.append($i37)\n  $r427 \u003d $r426.append(\" bytes from \")\n  $r428 \u003d $r427.append(r444)\n  $r429 \u003d $r428.append(\"_\")\n  $r430 \u003d String type\u003e\n  $r431 \u003d $r429.append($r430)\n  $r432 \u003d $r431.append(\" nestname_RU\")\n  $r433 \u003d List nestname_RU\u003e\n  $i38 \u003d $r433.size()\n  $r434 \u003d $r432.append($i38)\n  $r435 \u003d $r434.append(\"\")\n  $r436 \u003d $r435.toString()\n  PackingUtils.log($r436)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B11",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MetadataBandGroup#cpEntryListToArray(...1)",
        "body": "(source not found)"
      },
      {
        "name": "MetadataBandGroup#hasContent(...0)",
        "body": "{\r\n    return type_RS.size() \u003e 0;\r\n}"
      },
      {
        "name": "MetadataBandGroup#tagListToArray(...1)",
        "body": "{\r\n    return list.stream().mapToInt(s -\u003e s.charAt(0)).toArray();\r\n}"
      },
      {
        "name": "MetadataBandGroup#encodeBandInt(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.MetadataBandGroup",
    "methodName": "removeLatest",
    "signature": "void removeLatest()",
    "visibility": "public",
    "body": "{\r\n    final int latest \u003d anno_N.remove(anno_N.size() - 1);\r\n    for (int i \u003d 0; i \u003c latest; i++) {\r\n        type_RS.remove(type_RS.size() - 1);\r\n        final int pairs \u003d pair_N.remove(pair_N.size() - 1);\r\n        for (int j \u003d 0; j \u003c pairs; j++) {\r\n            removeOnePair();\r\n        }\r\n    }\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i8 \u003e\u003d i2) → B2 | else → B6",
      "B3 : If(i9 \u003e\u003d i7) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  $r2 \u003d IntList anno_N\u003e\n  $r1 \u003d IntList anno_N\u003e\n  $i0 \u003d $r1.size()\n  $i1 \u003d $i0 - 1\n  i2 \u003d $r2.remove($i1)\n  i8 \u003d 0\n}",
      "B1 {\n  if (i8 \u003e\u003d i2) goto B2 else B6\n}",
      "B2 {\n  $r4 \u003d List type_RS\u003e\n  $r3 \u003d List type_RS\u003e\n  $i3 \u003d $r3.size()\n  $i4 \u003d $i3 - 1\n  $r4.remove($i4)\n  $r6 \u003d IntList pair_N\u003e\n  $r5 \u003d IntList pair_N\u003e\n  $i5 \u003d $r5.size()\n  $i6 \u003d $i5 - 1\n  i7 \u003d $r6.remove($i6)\n  i9 \u003d 0\n}",
      "B3 {\n  if (i9 \u003e\u003d i7) goto B4 else B5\n}",
      "B4 {\n  r0.removeOnePair()\n  i9 \u003d i9 + 1\n  goto B3\n}",
      "B5 {\n  i8 \u003d i8 + 1\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MetadataBandGroup#removeOnePair(...0)",
        "body": "{\r\n    final String tag \u003d T.remove(T.size() - 1);\r\n    switch(tag) {\r\n        case \"B\":\r\n        case \"C\":\r\n        case \"I\":\r\n        case \"S\":\r\n        case \"Z\":\r\n            caseI_KI.remove(caseI_KI.size() - 1);\r\n            break;\r\n        case \"D\":\r\n            caseD_KD.remove(caseD_KD.size() - 1);\r\n            break;\r\n        case \"F\":\r\n            caseF_KF.remove(caseF_KF.size() - 1);\r\n            break;\r\n        case \"J\":\r\n            caseJ_KJ.remove(caseJ_KJ.size() - 1);\r\n            break;\r\n        case \"e\":\r\n            caseet_RS.remove(caseet_RS.size() - 1);\r\n            caseec_RU.remove(caseet_RS.size() - 1);\r\n            break;\r\n        case \"s\":\r\n            cases_RU.remove(cases_RU.size() - 1);\r\n            break;\r\n        case \"[\":\r\n            final int arraySize \u003d casearray_N.remove(casearray_N.size() - 1);\r\n            numBackwardsCalls -\u003d arraySize;\r\n            for (int k \u003d 0; k \u003c arraySize; k++) {\r\n                removeOnePair();\r\n            }\r\n            break;\r\n        case \"@\":\r\n            nesttype_RS.remove(nesttype_RS.size() - 1);\r\n            final int numPairs \u003d nestpair_N.remove(nestpair_N.size() - 1);\r\n            numBackwardsCalls -\u003d numPairs;\r\n            for (int i \u003d 0; i \u003c numPairs; i++) {\r\n                removeOnePair();\r\n            }\r\n            break;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttribute",
    "methodName": "addContext",
    "signature": "void addContext(int)",
    "visibility": "public",
    "body": "{\r\n    switch(context) {\r\n        case AttributeDefinitionBands.CONTEXT_CLASS:\r\n            contextClass \u003d true;\r\n            break;\r\n        case AttributeDefinitionBands.CONTEXT_METHOD:\r\n            contextMethod \u003d true;\r\n            break;\r\n        case AttributeDefinitionBands.CONTEXT_FIELD:\r\n            contextField \u003d true;\r\n            break;\r\n        case AttributeDefinitionBands.CONTEXT_CODE:\r\n            contextCode \u003d true;\r\n            break;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 9,
    "cc": 5,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  NewAttribute\n  i0 :\u003d @parameter0: int\n  NewAttribute: boolean contextCode\u003e \u003d 1;     default: goto return; }\n}",
      "B1 {\n  NewAttribute: boolean contextClass\u003e \u003d 1\n  goto B5\n}",
      "B2 {\n  NewAttribute: boolean contextMethod\u003e \u003d 1\n  goto B5\n}",
      "B3 {\n  NewAttribute: boolean contextField\u003e \u003d 1\n  goto B5\n}",
      "B4 {\n  NewAttribute: boolean contextCode\u003e \u003d 1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B0 --\u003e B2",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B1 --\u003e B5",
      "B2 --\u003e B5",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttribute",
    "methodName": "isCodeAttribute",
    "signature": "boolean isCodeAttribute()",
    "visibility": "public",
    "body": "{\r\n    return codeOff !\u003d -1;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NewAttribute\n  $i0 \u003d NewAttribute: int codeOff\u003e\n  $i2 \u003d (int) -1\n  if ($i0 \u003d\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttribute",
    "methodName": "isUnknown",
    "signature": "boolean isUnknown(int)",
    "visibility": "public",
    "body": "{\r\n    switch(context) {\r\n        case AttributeDefinitionBands.CONTEXT_CLASS:\r\n            return !contextClass;\r\n        case AttributeDefinitionBands.CONTEXT_METHOD:\r\n            return !contextMethod;\r\n        case AttributeDefinitionBands.CONTEXT_FIELD:\r\n            return !contextField;\r\n        case AttributeDefinitionBands.CONTEXT_CODE:\r\n            return !contextCode;\r\n    }\r\n    return false;\r\n}",
    "nodes": 18,
    "edges": 21,
    "cc": 5,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B9",
      "B1 : If($z3 !\u003d 0) → B2 | else → B3",
      "B5 : If($z1 !\u003d 0) → B6 | else → B7",
      "B9 : If($z2 !\u003d 0) → B10 | else → B11",
      "B13 : If($z0 !\u003d 0) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  NewAttribute\n  i0 :\u003d @parameter0: int\n  NewAttribute: boolean contextCode\u003e;     default: goto return 0; }\n}",
      "B1 {\n  $z3 \u003d NewAttribute: boolean contextClass\u003e\n  if ($z3 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z4 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z4 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z1 \u003d NewAttribute: boolean contextMethod\u003e\n  if ($z1 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $z5 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z5 \u003d 0\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $z2 \u003d NewAttribute: boolean contextField\u003e\n  if ($z2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $z6 \u003d 1\n  goto B12\n}",
      "B11 {\n  $z6 \u003d 0\n}",
      "B12 {\n  return\n}",
      "B13 {\n  $z0 \u003d NewAttribute: boolean contextCode\u003e\n  if ($z0 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  $z7 \u003d 1\n  goto B16\n}",
      "B15 {\n  $z7 \u003d 0\n}",
      "B16 {\n  return\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B9",
      "B0 --\u003e B5",
      "B0 --\u003e B13",
      "B0 --\u003e B17",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttributeBands",
    "methodName": "addAttribute",
    "signature": "void addAttribute(org.apache.commons.compress.harmony.pack200.NewAttribute)",
    "visibility": "public",
    "body": "{\r\n    usedAtLeastOnce \u003d true;\r\n    final InputStream stream \u003d new ByteArrayInputStream(attribute.getBytes());\r\n    for (final AttributeLayoutElement attributeLayoutElement : attributeLayoutElements) {\r\n        attributeLayoutElement.addAttributeToBand(attribute, stream);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  NewAttribute\n  NewAttributeBands: boolean usedAtLeastOnce\u003e \u003d 1\n  $r1 \u003d ByteArrayInputStream\n  $r3 \u003d r2.getBytes()\n  new ByteArrayInputStream($r3)\n  $r4 \u003d List attributeLayoutElements\u003e\n  r5 \u003d $r4.iterator()\n}",
      "B1 {\n  $z0 \u003d r5.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d r5.next()\n  r7 \u003d NewAttributeBands$AttributeLayoutElement) $r6\n  r7.addAttributeToBand(r2, $r1)\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttributeBands",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    for (final AttributeLayoutElement attributeLayoutElement : attributeLayoutElements) {\r\n        attributeLayoutElement.pack(outputStream);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  OutputStream\n  $r1 \u003d List attributeLayoutElements\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d NewAttributeBands$AttributeLayoutElement) $r3\n  r4.pack(r5)\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.NewAttributeBands",
    "methodName": "renumberBci",
    "signature": "void renumberBci(org.apache.commons.compress.harmony.pack200.IntList,java.util.Map)",
    "visibility": "public",
    "body": "{\r\n    for (final AttributeLayoutElement attributeLayoutElement : attributeLayoutElements) {\r\n        attributeLayoutElement.renumberBci(bciRenumbering, labelsToOffsets);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  IntList\n  Map\n  $r1 \u003d List attributeLayoutElements\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d NewAttributeBands$AttributeLayoutElement) $r3\n  r4.renumberBci(r5, r6)\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Pack200ClassReader",
    "methodName": "readConst",
    "signature": "java.lang.Object readConst(int,char[])",
    "visibility": "public",
    "body": "{\r\n    lastConstantHadWideIndex \u003d item \u003d\u003d lastUnsignedShort;\r\n    return super.readConst(item, buf);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Pack200ClassReader\n  i0 :\u003d @parameter0: int\n  r1 :\u003d @parameter1: char[]\n  $i1 \u003d Pack200ClassReader: int lastUnsignedShort\u003e\n  if (i0 !\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  Pack200ClassReader: boolean lastConstantHadWideIndex\u003e \u003d $z0\n  $r2 \u003d r0.readConst(i0, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Pack200ClassReader",
    "methodName": "readUnsignedShort",
    "signature": "int readUnsignedShort(int)",
    "visibility": "public",
    "body": "{\r\n    // Doing this to check whether last load-constant instruction was ldc (18) or ldc_w (19)\r\n    // TODO: Assess whether this impacts on performance\r\n    final int unsignedShort \u003d super.readUnsignedShort(index);\r\n    if (index \u003e 0 \u0026\u0026 b[index - 1] \u003d\u003d 19) {\r\n        lastUnsignedShort \u003d unsignedShort;\r\n    } else {\r\n        lastUnsignedShort \u003d Short.MIN_VALUE;\r\n    }\r\n    return unsignedShort;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($i4 !\u003d 19) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Pack200ClassReader\n  i0 :\u003d @parameter0: int\n  i1 \u003d r0.readUnsignedShort(i0)\n  if (i0 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r1 \u003d Pack200ClassReader: byte[] b\u003e\n  $i2 \u003d i0 - 1\n  $b3 \u003d $r1[$i2]\n  $i4 \u003d (int) $b3\n  if ($i4 !\u003d 19) goto B2 else B3\n}",
      "B2 {\n  Pack200ClassReader: int lastUnsignedShort\u003e \u003d i1\n  goto B4\n}",
      "B3 {\n  $i6 \u003d (int) -32768\n  Pack200ClassReader: int lastUnsignedShort\u003e \u003d $i6\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Pack200ClassReader",
    "methodName": "readUTF8",
    "signature": "java.lang.String readUTF8(int,char[])",
    "visibility": "public",
    "body": "{\r\n    final String utf8 \u003d super.readUTF8(arg0, arg1);\r\n    if (!anySyntheticAttributes \u0026\u0026 \"Synthetic\".equals(utf8)) {\r\n        anySyntheticAttributes \u003d true;\r\n    }\r\n    return utf8;\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Pack200ClassReader\n  i0 :\u003d @parameter0: int\n  r1 :\u003d @parameter1: char[]\n  r2 \u003d r0.readUTF8(i0, r1)\n  $z0 \u003d Pack200ClassReader: boolean anySyntheticAttributes\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d \"Synthetic\"\n  $z1 \u003d $r3.equals(r2)\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  Pack200ClassReader: boolean anySyntheticAttributes\u003e \u003d 1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Pack200PackerAdapter",
    "methodName": "pack",
    "signature": "void pack(java.util.jar.JarFile,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    if (file \u003d\u003d null || out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify both input and output streams\");\r\n    }\r\n    completed(0);\r\n    try {\r\n        new Archive(file, out, options).pack();\r\n    } catch (final Pack200Exception e) {\r\n        throw new IOException(\"Failed to pack Jar:\" + e);\r\n    }\r\n    completed(1);\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Pack200PackerAdapter\n  JarFile\n  OutputStream\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must specify both input and output streams\")\n  throw $r1\n}",
      "B3 {\n  r3.completed(0.0)\n  $r4 \u003d Archive\n  $r5 \u003d PackingOptions options\u003e\n  new Archive(r0, r2, $r5)\n  $r4.pack()\n  goto B5\n}",
      "B4 {\n  $r6 :\u003d @caughtexception\n  $r7 \u003d IOException\n  $r8 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r8.append(\"Failed to pack Jar:\")\n  $r10 \u003d $r9.append($r6)\n  $r11 \u003d $r10.toString()\n  new IOException($r11)\n  throw $r7\n}",
      "B5 {\n  r3.completed(1.0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Pack200PackerAdapter#completed(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Pack200PackerAdapter",
    "methodName": "pack",
    "signature": "void pack(java.util.jar.JarInputStream,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    if (in \u003d\u003d null || out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify both input and output streams\");\r\n    }\r\n    completed(0);\r\n    final PackingOptions options \u003d new PackingOptions();\r\n    try {\r\n        new Archive(in, out, options).pack();\r\n    } catch (final Pack200Exception e) {\r\n        throw new IOException(\"Failed to pack Jar:\" + e);\r\n    }\r\n    completed(1);\r\n    in.close();\r\n}",
    "nodes": 6,
    "edges": 5,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If(r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Pack200PackerAdapter\n  JarInputStream\n  OutputStream\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  if (r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must specify both input and output streams\")\n  throw $r1\n}",
      "B3 {\n  r3.completed(0.0)\n  $r4 \u003d PackingOptions\n  new PackingOptions()\n  $r5 \u003d Archive\n  new Archive(r0, r2, $r4)\n  $r5.pack()\n  goto B5\n}",
      "B4 {\n  $r6 :\u003d @caughtexception\n  $r7 \u003d IOException\n  $r8 \u003d StringBuilder\n  new StringBuilder()\n  $r9 \u003d $r8.append(\"Failed to pack Jar:\")\n  $r10 \u003d $r9.append($r6)\n  $r11 \u003d $r10.toString()\n  new IOException($r11)\n  throw $r7\n}",
      "B5 {\n  r3.completed(1.0)\n  r0.close()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Pack200PackerAdapter#completed(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "addPassFile",
    "signature": "void addPassFile(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    String fileSeparator \u003d FileSystems.getDefault().getSeparator();\r\n    if (fileSeparator.equals(\"\\\\\")) {\r\n        // Need to escape backslashes for replaceAll(), which uses regex\r\n        fileSeparator +\u003d \"\\\\\";\r\n    }\r\n    passFiles.add(passFileName.replaceAll(fileSeparator, \"/\"));\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  String\n  $r0 \u003d FileSystems.getDefault()\n  r8 \u003d $r0.getSeparator()\n  $z0 \u003d r8.equals(\"\\\\\")\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r5.append(r8)\n  $r7 \u003d $r6.append(\"\\\\\")\n  r8 \u003d $r7.toString()\n}",
      "B2 {\n  $r3 \u003d List passFiles\u003e\n  $r4 \u003d r2.replaceAll(r8, \"/\")\n  $r3.add($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "getUnknownAttributePrototypes",
    "signature": "org.objectweb.asm.Attribute[] getUnknownAttributePrototypes()",
    "visibility": "public",
    "body": "{\r\n    if (unknownAttributeTypes \u003d\u003d null) {\r\n        final List\u003cAttribute\u003e prototypes \u003d new ArrayList\u003c\u003e();\r\n        addOrUpdateAttributeActions(prototypes, classAttributeActions, AttributeDefinitionBands.CONTEXT_CLASS);\r\n        addOrUpdateAttributeActions(prototypes, methodAttributeActions, AttributeDefinitionBands.CONTEXT_METHOD);\r\n        addOrUpdateAttributeActions(prototypes, fieldAttributeActions, AttributeDefinitionBands.CONTEXT_FIELD);\r\n        addOrUpdateAttributeActions(prototypes, codeAttributeActions, AttributeDefinitionBands.CONTEXT_CODE);\r\n        unknownAttributeTypes \u003d prototypes.toArray(EMPTY_ATTRIBUTE_ARRAY);\r\n    }\r\n    return unknownAttributeTypes;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  $r1 \u003d Attribute[] unknownAttributeTypes\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ArrayList\n  new ArrayList()\n  $r4 \u003d Map classAttributeActions\u003e\n  r0.addOrUpdateAttributeActions($r3, $r4, 0)\n  $r5 \u003d Map methodAttributeActions\u003e\n  r0.addOrUpdateAttributeActions($r3, $r5, 2)\n  $r6 \u003d Map fieldAttributeActions\u003e\n  r0.addOrUpdateAttributeActions($r3, $r6, 1)\n  $r7 \u003d Map codeAttributeActions\u003e\n  r0.addOrUpdateAttributeActions($r3, $r7, 3)\n  $r8 \u003d Attribute[] EMPTY_ATTRIBUTE_ARRAY\u003e\n  $r9 \u003d $r3.toArray($r8)\n  $r10 \u003d Attribute[]) $r9\n  Attribute[] unknownAttributeTypes\u003e \u003d $r10\n}",
      "B2 {\n  $r2 \u003d Attribute[] unknownAttributeTypes\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PackingOptions#addOrUpdateAttributeActions(...3)",
        "body": "{\r\n    if (attributeActions !\u003d null \u0026\u0026 attributeActions.size() \u003e 0) {\r\n        NewAttribute newAttribute;\r\n        for (final Entry\u003cString, String\u003e entry : attributeActions.entrySet()) {\r\n            final String name \u003d entry.getKey();\r\n            final String action \u003d entry.getValue();\r\n            boolean prototypeExists \u003d false;\r\n            for (final Object prototype : prototypes) {\r\n                newAttribute \u003d (NewAttribute) prototype;\r\n                if (newAttribute.type.equals(name)) {\r\n                    // if the attribute exists, update its context\r\n                    newAttribute.addContext(tag);\r\n                    prototypeExists \u003d true;\r\n                    break;\r\n                }\r\n            }\r\n            // if no attribute is found, add a new attribute\r\n            if (!prototypeExists) {\r\n                switch(action) {\r\n                    case ERROR:\r\n                        newAttribute \u003d new NewAttribute.ErrorAttribute(name, tag);\r\n                        break;\r\n                    case STRIP:\r\n                        newAttribute \u003d new NewAttribute.StripAttribute(name, tag);\r\n                        break;\r\n                    case PASS:\r\n                        newAttribute \u003d new NewAttribute.PassAttribute(name, tag);\r\n                        break;\r\n                    default:\r\n                        newAttribute \u003d new NewAttribute(name, action, tag);\r\n                        break;\r\n                }\r\n                prototypes.add(newAttribute);\r\n            }\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "isPassFile",
    "signature": "boolean isPassFile(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    for (String pass : passFiles) {\r\n        if (passFileName.equals(pass)) {\r\n            return true;\r\n        }\r\n        if (!pass.endsWith(\".class\")) {\r\n            // a whole directory is\r\n            // passed\r\n            if (!pass.endsWith(\"/\")) {\r\n                // Make sure we don\u0027t get any false positives (for example\r\n                // exclude \"org/apache/harmony/pack\" should not match\r\n                // files under \"org/apache/harmony/pack200/\")\r\n                pass +\u003d \"/\";\r\n            }\r\n            return passFileName.startsWith(pass);\r\n        }\r\n    }\r\n    return false;\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B9",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 !\u003d 0) → B5 | else → B8",
      "B5 : If($z3 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  String\n  $r1 \u003d List passFiles\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B9\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r8 \u003d String) $r3\n  $z1 \u003d r4.equals(r8)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z2 \u003d r8.endsWith(\".class\")\n  if ($z2 !\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $z3 \u003d r8.endsWith(\"/\")\n  if ($z3 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r5.append(r8)\n  $r7 \u003d $r6.append(\"/\")\n  r8 \u003d $r7.toString()\n}",
      "B7 {\n  $z4 \u003d r4.startsWith(r8)\n  return\n}",
      "B8 {\n  goto B1\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B1",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "setDeflateHint",
    "signature": "void setDeflateHint(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!KEEP.equals(deflateHint) \u0026\u0026 !\"true\".equals(deflateHint) \u0026\u0026 !\"false\".equals(deflateHint)) {\r\n        throw new IllegalArgumentException(\"Bad argument: -H \" + deflateHint + \" ? deflate hint should be either true, false or keep (default)\");\r\n    }\r\n    this.deflateHint \u003d deflateHint;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B4",
      "B2 : If($z2 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  String\n  $r1 \u003d \"keep\"\n  $z0 \u003d $r1.equals(r0)\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d \"true\"\n  $z1 \u003d $r3.equals(r0)\n  if ($z1 !\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $r4 \u003d \"false\"\n  $z2 \u003d $r4.equals(r0)\n  if ($z2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"Bad argument: -H \")\n  $r8 \u003d $r7.append(r0)\n  $r9 \u003d $r8.append(\" ? deflate hint should be either true, false or keep (default)\")\n  $r10 \u003d $r9.toString()\n  new IllegalArgumentException($r10)\n  throw $r5\n}",
      "B4 {\n  String deflateHint\u003e \u003d r0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "setModificationTime",
    "signature": "void setModificationTime(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!KEEP.equals(modificationTime) \u0026\u0026 !\"latest\".equals(modificationTime)) {\r\n        throw new IllegalArgumentException(\"Bad argument: -m \" + modificationTime + \" ? transmit modtimes should be either latest or keep (default)\");\r\n    }\r\n    this.modificationTime \u003d modificationTime;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  String\n  $r1 \u003d \"keep\"\n  $z0 \u003d $r1.equals(r0)\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d \"latest\"\n  $z1 \u003d $r3.equals(r0)\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d IllegalArgumentException\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r5.append(\"Bad argument: -m \")\n  $r7 \u003d $r6.append(r0)\n  $r8 \u003d $r7.append(\" ? transmit modtimes should be either latest or keep (default)\")\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r4\n}",
      "B3 {\n  String modificationTime\u003e \u003d r0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "setQuiet",
    "signature": "void setQuiet(boolean)",
    "visibility": "public",
    "body": "{\r\n    this.verbose \u003d !quiet;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  PackingOptions: boolean verbose\u003e \u003d $z1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingOptions",
    "methodName": "setUnknownAttributeAction",
    "signature": "void setUnknownAttributeAction(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    this.unknownAttributeAction \u003d unknownAttributeAction;\r\n    if (!PASS.equals(unknownAttributeAction) \u0026\u0026 !ERROR.equals(unknownAttributeAction) \u0026\u0026 !STRIP.equals(unknownAttributeAction)) {\r\n        throw new IllegalArgumentException(\"Incorrect option for -U, \" + unknownAttributeAction);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B4",
      "B2 : If($z2 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  String\n  String unknownAttributeAction\u003e \u003d r1\n  $r2 \u003d \"pass\"\n  $z0 \u003d $r2.equals(r1)\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d \"error\"\n  $z1 \u003d $r3.equals(r1)\n  if ($z1 !\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $r4 \u003d \"strip\"\n  $z2 \u003d $r4.equals(r1)\n  if ($z2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"Incorrect option for -U, \")\n  $r8 \u003d $r7.append(r1)\n  $r9 \u003d $r8.toString()\n  new IllegalArgumentException($r9)\n  throw $r5\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingUtils",
    "methodName": "config",
    "signature": "void config(org.apache.commons.compress.harmony.pack200.PackingOptions)",
    "visibility": "public",
    "body": "{\r\n    final String logFileName \u003d options !\u003d null ? options.getLogFile() : null;\r\n    if (fileHandler !\u003d null) {\r\n        fileHandler.close();\r\n    }\r\n    if (logFileName !\u003d null) {\r\n        fileHandler \u003d new FileHandler(logFileName, false);\r\n        fileHandler.setFormatter(new SimpleFormatter());\r\n        packingLogger.addHandler(fileHandler);\r\n        packingLogger.setUseParentHandlers(false);\r\n    }\r\n    if (options !\u003d null) {\r\n        packingLogger.setVerbose(options.isVerbose());\r\n    }\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(r1 \u003d\u003d null) → B6 | else → B7",
      "B7 : If(r0 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  PackingOptions\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d r0.getLogFile()\n  goto B3\n}",
      "B2 {\n  $r11 \u003d null\n}",
      "B3 {\n  r1 \u003d $r11\n  $r2 \u003d FileHandler fileHandler\u003e\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r10 \u003d FileHandler fileHandler\u003e\n  $r10.close()\n}",
      "B5 {\n  if (r1 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d FileHandler\n  new FileHandler(r1, 0)\n  FileHandler fileHandler\u003e \u003d $r4\n  $r6 \u003d FileHandler fileHandler\u003e\n  $r5 \u003d SimpleFormatter\n  new SimpleFormatter()\n  $r6.setFormatter($r5)\n  $r8 \u003d PackingUtils$PackingLogger packingLogger\u003e\n  $r7 \u003d FileHandler fileHandler\u003e\n  $r8.addHandler($r7)\n  $r9 \u003d PackingUtils$PackingLogger packingLogger\u003e\n  $r9.setUseParentHandlers(0)\n}",
      "B7 {\n  if (r0 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r3 \u003d PackingUtils$PackingLogger packingLogger\u003e\n  $z0 \u003d r0.isVerbose()\n  PackingUtils$PackingLogger.access$000($r3, $z0)\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingUtils",
    "methodName": "copyThroughJar",
    "signature": "void copyThroughJar(java.util.jar.JarFile,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    try (JarOutputStream jarOutputStream \u003d new JarOutputStream(outputStream)) {\r\n        jarOutputStream.setComment(\"PACK200\");\r\n        final byte[] bytes \u003d new byte[16384];\r\n        final Enumeration\u003cJarEntry\u003e entries \u003d jarFile.entries();\r\n        while (entries.hasMoreElements()) {\r\n            final JarEntry jarEntry \u003d entries.nextElement();\r\n            jarOutputStream.putNextEntry(jarEntry);\r\n            try (InputStream inputStream \u003d jarFile.getInputStream(jarEntry)) {\r\n                int bytesRead;\r\n                while ((bytesRead \u003d inputStream.read(bytes)) !\u003d -1) {\r\n                    jarOutputStream.write(bytes, 0, bytesRead);\r\n                }\r\n                jarOutputStream.closeEntry();\r\n                log(\"Packed \" + jarEntry.getName());\r\n            }\r\n        }\r\n        jarFile.close();\r\n    }\r\n}",
    "nodes": 17,
    "edges": 18,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B12",
      "B3 : If($i0 \u003d\u003d $i2) → B4 | else → B5",
      "B5 : If(r5 \u003d\u003d null) → B6 | else → B11",
      "B7 : If(r5 \u003d\u003d null) → B8 | else → B10"
    ],
    "blockList": [
      "B0 {\n  JarFile\n  OutputStream\n  $r17 \u003d JarOutputStream\n  new JarOutputStream(r1)\n  $r17.setComment(\"PACK200\")\n  r15 \u003d newarray (byte)[16384]\n  r16 \u003d r2.entries()\n}",
      "B1 {\n  $z0 \u003d r16.hasMoreElements()\n  if ($z0 \u003d\u003d false) goto B2 else B12\n}",
      "B2 {\n  $r3 \u003d r16.nextElement()\n  r4 \u003d JarEntry) $r3\n  $r17.putNextEntry(r4)\n  r5 \u003d r2.getInputStream(r4)\n}",
      "B3 {\n  $i0 \u003d r5.read(r15)\n  $i2 \u003d (int) -1\n  if ($i0 \u003d\u003d $i2) goto B4 else B5\n}",
      "B4 {\n  $r17.write(r15, 0, $i0)\n  goto B3\n}",
      "B5 {\n  $r17.closeEntry()\n  $r18 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r18.append(\"Packed \")\n  $r7 \u003d r4.getName()\n  $r9 \u003d $r8.append($r7)\n  $r10 \u003d $r9.toString()\n  PackingUtils.log($r10)\n  if (r5 \u003d\u003d null) goto B6 else B11\n}",
      "B6 {\n  r5.close()\n  goto B11\n}",
      "B7 {\n  $r14 :\u003d @caughtexception\n  if (r5 \u003d\u003d null) goto B8 else B10\n}",
      "B8 {\n  r5.close()\n  goto B10\n}",
      "B9 {\n  $r13 :\u003d @caughtexception\n  $r14.addSuppressed($r13)\n}",
      "B10 {\n  throw $r14\n}",
      "B11 {\n  goto B1\n}",
      "B12 {\n  r2.close()\n  $r17.close()\n  goto B16\n}",
      "B13 {\n  $r12 :\u003d @caughtexception\n  $r17.close()\n  goto B15\n}",
      "B14 {\n  $r11 :\u003d @caughtexception\n  $r12.addSuppressed($r11)\n}",
      "B15 {\n  throw $r12\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B1",
      "B12 --\u003e B16",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PackingUtils#log(...1)",
        "body": "{\r\n    packingLogger.log(Level.INFO, message);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingUtils",
    "methodName": "copyThroughJar",
    "signature": "void copyThroughJar(java.util.jar.JarInputStream,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    final Manifest manifest \u003d jarInputStream.getManifest();\r\n    try (JarOutputStream jarOutputStream \u003d new JarOutputStream(outputStream, manifest)) {\r\n        jarOutputStream.setComment(\"PACK200\");\r\n        log(\"Packed \" + JarFile.MANIFEST_NAME);\r\n        final byte[] bytes \u003d new byte[16384];\r\n        JarEntry jarEntry;\r\n        int bytesRead;\r\n        while ((jarEntry \u003d jarInputStream.getNextJarEntry()) !\u003d null) {\r\n            jarOutputStream.putNextEntry(jarEntry);\r\n            while ((bytesRead \u003d jarInputStream.read(bytes)) !\u003d -1) {\r\n                jarOutputStream.write(bytes, 0, bytesRead);\r\n            }\r\n            log(\"Packed \" + jarEntry.getName());\r\n        }\r\n        jarInputStream.close();\r\n    }\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B1 : If($r4 \u003d\u003d null) → B2 | else → B6",
      "B3 : If($i0 \u003d\u003d $i2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JarInputStream\n  OutputStream\n  r1 \u003d r0.getManifest()\n  $r13 \u003d JarOutputStream\n  new JarOutputStream(r3, r1)\n  $r13.setComment(\"PACK200\")\n  PackingUtils.log(\"Packed META-INF/MANIFEST.MF\")\n  r12 \u003d newarray (byte)[16384]\n}",
      "B1 {\n  $r4 \u003d r0.getNextJarEntry()\n  if ($r4 \u003d\u003d null) goto B2 else B6\n}",
      "B2 {\n  $r13.putNextEntry($r4)\n}",
      "B3 {\n  $i0 \u003d r0.read(r12)\n  $i2 \u003d (int) -1\n  if ($i0 \u003d\u003d $i2) goto B4 else B5\n}",
      "B4 {\n  $r13.write(r12, 0, $i0)\n  goto B3\n}",
      "B5 {\n  $r14 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r14.append(\"Packed \")\n  $r6 \u003d $r4.getName()\n  $r8 \u003d $r7.append($r6)\n  $r9 \u003d $r8.toString()\n  PackingUtils.log($r9)\n  goto B1\n}",
      "B6 {\n  r0.close()\n  $r13.close()\n  goto B10\n}",
      "B7 {\n  $r11 :\u003d @caughtexception\n  $r13.close()\n  goto B9\n}",
      "B8 {\n  $r10 :\u003d @caughtexception\n  $r11.addSuppressed($r10)\n}",
      "B9 {\n  throw $r11\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B1",
      "B6 --\u003e B10",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PackingUtils#log(...1)",
        "body": "{\r\n    packingLogger.log(Level.INFO, message);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingUtils",
    "methodName": "getPackingFileListFromJar",
    "signature": "java.util.List getPackingFileListFromJar(java.util.jar.JarFile,boolean)",
    "visibility": "public",
    "body": "{\r\n    final List\u003cPackingFile\u003e packingFileList \u003d new ArrayList\u003c\u003e();\r\n    final Enumeration\u003cJarEntry\u003e jarEntries \u003d jarFile.entries();\r\n    while (jarEntries.hasMoreElements()) {\r\n        final JarEntry jarEntry \u003d jarEntries.nextElement();\r\n        try (InputStream inputStream \u003d jarFile.getInputStream(jarEntry)) {\r\n            final byte[] bytes \u003d readJarEntry(jarEntry, new BufferedInputStream(inputStream));\r\n            packingFileList.add(new PackingFile(bytes, jarEntry));\r\n        }\r\n    }\r\n    // check whether it need reorder packing file list\r\n    if (!keepFileOrder) {\r\n        reorderPackingFiles(packingFileList);\r\n    }\r\n    return packingFileList;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B9",
      "B2 : If(r5 \u003d\u003d null) → B3 | else → B8",
      "B4 : If(r5 \u003d\u003d null) → B5 | else → B7",
      "B9 : If(z1 !\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  JarFile\n  z1 :\u003d @parameter1: boolean\n  $r0 \u003d ArrayList\n  new ArrayList()\n  r2 \u003d r1.entries()\n}",
      "B1 {\n  $z0 \u003d r2.hasMoreElements()\n  if ($z0 \u003d\u003d false) goto B2 else B9\n}",
      "B2 {\n  $r3 \u003d r2.nextElement()\n  r4 \u003d JarEntry) $r3\n  r5 \u003d r1.getInputStream(r4)\n  $r6 \u003d BufferedInputStream\n  new BufferedInputStream(r5)\n  r10 \u003d PackingUtils.readJarEntry(r4, $r6)\n  $r7 \u003d Archive$PackingFile\n  new Archive$PackingFile(r10, r4)\n  $r0.add($r7)\n  if (r5 \u003d\u003d null) goto B3 else B8\n}",
      "B3 {\n  r5.close()\n  goto B8\n}",
      "B4 {\n  $r9 :\u003d @caughtexception\n  if (r5 \u003d\u003d null) goto B5 else B7\n}",
      "B5 {\n  r5.close()\n  goto B7\n}",
      "B6 {\n  $r8 :\u003d @caughtexception\n  $r9.addSuppressed($r8)\n}",
      "B7 {\n  throw $r9\n}",
      "B8 {\n  goto B1\n}",
      "B9 {\n  if (z1 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  PackingUtils.reorderPackingFiles($r0)\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B1",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PackingUtils#readJarEntry(...2)",
        "body": "{\r\n    long size \u003d jarEntry.getSize();\r\n    if (size \u003e Integer.MAX_VALUE) {\r\n        // TODO: Should probably allow this\r\n        throw new IllegalArgumentException(\"Large Class!\");\r\n    }\r\n    if (size \u003c 0) {\r\n        size \u003d 0;\r\n    }\r\n    final byte[] bytes \u003d new byte[(int) size];\r\n    if (inputStream.read(bytes) !\u003d size) {\r\n        throw new IllegalArgumentException(\"Error reading from stream\");\r\n    }\r\n    return bytes;\r\n}"
      },
      {
        "name": "PackingUtils#reorderPackingFiles(...1)",
        "body": "{\r\n    final Iterator\u003cPackingFile\u003e iterator \u003d packingFileList.iterator();\r\n    while (iterator.hasNext()) {\r\n        final PackingFile packingFile \u003d iterator.next();\r\n        if (packingFile.isDirectory()) {\r\n            // remove directory entries\r\n            iterator.remove();\r\n        }\r\n    }\r\n    // Sort files by name, \"META-INF/MANIFEST.MF\" should be put in the 1st\r\n    // position\r\n    packingFileList.sort((arg0, arg1) -\u003e {\r\n        final String fileName0 \u003d arg0.getName();\r\n        final String fileName1 \u003d arg1.getName();\r\n        if (fileName0.equals(fileName1)) {\r\n            return 0;\r\n        }\r\n        if (JarFile.MANIFEST_NAME.equals(fileName0)) {\r\n            return -1;\r\n        }\r\n        if (JarFile.MANIFEST_NAME.equals(fileName1)) {\r\n            return 1;\r\n        }\r\n        return fileName0.compareTo(fileName1);\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PackingUtils",
    "methodName": "getPackingFileListFromJar",
    "signature": "java.util.List getPackingFileListFromJar(java.util.jar.JarInputStream,boolean)",
    "visibility": "public",
    "body": "{\r\n    final List\u003cPackingFile\u003e packingFileList \u003d new ArrayList\u003c\u003e();\r\n    // add manifest file\r\n    final Manifest manifest \u003d jarInputStream.getManifest();\r\n    if (manifest !\u003d null) {\r\n        final ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\r\n        manifest.write(baos);\r\n        packingFileList.add(new PackingFile(JarFile.MANIFEST_NAME, baos.toByteArray(), 0));\r\n    }\r\n    // add rest of entries in the jar\r\n    JarEntry jarEntry;\r\n    byte[] bytes;\r\n    while ((jarEntry \u003d jarInputStream.getNextJarEntry()) !\u003d null) {\r\n        bytes \u003d readJarEntry(jarEntry, new BufferedInputStream(jarInputStream));\r\n        packingFileList.add(new PackingFile(bytes, jarEntry));\r\n    }\r\n    // check whether it need reorder packing file list\r\n    if (!keepFileOrder) {\r\n        reorderPackingFiles(packingFileList);\r\n    }\r\n    return packingFileList;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r9 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(z0 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JarInputStream\n  z0 :\u003d @parameter1: boolean\n  $r0 \u003d ArrayList\n  new ArrayList()\n  r2 \u003d r1.getManifest()\n  if (r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n  r2.write($r6)\n  $r7 \u003d Archive$PackingFile\n  $r8 \u003d $r6.toByteArray()\n  new Archive$PackingFile(\"META-INF/MANIFEST.MF\", $r8, 0L)\n  $r0.add($r7)\n}",
      "B2 {\n  $r9 \u003d r1.getNextJarEntry()\n  if ($r9 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d BufferedInputStream\n  new BufferedInputStream(r1)\n  r4 \u003d PackingUtils.readJarEntry($r9, $r3)\n  $r5 \u003d Archive$PackingFile\n  new Archive$PackingFile(r4, $r9)\n  $r0.add($r5)\n  goto B2\n}",
      "B4 {\n  if (z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  PackingUtils.reorderPackingFiles($r0)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PackingUtils#readJarEntry(...2)",
        "body": "{\r\n    long size \u003d jarEntry.getSize();\r\n    if (size \u003e Integer.MAX_VALUE) {\r\n        // TODO: Should probably allow this\r\n        throw new IllegalArgumentException(\"Large Class!\");\r\n    }\r\n    if (size \u003c 0) {\r\n        size \u003d 0;\r\n    }\r\n    final byte[] bytes \u003d new byte[(int) size];\r\n    if (inputStream.read(bytes) !\u003d size) {\r\n        throw new IllegalArgumentException(\"Error reading from stream\");\r\n    }\r\n    return bytes;\r\n}"
      },
      {
        "name": "PackingUtils#reorderPackingFiles(...1)",
        "body": "{\r\n    final Iterator\u003cPackingFile\u003e iterator \u003d packingFileList.iterator();\r\n    while (iterator.hasNext()) {\r\n        final PackingFile packingFile \u003d iterator.next();\r\n        if (packingFile.isDirectory()) {\r\n            // remove directory entries\r\n            iterator.remove();\r\n        }\r\n    }\r\n    // Sort files by name, \"META-INF/MANIFEST.MF\" should be put in the 1st\r\n    // position\r\n    packingFileList.sort((arg0, arg1) -\u003e {\r\n        final String fileName0 \u003d arg0.getName();\r\n        final String fileName1 \u003d arg1.getName();\r\n        if (fileName0.equals(fileName1)) {\r\n            return 0;\r\n        }\r\n        if (JarFile.MANIFEST_NAME.equals(fileName0)) {\r\n            return -1;\r\n        }\r\n        if (JarFile.MANIFEST_NAME.equals(fileName1)) {\r\n            return 1;\r\n        }\r\n        return fileName0.compareTo(fileName1);\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.PopulationCodec",
    "methodName": "decodeInts",
    "signature": "int[] decodeInts(int,java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    lastBandLength \u003d 0;\r\n    // there must be \u003c\u003d n values, but probably a lot\r\n    favoured \u003d new int[check(n, in)];\r\n    // less\r\n    final int[] result;\r\n    // read table of favorites first\r\n    int smallest \u003d Integer.MAX_VALUE;\r\n    int absoluteSmallest;\r\n    int last \u003d 0;\r\n    int value \u003d 0;\r\n    int absoluteValue;\r\n    int k \u003d -1;\r\n    while (true) {\r\n        value \u003d favouredCodec.decode(in, last);\r\n        if (k \u003e -1 \u0026\u0026 (value \u003d\u003d smallest || value \u003d\u003d last)) {\r\n            break;\r\n        }\r\n        favoured[++k] \u003d value;\r\n        absoluteSmallest \u003d Math.abs(smallest);\r\n        absoluteValue \u003d Math.abs(value);\r\n        if (absoluteSmallest \u003e absoluteValue) {\r\n            smallest \u003d value;\r\n        } else if (absoluteSmallest \u003d\u003d absoluteValue) {\r\n            // ensure that -X and +X -\u003e +X\r\n            smallest \u003d absoluteSmallest;\r\n        }\r\n        last \u003d value;\r\n    }\r\n    lastBandLength +\u003d k;\r\n    // if tokenCodec needs to be derived from the T, L and K values\r\n    if (tokenCodec \u003d\u003d null) {\r\n        if (k \u003c 256) {\r\n            tokenCodec \u003d BYTE1;\r\n        } else {\r\n            // if k \u003e\u003d 256, b \u003e\u003d 2\r\n            int b \u003d 1;\r\n            BHSDCodec codec;\r\n            while (++b \u003c 5) {\r\n                codec \u003d new BHSDCodec(b, 256 - l, 0);\r\n                if (codec.encodes(k)) {\r\n                    tokenCodec \u003d codec;\r\n                    break;\r\n                }\r\n            }\r\n            if (tokenCodec \u003d\u003d null) {\r\n                throw new Pack200Exception(\"Cannot calculate token codec from \" + k + \" and \" + l);\r\n            }\r\n        }\r\n    }\r\n    // read favorites\r\n    lastBandLength +\u003d n;\r\n    result \u003d tokenCodec.decodeInts(n, in);\r\n    // read unfavorites\r\n    last \u003d 0;\r\n    for (int i \u003d 0; i \u003c n; i++) {\r\n        final int index \u003d result[i];\r\n        if (index \u003d\u003d 0) {\r\n            lastBandLength++;\r\n            result[i] \u003d last \u003d unfavouredCodec.decode(in, last);\r\n        } else {\r\n            result[i] \u003d favoured[index - 1];\r\n        }\r\n    }\r\n    return result;\r\n}",
    "nodes": 26,
    "edges": 36,
    "cc": 12,
    "flowSummary": [
      "B1 : If(i20 \u003c\u003d $i30) → B2 | else → B5",
      "B2 : If($i3 \u003d\u003d i18) → B3 | else → B10",
      "B3 : If($i3 !\u003d i19) → B4 | else → B5",
      "B5 : If($i16 \u003c\u003d $i17) → B6 | else → B7",
      "B7 : If($i16 !\u003d $i17) → B8 | else → B9",
      "B10 : If($r5 !\u003d null) → B11 | else → B19",
      "B11 : If(i20 \u003e\u003d 256) → B12 | else → B13",
      "B14 : If(i21 \u003e\u003d 5) → B15 | else → B17",
      "B15 : If($z0 \u003d\u003d false) → B16 | else → B14",
      "B17 : If($r8 !\u003d null) → B18 | else → B19",
      "B20 : If(i25 \u003e\u003d i0) → B21 | else → B25",
      "B21 : If(i26 !\u003d 0) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  PopulationCodec\n  i0 :\u003d @parameter0: int\n  InputStream\n  PopulationCodec: int lastBandLength\u003e \u003d 0\n  $i1 \u003d r0.check(i0, r1)\n  $r2 \u003d newarray (int)[$i1]\n  PopulationCodec: int[] favoured\u003e \u003d $r2\n  i18 \u003d 2147483647\n  i19 \u003d 0\n  $i28 \u003d (int) -1\n  i20 \u003d $i28\n}",
      "B1 {\n  $r3 \u003d Codec favouredCodec\u003e\n  $l2 \u003d (long) i19\n  $i3 \u003d $r3.decode(r1, $l2)\n  $i30 \u003d (int) -1\n  if (i20 \u003c\u003d $i30) goto B2 else B5\n}",
      "B2 {\n  if ($i3 \u003d\u003d i18) goto B3 else B10\n}",
      "B3 {\n  if ($i3 !\u003d i19) goto B4 else B5\n}",
      "B4 {\n  goto B10\n}",
      "B5 {\n  $r4 \u003d PopulationCodec: int[] favoured\u003e\n  i20 \u003d i20 + 1\n  $r4[i20] \u003d $i3\n  $i16 \u003d Math.abs(i18)\n  $i17 \u003d Math.abs($i3)\n  if ($i16 \u003c\u003d $i17) goto B6 else B7\n}",
      "B6 {\n  i18 \u003d $i3\n  goto B9\n}",
      "B7 {\n  if ($i16 !\u003d $i17) goto B8 else B9\n}",
      "B8 {\n  i18 \u003d $i16\n}",
      "B9 {\n  i19 \u003d $i3\n  goto B1\n}",
      "B10 {\n  $i4 \u003d PopulationCodec: int lastBandLength\u003e\n  $i5 \u003d $i4 + i20\n  PopulationCodec: int lastBandLength\u003e \u003d $i5\n  $r5 \u003d Codec tokenCodec\u003e\n  if ($r5 !\u003d null) goto B11 else B19\n}",
      "B11 {\n  if (i20 \u003e\u003d 256) goto B12 else B13\n}",
      "B12 {\n  $r17 \u003d BHSDCodec BYTE1\u003e\n  Codec tokenCodec\u003e \u003d $r17\n  goto B19\n}",
      "B13 {\n  i21 \u003d 1\n}",
      "B14 {\n  i21 \u003d i21 + 1\n  if (i21 \u003e\u003d 5) goto B15 else B17\n}",
      "B15 {\n  $r20 \u003d BHSDCodec\n  $i13 \u003d PopulationCodec: int l\u003e\n  $i14 \u003d 256 - $i13\n  new BHSDCodec(i21, $i14, 0)\n  $l15 \u003d (long) i20\n  $z0 \u003d $r20.encodes($l15)\n  if ($z0 \u003d\u003d false) goto B16 else B14\n}",
      "B16 {\n  Codec tokenCodec\u003e \u003d $r20\n  goto B17\n}",
      "B17 {\n  $r8 \u003d Codec tokenCodec\u003e\n  if ($r8 !\u003d null) goto B18 else B19\n}",
      "B18 {\n  $r22 \u003d Pack200Exception\n  $r21 \u003d StringBuilder\n  new StringBuilder()\n  $r11 \u003d $r21.append(\"Cannot calculate token codec from \")\n  $r12 \u003d $r11.append(i20)\n  $r13 \u003d $r12.append(\" and \")\n  $i12 \u003d PopulationCodec: int l\u003e\n  $r14 \u003d $r13.append($i12)\n  $r15 \u003d $r14.toString()\n  new Pack200Exception($r15)\n  throw $r22\n}",
      "B19 {\n  $i22 \u003d PopulationCodec: int lastBandLength\u003e\n  $i23 \u003d $i22 + i0\n  PopulationCodec: int lastBandLength\u003e \u003d $i23\n  $r18 \u003d Codec tokenCodec\u003e\n  $r19 \u003d $r18.decodeInts(i0, r1)\n  i24 \u003d 0\n  i25 \u003d 0\n}",
      "B20 {\n  if (i25 \u003e\u003d i0) goto B21 else B25\n}",
      "B21 {\n  i26 \u003d $r19[i25]\n  if (i26 !\u003d 0) goto B22 else B23\n}",
      "B22 {\n  $i8 \u003d PopulationCodec: int lastBandLength\u003e\n  $i9 \u003d $i8 + 1\n  PopulationCodec: int lastBandLength\u003e \u003d $i9\n  $r7 \u003d Codec unfavouredCodec\u003e\n  $l10 \u003d (long) i24\n  $i11 \u003d $r7.decode(r1, $l10)\n  i24 \u003d $i11\n  $r19[i25] \u003d $i11\n  goto B24\n}",
      "B23 {\n  $r6 \u003d PopulationCodec: int[] favoured\u003e\n  $i6 \u003d i26 - 1\n  $i7 \u003d $r6[$i6]\n  $r19[i25] \u003d $i7\n}",
      "B24 {\n  i25 \u003d i25 + 1\n  goto B20\n}",
      "B25 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B10",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B1",
      "B10 --\u003e B11",
      "B10 --\u003e B19",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B19",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B14",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B20",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "PopulationCodec#check(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.RunCodec",
    "methodName": "decode",
    "signature": "int decode(java.io.InputStream,long)",
    "visibility": "public",
    "body": "{\r\n    if (--k \u003e\u003d 0) {\r\n        final int value \u003d aCodec.decode(in, this.last);\r\n        this.last \u003d k \u003d\u003d 0 ? 0 : value;\r\n        return normalise(value, aCodec);\r\n    }\r\n    this.last \u003d bCodec.decode(in, this.last);\r\n    return normalise(this.last, bCodec);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003c 0) → B1 | else → B5",
      "B1 : If($i10 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  RunCodec\n  InputStream\n  l12 :\u003d @parameter1: long\n  $i0 \u003d RunCodec: int k\u003e\n  $i1 \u003d $i0 - 1\n  RunCodec: int k\u003e \u003d $i1\n  if ($i1 \u003c 0) goto B1 else B5\n}",
      "B1 {\n  $r4 \u003d Codec aCodec\u003e\n  $i7 \u003d RunCodec: int last\u003e\n  $l8 \u003d (long) $i7\n  i9 \u003d $r4.decode(r1, $l8)\n  $i10 \u003d RunCodec: int k\u003e\n  if ($i10 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i13 \u003d 0\n  goto B4\n}",
      "B3 {\n  $i13 \u003d i9\n}",
      "B4 {\n  RunCodec: int last\u003e \u003d $i13\n  $r5 \u003d Codec aCodec\u003e\n  $i11 \u003d r0.normalise(i9, $r5)\n  return\n}",
      "B5 {\n  $r2 \u003d Codec bCodec\u003e\n  $i2 \u003d RunCodec: int last\u003e\n  $l3 \u003d (long) $i2\n  $i4 \u003d $r2.decode(r1, $l3)\n  RunCodec: int last\u003e \u003d $i4\n  $i5 \u003d RunCodec: int last\u003e\n  $r3 \u003d Codec bCodec\u003e\n  $i6 \u003d r0.normalise($i5, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "RunCodec#normalise(...2)",
        "body": "{\r\n    if (codecUsed instanceof BHSDCodec) {\r\n        final BHSDCodec bhsd \u003d (BHSDCodec) codecUsed;\r\n        if (bhsd.isDelta()) {\r\n            final long cardinality \u003d bhsd.cardinality();\r\n            while (value \u003e bhsd.largest()) {\r\n                value -\u003d cardinality;\r\n            }\r\n            while (value \u003c bhsd.smallest()) {\r\n                value \u003d ExactMath.add(value, cardinality);\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Segment",
    "methodName": "pack",
    "signature": "void pack(org.apache.commons.compress.harmony.pack200.Archive$SegmentUnit,java.io.OutputStream,org.apache.commons.compress.harmony.pack200.PackingOptions)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z1 !\u003d 0) → B1 | else → B2",
      "B3 : If($z2 !\u003d 0) → B4 | else → B5",
      "B5 : If($i11 \u003c\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Segment\n  Archive$SegmentUnit\n  OutputStream\n  PackingOptions\n  PackingOptions options\u003e \u003d r1\n  $z0 \u003d r1.isStripDebug()\n  Segment: boolean stripDebug\u003e \u003d $z0\n  i0 \u003d r1.getEffort()\n  $r2 \u003d r1.getUnknownAttributePrototypes()\n  Attribute[] nonStandardAttributePrototypes\u003e \u003d $r2\n  $r3 \u003d StringBuilder\n  new StringBuilder()\n  $r5 \u003d $r3.append(\"Start to pack a new segment with \")\n  $i1 \u003d r4.fileListSize()\n  $r6 \u003d $r5.append($i1)\n  $r7 \u003d $r6.append(\" files including \")\n  $i2 \u003d r4.classListSize()\n  $r8 \u003d $r7.append($i2)\n  $r9 \u003d $r8.append(\" classes\")\n  $r10 \u003d $r9.toString()\n  PackingUtils.log($r10)\n  PackingUtils.log(\"Initialize a header for the segment\")\n  $r11 \u003d SegmentHeader\n  new SegmentHeader()\n  SegmentHeader segmentHeader\u003e \u003d $r11\n  $r12 \u003d SegmentHeader segmentHeader\u003e\n  $i3 \u003d r4.fileListSize()\n  $r12.setFile_count($i3)\n  $r13 \u003d SegmentHeader segmentHeader\u003e\n  $z1 \u003d Segment: boolean stripDebug\u003e\n  if ($z1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z5 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z5 \u003d 0\n}",
      "B3 {\n  $r13.setHave_all_code_flags($z5)\n  $z2 \u003d r1.isKeepDeflateHint()\n  if ($z2 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r59 \u003d SegmentHeader segmentHeader\u003e\n  $r60 \u003d r1.getDeflateHint()\n  $z4 \u003d Boolean.parseBoolean($r60)\n  $r59.setDeflate_hint($z4)\n}",
      "B5 {\n  PackingUtils.log(\"Setup constant pool bands for the segment\")\n  $r14 \u003d CpBands\n  new CpBands(r0, i0)\n  CpBands cpBands\u003e \u003d $r14\n  PackingUtils.log(\"Setup attribute definition bands for the segment\")\n  $r15 \u003d AttributeDefinitionBands\n  $r16 \u003d Attribute[] nonStandardAttributePrototypes\u003e\n  new AttributeDefinitionBands(r0, i0, $r16)\n  AttributeDefinitionBands attributeDefinitionBands\u003e \u003d $r15\n  PackingUtils.log(\"Setup internal class bands for the segment\")\n  $r17 \u003d IcBands\n  $r19 \u003d SegmentHeader segmentHeader\u003e\n  $r18 \u003d CpBands cpBands\u003e\n  new IcBands($r19, $r18, i0)\n  IcBands icBands\u003e \u003d $r17\n  PackingUtils.log(\"Setup class bands for the segment\")\n  $r20 \u003d ClassBands\n  $i4 \u003d r4.classListSize()\n  $z3 \u003d Segment: boolean stripDebug\u003e\n  new ClassBands(r0, $i4, i0, $z3)\n  ClassBands classBands\u003e \u003d $r20\n  PackingUtils.log(\"Setup byte code bands for the segment\")\n  $r21 \u003d BcBands\n  $r22 \u003d CpBands cpBands\u003e\n  new BcBands($r22, r0, i0)\n  BcBands bcBands\u003e \u003d $r21\n  PackingUtils.log(\"Setup file bands for the segment\")\n  $r23 \u003d FileBands\n  $r25 \u003d CpBands cpBands\u003e\n  $r24 \u003d SegmentHeader segmentHeader\u003e\n  new FileBands($r25, $r24, r1, r4, i0)\n  FileBands fileBands\u003e \u003d $r23\n  $r26 \u003d Attribute[] nonStandardAttributePrototypes\u003e\n  r0.processClasses(r4, $r26)\n  $r27 \u003d CpBands cpBands\u003e\n  $r27.finaliseBands()\n  $r28 \u003d AttributeDefinitionBands attributeDefinitionBands\u003e\n  $r28.finaliseBands()\n  $r29 \u003d IcBands icBands\u003e\n  $r29.finaliseBands()\n  $r30 \u003d ClassBands classBands\u003e\n  $r30.finaliseBands()\n  $r31 \u003d BcBands bcBands\u003e\n  $r31.finaliseBands()\n  $r32 \u003d FileBands fileBands\u003e\n  $r32.finaliseBands()\n  $r33 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n  PackingUtils.log(\"Packing...\")\n  $r34 \u003d ClassBands classBands\u003e\n  $i11 \u003d $r34.numClassesProcessed()\n  $r35 \u003d SegmentHeader segmentHeader\u003e\n  $r35.setClass_count($i11)\n  $r36 \u003d CpBands cpBands\u003e\n  $r36.pack($r33)\n  if ($i11 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r55 \u003d AttributeDefinitionBands attributeDefinitionBands\u003e\n  $r55.pack($r33)\n  $r56 \u003d IcBands icBands\u003e\n  $r56.pack($r33)\n  $r57 \u003d ClassBands classBands\u003e\n  $r57.pack($r33)\n  $r58 \u003d BcBands bcBands\u003e\n  $r58.pack($r33)\n}",
      "B7 {\n  $r37 \u003d FileBands fileBands\u003e\n  $r37.pack($r33)\n  $r38 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n  $r39 \u003d SegmentHeader segmentHeader\u003e\n  $r39.pack($r38)\n  $r38.writeTo(r40)\n  $r33.writeTo(r40)\n  $i5 \u003d $r38.size()\n  r4.addPackedByteAmount($i5)\n  $i6 \u003d $r33.size()\n  r4.addPackedByteAmount($i6)\n  $r41 \u003d StringBuilder\n  new StringBuilder()\n  $r42 \u003d $r41.append(\"Wrote total of \")\n  $i7 \u003d r4.getPackedByteAmount()\n  $r43 \u003d $r42.append($i7)\n  $r44 \u003d $r43.append(\" bytes\")\n  $r45 \u003d $r44.toString()\n  PackingUtils.log($r45)\n  $r46 \u003d StringBuilder\n  new StringBuilder()\n  $r47 \u003d $r46.append(\"Transmitted \")\n  $i8 \u003d r4.fileListSize()\n  $r48 \u003d $r47.append($i8)\n  $r49 \u003d $r48.append(\" files of \")\n  $i9 \u003d r4.getByteAmount()\n  $r50 \u003d $r49.append($i9)\n  $r51 \u003d $r50.append(\" input bytes in a segment of \")\n  $i10 \u003d r4.getPackedByteAmount()\n  $r52 \u003d $r51.append($i10)\n  $r53 \u003d $r52.append(\" bytes\")\n  $r54 \u003d $r53.toString()\n  PackingUtils.log($r54)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Segment",
    "methodName": "visitAttribute",
    "signature": "void visitAttribute(org.objectweb.asm.Attribute)",
    "visibility": "public",
    "body": "{\r\n    if (attribute.isUnknown()) {\r\n        final String action \u003d options.getUnknownAttributeAction();\r\n        if (action.equals(PackingOptions.PASS)) {\r\n            passCurrentClass();\r\n        } else if (action.equals(PackingOptions.ERROR)) {\r\n            throw new Error(\"Unknown attribute encountered\");\r\n        }\r\n        // else skip\r\n    } else if (attribute instanceof NewAttribute) {\r\n        final NewAttribute newAttribute \u003d (NewAttribute) attribute;\r\n        if (newAttribute.isUnknown(AttributeDefinitionBands.CONTEXT_CLASS)) {\r\n            final String action \u003d options.getUnknownClassAttributeAction(newAttribute.type);\r\n            if (action.equals(PackingOptions.PASS)) {\r\n                passCurrentClass();\r\n            } else if (action.equals(PackingOptions.ERROR)) {\r\n                throw new Error(\"Unknown attribute encountered\");\r\n            }\r\n            // else skip\r\n        }\r\n        classBands.addClassAttribute(newAttribute);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Unexpected attribute encountered: \" + attribute.type);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B6",
      "B1 : If($z5 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($z6 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B13",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B12",
      "B8 : If($z3 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z4 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  Segment\n  Attribute\n  $z0 \u003d r0.isUnknown()\n  if ($z0 \u003d\u003d false) goto B1 else B6\n}",
      "B1 {\n  $r12 \u003d PackingOptions options\u003e\n  r14 \u003d $r12.getUnknownAttributeAction()\n  $z5 \u003d r14.equals(\"pass\")\n  if ($z5 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  r7.passCurrentClass()\n  goto B5\n}",
      "B3 {\n  $z6 \u003d r14.equals(\"error\")\n  if ($z6 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r13 \u003d Error\n  new Error(\"Unknown attribute encountered\")\n  throw $r13\n}",
      "B5 {\n  goto B14\n}",
      "B6 {\n  $z1 \u003d NewAttribute\n  if ($z1 \u003d\u003d false) goto B7 else B13\n}",
      "B7 {\n  r15 \u003d NewAttribute) r0\n  $z2 \u003d r15.isUnknown(0)\n  if ($z2 \u003d\u003d false) goto B8 else B12\n}",
      "B8 {\n  $r9 \u003d PackingOptions options\u003e\n  $r8 \u003d String type\u003e\n  r10 \u003d $r9.getUnknownClassAttributeAction($r8)\n  $z3 \u003d r10.equals(\"pass\")\n  if ($z3 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r7.passCurrentClass()\n  goto B12\n}",
      "B10 {\n  $z4 \u003d r10.equals(\"error\")\n  if ($z4 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $r11 \u003d Error\n  new Error(\"Unknown attribute encountered\")\n  throw $r11\n}",
      "B12 {\n  $r16 \u003d ClassBands classBands\u003e\n  $r16.addClassAttribute(r15)\n  goto B14\n}",
      "B13 {\n  $r1 \u003d IllegalArgumentException\n  $r2 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r2.append(\"Unexpected attribute encountered: \")\n  $r3 \u003d String type\u003e\n  $r5 \u003d $r4.append($r3)\n  $r6 \u003d $r5.toString()\n  new IllegalArgumentException($r6)\n  throw $r1\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B14",
      "B6 --\u003e B7",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Segment#passCurrentClass(...0)",
        "body": "{\r\n    throw new PassException();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.Segment",
    "methodName": "visitSource",
    "signature": "void visitSource(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!stripDebug) {\r\n        classBands.addSourceFile(source);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Segment\n  String\n  String\n  $z0 \u003d Segment: boolean stripDebug\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ClassBands classBands\u003e\n  $r2.addSourceFile(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.pack200.SegmentHeader",
    "methodName": "pack",
    "signature": "void pack(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    out.write(encodeScalar(magic, Codec.BYTE1));\r\n    out.write(encodeScalar(archive_minver, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(archive_majver, Codec.UNSIGNED5));\r\n    calculateArchiveOptions();\r\n    out.write(encodeScalar(archive_options, Codec.UNSIGNED5));\r\n    writeArchiveFileCounts(out);\r\n    writeArchiveSpecialCounts(out);\r\n    writeCpCounts(out);\r\n    writeClassCounts(out);\r\n    if (band_headers.size() \u003e 0) {\r\n        out.write(encodeScalar(band_headers.toArray(), Codec.BYTE1));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentHeader\n  OutputStream\n  $r3 \u003d SegmentHeader: int[] magic\u003e\n  $r2 \u003d BHSDCodec BYTE1\u003e\n  $r4 \u003d r1.encodeScalar($r3, $r2)\n  r0.write($r4)\n  $r5 \u003d BHSDCodec UNSIGNED5\u003e\n  $r6 \u003d r1.encodeScalar(7, $r5)\n  r0.write($r6)\n  $r7 \u003d BHSDCodec UNSIGNED5\u003e\n  $r8 \u003d r1.encodeScalar(150, $r7)\n  r0.write($r8)\n  r1.calculateArchiveOptions()\n  $i0 \u003d SegmentHeader: int archive_options\u003e\n  $r9 \u003d BHSDCodec UNSIGNED5\u003e\n  $r10 \u003d r1.encodeScalar($i0, $r9)\n  r0.write($r10)\n  r1.writeArchiveFileCounts(r0)\n  r1.writeArchiveSpecialCounts(r0)\n  r1.writeCpCounts(r0)\n  r1.writeClassCounts(r0)\n  $r11 \u003d IntList band_headers\u003e\n  $i1 \u003d $r11.size()\n  if ($i1 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d IntList band_headers\u003e\n  $r14 \u003d $r12.toArray()\n  $r13 \u003d BHSDCodec BYTE1\u003e\n  $r15 \u003d r1.encodeScalar($r14, $r13)\n  r0.write($r15)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentHeader#encodeScalar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "SegmentHeader#writeArchiveSpecialCounts(...1)",
        "body": "{\r\n    if ((archive_options \u0026 1) \u003e 0) {\r\n        // have_special_formats\r\n        out.write(encodeScalar(band_headers.size(), Codec.UNSIGNED5));\r\n        out.write(encodeScalar(attribute_definition_count, Codec.UNSIGNED5));\r\n    }\r\n}"
      },
      {
        "name": "SegmentHeader#writeCpCounts(...1)",
        "body": "{\r\n    out.write(encodeScalar(cp_Utf8_count, Codec.UNSIGNED5));\r\n    if ((archive_options \u0026 1 \u003c\u003c 1) !\u003d 0) {\r\n        // have_cp_numbers\r\n        out.write(encodeScalar(cp_Int_count, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(cp_Float_count, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(cp_Long_count, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(cp_Double_count, Codec.UNSIGNED5));\r\n    }\r\n    out.write(encodeScalar(cp_String_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Class_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Signature_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Descr_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Field_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Method_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(cp_Imethod_count, Codec.UNSIGNED5));\r\n}"
      },
      {
        "name": "SegmentHeader#calculateArchiveOptions(...0)",
        "body": "{\r\n    if (attribute_definition_count \u003e 0 || band_headers.size() \u003e 0) {\r\n        archive_options |\u003d 1;\r\n    }\r\n    if (cp_Int_count \u003e 0 || cp_Float_count \u003e 0 || cp_Long_count \u003e 0 || cp_Double_count \u003e 0) {\r\n        archive_options |\u003d 1 \u003c\u003c 1;\r\n    }\r\n    if (have_all_code_flags) {\r\n        archive_options |\u003d 1 \u003c\u003c 2;\r\n    }\r\n    if (file_count \u003e 0) {\r\n        archive_options |\u003d 1 \u003c\u003c 4;\r\n    }\r\n    if (deflate_hint) {\r\n        archive_options |\u003d 1 \u003c\u003c 5;\r\n    }\r\n    if (have_file_modtime) {\r\n        archive_options |\u003d 1 \u003c\u003c 6;\r\n    }\r\n    if (have_file_options) {\r\n        archive_options |\u003d 1 \u003c\u003c 7;\r\n    }\r\n    if (have_file_size_hi) {\r\n        archive_options |\u003d 1 \u003c\u003c 8;\r\n    }\r\n    if (have_class_flags_hi) {\r\n        archive_options |\u003d 1 \u003c\u003c 9;\r\n    }\r\n    if (have_field_flags_hi) {\r\n        archive_options |\u003d 1 \u003c\u003c 10;\r\n    }\r\n    if (have_method_flags_hi) {\r\n        archive_options |\u003d 1 \u003c\u003c 11;\r\n    }\r\n    if (have_code_flags_hi) {\r\n        archive_options |\u003d 1 \u003c\u003c 12;\r\n    }\r\n}"
      },
      {
        "name": "SegmentHeader#writeClassCounts(...1)",
        "body": "{\r\n    final int default_class_minver \u003d 0;\r\n    final int default_class_majver \u003d majverCounter.getMostCommon();\r\n    out.write(encodeScalar(ic_count, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(default_class_minver, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(default_class_majver, Codec.UNSIGNED5));\r\n    out.write(encodeScalar(class_count, Codec.UNSIGNED5));\r\n}"
      },
      {
        "name": "SegmentHeader#writeArchiveFileCounts(...1)",
        "body": "{\r\n    if ((archive_options \u0026 1 \u003c\u003c 4) \u003e 0) {\r\n        // have_file_headers\r\n        out.write(encodeScalar(archive_size_hi, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(archive_size_lo, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(archive_next_count, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(archive_modtime, Codec.UNSIGNED5));\r\n        out.write(encodeScalar(file_count, Codec.UNSIGNED5));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Archive",
    "methodName": "setQuiet",
    "signature": "void setQuiet(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (quiet || logLevel \u003d\u003d Segment.LOG_LEVEL_QUIET) {\r\n        logLevel \u003d Segment.LOG_LEVEL_QUIET;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Archive\n  z0 :\u003d @parameter0: boolean\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d Archive: int logLevel\u003e\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  Archive: int logLevel\u003e \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Archive",
    "methodName": "setVerbose",
    "signature": "void setVerbose(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (verbose) {\r\n        logLevel \u003d Segment.LOG_LEVEL_VERBOSE;\r\n    } else if (logLevel \u003d\u003d Segment.LOG_LEVEL_VERBOSE) {\r\n        logLevel \u003d Segment.LOG_LEVEL_STANDARD;\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i0 !\u003d 2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Archive\n  z0 :\u003d @parameter0: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  Archive: int logLevel\u003e \u003d 2\n  goto B4\n}",
      "B2 {\n  $i0 \u003d Archive: int logLevel\u003e\n  if ($i0 !\u003d 2) goto B3 else B4\n}",
      "B3 {\n  Archive: int logLevel\u003e \u003d 1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Archive",
    "methodName": "unpack",
    "signature": "void unpack()",
    "visibility": "public",
    "body": "{\r\n    outputStream.setComment(\"PACK200\");\r\n    try {\r\n        if (!inputStream.markSupported()) {\r\n            inputStream \u003d new BoundedInputStream(new BufferedInputStream(inputStream));\r\n            if (!inputStream.markSupported()) {\r\n                throw new IllegalStateException();\r\n            }\r\n        }\r\n        inputStream.mark(2);\r\n        if ((inputStream.read() \u0026 0xFF | (inputStream.read() \u0026 0xFF) \u003c\u003c 8) \u003d\u003d GZIPInputStream.GZIP_MAGIC) {\r\n            inputStream.reset();\r\n            inputStream \u003d new BoundedInputStream(new BufferedInputStream(new GZIPInputStream(inputStream)));\r\n        } else {\r\n            inputStream.reset();\r\n        }\r\n        inputStream.mark(MAGIC.length);\r\n        // pack200\r\n        final int[] word \u003d new int[MAGIC.length];\r\n        for (int i \u003d 0; i \u003c word.length; i++) {\r\n            word[i] \u003d inputStream.read();\r\n        }\r\n        boolean compressedWithE0 \u003d false;\r\n        for (int m \u003d 0; m \u003c MAGIC.length; m++) {\r\n            if (word[m] !\u003d MAGIC[m]) {\r\n                compressedWithE0 \u003d true;\r\n                break;\r\n            }\r\n        }\r\n        inputStream.reset();\r\n        if (compressedWithE0) {\r\n            // The original Jar was not packed, so just copy it across.\r\n            final JarInputStream jarInputStream \u003d new JarInputStream(inputStream);\r\n            JarEntry jarEntry;\r\n            while ((jarEntry \u003d jarInputStream.getNextJarEntry()) !\u003d null) {\r\n                outputStream.putNextEntry(jarEntry);\r\n                IOUtils.copy(jarInputStream, outputStream, 16_384);\r\n                outputStream.closeEntry();\r\n            }\r\n        } else {\r\n            int i \u003d 0;\r\n            while (available(inputStream)) {\r\n                i++;\r\n                final Segment segment \u003d new Segment();\r\n                segment.setLogLevel(logLevel);\r\n                segment.setLogStream(logFile);\r\n                segment.setPreRead(false);\r\n                if (i \u003d\u003d 1) {\r\n                    segment.log(Segment.LOG_LEVEL_VERBOSE, \"Unpacking from \" + inputPath + \" to \" + outputFileName);\r\n                }\r\n                segment.log(Segment.LOG_LEVEL_VERBOSE, \"Reading segment \" + i);\r\n                if (overrideDeflateHint) {\r\n                    segment.overrideDeflateHint(deflateHint);\r\n                }\r\n                segment.unpack(inputStream, outputStream);\r\n                outputStream.flush();\r\n            }\r\n        }\r\n    } finally {\r\n        if (closeStreams) {\r\n            IOUtils.closeQuietly(inputStream);\r\n            IOUtils.closeQuietly(outputStream);\r\n        }\r\n        IOUtils.closeQuietly(logFile);\r\n    }\r\n    if (removePackFile \u0026\u0026 inputPath !\u003d null) {\r\n        Files.delete(inputPath);\r\n    }\r\n}",
    "nodes": 36,
    "edges": 48,
    "cc": 14,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z6 !\u003d 0) → B2 | else → B3",
      "B3 : If($i5 !\u003d $i18) → B4 | else → B5",
      "B7 : If(i13 \u003e\u003d $i14) → B8 | else → B9",
      "B10 : If(i15 \u003e\u003d $i8) → B11 | else → B14",
      "B11 : If($i11 \u003d\u003d $i10) → B12 | else → B13",
      "B14 : If(z8 \u003d\u003d false) → B15 | else → B19",
      "B16 : If($r37 \u003d\u003d null) → B17 | else → B18",
      "B20 : If($z1 \u003d\u003d false) → B21 | else → B26",
      "B21 : If(i16 !\u003d 1) → B22 | else → B23",
      "B23 : If($z4 \u003d\u003d false) → B24 | else → B25",
      "B26 : If($z2 \u003d\u003d false) → B27 | else → B28",
      "B29 : If($z7 \u003d\u003d false) → B30 | else → B31",
      "B32 : If($z3 \u003d\u003d false) → B33 | else → B35",
      "B33 : If($r14 \u003d\u003d null) → B34 | else → B35"
    ],
    "blockList": [
      "B0 {\n  Archive\n  $r1 \u003d JarOutputStream outputStream\u003e\n  $r1.setComment(\"PACK200\")\n  $r2 \u003d BoundedInputStream inputStream\u003e\n  $z0 \u003d $r2.markSupported()\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $r59 \u003d BoundedInputStream\n  $r58 \u003d BufferedInputStream\n  $r51 \u003d BoundedInputStream inputStream\u003e\n  new BufferedInputStream($r51)\n  new BoundedInputStream($r58)\n  BoundedInputStream inputStream\u003e \u003d $r59\n  $r52 \u003d BoundedInputStream inputStream\u003e\n  $z6 \u003d $r52.markSupported()\n  if ($z6 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r60 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r60\n}",
      "B3 {\n  $r3 \u003d BoundedInputStream inputStream\u003e\n  $r3.mark(2)\n  $r4 \u003d BoundedInputStream inputStream\u003e\n  $i0 \u003d $r4.read()\n  $i4 \u003d $i0 \u0026 255\n  $r5 \u003d BoundedInputStream inputStream\u003e\n  $i1 \u003d $r5.read()\n  $i2 \u003d $i1 \u0026 255\n  $i3 \u003d $i2 \u003c\u003c 8\n  $i5 \u003d $i4 | $i3\n  $i18 \u003d (int) 35615\n  if ($i5 !\u003d $i18) goto B4 else B5\n}",
      "B4 {\n  $r43 \u003d BoundedInputStream inputStream\u003e\n  $r43.reset()\n  $r63 \u003d BoundedInputStream\n  $r62 \u003d BufferedInputStream\n  $r61 \u003d GZIPInputStream\n  $r47 \u003d BoundedInputStream inputStream\u003e\n  new GZIPInputStream($r47)\n  new BufferedInputStream($r61)\n  new BoundedInputStream($r62)\n  BoundedInputStream inputStream\u003e \u003d $r63\n  goto B6\n}",
      "B5 {\n  $r6 \u003d BoundedInputStream inputStream\u003e\n  $r6.reset()\n}",
      "B6 {\n  $r8 \u003d BoundedInputStream inputStream\u003e\n  $r7 \u003d Archive: int[] MAGIC\u003e\n  $i6 \u003d lengthof $r7\n  $r8.mark($i6)\n  $r9 \u003d Archive: int[] MAGIC\u003e\n  $i7 \u003d lengthof $r9\n  $r48 \u003d newarray (int)[$i7]\n  i13 \u003d 0\n}",
      "B7 {\n  $i14 \u003d lengthof $r48\n  if (i13 \u003e\u003d $i14) goto B8 else B9\n}",
      "B8 {\n  $r42 \u003d BoundedInputStream inputStream\u003e\n  $i12 \u003d $r42.read()\n  $r48[i13] \u003d $i12\n  i13 \u003d i13 + 1\n  goto B7\n}",
      "B9 {\n  z8 \u003d 0\n  i15 \u003d 0\n}",
      "B10 {\n  $r10 \u003d Archive: int[] MAGIC\u003e\n  $i8 \u003d lengthof $r10\n  if (i15 \u003e\u003d $i8) goto B11 else B14\n}",
      "B11 {\n  $i11 \u003d $r48[i15]\n  $r41 \u003d Archive: int[] MAGIC\u003e\n  $i10 \u003d $r41[i15]\n  if ($i11 \u003d\u003d $i10) goto B12 else B13\n}",
      "B12 {\n  z8 \u003d 1\n  goto B14\n}",
      "B13 {\n  i15 \u003d i15 + 1\n  goto B10\n}",
      "B14 {\n  $r11 \u003d BoundedInputStream inputStream\u003e\n  $r11.reset()\n  if (z8 \u003d\u003d false) goto B15 else B19\n}",
      "B15 {\n  $r64 \u003d JarInputStream\n  $r36 \u003d BoundedInputStream inputStream\u003e\n  new JarInputStream($r36)\n}",
      "B16 {\n  $r37 \u003d $r64.getNextJarEntry()\n  if ($r37 \u003d\u003d null) goto B17 else B18\n}",
      "B17 {\n  $r38 \u003d JarOutputStream outputStream\u003e\n  $r38.putNextEntry($r37)\n  $r39 \u003d JarOutputStream outputStream\u003e\n  IOUtils.copy($r64, $r39, 16384)\n  $r40 \u003d JarOutputStream outputStream\u003e\n  $r40.closeEntry()\n  goto B16\n}",
      "B18 {\n  goto B26\n}",
      "B19 {\n  i16 \u003d 0\n}",
      "B20 {\n  $r12 \u003d BoundedInputStream inputStream\u003e\n  $z1 \u003d r0.available($r12)\n  if ($z1 \u003d\u003d false) goto B21 else B26\n}",
      "B21 {\n  i16 \u003d i16 + 1\n  $r65 \u003d Segment\n  new Segment()\n  $i9 \u003d Archive: int logLevel\u003e\n  $r65.setLogLevel($i9)\n  $r19 \u003d FileOutputStream logFile\u003e\n  $r65.setLogStream($r19)\n  $r65.setPreRead(0)\n  if (i16 !\u003d 1) goto B22 else B23\n}",
      "B22 {\n  $r66 \u003d StringBuilder\n  new StringBuilder()\n  $r29 \u003d $r66.append(\"Unpacking from \")\n  $r28 \u003d Path inputPath\u003e\n  $r30 \u003d $r29.append($r28)\n  $r32 \u003d $r30.append(\" to \")\n  $r31 \u003d String outputFileName\u003e\n  $r33 \u003d $r32.append($r31)\n  $r34 \u003d $r33.toString()\n  $r65.log(2, $r34)\n}",
      "B23 {\n  $r67 \u003d StringBuilder\n  new StringBuilder()\n  $r21 \u003d $r67.append(\"Reading segment \")\n  $r22 \u003d $r21.append(i16)\n  $r23 \u003d $r22.toString()\n  $r65.log(2, $r23)\n  $z4 \u003d Archive: boolean overrideDeflateHint\u003e\n  if ($z4 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $z5 \u003d Archive: boolean deflateHint\u003e\n  $r65.overrideDeflateHint($z5)\n}",
      "B25 {\n  $r25 \u003d BoundedInputStream inputStream\u003e\n  $r24 \u003d JarOutputStream outputStream\u003e\n  $r65.unpack($r25, $r24)\n  $r26 \u003d JarOutputStream outputStream\u003e\n  $r26.flush()\n  goto B20\n}",
      "B26 {\n  $z2 \u003d Archive: boolean closeStreams\u003e\n  if ($z2 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  $r16 \u003d BoundedInputStream inputStream\u003e\n  IOUtils.closeQuietly($r16)\n  $r17 \u003d JarOutputStream outputStream\u003e\n  IOUtils.closeQuietly($r17)\n}",
      "B28 {\n  $r13 \u003d FileOutputStream logFile\u003e\n  IOUtils.closeQuietly($r13)\n  goto B32\n}",
      "B29 {\n  $r54 :\u003d @caughtexception\n  $z7 \u003d Archive: boolean closeStreams\u003e\n  if ($z7 \u003d\u003d false) goto B30 else B31\n}",
      "B30 {\n  $r56 \u003d BoundedInputStream inputStream\u003e\n  IOUtils.closeQuietly($r56)\n  $r57 \u003d JarOutputStream outputStream\u003e\n  IOUtils.closeQuietly($r57)\n}",
      "B31 {\n  $r55 \u003d FileOutputStream logFile\u003e\n  IOUtils.closeQuietly($r55)\n  throw $r54\n}",
      "B32 {\n  $z3 \u003d Archive: boolean removePackFile\u003e\n  if ($z3 \u003d\u003d false) goto B33 else B35\n}",
      "B33 {\n  $r14 \u003d Path inputPath\u003e\n  if ($r14 \u003d\u003d null) goto B34 else B35\n}",
      "B34 {\n  $r15 \u003d Path inputPath\u003e\n  Files.delete($r15)\n}",
      "B35 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B10",
      "B14 --\u003e B15",
      "B14 --\u003e B19",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B16",
      "B18 --\u003e B26",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B26",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B20",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B31",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e B33",
      "B32 --\u003e B35",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e B35",
      "B35 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Archive#available(...1)",
        "body": "{\r\n    inputStream.mark(1);\r\n    final int check \u003d inputStream.read();\r\n    inputStream.reset();\r\n    return check !\u003d -1;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttrDefinitionBands",
    "methodName": "read",
    "signature": "void read(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final int attributeDefinitionCount \u003d header.getAttributeDefinitionCount();\r\n    attributeDefinitionHeader \u003d decodeBandInt(\"attr_definition_headers\", in, Codec.BYTE1, attributeDefinitionCount);\r\n    attributeDefinitionName \u003d parseReferences(\"attr_definition_name\", in, Codec.UNSIGNED5, attributeDefinitionCount, cpUTF8);\r\n    attributeDefinitionLayout \u003d parseReferences(\"attr_definition_layout\", in, Codec.UNSIGNED5, attributeDefinitionCount, cpUTF8);\r\n    attributeDefinitionMap \u003d new AttributeLayoutMap();\r\n    int overflowIndex \u003d 32;\r\n    if (segment.getSegmentHeader().getOptions().hasClassFlagsHi()) {\r\n        overflowIndex \u003d 63;\r\n    }\r\n    for (int i \u003d 0; i \u003c attributeDefinitionCount; i++) {\r\n        final int context \u003d attributeDefinitionHeader[i] \u0026 0x03;\r\n        int index \u003d (attributeDefinitionHeader[i] \u003e\u003e 2) - 1;\r\n        if (index \u003d\u003d -1) {\r\n            index \u003d overflowIndex++;\r\n        }\r\n        final AttributeLayout layout \u003d new AttributeLayout(attributeDefinitionName[i], context, attributeDefinitionLayout[i], index, false);\r\n        final NewAttributeBands newBands \u003d new NewAttributeBands(segment, layout);\r\n        attributeDefinitionMap.add(layout, newBands);\r\n    }\r\n    attributeDefinitionMap.checkMap();\r\n    setupDefaultAttributeNames();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i7 \u003e\u003d i0) → B4 | else → B7",
      "B4 : If(i8 !\u003d $i10) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  AttrDefinitionBands\n  InputStream\n  $r1 \u003d SegmentHeader header\u003e\n  i0 \u003d $r1.getAttributeDefinitionCount()\n  $r3 \u003d BHSDCodec BYTE1\u003e\n  $r4 \u003d r0.decodeBandInt(\"attr_definition_headers\", r2, $r3, i0)\n  AttrDefinitionBands: int[] attributeDefinitionHeader\u003e \u003d $r4\n  $r6 \u003d BHSDCodec UNSIGNED5\u003e\n  $r5 \u003d String[] cpUTF8\u003e\n  $r7 \u003d r0.parseReferences(\"attr_definition_name\", r2, $r6, i0, $r5)\n  String[] attributeDefinitionName\u003e \u003d $r7\n  $r9 \u003d BHSDCodec UNSIGNED5\u003e\n  $r8 \u003d String[] cpUTF8\u003e\n  $r10 \u003d r0.parseReferences(\"attr_definition_layout\", r2, $r9, i0, $r8)\n  String[] attributeDefinitionLayout\u003e \u003d $r10\n  $r26 \u003d AttributeLayoutMap\n  new AttributeLayoutMap()\n  AttributeLayoutMap attributeDefinitionMap\u003e \u003d $r26\n  i6 \u003d 32\n  $r12 \u003d Segment segment\u003e\n  $r13 \u003d $r12.getSegmentHeader()\n  $r14 \u003d $r13.getOptions()\n  $z0 \u003d $r14.hasClassFlagsHi()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  i6 \u003d 63\n}",
      "B2 {\n  i7 \u003d 0\n}",
      "B3 {\n  if (i7 \u003e\u003d i0) goto B4 else B7\n}",
      "B4 {\n  $r16 \u003d AttrDefinitionBands: int[] attributeDefinitionHeader\u003e\n  $i1 \u003d $r16[i7]\n  i2 \u003d $i1 \u0026 3\n  $r17 \u003d AttrDefinitionBands: int[] attributeDefinitionHeader\u003e\n  $i3 \u003d $r17[i7]\n  $i4 \u003d $i3 \u003e\u003e 2\n  i8 \u003d $i4 - 1\n  $i10 \u003d (int) -1\n  if (i8 !\u003d $i10) goto B5 else B6\n}",
      "B5 {\n  $i5 \u003d i6\n  i6 \u003d i6 + 1\n  i8 \u003d $i5\n}",
      "B6 {\n  $r27 \u003d AttributeLayout\n  $r19 \u003d String[] attributeDefinitionName\u003e\n  $r22 \u003d $r19[i7]\n  $r20 \u003d String[] attributeDefinitionLayout\u003e\n  $r21 \u003d $r20[i7]\n  new AttributeLayout($r22, i2, $r21, i8, 0)\n  $r28 \u003d NewAttributeBands\n  $r24 \u003d Segment segment\u003e\n  new NewAttributeBands($r24, $r27)\n  $r25 \u003d AttributeLayoutMap attributeDefinitionMap\u003e\n  $r25.add($r27, $r28)\n  i7 \u003d i7 + 1\n  goto B3\n}",
      "B7 {\n  $r15 \u003d AttributeLayoutMap attributeDefinitionMap\u003e\n  $r15.checkMap()\n  r0.setupDefaultAttributeNames()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AttrDefinitionBands#parseReferences(...5)",
        "body": "(source not found)"
      },
      {
        "name": "AttrDefinitionBands#decodeBandInt(...4)",
        "body": "(source not found)"
      },
      {
        "name": "AttrDefinitionBands#setupDefaultAttributeNames(...0)",
        "body": "{\r\n    //$NON-NLS-1$\r\n    AnnotationDefaultAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"AnnotationDefault\"));\r\n    //$NON-NLS-1$\r\n    CodeAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"Code\"));\r\n    //$NON-NLS-1$\r\n    ConstantValueAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"ConstantValue\"));\r\n    //$NON-NLS-1$\r\n    DeprecatedAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"Deprecated\"));\r\n    //$NON-NLS-1$\r\n    EnclosingMethodAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"EnclosingMethod\"));\r\n    //$NON-NLS-1$\r\n    ExceptionsAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"Exceptions\"));\r\n    //$NON-NLS-1$\r\n    InnerClassesAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"InnerClasses\"));\r\n    //$NON-NLS-1$\r\n    LineNumberTableAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"LineNumberTable\"));\r\n    //$NON-NLS-1$\r\n    LocalVariableTableAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"LocalVariableTable\"));\r\n    //$NON-NLS-1$\r\n    LocalVariableTypeTableAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"LocalVariableTypeTable\"));\r\n    //$NON-NLS-1$\r\n    SignatureAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"Signature\"));\r\n    //$NON-NLS-1$\r\n    SourceFileAttribute.setAttributeName(segment.getCpBands().cpUTF8Value(\"SourceFile\"));\r\n    MetadataBandGroup.setRvaAttributeName(segment.getCpBands().cpUTF8Value(\"RuntimeVisibleAnnotations\"));\r\n    MetadataBandGroup.setRiaAttributeName(segment.getCpBands().cpUTF8Value(\"RuntimeInvisibleAnnotations\"));\r\n    MetadataBandGroup.setRvpaAttributeName(segment.getCpBands().cpUTF8Value(\"RuntimeVisibleParameterAnnotations\"));\r\n    MetadataBandGroup.setRipaAttributeName(segment.getCpBands().cpUTF8Value(\"RuntimeInvisibleParameterAnnotations\"));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayout",
    "methodName": "getCodec",
    "signature": "org.apache.commons.compress.harmony.pack200.Codec getCodec()",
    "visibility": "public",
    "body": "{\r\n    if (layout.indexOf(\u0027O\u0027) \u003e\u003d 0) {\r\n        return Codec.BRANCH5;\r\n    }\r\n    if (layout.indexOf(\u0027P\u0027) \u003e\u003d 0) {\r\n        return Codec.BCI5;\r\n    }\r\n    if (//$NON-NLS-1$\r\n    layout.indexOf(\u0027S\u0027) \u003e\u003d 0 \u0026\u0026 !layout.contains(\"KS\") \u0026\u0026 !layout.contains(\"RS\")) {\r\n        //$NON-NLS-1$\r\n        return Codec.SIGNED5;\r\n    }\r\n    if (layout.indexOf(\u0027B\u0027) \u003e\u003d 0) {\r\n        return Codec.BYTE1;\r\n    }\r\n    return Codec.UNSIGNED5;\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($i1 \u003c 0) → B3 | else → B4",
      "B4 : If($i2 \u003c 0) → B5 | else → B8",
      "B5 : If($z0 !\u003d 0) → B6 | else → B8",
      "B6 : If($z1 !\u003d 0) → B7 | else → B8",
      "B8 : If($i3 \u003c 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  AttributeLayout\n  $r1 \u003d String layout\u003e\n  $i0 \u003d $r1.indexOf(79)\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d BHSDCodec BRANCH5\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d String layout\u003e\n  $i1 \u003d $r2.indexOf(80)\n  if ($i1 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $r9 \u003d BHSDCodec BCI5\u003e\n  return\n}",
      "B4 {\n  $r3 \u003d String layout\u003e\n  $i2 \u003d $r3.indexOf(83)\n  if ($i2 \u003c 0) goto B5 else B8\n}",
      "B5 {\n  $r6 \u003d String layout\u003e\n  $z0 \u003d $r6.contains(\"KS\")\n  if ($z0 !\u003d 0) goto B6 else B8\n}",
      "B6 {\n  $r7 \u003d String layout\u003e\n  $z1 \u003d $r7.contains(\"RS\")\n  if ($z1 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $r8 \u003d BHSDCodec SIGNED5\u003e\n  return\n}",
      "B8 {\n  $r11 \u003d String layout\u003e\n  $i3 \u003d $r11.indexOf(66)\n  if ($i3 \u003c 0) goto B9 else B10\n}",
      "B9 {\n  $r5 \u003d BHSDCodec BYTE1\u003e\n  return\n}",
      "B10 {\n  $r4 \u003d BHSDCodec UNSIGNED5\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayout",
    "methodName": "getValue",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry getValue(long,java.lang.String,org.apache.commons.compress.harmony.unpack200.SegmentConstantPool)",
    "visibility": "public",
    "body": "{\r\n    // TODO This really needs to be better tested, esp. the different types\r\n    // TODO This should have the ability to deal with RUN stuff too, and\r\n    // unions\r\n    if (!layout.startsWith(\"KQ\")) {\r\n        return getValue(layout, longIndex, pool);\r\n    }\r\n    if (type.equals(\"Ljava/lang/String;\")) {\r\n        //$NON-NLS-1$\r\n        return getValue(\"KS\", longIndex, pool);\r\n    }\r\n    return //$NON-NLS-1$\r\n    getValue(//$NON-NLS-1$\r\n    \"K\" + type + layout.substring(2), //$NON-NLS-1$\r\n    longIndex, pool);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  AttributeLayout\n  l0 :\u003d @parameter0: long\n  String\n  SegmentConstantPool\n  $r1 \u003d String layout\u003e\n  $z0 \u003d $r1.startsWith(\"KQ\")\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d String layout\u003e\n  $r14 \u003d AttributeLayout.getValue($r13, l0, r9)\n  return\n}",
      "B2 {\n  $z1 \u003d r2.equals(\"Ljava/lang/String;\")\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d AttributeLayout.getValue(\"KS\", l0, r9)\n  return\n}",
      "B4 {\n  $r3 \u003d StringBuilder\n  new StringBuilder()\n  $r4 \u003d $r3.append(\"K\")\n  $r7 \u003d $r4.append(r2)\n  $r5 \u003d String layout\u003e\n  $r6 \u003d $r5.substring(2)\n  $r8 \u003d $r7.append($r6)\n  $r10 \u003d $r8.toString()\n  $r11 \u003d AttributeLayout.getValue($r10, l0, r9)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AttributeLayout#getValue(...3)",
        "body": "{\r\n    if (layout.startsWith(\"R\")) {\r\n        //$NON-NLS-1$\r\n        // references\r\n        if (layout.indexOf(\u0027N\u0027) !\u003d -1) {\r\n            longIndex--;\r\n        }\r\n        if (layout.startsWith(\"RU\")) {\r\n            //$NON-NLS-1$\r\n            return pool.getValue(SegmentConstantPool.UTF_8, longIndex);\r\n        }\r\n        if (layout.startsWith(\"RS\")) {\r\n            //$NON-NLS-1$\r\n            return pool.getValue(SegmentConstantPool.SIGNATURE, longIndex);\r\n        }\r\n    } else if (layout.startsWith(\"K\")) {\r\n        //$NON-NLS-1$\r\n        final char type \u003d layout.charAt(1);\r\n        switch(type) {\r\n            case // String\r\n            \u0027S\u0027:\r\n                return pool.getValue(SegmentConstantPool.CP_STRING, longIndex);\r\n            // Int (or byte or short)\r\n            case \u0027I\u0027:\r\n            case // Char\r\n            \u0027C\u0027:\r\n                return pool.getValue(SegmentConstantPool.CP_INT, longIndex);\r\n            case // Float\r\n            \u0027F\u0027:\r\n                return pool.getValue(SegmentConstantPool.CP_FLOAT, longIndex);\r\n            case // Long\r\n            \u0027J\u0027:\r\n                return pool.getValue(SegmentConstantPool.CP_LONG, longIndex);\r\n            case // Double\r\n            \u0027D\u0027:\r\n                return pool.getValue(SegmentConstantPool.CP_DOUBLE, longIndex);\r\n        }\r\n    }\r\n    throw new Pack200Exception(\"Unknown layout encoding: \" + layout);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayout",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final int prime \u003d 31;\r\n    int r \u003d 1;\r\n    if (name !\u003d null) {\r\n        r \u003d r * prime + name.hashCode();\r\n    }\r\n    if (layout !\u003d null) {\r\n        r \u003d r * prime + layout.hashCode();\r\n    }\r\n    r \u003d r * prime + index;\r\n    r \u003d r * prime + context;\r\n    return r;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  AttributeLayout\n  i9 \u003d 1\n  $r1 \u003d String name\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d String name\u003e\n  $i8 \u003d $r4.hashCode()\n  i9 \u003d 31 + $i8\n}",
      "B2 {\n  $r2 \u003d String layout\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d i9 * 31\n  $r3 \u003d String layout\u003e\n  $i4 \u003d $r3.hashCode()\n  i9 \u003d $i5 + $i4\n}",
      "B4 {\n  $i1 \u003d i9 * 31\n  $i0 \u003d AttributeLayout: int index\u003e\n  $i6 \u003d $i1 + $i0\n  $i3 \u003d $i6 * 31\n  $i2 \u003d AttributeLayout: int context\u003e\n  $i7 \u003d $i3 + $i2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayout",
    "methodName": "matches",
    "signature": "boolean matches(long)",
    "visibility": "public",
    "body": "{\r\n    return (value \u0026 mask) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($b3 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  AttributeLayout\n  l0 :\u003d @parameter0: long\n  $l1 \u003d AttributeLayout: long mask\u003e\n  $l2 \u003d l0 \u0026 $l1\n  $b3 \u003d $l2 cmp 0L\n  if ($b3 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayout",
    "methodName": "numBackwardsCallables",
    "signature": "int numBackwardsCallables()",
    "visibility": "public",
    "body": "{\r\n    if (\"*\".equals(layout)) {\r\n        return 1;\r\n    }\r\n    return backwardsCallCount;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  AttributeLayout\n  $r2 \u003d \"*\"\n  $r1 \u003d String layout\u003e\n  $z0 \u003d $r2.equals($r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d AttributeLayout: int backwardsCallCount\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayoutMap",
    "methodName": "checkMap",
    "signature": "void checkMap()",
    "visibility": "public",
    "body": "{\r\n    for (final Map\u003cInteger, AttributeLayout\u003e map : layouts) {\r\n        Collection\u003cAttributeLayout\u003e c \u003d map.values();\r\n        if (!(c instanceof List)) {\r\n            c \u003d new ArrayList\u003c\u003e(c);\r\n        }\r\n        final List\u003cAttributeLayout\u003e layouts \u003d (List\u003cAttributeLayout\u003e) c;\r\n        for (int j \u003d 0; j \u003c layouts.size(); j++) {\r\n            final AttributeLayout layout1 \u003d layouts.get(j);\r\n            for (int j2 \u003d j + 1; j2 \u003c layouts.size(); j2++) {\r\n                final AttributeLayout layout2 \u003d layouts.get(j2);\r\n                if (layout1.getName().equals(layout2.getName()) \u0026\u0026 layout1.getLayout().equals(layout2.getLayout())) {\r\n                    throw new Pack200Exception(\"Same layout/name combination: \" + layout1.getLayout() + \"/\" + layout1.getName() + \" exists twice for context: \" + AttributeLayout.contextNames[layout1.getContext()]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
    "nodes": 15,
    "edges": 19,
    "cc": 6,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B14",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B5 : If(i4 \u003e\u003d $i5) → B6 | else → B13",
      "B7 : If(i6 \u003e\u003d $i1) → B8 | else → B12",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B11",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  AttributeLayoutMap\n  r1 \u003d Map[] layouts\u003e\n  i0 \u003d lengthof r1\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B14\n}",
      "B2 {\n  r2 \u003d r1[i3]\n  r26 \u003d r2.values()\n  $z0 \u003d List\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r24 \u003d ArrayList\n  new ArrayList(r26)\n  r26 \u003d $r24\n}",
      "B4 {\n  $r25 \u003d List) r26\n  i4 \u003d 0\n}",
      "B5 {\n  $i5 \u003d $r25.size()\n  if (i4 \u003e\u003d $i5) goto B6 else B13\n}",
      "B6 {\n  $r3 \u003d $r25.get(i4)\n  r4 \u003d AttributeLayout) $r3\n  i6 \u003d i4 + 1\n}",
      "B7 {\n  $i1 \u003d $r25.size()\n  if (i6 \u003e\u003d $i1) goto B8 else B12\n}",
      "B8 {\n  $r5 \u003d $r25.get(i6)\n  r6 \u003d AttributeLayout) $r5\n  $r8 \u003d r4.getName()\n  $r7 \u003d r6.getName()\n  $z1 \u003d $r8.equals($r7)\n  if ($z1 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  $r10 \u003d r4.getLayout()\n  $r9 \u003d r6.getLayout()\n  $z2 \u003d $r10.equals($r9)\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r11 \u003d Pack200Exception\n  $r12 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r12.append(\"Same layout/name combination: \")\n  $r13 \u003d r4.getLayout()\n  $r15 \u003d $r14.append($r13)\n  $r17 \u003d $r15.append(\"/\")\n  $r16 \u003d r4.getName()\n  $r18 \u003d $r17.append($r16)\n  $r21 \u003d $r18.append(\" exists twice for context: \")\n  $r19 \u003d String[] contextNames\u003e\n  $i2 \u003d r4.getContext()\n  $r20 \u003d $r19[$i2]\n  $r22 \u003d $r21.append($r20)\n  $r23 \u003d $r22.toString()\n  new Pack200Exception($r23)\n  throw $r11\n}",
      "B11 {\n  i6 \u003d i6 + 1\n  goto B7\n}",
      "B12 {\n  i4 \u003d i4 + 1\n  goto B5\n}",
      "B13 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B14",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B7",
      "B12 --\u003e B5",
      "B13 --\u003e B1",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.AttributeLayoutMap",
    "methodName": "getAttributeLayout",
    "signature": "org.apache.commons.compress.harmony.unpack200.AttributeLayout getAttributeLayout(java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    final Map\u003cInteger, AttributeLayout\u003e map \u003d getLayout(context);\r\n    for (final AttributeLayout layout : map.values()) {\r\n        if (layout.getName().equals(name)) {\r\n            return layout;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  AttributeLayoutMap\n  String\n  i0 :\u003d @parameter1: int\n  r1 \u003d r0.getLayout(i0)\n  $r2 \u003d r1.values()\n  r3 \u003d $r2.iterator()\n}",
      "B1 {\n  $z0 \u003d r3.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r4 \u003d r3.next()\n  r5 \u003d AttributeLayout) $r4\n  $r7 \u003d r5.getName()\n  $z1 \u003d $r7.equals(r6)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "AttributeLayoutMap#getLayout(...1)",
        "body": "{\r\n    return layouts[context];\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.BcBands",
    "methodName": "read",
    "signature": "void read(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final AttributeLayoutMap attributeDefinitionMap \u003d segment.getAttrDefinitionBands().getAttributeDefinitionMap();\r\n    final int classCount \u003d header.getClassCount();\r\n    final long[][] methodFlags \u003d segment.getClassBands().getMethodFlags();\r\n    int bcCaseCountCount \u003d 0;\r\n    int bcByteCount \u003d 0;\r\n    int bcShortCount \u003d 0;\r\n    int bcLocalCount \u003d 0;\r\n    int bcLabelCount \u003d 0;\r\n    int bcIntRefCount \u003d 0;\r\n    int bcFloatRefCount \u003d 0;\r\n    int bcLongRefCount \u003d 0;\r\n    int bcDoubleRefCount \u003d 0;\r\n    int bcStringRefCount \u003d 0;\r\n    int bcClassRefCount \u003d 0;\r\n    int bcFieldRefCount \u003d 0;\r\n    int bcMethodRefCount \u003d 0;\r\n    int bcIMethodRefCount \u003d 0;\r\n    int bcThisFieldCount \u003d 0;\r\n    int bcSuperFieldCount \u003d 0;\r\n    int bcThisMethodCount \u003d 0;\r\n    int bcSuperMethodCount \u003d 0;\r\n    int bcInitRefCount \u003d 0;\r\n    int bcEscCount \u003d 0;\r\n    int bcEscRefCount \u003d 0;\r\n    final AttributeLayout abstractModifier \u003d attributeDefinitionMap.getAttributeLayout(AttributeLayout.ACC_ABSTRACT, AttributeLayout.CONTEXT_METHOD);\r\n    final AttributeLayout nativeModifier \u003d attributeDefinitionMap.getAttributeLayout(AttributeLayout.ACC_NATIVE, AttributeLayout.CONTEXT_METHOD);\r\n    methodByteCodePacked \u003d new byte[classCount][][];\r\n    final List\u003cBoolean\u003e switchIsTableSwitch \u003d new ArrayList\u003c\u003e();\r\n    wideByteCodes \u003d new ArrayList\u003c\u003e();\r\n    for (int c \u003d 0; c \u003c classCount; c++) {\r\n        final int numberOfMethods \u003d methodFlags[c].length;\r\n        methodByteCodePacked[c] \u003d new byte[numberOfMethods][];\r\n        for (int m \u003d 0; m \u003c numberOfMethods; m++) {\r\n            final long methodFlag \u003d methodFlags[c][m];\r\n            if (!abstractModifier.matches(methodFlag) \u0026\u0026 !nativeModifier.matches(methodFlag)) {\r\n                final ByteArrayOutputStream codeBytes \u003d new ByteArrayOutputStream();\r\n                byte code;\r\n                while ((code \u003d (byte) (0xff \u0026 in.read())) !\u003d -1) {\r\n                    codeBytes.write(code);\r\n                }\r\n                methodByteCodePacked[c][m] \u003d codeBytes.toByteArray();\r\n                final int[] codes \u003d new int[methodByteCodePacked[c][m].length];\r\n                for (int i \u003d 0; i \u003c codes.length; i++) {\r\n                    codes[i] \u003d methodByteCodePacked[c][m][i] \u0026 0xff;\r\n                }\r\n                for (int i \u003d 0; i \u003c methodByteCodePacked[c][m].length; i++) {\r\n                    final int codePacked \u003d 0xff \u0026 methodByteCodePacked[c][m][i];\r\n                    switch(codePacked) {\r\n                        // bipush\r\n                        case 16:\r\n                        case // newarray\r\n                        188:\r\n                            bcByteCount++;\r\n                            break;\r\n                        case // sipush\r\n                        17:\r\n                            bcShortCount++;\r\n                            break;\r\n                        // (a)ldc\r\n                        case 18:\r\n                        case // aldc_w\r\n                        19:\r\n                            bcStringRefCount++;\r\n                            break;\r\n                        // ildc\r\n                        case 234:\r\n                        case // ildc_w\r\n                        237:\r\n                            bcIntRefCount++;\r\n                            break;\r\n                        // fldc\r\n                        case 235:\r\n                        case // fldc_w\r\n                        238:\r\n                            bcFloatRefCount++;\r\n                            break;\r\n                        case // multianewarray\r\n                        197:\r\n                            bcByteCount++;\r\n                        // falls-through\r\n                        // cldc\r\n                        case 233:\r\n                        // cldc_w\r\n                        case 236:\r\n                        // new\r\n                        case 187:\r\n                        // anewarray\r\n                        case 189:\r\n                        // checkcast\r\n                        case 192:\r\n                        case // instanceof\r\n                        193:\r\n                            bcClassRefCount++;\r\n                            break;\r\n                        case // lldc2_w\r\n                        20:\r\n                            bcLongRefCount++;\r\n                            break;\r\n                        case // dldc2_w\r\n                        239:\r\n                            bcDoubleRefCount++;\r\n                            break;\r\n                        case // ret\r\n                        169:\r\n                            bcLocalCount++;\r\n                            break;\r\n                        // goto\r\n                        case 167:\r\n                        // jsr\r\n                        case 168:\r\n                        // goto_w\r\n                        case 200:\r\n                        case // jsr_w\r\n                        201:\r\n                            bcLabelCount++;\r\n                            break;\r\n                        case // tableswitch\r\n                        170:\r\n                            switchIsTableSwitch.add(Boolean.TRUE);\r\n                            bcCaseCountCount++;\r\n                            bcLabelCount++;\r\n                            break;\r\n                        case // lookupswitch\r\n                        171:\r\n                            switchIsTableSwitch.add(Boolean.FALSE);\r\n                            bcCaseCountCount++;\r\n                            bcLabelCount++;\r\n                            break;\r\n                        // getstatic\r\n                        case 178:\r\n                        // putstatic\r\n                        case 179:\r\n                        // getfield\r\n                        case 180:\r\n                        case // putfield\r\n                        181:\r\n                            bcFieldRefCount++;\r\n                            break;\r\n                        // invokevirtual\r\n                        case 182:\r\n                        // invokespecial\r\n                        case 183:\r\n                        case // invokestatic\r\n                        184:\r\n                            bcMethodRefCount++;\r\n                            break;\r\n                        case // invokeinterface\r\n                        185:\r\n                            bcIMethodRefCount++;\r\n                            break;\r\n                        // getstatic_this\r\n                        case 202:\r\n                        // putstatic_this\r\n                        case 203:\r\n                        // getfield_this\r\n                        case 204:\r\n                        // putfield_this\r\n                        case 205:\r\n                        // aload_0_getstatic_this\r\n                        case 209:\r\n                        // aload_0_putstatic_this\r\n                        case 210:\r\n                        // aload_0_putfield_this\r\n                        case 211:\r\n                        case // aload_0_putfield_this\r\n                        212:\r\n                            bcThisFieldCount++;\r\n                            break;\r\n                        // invokevirtual_this\r\n                        case 206:\r\n                        // invokespecial_this\r\n                        case 207:\r\n                        // invokestatic_this\r\n                        case 208:\r\n                        // aload_0_invokevirtual_this\r\n                        case 213:\r\n                        // aload_0_invokespecial_this\r\n                        case 214:\r\n                        case // aload_0_invokestatic_this\r\n                        215:\r\n                            bcThisMethodCount++;\r\n                            break;\r\n                        // getstatic_super\r\n                        case 216:\r\n                        // putstatic_super\r\n                        case 217:\r\n                        // getfield_super\r\n                        case 218:\r\n                        // putfield_super\r\n                        case 219:\r\n                        // aload_0_getstatic_super\r\n                        case 223:\r\n                        // aload_0_putstatic_super\r\n                        case 224:\r\n                        // aload_0_getfield_super\r\n                        case 225:\r\n                        case // aload_0_putfield_super\r\n                        226:\r\n                            bcSuperFieldCount++;\r\n                            break;\r\n                        // invokevirtual_super\r\n                        case 220:\r\n                        // invokespecial_super\r\n                        case 221:\r\n                        // invokestatic_super\r\n                        case 222:\r\n                        // aload_0_invokevirtual_super\r\n                        case 227:\r\n                        // aload_0_invokespecial_super\r\n                        case 228:\r\n                        case // aload_0_invokestatic_super\r\n                        229:\r\n                            bcSuperMethodCount++;\r\n                            break;\r\n                        case // iinc\r\n                        132:\r\n                            bcLocalCount++;\r\n                            bcByteCount++;\r\n                            break;\r\n                        case // wide\r\n                        196:\r\n                            final int nextInstruction \u003d 0xff \u0026 methodByteCodePacked[c][m][i + 1];\r\n                            wideByteCodes.add(Integer.valueOf(nextInstruction));\r\n                            if (nextInstruction \u003d\u003d 132) {\r\n                                // iinc\r\n                                bcLocalCount++;\r\n                                bcShortCount++;\r\n                            } else if (endsWithLoad(nextInstruction) || endsWithStore(nextInstruction) || nextInstruction \u003d\u003d 169) {\r\n                                bcLocalCount++;\r\n                            } else {\r\n                                segment.log(Segment.LOG_LEVEL_VERBOSE, \"Found unhandled \" + ByteCode.getByteCode(nextInstruction));\r\n                            }\r\n                            i++;\r\n                            break;\r\n                        // invokespecial_this_init\r\n                        case 230:\r\n                        // invokespecial_super_init\r\n                        case 231:\r\n                        case // invokespecial_new_init\r\n                        232:\r\n                            bcInitRefCount++;\r\n                            break;\r\n                        case // ref_escape\r\n                        253:\r\n                            bcEscRefCount++;\r\n                            break;\r\n                        case // byte_escape\r\n                        254:\r\n                            bcEscCount++;\r\n                            break;\r\n                        default:\r\n                            if (endsWithLoad(codePacked) || endsWithStore(codePacked)) {\r\n                                bcLocalCount++;\r\n                            } else if (startsWithIf(codePacked)) {\r\n                                bcLabelCount++;\r\n                            }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // other bytecode bands\r\n    bcCaseCount \u003d decodeBandInt(\"bc_case_count\", in, Codec.UNSIGNED5, bcCaseCountCount);\r\n    int bcCaseValueCount \u003d 0;\r\n    for (int i \u003d 0; i \u003c bcCaseCount.length; i++) {\r\n        final boolean isTableSwitch \u003d switchIsTableSwitch.get(i).booleanValue();\r\n        if (isTableSwitch) {\r\n            bcCaseValueCount +\u003d 1;\r\n        } else {\r\n            bcCaseValueCount +\u003d bcCaseCount[i];\r\n        }\r\n    }\r\n    bcCaseValue \u003d decodeBandInt(\"bc_case_value\", in, Codec.DELTA5, bcCaseValueCount);\r\n    // Every case value needs a label. We weren\u0027t able to count these\r\n    // above, because we didn\u0027t know how many cases there were.\r\n    // Have to correct it now.\r\n    for (int index \u003d 0; index \u003c bcCaseCountCount; index++) {\r\n        bcLabelCount +\u003d bcCaseCount[index];\r\n    }\r\n    bcByte \u003d decodeBandInt(\"bc_byte\", in, Codec.BYTE1, bcByteCount);\r\n    bcShort \u003d decodeBandInt(\"bc_short\", in, Codec.DELTA5, bcShortCount);\r\n    bcLocal \u003d decodeBandInt(\"bc_local\", in, Codec.UNSIGNED5, bcLocalCount);\r\n    bcLabel \u003d decodeBandInt(\"bc_label\", in, Codec.BRANCH5, bcLabelCount);\r\n    bcIntRef \u003d decodeBandInt(\"bc_intref\", in, Codec.DELTA5, bcIntRefCount);\r\n    bcFloatRef \u003d decodeBandInt(\"bc_floatref\", in, Codec.DELTA5, bcFloatRefCount);\r\n    bcLongRef \u003d decodeBandInt(\"bc_longref\", in, Codec.DELTA5, bcLongRefCount);\r\n    bcDoubleRef \u003d decodeBandInt(\"bc_doubleref\", in, Codec.DELTA5, bcDoubleRefCount);\r\n    bcStringRef \u003d decodeBandInt(\"bc_stringref\", in, Codec.DELTA5, bcStringRefCount);\r\n    bcClassRef \u003d decodeBandInt(\"bc_classref\", in, Codec.UNSIGNED5, bcClassRefCount);\r\n    bcFieldRef \u003d decodeBandInt(\"bc_fieldref\", in, Codec.DELTA5, bcFieldRefCount);\r\n    bcMethodRef \u003d decodeBandInt(\"bc_methodref\", in, Codec.UNSIGNED5, bcMethodRefCount);\r\n    bcIMethodRef \u003d decodeBandInt(\"bc_imethodref\", in, Codec.DELTA5, bcIMethodRefCount);\r\n    bcThisField \u003d decodeBandInt(\"bc_thisfield\", in, Codec.UNSIGNED5, bcThisFieldCount);\r\n    bcSuperField \u003d decodeBandInt(\"bc_superfield\", in, Codec.UNSIGNED5, bcSuperFieldCount);\r\n    bcThisMethod \u003d decodeBandInt(\"bc_thismethod\", in, Codec.UNSIGNED5, bcThisMethodCount);\r\n    bcSuperMethod \u003d decodeBandInt(\"bc_supermethod\", in, Codec.UNSIGNED5, bcSuperMethodCount);\r\n    bcInitRef \u003d decodeBandInt(\"bc_initref\", in, Codec.UNSIGNED5, bcInitRefCount);\r\n    bcEscRef \u003d decodeBandInt(\"bc_escref\", in, Codec.UNSIGNED5, bcEscRefCount);\r\n    bcEscRefSize \u003d decodeBandInt(\"bc_escrefsize\", in, Codec.UNSIGNED5, bcEscRefCount);\r\n    bcEscSize \u003d decodeBandInt(\"bc_escsize\", in, Codec.UNSIGNED5, bcEscCount);\r\n    bcEscByte \u003d decodeBandInt(\"bc_escbyte\", in, Codec.BYTE1, bcEscSize);\r\n}",
    "nodes": 65,
    "edges": 106,
    "cc": 43,
    "flowSummary": [
      "B1 : If(i39 \u003e\u003d i0) → B2 | else → B55",
      "B3 : If(i41 \u003e\u003d i40) → B4 | else → B54",
      "B4 : If($z0 !\u003d 0) → B5 | else → B53",
      "B5 : If($z1 !\u003d 0) → B6 | else → B53",
      "B7 : If($i47 \u003d\u003d $i49) → B8 | else → B9",
      "B10 : If(i42 \u003e\u003d $i9) → B11 | else → B12",
      "B13 : If(i43 \u003e\u003d $i10) → B14 | else → B53",
      "B14 : If(switch-on $i54) → B15 | else → B16",
      "B36 : If($i57 !\u003d 132) → B37 | else → B38",
      "B38 : If($z2 !\u003d 0) → B39 | else → B41",
      "B39 : If($z3 !\u003d 0) → B40 | else → B41",
      "B40 : If($i60 !\u003d 169) → B41 | else → B42",
      "B47 : If($z4 !\u003d 0) → B48 | else → B49",
      "B48 : If($z5 \u003d\u003d false) → B49 | else → B50",
      "B50 : If($z6 \u003d\u003d false) → B51 | else → B52",
      "B56 : If(i45 \u003e\u003d $i1) → B57 | else → B61",
      "B57 : If(z7 \u003d\u003d false) → B58 | else → B59",
      "B62 : If(i46 \u003e\u003d i18) → B63 | else → B64"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  InputStream\n  $r1 \u003d Segment segment\u003e\n  $r2 \u003d $r1.getAttrDefinitionBands()\n  r3 \u003d $r2.getAttributeDefinitionMap()\n  $r4 \u003d SegmentHeader header\u003e\n  i0 \u003d $r4.getClassCount()\n  $r5 \u003d Segment segment\u003e\n  $r6 \u003d $r5.getClassBands()\n  r7 \u003d $r6.getMethodFlags()\n  i18 \u003d 0\n  i19 \u003d 0\n  i20 \u003d 0\n  i21 \u003d 0\n  i22 \u003d 0\n  i23 \u003d 0\n  i24 \u003d 0\n  i25 \u003d 0\n  i26 \u003d 0\n  i27 \u003d 0\n  i28 \u003d 0\n  i29 \u003d 0\n  i30 \u003d 0\n  i31 \u003d 0\n  i32 \u003d 0\n  i33 \u003d 0\n  i34 \u003d 0\n  i35 \u003d 0\n  i36 \u003d 0\n  i37 \u003d 0\n  i38 \u003d 0\n  r8 \u003d r3.getAttributeLayout(\"ACC_ABSTRACT\", 2)\n  r9 \u003d r3.getAttributeLayout(\"ACC_NATIVE\", 2)\n  $r10 \u003d newarray (byte[][])[i0]\n  BcBands: byte[][][] methodByteCodePacked\u003e \u003d $r10\n  $r102 \u003d ArrayList\n  new ArrayList()\n  $r103 \u003d ArrayList\n  new ArrayList()\n  List wideByteCodes\u003e \u003d $r103\n  i39 \u003d 0\n}",
      "B1 {\n  if (i39 \u003e\u003d i0) goto B2 else B55\n}",
      "B2 {\n  $r68 \u003d r7[i39]\n  i40 \u003d lengthof $r68\n  $r70 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r69 \u003d newarray (byte[])[i40]\n  $r70[i39] \u003d $r69\n  i41 \u003d 0\n}",
      "B3 {\n  if (i41 \u003e\u003d i40) goto B4 else B54\n}",
      "B4 {\n  $r71 \u003d r7[i39]\n  l4 \u003d $r71[i41]\n  $z0 \u003d r8.matches(l4)\n  if ($z0 !\u003d 0) goto B5 else B53\n}",
      "B5 {\n  $z1 \u003d r9.matches(l4)\n  if ($z1 !\u003d 0) goto B6 else B53\n}",
      "B6 {\n  $r104 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n}",
      "B7 {\n  $i5 \u003d r13.read()\n  $i6 \u003d 255 \u0026 $i5\n  $b7 \u003d (byte) $i6\n  $i47 \u003d (int) $b7\n  $i49 \u003d (int) -1\n  if ($i47 \u003d\u003d $i49) goto B8 else B9\n}",
      "B8 {\n  $i50 \u003d (int) $b7\n  $r104.write($i50)\n  goto B7\n}",
      "B9 {\n  $r73 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r74 \u003d $r73[i39]\n  $r75 \u003d $r104.toByteArray()\n  $r74[i41] \u003d $r75\n  $r76 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r77 \u003d $r76[i39]\n  $r78 \u003d $r77[i41]\n  $i8 \u003d lengthof $r78\n  r79 \u003d newarray (int)[$i8]\n  i42 \u003d 0\n}",
      "B10 {\n  $i9 \u003d lengthof r79\n  if (i42 \u003e\u003d $i9) goto B11 else B12\n}",
      "B11 {\n  $r99 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r100 \u003d $r99[i39]\n  $r101 \u003d $r100[i41]\n  $b16 \u003d $r101[i42]\n  $s51 \u003d (short) $b16\n  $s17 \u003d $s51 \u0026 255\n  $i52 \u003d (int) $s17\n  r79[i42] \u003d $i52\n  i42 \u003d i42 + 1\n  goto B10\n}",
      "B12 {\n  i43 \u003d 0\n}",
      "B13 {\n  $r80 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r81 \u003d $r80[i39]\n  $r82 \u003d $r81[i41]\n  $i10 \u003d lengthof $r82\n  if (i43 \u003e\u003d $i10) goto B14 else B53\n}",
      "B14 {\n  $r83 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r84 \u003d $r83[i39]\n  $r85 \u003d $r84[i41]\n  $b11 \u003d $r85[i43]\n  $s53 \u003d (short) $b11\n  s12 \u003d 255 \u0026 $s53\n  $i54 \u003d (int) s12\n  BcBands: byte[][][] methodByteCodePacked\u003e;     case 197: goto i19 \u003d i19 + 1;     case 198: goto $i62 \u003d (int) s12;     case 199: goto $i62 \u003d (int) s12;     case 200: goto i22 \u003d i22 + 1;     case 201: goto i22 \u003d i22 + 1;     case 202: goto i32 \u003d i32 + 1;     case 203: goto i32 \u003d i32 + 1;     case 204: goto i32 \u003d i32 + 1;     case 205: goto i32 \u003d i32 + 1;     case 206: goto i34 \u003d i34 + 1;     case 207: goto i34 \u003d i34 + 1;     case 208: goto i34 \u003d i34 + 1;     case 209: goto i32 \u003d i32 + 1;     case 210: goto i32 \u003d i32 + 1;     case 211: goto i32 \u003d i32 + 1;     case 212: goto i32 \u003d i32 + 1;     case 213: goto i34 \u003d i34 + 1;     case 214: goto i34 \u003d i34 + 1;     case 215: goto i34 \u003d i34 + 1;     case 216: goto i33 \u003d i33 + 1;     case 217: goto i33 \u003d i33 + 1;     case 218: goto i33 \u003d i33 + 1;     case 219: goto i33 \u003d i33 + 1;     case 220: goto i35 \u003d i35 + 1;     case 221: goto i35 \u003d i35 + 1;     case 222: goto i35 \u003d i35 + 1;     case 223: goto i33 \u003d i33 + 1;     case 224: goto i33 \u003d i33 + 1;     case 225: goto i33 \u003d i33 + 1;     case 226: goto i33 \u003d i33 + 1;     case 227: goto i35 \u003d i35 + 1;     case 228: goto i35 \u003d i35 + 1;     case 229: goto i35 \u003d i35 + 1;     case 230: goto i36 \u003d i36 + 1;     case 231: goto i36 \u003d i36 + 1;     case 232: goto i36 \u003d i36 + 1;     case 233: goto i28 \u003d i28 + 1;     case 234: goto i23 \u003d i23 + 1;     case 235: goto i24 \u003d i24 + 1;     case 236: goto i28 \u003d i28 + 1;     case 237: goto i23 \u003d i23 + 1;     case 238: goto i24 \u003d i24 + 1;     case 239: goto i26 \u003d i26 + 1;     case 240: goto $i62 \u003d (int) s12;     case 241: goto $i62 \u003d (int) s12;     case 242: goto $i62 \u003d (int) s12;     case 243: goto $i62 \u003d (int) s12;     case 244: goto $i62 \u003d (int) s12;     case 245: goto $i62 \u003d (int) s12;     case 246: goto $i62 \u003d (int) s12;     case 247: goto $i62 \u003d (int) s12;     case 248: goto $i62 \u003d (int) s12;     case 249: goto $i62 \u003d (int) s12;     case 250: goto $i62 \u003d (int) s12;     case 251: goto $i62 \u003d (int) s12;     case 252: goto $i62 \u003d (int) s12;     case 253: goto i38 \u003d i38 + 1;     case 254: goto i37 \u003d i37 + 1;     default: goto $i62 \u003d (int) s12; }\n}",
      "B15 {\n  i19 \u003d i19 + 1\n  goto B52\n}",
      "B16 {\n  i20 \u003d i20 + 1\n  goto B52\n}",
      "B17 {\n  i27 \u003d i27 + 1\n  goto B52\n}",
      "B18 {\n  i23 \u003d i23 + 1\n  goto B52\n}",
      "B19 {\n  i24 \u003d i24 + 1\n  goto B52\n}",
      "B20 {\n  i19 \u003d i19 + 1\n}",
      "B21 {\n  i28 \u003d i28 + 1\n  goto B52\n}",
      "B22 {\n  i25 \u003d i25 + 1\n  goto B52\n}",
      "B23 {\n  i26 \u003d i26 + 1\n  goto B52\n}",
      "B24 {\n  i21 \u003d i21 + 1\n  goto B52\n}",
      "B25 {\n  i22 \u003d i22 + 1\n  goto B52\n}",
      "B26 {\n  $r98 \u003d Boolean TRUE\u003e\n  $r102.add($r98)\n  i18 \u003d i18 + 1\n  i22 \u003d i22 + 1\n  goto B52\n}",
      "B27 {\n  $r97 \u003d Boolean FALSE\u003e\n  $r102.add($r97)\n  i18 \u003d i18 + 1\n  i22 \u003d i22 + 1\n  goto B52\n}",
      "B28 {\n  i29 \u003d i29 + 1\n  goto B52\n}",
      "B29 {\n  i30 \u003d i30 + 1\n  goto B52\n}",
      "B30 {\n  i31 \u003d i31 + 1\n  goto B52\n}",
      "B31 {\n  i32 \u003d i32 + 1\n  goto B52\n}",
      "B32 {\n  i34 \u003d i34 + 1\n  goto B52\n}",
      "B33 {\n  i33 \u003d i33 + 1\n  goto B52\n}",
      "B34 {\n  i35 \u003d i35 + 1\n  goto B52\n}",
      "B35 {\n  i21 \u003d i21 + 1\n  i19 \u003d i19 + 1\n  goto B52\n}",
      "B36 {\n  $r86 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r87 \u003d $r86[i39]\n  $r88 \u003d $r87[i41]\n  $i13 \u003d i43 + 1\n  $b14 \u003d $r88[$i13]\n  $s55 \u003d (short) $b14\n  s15 \u003d 255 \u0026 $s55\n  $r89 \u003d List wideByteCodes\u003e\n  $i56 \u003d (int) s15\n  $r90 \u003d Integer.valueOf($i56)\n  $r89.add($r90)\n  $i57 \u003d (int) s15\n  if ($i57 !\u003d 132) goto B37 else B38\n}",
      "B37 {\n  i21 \u003d i21 + 1\n  i20 \u003d i20 + 1\n  goto B43\n}",
      "B38 {\n  $i58 \u003d (int) s15\n  $z2 \u003d r0.endsWithLoad($i58)\n  if ($z2 !\u003d 0) goto B39 else B41\n}",
      "B39 {\n  $i59 \u003d (int) s15\n  $z3 \u003d r0.endsWithStore($i59)\n  if ($z3 !\u003d 0) goto B40 else B41\n}",
      "B40 {\n  $i60 \u003d (int) s15\n  if ($i60 !\u003d 169) goto B41 else B42\n}",
      "B41 {\n  i21 \u003d i21 + 1\n  goto B43\n}",
      "B42 {\n  $r92 \u003d Segment segment\u003e\n  $r105 \u003d StringBuilder\n  new StringBuilder()\n  $r94 \u003d $r105.append(\"Found unhandled \")\n  $i61 \u003d (int) s15\n  $r93 \u003d ByteCode.getByteCode($i61)\n  $r95 \u003d $r94.append($r93)\n  $r96 \u003d $r95.toString()\n  $r92.log(2, $r96)\n}",
      "B43 {\n  i43 \u003d i43 + 1\n  goto B52\n}",
      "B44 {\n  i36 \u003d i36 + 1\n  goto B52\n}",
      "B45 {\n  i38 \u003d i38 + 1\n  goto B52\n}",
      "B46 {\n  i37 \u003d i37 + 1\n  goto B52\n}",
      "B47 {\n  $i62 \u003d (int) s12\n  $z4 \u003d r0.endsWithLoad($i62)\n  if ($z4 !\u003d 0) goto B48 else B49\n}",
      "B48 {\n  $i63 \u003d (int) s12\n  $z5 \u003d r0.endsWithStore($i63)\n  if ($z5 \u003d\u003d false) goto B49 else B50\n}",
      "B49 {\n  i21 \u003d i21 + 1\n  goto B52\n}",
      "B50 {\n  $i64 \u003d (int) s12\n  $z6 \u003d r0.startsWithIf($i64)\n  if ($z6 \u003d\u003d false) goto B51 else B52\n}",
      "B51 {\n  i22 \u003d i22 + 1\n}",
      "B52 {\n  i43 \u003d i43 + 1\n  goto B13\n}",
      "B53 {\n  i41 \u003d i41 + 1\n  goto B3\n}",
      "B54 {\n  i39 \u003d i39 + 1\n  goto B1\n}",
      "B55 {\n  $r14 \u003d BHSDCodec UNSIGNED5\u003e\n  $r15 \u003d r0.decodeBandInt(\"bc_case_count\", r13, $r14, i18)\n  BcBands: int[] bcCaseCount\u003e \u003d $r15\n  i44 \u003d 0\n  i45 \u003d 0\n}",
      "B56 {\n  $r16 \u003d BcBands: int[] bcCaseCount\u003e\n  $i1 \u003d lengthof $r16\n  if (i45 \u003e\u003d $i1) goto B57 else B61\n}",
      "B57 {\n  $r65 \u003d $r102.get(i45)\n  $r66 \u003d Boolean) $r65\n  z7 \u003d $r66.booleanValue()\n  if (z7 \u003d\u003d false) goto B58 else B59\n}",
      "B58 {\n  i44 \u003d i44 + 1\n  goto B60\n}",
      "B59 {\n  $r67 \u003d BcBands: int[] bcCaseCount\u003e\n  $i3 \u003d $r67[i45]\n  i44 \u003d i44 + $i3\n}",
      "B60 {\n  i45 \u003d i45 + 1\n  goto B56\n}",
      "B61 {\n  $r17 \u003d BHSDCodec DELTA5\u003e\n  $r18 \u003d r0.decodeBandInt(\"bc_case_value\", r13, $r17, i44)\n  BcBands: int[] bcCaseValue\u003e \u003d $r18\n  i46 \u003d 0\n}",
      "B62 {\n  if (i46 \u003e\u003d i18) goto B63 else B64\n}",
      "B63 {\n  $r64 \u003d BcBands: int[] bcCaseCount\u003e\n  $i2 \u003d $r64[i46]\n  i22 \u003d i22 + $i2\n  i46 \u003d i46 + 1\n  goto B62\n}",
      "B64 {\n  $r19 \u003d BHSDCodec BYTE1\u003e\n  $r20 \u003d r0.decodeBandInt(\"bc_byte\", r13, $r19, i19)\n  BcBands: int[] bcByte\u003e \u003d $r20\n  $r21 \u003d BHSDCodec DELTA5\u003e\n  $r22 \u003d r0.decodeBandInt(\"bc_short\", r13, $r21, i20)\n  BcBands: int[] bcShort\u003e \u003d $r22\n  $r23 \u003d BHSDCodec UNSIGNED5\u003e\n  $r24 \u003d r0.decodeBandInt(\"bc_local\", r13, $r23, i21)\n  BcBands: int[] bcLocal\u003e \u003d $r24\n  $r25 \u003d BHSDCodec BRANCH5\u003e\n  $r26 \u003d r0.decodeBandInt(\"bc_label\", r13, $r25, i22)\n  BcBands: int[] bcLabel\u003e \u003d $r26\n  $r27 \u003d BHSDCodec DELTA5\u003e\n  $r28 \u003d r0.decodeBandInt(\"bc_intref\", r13, $r27, i23)\n  BcBands: int[] bcIntRef\u003e \u003d $r28\n  $r29 \u003d BHSDCodec DELTA5\u003e\n  $r30 \u003d r0.decodeBandInt(\"bc_floatref\", r13, $r29, i24)\n  BcBands: int[] bcFloatRef\u003e \u003d $r30\n  $r31 \u003d BHSDCodec DELTA5\u003e\n  $r32 \u003d r0.decodeBandInt(\"bc_longref\", r13, $r31, i25)\n  BcBands: int[] bcLongRef\u003e \u003d $r32\n  $r33 \u003d BHSDCodec DELTA5\u003e\n  $r34 \u003d r0.decodeBandInt(\"bc_doubleref\", r13, $r33, i26)\n  BcBands: int[] bcDoubleRef\u003e \u003d $r34\n  $r35 \u003d BHSDCodec DELTA5\u003e\n  $r36 \u003d r0.decodeBandInt(\"bc_stringref\", r13, $r35, i27)\n  BcBands: int[] bcStringRef\u003e \u003d $r36\n  $r37 \u003d BHSDCodec UNSIGNED5\u003e\n  $r38 \u003d r0.decodeBandInt(\"bc_classref\", r13, $r37, i28)\n  BcBands: int[] bcClassRef\u003e \u003d $r38\n  $r39 \u003d BHSDCodec DELTA5\u003e\n  $r40 \u003d r0.decodeBandInt(\"bc_fieldref\", r13, $r39, i29)\n  BcBands: int[] bcFieldRef\u003e \u003d $r40\n  $r41 \u003d BHSDCodec UNSIGNED5\u003e\n  $r42 \u003d r0.decodeBandInt(\"bc_methodref\", r13, $r41, i30)\n  BcBands: int[] bcMethodRef\u003e \u003d $r42\n  $r43 \u003d BHSDCodec DELTA5\u003e\n  $r44 \u003d r0.decodeBandInt(\"bc_imethodref\", r13, $r43, i31)\n  BcBands: int[] bcIMethodRef\u003e \u003d $r44\n  $r45 \u003d BHSDCodec UNSIGNED5\u003e\n  $r46 \u003d r0.decodeBandInt(\"bc_thisfield\", r13, $r45, i32)\n  BcBands: int[] bcThisField\u003e \u003d $r46\n  $r47 \u003d BHSDCodec UNSIGNED5\u003e\n  $r48 \u003d r0.decodeBandInt(\"bc_superfield\", r13, $r47, i33)\n  BcBands: int[] bcSuperField\u003e \u003d $r48\n  $r49 \u003d BHSDCodec UNSIGNED5\u003e\n  $r50 \u003d r0.decodeBandInt(\"bc_thismethod\", r13, $r49, i34)\n  BcBands: int[] bcThisMethod\u003e \u003d $r50\n  $r51 \u003d BHSDCodec UNSIGNED5\u003e\n  $r52 \u003d r0.decodeBandInt(\"bc_supermethod\", r13, $r51, i35)\n  BcBands: int[] bcSuperMethod\u003e \u003d $r52\n  $r53 \u003d BHSDCodec UNSIGNED5\u003e\n  $r54 \u003d r0.decodeBandInt(\"bc_initref\", r13, $r53, i36)\n  BcBands: int[] bcInitRef\u003e \u003d $r54\n  $r55 \u003d BHSDCodec UNSIGNED5\u003e\n  $r56 \u003d r0.decodeBandInt(\"bc_escref\", r13, $r55, i38)\n  BcBands: int[] bcEscRef\u003e \u003d $r56\n  $r57 \u003d BHSDCodec UNSIGNED5\u003e\n  $r58 \u003d r0.decodeBandInt(\"bc_escrefsize\", r13, $r57, i38)\n  BcBands: int[] bcEscRefSize\u003e \u003d $r58\n  $r59 \u003d BHSDCodec UNSIGNED5\u003e\n  $r60 \u003d r0.decodeBandInt(\"bc_escsize\", r13, $r59, i37)\n  BcBands: int[] bcEscSize\u003e \u003d $r60\n  $r62 \u003d BHSDCodec BYTE1\u003e\n  $r61 \u003d BcBands: int[] bcEscSize\u003e\n  $r63 \u003d r0.decodeBandInt(\"bc_escbyte\", r13, $r62, $r61)\n  BcBands: int[][] bcEscByte\u003e \u003d $r63\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B55",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B54",
      "B4 --\u003e B5",
      "B4 --\u003e B53",
      "B5 --\u003e B6",
      "B5 --\u003e B53",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B53",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B14 --\u003e B17",
      "B14 --\u003e B22",
      "B14 --\u003e B47",
      "B14 --\u003e B35",
      "B14 --\u003e B25",
      "B14 --\u003e B24",
      "B14 --\u003e B26",
      "B14 --\u003e B27",
      "B14 --\u003e B28",
      "B14 --\u003e B29",
      "B14 --\u003e B30",
      "B14 --\u003e B21",
      "B14 --\u003e B36",
      "B14 --\u003e B20",
      "B14 --\u003e B31",
      "B14 --\u003e B32",
      "B14 --\u003e B33",
      "B14 --\u003e B34",
      "B14 --\u003e B44",
      "B14 --\u003e B18",
      "B14 --\u003e B19",
      "B14 --\u003e B23",
      "B14 --\u003e B45",
      "B14 --\u003e B46",
      "B15 --\u003e B52",
      "B16 --\u003e B52",
      "B17 --\u003e B52",
      "B18 --\u003e B52",
      "B19 --\u003e B52",
      "B20 --\u003e B21",
      "B21 --\u003e B52",
      "B22 --\u003e B52",
      "B23 --\u003e B52",
      "B24 --\u003e B52",
      "B25 --\u003e B52",
      "B26 --\u003e B52",
      "B27 --\u003e B52",
      "B28 --\u003e B52",
      "B29 --\u003e B52",
      "B30 --\u003e B52",
      "B31 --\u003e B52",
      "B32 --\u003e B52",
      "B33 --\u003e B52",
      "B34 --\u003e B52",
      "B35 --\u003e B52",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e B43",
      "B38 --\u003e B39",
      "B38 --\u003e B41",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e B41",
      "B40 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B43",
      "B43 --\u003e B52",
      "B44 --\u003e B52",
      "B45 --\u003e B52",
      "B46 --\u003e B52",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B48 --\u003e B50",
      "B49 --\u003e B52",
      "B50 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B13",
      "B53 --\u003e B3",
      "B54 --\u003e B1",
      "B55 --\u003e B56",
      "B56 --\u003e B57",
      "B56 --\u003e B61",
      "B57 --\u003e B58",
      "B57 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B56",
      "B61 --\u003e B62",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B62",
      "B64 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BcBands#startsWithIf(...1)",
        "body": "{\r\n    return codePacked \u003e\u003d 153 \u0026\u0026 codePacked \u003c\u003d 166 || codePacked \u003d\u003d 198 || codePacked \u003d\u003d 199;\r\n}"
      },
      {
        "name": "BcBands#endsWithStore(...1)",
        "body": "{\r\n    return codePacked \u003e\u003d 54 \u0026\u0026 codePacked \u003c\u003d 58;\r\n}"
      },
      {
        "name": "BcBands#decodeBandInt(...4)",
        "body": "(source not found)"
      },
      {
        "name": "BcBands#endsWithLoad(...1)",
        "body": "{\r\n    return codePacked \u003e\u003d 21 \u0026\u0026 codePacked \u003c\u003d 25;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.BcBands",
    "methodName": "unpack",
    "signature": "void unpack()",
    "visibility": "public",
    "body": "{\r\n    final int classCount \u003d header.getClassCount();\r\n    final long[][] methodFlags \u003d segment.getClassBands().getMethodFlags();\r\n    final int[] codeMaxNALocals \u003d segment.getClassBands().getCodeMaxNALocals();\r\n    final int[] codeMaxStack \u003d segment.getClassBands().getCodeMaxStack();\r\n    final ArrayList\u003cAttribute\u003e[][] methodAttributes \u003d segment.getClassBands().getMethodAttributes();\r\n    final String[][] methodDescr \u003d segment.getClassBands().getMethodDescr();\r\n    final AttributeLayoutMap attributeDefinitionMap \u003d segment.getAttrDefinitionBands().getAttributeDefinitionMap();\r\n    final AttributeLayout abstractModifier \u003d attributeDefinitionMap.getAttributeLayout(AttributeLayout.ACC_ABSTRACT, AttributeLayout.CONTEXT_METHOD);\r\n    final AttributeLayout nativeModifier \u003d attributeDefinitionMap.getAttributeLayout(AttributeLayout.ACC_NATIVE, AttributeLayout.CONTEXT_METHOD);\r\n    final AttributeLayout staticModifier \u003d attributeDefinitionMap.getAttributeLayout(AttributeLayout.ACC_STATIC, AttributeLayout.CONTEXT_METHOD);\r\n    final int[] wideByteCodeArray \u003d new int[wideByteCodes.size()];\r\n    for (int index \u003d 0; index \u003c wideByteCodeArray.length; index++) {\r\n        wideByteCodeArray[index] \u003d wideByteCodes.get(index).intValue();\r\n    }\r\n    final OperandManager operandManager \u003d new OperandManager(bcCaseCount, bcCaseValue, bcByte, bcShort, bcLocal, bcLabel, bcIntRef, bcFloatRef, bcLongRef, bcDoubleRef, bcStringRef, bcClassRef, bcFieldRef, bcMethodRef, bcIMethodRef, bcThisField, bcSuperField, bcThisMethod, bcSuperMethod, bcInitRef, wideByteCodeArray);\r\n    operandManager.setSegment(segment);\r\n    int i \u003d 0;\r\n    final ArrayList\u003cList\u003cAttribute\u003e\u003e orderedCodeAttributes \u003d segment.getClassBands().getOrderedCodeAttributes();\r\n    int codeAttributeIndex \u003d 0;\r\n    // Exception table fields\r\n    final int[] handlerCount \u003d segment.getClassBands().getCodeHandlerCount();\r\n    final int[][] handlerStartPCs \u003d segment.getClassBands().getCodeHandlerStartP();\r\n    final int[][] handlerEndPCs \u003d segment.getClassBands().getCodeHandlerEndPO();\r\n    final int[][] handlerCatchPCs \u003d segment.getClassBands().getCodeHandlerCatchPO();\r\n    final int[][] handlerClassTypes \u003d segment.getClassBands().getCodeHandlerClassRCN();\r\n    final boolean allCodeHasFlags \u003d segment.getSegmentHeader().getOptions().hasAllCodeFlags();\r\n    final boolean[] codeHasFlags \u003d segment.getClassBands().getCodeHasAttributes();\r\n    for (int c \u003d 0; c \u003c classCount; c++) {\r\n        final int numberOfMethods \u003d methodFlags[c].length;\r\n        for (int m \u003d 0; m \u003c numberOfMethods; m++) {\r\n            final long methodFlag \u003d methodFlags[c][m];\r\n            if (!abstractModifier.matches(methodFlag) \u0026\u0026 !nativeModifier.matches(methodFlag)) {\r\n                final int maxStack \u003d codeMaxStack[i];\r\n                int maxLocal \u003d codeMaxNALocals[i];\r\n                if (!staticModifier.matches(methodFlag)) {\r\n                    // one for \u0027this\u0027 parameter\r\n                    maxLocal++;\r\n                }\r\n                // I believe this has to take wide arguments into account\r\n                maxLocal +\u003d SegmentUtils.countInvokeInterfaceArgs(methodDescr[c][m]);\r\n                final String[] cpClass \u003d segment.getCpBands().getCpClass();\r\n                operandManager.setCurrentClass(cpClass[segment.getClassBands().getClassThisInts()[c]]);\r\n                operandManager.setSuperClass(cpClass[segment.getClassBands().getClassSuperInts()[c]]);\r\n                final List\u003cExceptionTableEntry\u003e exceptionTable \u003d new ArrayList\u003c\u003e();\r\n                if (handlerCount !\u003d null) {\r\n                    for (int j \u003d 0; j \u003c handlerCount[i]; j++) {\r\n                        final int handlerClass \u003d handlerClassTypes[i][j] - 1;\r\n                        CPClass cpHandlerClass \u003d null;\r\n                        if (handlerClass !\u003d -1) {\r\n                            // The handlerClass will be null if the\r\n                            // catch is a finally (that is, the\r\n                            // exception table catch_type should be 0\r\n                            cpHandlerClass \u003d segment.getCpBands().cpClassValue(handlerClass);\r\n                        }\r\n                        final ExceptionTableEntry entry \u003d new ExceptionTableEntry(handlerStartPCs[i][j], handlerEndPCs[i][j], handlerCatchPCs[i][j], cpHandlerClass);\r\n                        exceptionTable.add(entry);\r\n                    }\r\n                }\r\n                final CodeAttribute codeAttr \u003d new CodeAttribute(maxStack, maxLocal, methodByteCodePacked[c][m], segment, operandManager, exceptionTable);\r\n                final List\u003cAttribute\u003e methodAttributesList \u003d methodAttributes[c][m];\r\n                // Make sure we add the code attribute in the right place\r\n                int indexForCodeAttr \u003d 0;\r\n                for (final Attribute attribute : methodAttributesList) {\r\n                    if (!(attribute instanceof NewAttribute) || ((NewAttribute) attribute).getLayoutIndex() \u003e\u003d 15) {\r\n                        break;\r\n                    }\r\n                    indexForCodeAttr++;\r\n                }\r\n                methodAttributesList.add(indexForCodeAttr, codeAttr);\r\n                codeAttr.renumber(codeAttr.byteCodeOffsets);\r\n                final List\u003cAttribute\u003e currentAttributes;\r\n                if (allCodeHasFlags) {\r\n                    currentAttributes \u003d orderedCodeAttributes.get(i);\r\n                } else if (codeHasFlags[i]) {\r\n                    currentAttributes \u003d orderedCodeAttributes.get(codeAttributeIndex);\r\n                    codeAttributeIndex++;\r\n                } else {\r\n                    currentAttributes \u003d Collections.EMPTY_LIST;\r\n                }\r\n                for (final Attribute currentAttribute : currentAttributes) {\r\n                    codeAttr.addAttribute(currentAttribute);\r\n                    // Fix up the line numbers if needed\r\n                    if (currentAttribute.hasBCIRenumbering()) {\r\n                        ((BCIRenumberedAttribute) currentAttribute).renumber(codeAttr.byteCodeOffsets);\r\n                    }\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n}",
    "nodes": 37,
    "edges": 52,
    "cc": 17,
    "flowSummary": [
      "B1 : If(i17 \u003e\u003d $i2) → B2 | else → B3",
      "B4 : If(i20 \u003e\u003d i0) → B5 | else → B36",
      "B6 : If(i21 \u003e\u003d i3) → B7 | else → B35",
      "B7 : If($z1 !\u003d 0) → B8 | else → B34",
      "B8 : If($z2 !\u003d 0) → B9 | else → B34",
      "B9 : If($z3 !\u003d 0) → B10 | else → B11",
      "B11 : If(r52 \u003d\u003d null) → B12 | else → B17",
      "B13 : If(i23 \u003e\u003d $i10) → B14 | else → B17",
      "B14 : If(i24 \u003d\u003d $i27) → B15 | else → B16",
      "B18 : If($z7 \u003d\u003d false) → B19 | else → B23",
      "B19 : If($z6 \u003d\u003d false) → B20 | else → B23",
      "B20 : If($i9 \u003c 15) → B21 | else → B22",
      "B23 : If(z0 \u003d\u003d false) → B24 | else → B25",
      "B25 : If($z4 \u003d\u003d false) → B26 | else → B27",
      "B29 : If($z8 \u003d\u003d false) → B30 | else → B33",
      "B30 : If($z5 \u003d\u003d false) → B31 | else → B32"
    ],
    "blockList": [
      "B0 {\n  BcBands\n  $r1 \u003d SegmentHeader header\u003e\n  i0 \u003d $r1.getClassCount()\n  $r2 \u003d Segment segment\u003e\n  $r3 \u003d $r2.getClassBands()\n  r4 \u003d $r3.getMethodFlags()\n  $r5 \u003d Segment segment\u003e\n  $r6 \u003d $r5.getClassBands()\n  r7 \u003d $r6.getCodeMaxNALocals()\n  $r8 \u003d Segment segment\u003e\n  $r9 \u003d $r8.getClassBands()\n  r10 \u003d $r9.getCodeMaxStack()\n  $r11 \u003d Segment segment\u003e\n  $r12 \u003d $r11.getClassBands()\n  r13 \u003d $r12.getMethodAttributes()\n  $r14 \u003d Segment segment\u003e\n  $r15 \u003d $r14.getClassBands()\n  r16 \u003d $r15.getMethodDescr()\n  $r17 \u003d Segment segment\u003e\n  $r18 \u003d $r17.getAttrDefinitionBands()\n  r19 \u003d $r18.getAttributeDefinitionMap()\n  r20 \u003d r19.getAttributeLayout(\"ACC_ABSTRACT\", 2)\n  r21 \u003d r19.getAttributeLayout(\"ACC_NATIVE\", 2)\n  r22 \u003d r19.getAttributeLayout(\"ACC_STATIC\", 2)\n  $r23 \u003d List wideByteCodes\u003e\n  $i1 \u003d $r23.size()\n  r24 \u003d newarray (int)[$i1]\n  i17 \u003d 0\n}",
      "B1 {\n  $i2 \u003d lengthof r24\n  if (i17 \u003e\u003d $i2) goto B2 else B3\n}",
      "B2 {\n  $r110 \u003d List wideByteCodes\u003e\n  $r111 \u003d $r110.get(i17)\n  $r112 \u003d Integer) $r111\n  $i16 \u003d $r112.intValue()\n  r24[i17] \u003d $i16\n  i17 \u003d i17 + 1\n  goto B1\n}",
      "B3 {\n  $r118 \u003d OperandManager\n  $r45 \u003d BcBands: int[] bcCaseCount\u003e\n  $r44 \u003d BcBands: int[] bcCaseValue\u003e\n  $r43 \u003d BcBands: int[] bcByte\u003e\n  $r42 \u003d BcBands: int[] bcShort\u003e\n  $r41 \u003d BcBands: int[] bcLocal\u003e\n  $r40 \u003d BcBands: int[] bcLabel\u003e\n  $r39 \u003d BcBands: int[] bcIntRef\u003e\n  $r38 \u003d BcBands: int[] bcFloatRef\u003e\n  $r37 \u003d BcBands: int[] bcLongRef\u003e\n  $r36 \u003d BcBands: int[] bcDoubleRef\u003e\n  $r35 \u003d BcBands: int[] bcStringRef\u003e\n  $r34 \u003d BcBands: int[] bcClassRef\u003e\n  $r33 \u003d BcBands: int[] bcFieldRef\u003e\n  $r32 \u003d BcBands: int[] bcMethodRef\u003e\n  $r31 \u003d BcBands: int[] bcIMethodRef\u003e\n  $r30 \u003d BcBands: int[] bcThisField\u003e\n  $r29 \u003d BcBands: int[] bcSuperField\u003e\n  $r28 \u003d BcBands: int[] bcThisMethod\u003e\n  $r27 \u003d BcBands: int[] bcSuperMethod\u003e\n  $r26 \u003d BcBands: int[] bcInitRef\u003e\n  new OperandManager($r45, $r44, $r43, $r42, $r41, $r40, $r39, $r38, $r37, $r36, $r35, $r34, $r33, $r32, $r31, $r30, $r29, $r28, $r27, $r26, r24)\n  $r46 \u003d Segment segment\u003e\n  $r118.setSegment($r46)\n  i18 \u003d 0\n  $r47 \u003d Segment segment\u003e\n  $r48 \u003d $r47.getClassBands()\n  r49 \u003d $r48.getOrderedCodeAttributes()\n  i19 \u003d 0\n  $r50 \u003d Segment segment\u003e\n  $r51 \u003d $r50.getClassBands()\n  r52 \u003d $r51.getCodeHandlerCount()\n  $r53 \u003d Segment segment\u003e\n  $r54 \u003d $r53.getClassBands()\n  r55 \u003d $r54.getCodeHandlerStartP()\n  $r56 \u003d Segment segment\u003e\n  $r57 \u003d $r56.getClassBands()\n  r58 \u003d $r57.getCodeHandlerEndPO()\n  $r59 \u003d Segment segment\u003e\n  $r60 \u003d $r59.getClassBands()\n  r61 \u003d $r60.getCodeHandlerCatchPO()\n  $r62 \u003d Segment segment\u003e\n  $r63 \u003d $r62.getClassBands()\n  r64 \u003d $r63.getCodeHandlerClassRCN()\n  $r65 \u003d Segment segment\u003e\n  $r66 \u003d $r65.getSegmentHeader()\n  $r67 \u003d $r66.getOptions()\n  z0 \u003d $r67.hasAllCodeFlags()\n  $r68 \u003d Segment segment\u003e\n  $r69 \u003d $r68.getClassBands()\n  r70 \u003d $r69.getCodeHasAttributes()\n  i20 \u003d 0\n}",
      "B4 {\n  if (i20 \u003e\u003d i0) goto B5 else B36\n}",
      "B5 {\n  $r71 \u003d r4[i20]\n  i3 \u003d lengthof $r71\n  i21 \u003d 0\n}",
      "B6 {\n  if (i21 \u003e\u003d i3) goto B7 else B35\n}",
      "B7 {\n  $r72 \u003d r4[i20]\n  l4 \u003d $r72[i21]\n  $z1 \u003d r20.matches(l4)\n  if ($z1 !\u003d 0) goto B8 else B34\n}",
      "B8 {\n  $z2 \u003d r21.matches(l4)\n  if ($z2 !\u003d 0) goto B9 else B34\n}",
      "B9 {\n  i5 \u003d r10[i18]\n  i22 \u003d r7[i18]\n  $z3 \u003d r22.matches(l4)\n  if ($z3 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  i22 \u003d i22 + 1\n}",
      "B11 {\n  $r73 \u003d r16[i20]\n  $r74 \u003d $r73[i21]\n  $i6 \u003d SegmentUtils.countInvokeInterfaceArgs($r74)\n  $i15 \u003d i22 + $i6\n  $r75 \u003d Segment segment\u003e\n  $r76 \u003d $r75.getCpBands()\n  $r109 \u003d $r76.getCpClass()\n  $r77 \u003d Segment segment\u003e\n  $r78 \u003d $r77.getClassBands()\n  $r79 \u003d $r78.getClassThisInts()\n  $i7 \u003d $r79[i20]\n  $r80 \u003d $r109[$i7]\n  $r118.setCurrentClass($r80)\n  $r81 \u003d Segment segment\u003e\n  $r82 \u003d $r81.getClassBands()\n  $r83 \u003d $r82.getClassSuperInts()\n  $i8 \u003d $r83[i20]\n  $r84 \u003d $r109[$i8]\n  $r118.setSuperClass($r84)\n  $r119 \u003d ArrayList\n  new ArrayList()\n  if (r52 \u003d\u003d null) goto B12 else B17\n}",
      "B12 {\n  i23 \u003d 0\n}",
      "B13 {\n  $i10 \u003d r52[i18]\n  if (i23 \u003e\u003d $i10) goto B14 else B17\n}",
      "B14 {\n  $r102 \u003d r64[i18]\n  $i11 \u003d $r102[i23]\n  i24 \u003d $i11 - 1\n  r113 \u003d null\n  $i27 \u003d (int) -1\n  if (i24 \u003d\u003d $i27) goto B15 else B16\n}",
      "B15 {\n  $r107 \u003d Segment segment\u003e\n  $r108 \u003d $r107.getCpBands()\n  r113 \u003d $r108.cpClassValue(i24)\n}",
      "B16 {\n  $r120 \u003d ExceptionTableEntry\n  $r104 \u003d r55[i18]\n  $i14 \u003d $r104[i23]\n  $r105 \u003d r58[i18]\n  $i13 \u003d $r105[i23]\n  $r106 \u003d r61[i18]\n  $i12 \u003d $r106[i23]\n  new ExceptionTableEntry($i14, $i13, $i12, r113)\n  $r119.add($r120)\n  i23 \u003d i23 + 1\n  goto B13\n}",
      "B17 {\n  $r121 \u003d CodeAttribute\n  $r87 \u003d BcBands: byte[][][] methodByteCodePacked\u003e\n  $r88 \u003d $r87[i20]\n  $r90 \u003d $r88[i21]\n  $r89 \u003d Segment segment\u003e\n  new CodeAttribute(i5, $i15, $r90, $r89, $r118, $r119)\n  $r91 \u003d r13[i20]\n  $r100 \u003d $r91[i21]\n  i25 \u003d 0\n  $r101 \u003d $r100.iterator()\n}",
      "B18 {\n  $z7 \u003d $r101.hasNext()\n  if ($z7 \u003d\u003d false) goto B19 else B23\n}",
      "B19 {\n  $r98 \u003d $r101.next()\n  r114 \u003d Attribute) $r98\n  $z6 \u003d NewAttribute\n  if ($z6 \u003d\u003d false) goto B20 else B23\n}",
      "B20 {\n  $r99 \u003d NewAttribute) r114\n  $i9 \u003d $r99.getLayoutIndex()\n  if ($i9 \u003c 15) goto B21 else B22\n}",
      "B21 {\n  goto B23\n}",
      "B22 {\n  i25 \u003d i25 + 1\n  goto B18\n}",
      "B23 {\n  $r100.add(i25, $r121)\n  $r115 \u003d List byteCodeOffsets\u003e\n  $r121.renumber($r115)\n  if (z0 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $r97 \u003d r49.get(i18)\n  r116 \u003d List) $r97\n  goto B28\n}",
      "B25 {\n  $z4 \u003d r70[i18]\n  if ($z4 \u003d\u003d false) goto B26 else B27\n}",
      "B26 {\n  $r96 \u003d r49.get(i19)\n  r116 \u003d List) $r96\n  i19 \u003d i19 + 1\n  goto B28\n}",
      "B27 {\n  r116 \u003d List EMPTY_LIST\u003e\n}",
      "B28 {\n  $r117 \u003d r116.iterator()\n}",
      "B29 {\n  $z8 \u003d $r117.hasNext()\n  if ($z8 \u003d\u003d false) goto B30 else B33\n}",
      "B30 {\n  $r92 \u003d $r117.next()\n  r93 \u003d Attribute) $r92\n  $r121.addAttribute(r93)\n  $z5 \u003d r93.hasBCIRenumbering()\n  if ($z5 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  $r95 \u003d BCIRenumberedAttribute) r93\n  $r94 \u003d List byteCodeOffsets\u003e\n  $r95.renumber($r94)\n}",
      "B32 {\n  goto B29\n}",
      "B33 {\n  i18 \u003d i18 + 1\n}",
      "B34 {\n  i21 \u003d i21 + 1\n  goto B6\n}",
      "B35 {\n  i20 \u003d i20 + 1\n  goto B4\n}",
      "B36 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B36",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B35",
      "B7 --\u003e B8",
      "B7 --\u003e B34",
      "B8 --\u003e B9",
      "B8 --\u003e B34",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B17",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B13",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B23",
      "B19 --\u003e B20",
      "B19 --\u003e B23",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B18",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B29 --\u003e B33",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B29",
      "B33 --\u003e B34",
      "B34 --\u003e B6",
      "B35 --\u003e B4",
      "B36 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.AnnotationDefaultAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return this \u003d\u003d obj;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  AnnotationDefaultAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "getByteCode",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode getByteCode(int)",
    "visibility": "public",
    "body": "{\r\n    final int byteOpcode \u003d 0xFF \u0026 opcode;\r\n    if (ByteCodeForm.get(byteOpcode).hasNoOperand()) {\r\n        if (null \u003d\u003d noArgByteCodes[byteOpcode]) {\r\n            noArgByteCodes[byteOpcode] \u003d new ByteCode(byteOpcode);\r\n        }\r\n        return noArgByteCodes[byteOpcode];\r\n    }\r\n    return new ByteCode(byteOpcode);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B4",
      "B1 : If(null !\u003d $r3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  i1 \u003d 255 \u0026 i0\n  $r0 \u003d ByteCodeForm.get(i1)\n  $z0 \u003d $r0.hasNoOperand()\n  if ($z0 \u003d\u003d false) goto B1 else B4\n}",
      "B1 {\n  $r2 \u003d ByteCode[] noArgByteCodes\u003e\n  $r3 \u003d $r2[i1]\n  if (null !\u003d $r3) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d ByteCode[] noArgByteCodes\u003e\n  $r6 \u003d ByteCode\n  new ByteCode(i1)\n  $r7[i1] \u003d $r6\n}",
      "B3 {\n  $r4 \u003d ByteCode[] noArgByteCodes\u003e\n  $r5 \u003d $r4[i1]\n  return\n}",
      "B4 {\n  $r1 \u003d ByteCode\n  new ByteCode(i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return this \u003d\u003d obj;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteCode\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "setOperand2Bytes",
    "signature": "void setOperand2Bytes(int,int)",
    "visibility": "public",
    "body": "{\r\n    final int firstOperandIndex \u003d getByteCodeForm().firstOperandIndex();\r\n    final int byteCodeFormLength \u003d getByteCodeForm().getRewrite().length;\r\n    if (firstOperandIndex \u003c 1) {\r\n        // No operand rewriting permitted for this bytecode\r\n        throw new Error(\"Trying to rewrite \" + this + \" that has no rewrite\");\r\n    }\r\n    if (firstOperandIndex + position + 1 \u003e byteCodeFormLength) {\r\n        throw new Error(\"Trying to rewrite \" + this + \" with an int at position \" + position + \" but this won\u0027t fit in the rewrite array\");\r\n    }\r\n    rewrite[firstOperandIndex + position] \u003d (operand \u0026 0xFF00) \u003e\u003e 8;\r\n    rewrite[firstOperandIndex + position + 1] \u003d operand \u0026 0xFF;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If($i4 \u003c\u003d i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteCode\n  i5 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  $r1 \u003d r0.getByteCodeForm()\n  i0 \u003d $r1.firstOperandIndex()\n  $r2 \u003d r0.getByteCodeForm()\n  $r3 \u003d $r2.getRewrite()\n  i1 \u003d lengthof $r3\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r21 \u003d Error\n  $r20 \u003d StringBuilder\n  new StringBuilder()\n  $r16 \u003d $r20.append(\"Trying to rewrite \")\n  $r17 \u003d $r16.append(r0)\n  $r18 \u003d $r17.append(\" that has no rewrite\")\n  $r19 \u003d $r18.toString()\n  new Error($r19)\n  throw $r21\n}",
      "B2 {\n  $i3 \u003d i0 + i2\n  $i4 \u003d $i3 + 1\n  if ($i4 \u003c\u003d i1) goto B3 else B4\n}",
      "B3 {\n  $r23 \u003d Error\n  $r22 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r22.append(\"Trying to rewrite \")\n  $r9 \u003d $r8.append(r0)\n  $r10 \u003d $r9.append(\" with an int at position \")\n  $r11 \u003d $r10.append(i2)\n  $r12 \u003d $r11.append(\" but this won\\\u0027t fit in the rewrite array\")\n  $r13 \u003d $r12.toString()\n  new Error($r13)\n  throw $r23\n}",
      "B4 {\n  $r4 \u003d ByteCode: int[] rewrite\u003e\n  $i8 \u003d i0 + i2\n  $i13 \u003d (int) 65280\n  $i6 \u003d i5 \u0026 $i13\n  $i7 \u003d $i6 \u003e\u003e 8\n  $r4[$i8] \u003d $i7\n  $r5 \u003d ByteCode: int[] rewrite\u003e\n  $i9 \u003d i0 + i2\n  $i11 \u003d $i9 + 1\n  $i10 \u003d i5 \u0026 255\n  $r5[$i11] \u003d $i10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteCode#getByteCodeForm(...0)",
        "body": "{\r\n    return byteCodeForm;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "setOperandByte",
    "signature": "void setOperandByte(int,int)",
    "visibility": "public",
    "body": "{\r\n    final int firstOperandIndex \u003d getByteCodeForm().firstOperandIndex();\r\n    final int byteCodeFormLength \u003d getByteCodeForm().operandLength();\r\n    if (firstOperandIndex \u003c 1) {\r\n        // No operand rewriting permitted for this bytecode\r\n        throw new Error(\"Trying to rewrite \" + this + \" that has no rewrite\");\r\n    }\r\n    if (firstOperandIndex + position \u003e byteCodeFormLength) {\r\n        throw new Error(\"Trying to rewrite \" + this + \" with an byte at position \" + position + \" but this won\u0027t fit in the rewrite array\");\r\n    }\r\n    rewrite[firstOperandIndex + position] \u003d operand \u0026 0xFF;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If($i3 \u003c\u003d i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteCode\n  i4 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  $r1 \u003d r0.getByteCodeForm()\n  i0 \u003d $r1.firstOperandIndex()\n  $r2 \u003d r0.getByteCodeForm()\n  i1 \u003d $r2.operandLength()\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d Error\n  $r13 \u003d StringBuilder\n  new StringBuilder()\n  $r14 \u003d $r13.append(\"Trying to rewrite \")\n  $r15 \u003d $r14.append(r0)\n  $r16 \u003d $r15.append(\" that has no rewrite\")\n  $r17 \u003d $r16.toString()\n  new Error($r17)\n  throw $r12\n}",
      "B2 {\n  $i3 \u003d i0 + i2\n  if ($i3 \u003c\u003d i1) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d Error\n  $r5 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r5.append(\"Trying to rewrite \")\n  $r7 \u003d $r6.append(r0)\n  $r8 \u003d $r7.append(\" with an byte at position \")\n  $r9 \u003d $r8.append(i2)\n  $r10 \u003d $r9.append(\" but this won\\\u0027t fit in the rewrite array\")\n  $r11 \u003d $r10.toString()\n  new Error($r11)\n  throw $r4\n}",
      "B4 {\n  $r3 \u003d ByteCode: int[] rewrite\u003e\n  $i6 \u003d i0 + i2\n  $i5 \u003d i4 \u0026 255\n  $r3[$i6] \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteCode#getByteCodeForm(...0)",
        "body": "{\r\n    return byteCodeForm;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "setOperandBytes",
    "signature": "void setOperandBytes(int[])",
    "visibility": "public",
    "body": "{\r\n    final int firstOperandIndex \u003d getByteCodeForm().firstOperandIndex();\r\n    final int byteCodeFormLength \u003d getByteCodeForm().operandLength();\r\n    if (firstOperandIndex \u003c 1) {\r\n        // No operand rewriting permitted for this bytecode\r\n        throw new Error(\"Trying to rewrite \" + this + \" that has no rewrite\");\r\n    }\r\n    if (byteCodeFormLength !\u003d operands.length) {\r\n        throw new Error(\"Trying to rewrite \" + this + \" with \" + operands.length + \" but bytecode has length \" + byteCodeForm.operandLength());\r\n    }\r\n    for (int index \u003d 0; index \u003c byteCodeFormLength; index++) {\r\n        rewrite[index + firstOperandIndex] \u003d operands[index] \u0026 0xFF;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If(i1 \u003d\u003d $i2) → B3 | else → B4",
      "B5 : If(i8 \u003e\u003d i1) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ByteCode\n  r3 :\u003d @parameter0: int[]\n  $r1 \u003d r0.getByteCodeForm()\n  i0 \u003d $r1.firstOperandIndex()\n  $r2 \u003d r0.getByteCodeForm()\n  i1 \u003d $r2.operandLength()\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d Error\n  $r16 \u003d StringBuilder\n  new StringBuilder()\n  $r17 \u003d $r16.append(\"Trying to rewrite \")\n  $r18 \u003d $r17.append(r0)\n  $r19 \u003d $r18.append(\" that has no rewrite\")\n  $r20 \u003d $r19.toString()\n  new Error($r20)\n  throw $r15\n}",
      "B2 {\n  $i2 \u003d lengthof r3\n  if (i1 \u003d\u003d $i2) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d Error\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"Trying to rewrite \")\n  $r8 \u003d $r7.append(r0)\n  $r9 \u003d $r8.append(\" with \")\n  $i6 \u003d lengthof r3\n  $r10 \u003d $r9.append($i6)\n  $r12 \u003d $r10.append(\" but bytecode has length \")\n  $r11 \u003d ByteCodeForm byteCodeForm\u003e\n  $i7 \u003d $r11.operandLength()\n  $r13 \u003d $r12.append($i7)\n  $r14 \u003d $r13.toString()\n  new Error($r14)\n  throw $r5\n}",
      "B4 {\n  i8 \u003d 0\n}",
      "B5 {\n  if (i8 \u003e\u003d i1) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d ByteCode: int[] rewrite\u003e\n  $i5 \u003d i8 + i0\n  $i3 \u003d r3[i8]\n  $i4 \u003d $i3 \u0026 255\n  $r4[$i5] \u003d $i4\n  i8 \u003d i8 + 1\n  goto B5\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteCode#getByteCodeForm(...0)",
        "body": "{\r\n    return byteCodeForm;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode",
    "methodName": "setOperandSigned2Bytes",
    "signature": "void setOperandSigned2Bytes(int,int)",
    "visibility": "public",
    "body": "{\r\n    if (operand \u003e\u003d 0) {\r\n        setOperand2Bytes(operand, position);\r\n    } else {\r\n        final int twosComplementOperand \u003d 0x10000 + operand;\r\n        setOperand2Bytes(twosComplementOperand, position);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteCode\n  i0 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  if (i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.setOperand2Bytes(i0, i2)\n  goto B3\n}",
      "B2 {\n  i1 \u003d 65536 + i0\n  r0.setOperand2Bytes(i1, i2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteCode#setOperand2Bytes(...2)",
        "body": "{\r\n    final int firstOperandIndex \u003d getByteCodeForm().firstOperandIndex();\r\n    final int byteCodeFormLength \u003d getByteCodeForm().getRewrite().length;\r\n    if (firstOperandIndex \u003c 1) {\r\n        // No operand rewriting permitted for this bytecode\r\n        throw new Error(\"Trying to rewrite \" + this + \" that has no rewrite\");\r\n    }\r\n    if (firstOperandIndex + position + 1 \u003e byteCodeFormLength) {\r\n        throw new Error(\"Trying to rewrite \" + this + \" with an int at position \" + position + \" but this won\u0027t fit in the rewrite array\");\r\n    }\r\n    rewrite[firstOperandIndex + position] \u003d (operand \u0026 0xFF00) \u003e\u003e 8;\r\n    rewrite[firstOperandIndex + position + 1] \u003d operand \u0026 0xFF;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool",
    "methodName": "add",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry add(org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry)",
    "visibility": "public",
    "body": "{\r\n    if (entry instanceof ByteCode) {\r\n        return null;\r\n    }\r\n    if (entry instanceof ConstantPoolEntry) {\r\n        if (entriesContainsSet.add(entry)) {\r\n            entries.add(entry);\r\n        }\r\n    } else if (othersContainsSet.add(entry)) {\r\n        others.add(entry);\r\n    }\r\n    return entry;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z3 \u003d\u003d false) → B4 | else → B7",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ClassConstantPool\n  ClassFileEntry\n  $z0 \u003d ByteCode\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z1 \u003d ConstantPoolEntry\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r4 \u003d HashSet entriesContainsSet\u003e\n  $z3 \u003d $r4.add(r0)\n  if ($z3 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  $r5 \u003d List entries\u003e\n  $r5.add(r0)\n  goto B7\n}",
      "B5 {\n  $r2 \u003d HashSet othersContainsSet\u003e\n  $z2 \u003d $r2.add(r0)\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r3 \u003d List others\u003e\n  $r3.add(r0)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool",
    "methodName": "addNestedEntries",
    "signature": "void addNestedEntries()",
    "visibility": "public",
    "body": "{\r\n    boolean added \u003d true;\r\n    // initial assignment\r\n    final List\u003cClassFileEntry\u003e parents \u003d new ArrayList\u003c\u003e(512);\r\n    final List\u003cClassFileEntry\u003e children \u003d new ArrayList\u003c\u003e(512);\r\n    // adding old entries\r\n    parents.addAll(entries);\r\n    parents.addAll(others);\r\n    // while there any parents to traverse and at least one change in target\r\n    // storage was made\r\n    while (added || parents.size() \u003e 0) {\r\n        children.clear();\r\n        final int entriesOriginalSize \u003d entries.size();\r\n        final int othersOriginalSize \u003d others.size();\r\n        // get the parents\u0027 children and add them to buffer\r\n        // concurrently add parents to target storage\r\n        for (int indexParents \u003d 0; indexParents \u003c parents.size(); indexParents++) {\r\n            final ClassFileEntry entry \u003d parents.get(indexParents);\r\n            // traverse children\r\n            final ClassFileEntry[] entryChildren \u003d entry.getNestedClassFileEntries();\r\n            children.addAll(Arrays.asList(entryChildren));\r\n            final boolean isAtStart \u003d entry instanceof ByteCode \u0026\u0026 ((ByteCode) entry).nestedMustStartClassPool();\r\n            if (isAtStart) {\r\n                mustStartClassPool.addAll(Arrays.asList(entryChildren));\r\n            }\r\n            // add parent\r\n            add(entry);\r\n        }\r\n        added \u003d !(entries.size() \u003d\u003d entriesOriginalSize \u0026\u0026 others.size() \u003d\u003d othersOriginalSize);\r\n        // parents are not needed anymore\r\n        // children now become parents\r\n        parents.clear();\r\n        parents.addAll(children);\r\n    }\r\n}",
    "nodes": 18,
    "edges": 25,
    "cc": 9,
    "flowSummary": [
      "B1 : If(z2 !\u003d 0) → B2 | else → B3",
      "B2 : If($i2 \u003c\u003d 0) → B3 | else → B17",
      "B4 : If(i5 \u003e\u003d $i6) → B5 | else → B12",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11",
      "B12 : If($i0 !\u003d $i3) → B13 | else → B14",
      "B13 : If($i1 \u003d\u003d $i4) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  ClassConstantPool\n  z2 \u003d 1\n  $r0 \u003d ArrayList\n  new ArrayList(512)\n  $r1 \u003d ArrayList\n  new ArrayList(512)\n  $r3 \u003d List entries\u003e\n  $r0.addAll($r3)\n  $r4 \u003d List others\u003e\n  $r0.addAll($r4)\n}",
      "B1 {\n  if (z2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d $r0.size()\n  if ($i2 \u003c\u003d 0) goto B3 else B17\n}",
      "B3 {\n  $r1.clear()\n  $r5 \u003d List entries\u003e\n  $i3 \u003d $r5.size()\n  $r6 \u003d List others\u003e\n  $i4 \u003d $r6.size()\n  i5 \u003d 0\n}",
      "B4 {\n  $i6 \u003d $r0.size()\n  if (i5 \u003e\u003d $i6) goto B5 else B12\n}",
      "B5 {\n  $r9 \u003d $r0.get(i5)\n  r10 \u003d ClassFileEntry) $r9\n  r11 \u003d r10.getNestedClassFileEntries()\n  $r12 \u003d Arrays.asList(r11)\n  $r1.addAll($r12)\n  $z0 \u003d ByteCode\n  if ($z0 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r15 \u003d ByteCode) r10\n  $z1 \u003d $r15.nestedMustStartClassPool()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z3 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z3 \u003d 0\n}",
      "B9 {\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r13 \u003d HashSet mustStartClassPool\u003e\n  $r14 \u003d Arrays.asList(r11)\n  $r13.addAll($r14)\n}",
      "B11 {\n  r2.add(r10)\n  i5 \u003d i5 + 1\n  goto B4\n}",
      "B12 {\n  $r7 \u003d List entries\u003e\n  $i0 \u003d $r7.size()\n  if ($i0 !\u003d $i3) goto B13 else B14\n}",
      "B13 {\n  $r8 \u003d List others\u003e\n  $i1 \u003d $r8.size()\n  if ($i1 \u003d\u003d $i4) goto B14 else B15\n}",
      "B14 {\n  $z4 \u003d 1\n  goto B16\n}",
      "B15 {\n  $z4 \u003d 0\n}",
      "B16 {\n  z2 \u003d $z4\n  $r0.clear()\n  $r0.addAll($r1)\n  goto B1\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B17",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B12",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B4",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B1",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassConstantPool#add(...1)",
        "body": "{\r\n    if (entry instanceof ByteCode) {\r\n        return null;\r\n    }\r\n    if (entry instanceof ConstantPoolEntry) {\r\n        if (entriesContainsSet.add(entry)) {\r\n            entries.add(entry);\r\n        }\r\n    } else if (othersContainsSet.add(entry)) {\r\n        others.add(entry);\r\n    }\r\n    return entry;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool",
    "methodName": "addWithNestedEntries",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry addWithNestedEntries(org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry)",
    "visibility": "public",
    "body": "{\r\n    add(entry);\r\n    for (final ClassFileEntry nestedEntry : entry.getNestedClassFileEntries()) {\r\n        addWithNestedEntries(nestedEntry);\r\n    }\r\n    return entry;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ClassConstantPool\n  ClassFileEntry\n  r0.add(r1)\n  r2 \u003d r1.getNestedClassFileEntries()\n  i0 \u003d lengthof r2\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r3 \u003d r2[i1]\n  r0.addWithNestedEntries(r3)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ClassConstantPool#addWithNestedEntries(...1)",
        "body": "{\r\n    add(entry);\r\n    for (final ClassFileEntry nestedEntry : entry.getNestedClassFileEntries()) {\r\n        addWithNestedEntries(nestedEntry);\r\n    }\r\n    return entry;\r\n}"
      },
      {
        "name": "ClassConstantPool#add(...1)",
        "body": "{\r\n    if (entry instanceof ByteCode) {\r\n        return null;\r\n    }\r\n    if (entry instanceof ConstantPoolEntry) {\r\n        if (entriesContainsSet.add(entry)) {\r\n            entries.add(entry);\r\n        }\r\n    } else if (othersContainsSet.add(entry)) {\r\n        others.add(entry);\r\n    }\r\n    return entry;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool",
    "methodName": "get",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry get(int)",
    "visibility": "public",
    "body": "{\r\n    if (!resolved) {\r\n        throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\r\n    }\r\n    return entries.get(--i);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ClassConstantPool\n  i0 :\u003d @parameter0: int\n  $z0 \u003d ClassConstantPool: boolean resolved\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalStateException\n  new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\")\n  throw $r5\n}",
      "B2 {\n  $r1 \u003d List entries\u003e\n  $i3 \u003d (int) -1\n  i1 \u003d i0 + $i3\n  $r2 \u003d $r1.get(i1)\n  $r3 \u003d ClassFileEntry) $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool",
    "methodName": "indexOf",
    "signature": "int indexOf(org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry)",
    "visibility": "public",
    "body": "{\r\n    if (!resolved) {\r\n        throw new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\");\r\n    }\r\n    if (null \u003d\u003d indexCache) {\r\n        throw new IllegalStateException(\"Index cache is not initialized!\");\r\n    }\r\n    final Integer entryIndex \u003d indexCache.get(entry);\r\n    // If the entry isn\u0027t found, answer -1, otherwise answer the entry.\r\n    if (entryIndex !\u003d null) {\r\n        return entryIndex.intValue() + 1;\r\n    }\r\n    return -1;\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(null !\u003d $r1) → B3 | else → B4",
      "B4 : If(r5 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ClassConstantPool\n  ClassFileEntry\n  $z0 \u003d ClassConstantPool: boolean resolved\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d IllegalStateException\n  new IllegalStateException(\"Constant pool is not yet resolved; this does not make any sense\")\n  throw $r8\n}",
      "B2 {\n  $r1 \u003d Map indexCache\u003e\n  if (null !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  $r9 \u003d IllegalStateException\n  new IllegalStateException(\"Index cache is not initialized!\")\n  throw $r9\n}",
      "B4 {\n  $r3 \u003d Map indexCache\u003e\n  $r4 \u003d $r3.get(r2)\n  r5 \u003d Integer) $r4\n  if (r5 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $i0 \u003d r5.intValue()\n  $i1 \u003d $i0 + 1\n  return\n}",
      "B6 {\n  $i3 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFile",
    "methodName": "write",
    "signature": "void write(java.io.DataOutputStream)",
    "visibility": "public",
    "body": "{\r\n    dos.writeInt(MAGIC);\r\n    dos.writeShort(minor);\r\n    dos.writeShort(major);\r\n    dos.writeShort(pool.size() + 1);\r\n    for (int i \u003d 1; i \u003c\u003d pool.size(); i++) {\r\n        final ConstantPoolEntry entry;\r\n        (entry \u003d (ConstantPoolEntry) pool.get(i)).doWrite(dos);\r\n        // Doubles and longs take up two spaces in the pool, but only one\r\n        // gets written\r\n        if (entry.getTag() \u003d\u003d ConstantPoolEntry.CP_Double || entry.getTag() \u003d\u003d ConstantPoolEntry.CP_Long) {\r\n            i++;\r\n        }\r\n    }\r\n    dos.writeShort(accessFlags);\r\n    dos.writeShort(thisClass);\r\n    dos.writeShort(superClass);\r\n    dos.writeShort(interfaces.length);\r\n    for (final int element : interfaces) {\r\n        dos.writeShort(element);\r\n    }\r\n    dos.writeShort(fields.length);\r\n    for (final ClassFileEntry field : fields) {\r\n        field.write(dos);\r\n    }\r\n    dos.writeShort(methods.length);\r\n    for (final ClassFileEntry method : methods) {\r\n        method.write(dos);\r\n    }\r\n    dos.writeShort(attributes.length);\r\n    for (final Attribute attribute : attributes) {\r\n        attribute.write(dos);\r\n    }\r\n}",
    "nodes": 19,
    "edges": 25,
    "cc": 8,
    "flowSummary": [
      "B1 : If(i14 \u003e $i4) → B2 | else → B6",
      "B2 : If($i24 \u003d\u003d 6) → B3 | else → B4",
      "B3 : If($i25 !\u003d 5) → B4 | else → B5",
      "B7 : If(i16 \u003e\u003d i15) → B8 | else → B9",
      "B10 : If(i19 \u003e\u003d i18) → B11 | else → B12",
      "B13 : If(i21 \u003e\u003d i20) → B14 | else → B15",
      "B16 : If(i23 \u003e\u003d i22) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  ClassFile\n  DataOutputStream\n  r0.writeInt(-889275714)\n  $i0 \u003d ClassFile: int minor\u003e\n  r0.writeShort($i0)\n  $i1 \u003d ClassFile: int major\u003e\n  r0.writeShort($i1)\n  $r2 \u003d ClassConstantPool pool\u003e\n  $i2 \u003d $r2.size()\n  $i3 \u003d $i2 + 1\n  r0.writeShort($i3)\n  i14 \u003d 1\n}",
      "B1 {\n  $r3 \u003d ClassConstantPool pool\u003e\n  $i4 \u003d $r3.size()\n  if (i14 \u003e $i4) goto B2 else B6\n}",
      "B2 {\n  $r8 \u003d ClassConstantPool pool\u003e\n  $r9 \u003d $r8.get(i14)\n  $r10 \u003d ConstantPoolEntry) $r9\n  $r10.doWrite(r0)\n  $b12 \u003d $r10.getTag()\n  $i24 \u003d (int) $b12\n  if ($i24 \u003d\u003d 6) goto B3 else B4\n}",
      "B3 {\n  $b13 \u003d $r10.getTag()\n  $i25 \u003d (int) $b13\n  if ($i25 !\u003d 5) goto B4 else B5\n}",
      "B4 {\n  i14 \u003d i14 + 1\n}",
      "B5 {\n  i14 \u003d i14 + 1\n  goto B1\n}",
      "B6 {\n  $i5 \u003d ClassFile: int accessFlags\u003e\n  r0.writeShort($i5)\n  $i6 \u003d ClassFile: int thisClass\u003e\n  r0.writeShort($i6)\n  $i7 \u003d ClassFile: int superClass\u003e\n  r0.writeShort($i7)\n  $r4 \u003d ClassFile: int[] interfaces\u003e\n  $i8 \u003d lengthof $r4\n  r0.writeShort($i8)\n  r11 \u003d ClassFile: int[] interfaces\u003e\n  i15 \u003d lengthof r11\n  i16 \u003d 0\n}",
      "B7 {\n  if (i16 \u003e\u003d i15) goto B8 else B9\n}",
      "B8 {\n  i17 \u003d r11[i16]\n  r0.writeShort(i17)\n  i16 \u003d i16 + 1\n  goto B7\n}",
      "B9 {\n  $r5 \u003d ClassFileEntry[] fields\u003e\n  $i9 \u003d lengthof $r5\n  r0.writeShort($i9)\n  r12 \u003d ClassFileEntry[] fields\u003e\n  i18 \u003d lengthof r12\n  i19 \u003d 0\n}",
      "B10 {\n  if (i19 \u003e\u003d i18) goto B11 else B12\n}",
      "B11 {\n  r13 \u003d r12[i19]\n  r13.write(r0)\n  i19 \u003d i19 + 1\n  goto B10\n}",
      "B12 {\n  $r6 \u003d ClassFileEntry[] methods\u003e\n  $i10 \u003d lengthof $r6\n  r0.writeShort($i10)\n  r14 \u003d ClassFileEntry[] methods\u003e\n  i20 \u003d lengthof r14\n  i21 \u003d 0\n}",
      "B13 {\n  if (i21 \u003e\u003d i20) goto B14 else B15\n}",
      "B14 {\n  r15 \u003d r14[i21]\n  r15.write(r0)\n  i21 \u003d i21 + 1\n  goto B13\n}",
      "B15 {\n  $r7 \u003d Attribute[] attributes\u003e\n  $i11 \u003d lengthof $r7\n  r0.writeShort($i11)\n  r16 \u003d Attribute[] attributes\u003e\n  i22 \u003d lengthof r16\n  i23 \u003d 0\n}",
      "B16 {\n  if (i23 \u003e\u003d i22) goto B17 else B18\n}",
      "B17 {\n  r17 \u003d r16[i23]\n  r17.write(r0)\n  i23 \u003d i23 + 1\n  goto B16\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B13",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B16",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute",
    "methodName": "addAttribute",
    "signature": "void addAttribute(org.apache.commons.compress.harmony.unpack200.bytecode.Attribute)",
    "visibility": "public",
    "body": "{\r\n    attributes.add(attribute);\r\n    if (attribute instanceof LocalVariableTableAttribute) {\r\n        ((LocalVariableTableAttribute) attribute).setCodeLength(codeLength);\r\n    }\r\n    if (attribute instanceof LocalVariableTypeTableAttribute) {\r\n        ((LocalVariableTypeTableAttribute) attribute).setCodeLength(codeLength);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CodeAttribute\n  Attribute\n  $r2 \u003d List attributes\u003e\n  $r2.add(r1)\n  $z0 \u003d LocalVariableTableAttribute\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d LocalVariableTableAttribute) r1\n  $i1 \u003d CodeAttribute: int codeLength\u003e\n  $r4.setCodeLength($i1)\n}",
      "B2 {\n  $z1 \u003d LocalVariableTypeTableAttribute\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d LocalVariableTypeTableAttribute) r1\n  $i0 \u003d CodeAttribute: int codeLength\u003e\n  $r3.setCodeLength($i0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantValueAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!super.equals(obj) || this.getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ConstantValueAttribute other \u003d (ConstantValueAttribute) obj;\r\n    return Objects.equals(entry, other.entry);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ConstantValueAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r0.equals(r1)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d ConstantValueAttribute) r1\n  $r6 \u003d ClassFileEntry entry\u003e\n  $r5 \u003d ClassFileEntry entry\u003e\n  $z1 \u003d Objects.equals($r6, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConstantValueAttribute#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantValueAttribute",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final int PRIME \u003d 31;\r\n    int result \u003d super.hashCode();\r\n    result \u003d PRIME * result + (entry \u003d\u003d null ? 0 : entry.hashCode());\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ConstantValueAttribute\n  i2 \u003d r0.hashCode()\n  $i0 \u003d 31 * i2\n  $r1 \u003d ClassFileEntry entry\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i3 \u003d 0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d ClassFileEntry entry\u003e\n  $i3 \u003d $r2.hashCode()\n}",
      "B3 {\n  $i1 \u003d $i0 + $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPClass",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || this.getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CPClass other \u003d (CPClass) obj;\r\n    return utf8.equals(other.utf8);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CPClass\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CPClass) r1\n  $r6 \u003d CPUTF8 utf8\u003e\n  $r5 \u003d CPUTF8 utf8\u003e\n  $z0 \u003d $r6.equals($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPClass#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPClass",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPClass\n  $z0 \u003d CPClass: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPClass: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPClass#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    cachedHashCode \u003d utf8.hashCode();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPFieldRef",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CPFieldRef other \u003d (CPFieldRef) obj;\r\n    return Objects.equals(className, other.className) \u0026\u0026 Objects.equals(nameAndType, other.nameAndType);\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  CPFieldRef\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CPFieldRef) r1\n  $r6 \u003d CPClass className\u003e\n  $r5 \u003d CPClass className\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d CPNameAndType nameAndType\u003e\n  $r7 \u003d CPNameAndType nameAndType\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPFieldRef#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPFieldRef",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPFieldRef\n  $z0 \u003d CPFieldRef: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPFieldRef: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPFieldRef#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + (className \u003d\u003d null ? 0 : className.hashCode());\r\n    result \u003d PRIME * result + (nameAndType \u003d\u003d null ? 0 : nameAndType.hashCode());\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPInterfaceMethodRef",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPInterfaceMethodRef\n  $z0 \u003d CPInterfaceMethodRef: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPInterfaceMethodRef: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPInterfaceMethodRef#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + className.hashCode();\r\n    result \u003d PRIME * result + nameAndType.hashCode();\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPMember",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CPMember other \u003d (CPMember) obj;\r\n    return Objects.equals(attributes, other.attributes) \u0026\u0026 Objects.equals(descriptor, other.descriptor) \u0026\u0026 flags \u003d\u003d other.flags \u0026\u0026 Objects.equals(name, other.name);\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B10",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B10",
      "B7 : If($i2 !\u003d $i3) → B8 | else → B10",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  CPMember\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CPMember) r1\n  $r6 \u003d List attributes\u003e\n  $r5 \u003d List attributes\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B10\n}",
      "B6 {\n  $r8 \u003d CPUTF8 descriptor\u003e\n  $r7 \u003d CPUTF8 descriptor\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  $s1 \u003d CPMember: short flags\u003e\n  $s0 \u003d CPMember: short flags\u003e\n  $i2 \u003d (int) $s1\n  $i3 \u003d (int) $s0\n  if ($i2 !\u003d $i3) goto B8 else B10\n}",
      "B8 {\n  $r10 \u003d CPUTF8 name\u003e\n  $r9 \u003d CPUTF8 name\u003e\n  $z2 \u003d Objects.equals($r10, $r9)\n  if ($z2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $z3 \u003d 1\n  goto B11\n}",
      "B10 {\n  $z3 \u003d 0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPMember#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPMethod",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPMethod\n  $z0 \u003d CPMethod: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPMethod: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPMethod#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + name.hashCode();\r\n    result \u003d PRIME * result + descriptor.hashCode();\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPMethodRef",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPMethodRef\n  $z0 \u003d CPMethodRef: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPMethodRef: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPMethodRef#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + className.hashCode();\r\n    result \u003d PRIME * result + nameAndType.hashCode();\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPNameAndType",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CPNameAndType other \u003d (CPNameAndType) obj;\r\n    return Objects.equals(descriptor, other.descriptor) \u0026\u0026 Objects.equals(name, other.name);\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  CPNameAndType\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CPNameAndType) r1\n  $r6 \u003d CPUTF8 descriptor\u003e\n  $r5 \u003d CPUTF8 descriptor\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d CPUTF8 name\u003e\n  $r7 \u003d CPUTF8 name\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $z2 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z2 \u003d 0\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPNameAndType#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPNameAndType",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPNameAndType\n  $z0 \u003d CPNameAndType: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPNameAndType: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPNameAndType#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + descriptor.hashCode();\r\n    result \u003d PRIME * result + name.hashCode();\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPString",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPString\n  $z0 \u003d CPString: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPString: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPString#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    int result \u003d 1;\r\n    result \u003d PRIME * result + name.hashCode();\r\n    cachedHashCode \u003d result;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || this.getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final CPUTF8 other \u003d (CPUTF8) obj;\r\n    return utf8.equals(other.utf8);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CPUTF8\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d CPUTF8) r1\n  $r6 \u003d String utf8\u003e\n  $r5 \u003d String utf8\u003e\n  $z0 \u003d $r6.equals($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPUTF8#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CPUTF8\n  $z0 \u003d CPUTF8: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d CPUTF8: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CPUTF8#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    final int PRIME \u003d 31;\r\n    cachedHashCode \u003d PRIME + utf8.hashCode();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionsAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!super.equals(obj) || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final ExceptionsAttribute other \u003d (ExceptionsAttribute) obj;\r\n    if (!Arrays.equals(exceptions, other.exceptions)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($z1 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ExceptionsAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r0.equals(r1)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d ExceptionsAttribute) r1\n  $r6 \u003d CPClass[] exceptions\u003e\n  $r5 \u003d CPClass[] exceptions\u003e\n  $z1 \u003d Arrays.equals($r6, $r5)\n  if ($z1 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ExceptionsAttribute#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionsAttribute",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    final StringBuilder sb \u003d new StringBuilder(\"Exceptions: \");\r\n    for (final CPClass exception : exceptions) {\r\n        sb.append(exception);\r\n        sb.append(\u0027 \u0027);\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ExceptionsAttribute\n  $r0 \u003d StringBuilder\n  new StringBuilder(\"Exceptions: \")\n  r2 \u003d CPClass[] exceptions\u003e\n  i0 \u003d lengthof r2\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r4 \u003d r2[i1]\n  $r0.append(r4)\n  $r0.append(32)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  $r3 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.ExceptionTableEntry",
    "methodName": "resolve",
    "signature": "void resolve(org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool)",
    "visibility": "public",
    "body": "{\r\n    if (catchType \u003d\u003d null) {\r\n        // If the catch type is a finally clause\r\n        // the index is always 0.\r\n        catchTypeIndex \u003d 0;\r\n        return;\r\n    }\r\n    catchType.resolve(pool);\r\n    catchTypeIndex \u003d pool.indexOf(catchType);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ExceptionTableEntry\n  ClassConstantPool\n  $r1 \u003d CPClass catchType\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  ExceptionTableEntry: int catchTypeIndex\u003e \u003d 0\n  return\n}",
      "B2 {\n  $r3 \u003d CPClass catchType\u003e\n  $r3.resolve(r2)\n  $r4 \u003d CPClass catchType\u003e\n  $i0 \u003d r2.indexOf($r4)\n  ExceptionTableEntry: int catchTypeIndex\u003e \u003d $i0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.LabelForm",
    "methodName": "fixUpByteCodeTargets",
    "signature": "void fixUpByteCodeTargets(org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode,org.apache.commons.compress.harmony.unpack200.bytecode.CodeAttribute)",
    "visibility": "public",
    "body": "{\r\n    // LabelForms need to fix up the target of label operations\r\n    final int originalTarget \u003d byteCode.getByteCodeTargets()[0];\r\n    final int sourceIndex \u003d byteCode.getByteCodeIndex();\r\n    final int absoluteInstructionTargetIndex \u003d sourceIndex + originalTarget;\r\n    final int targetValue \u003d codeAttribute.byteCodeOffsets.get(absoluteInstructionTargetIndex).intValue();\r\n    final int sourceValue \u003d codeAttribute.byteCodeOffsets.get(sourceIndex).intValue();\r\n    // The operand is the difference between the source instruction\r\n    // and the destination instruction.\r\n    byteCode.setOperandSigned2Bytes(targetValue - sourceValue, 0);\r\n    if (widened) {\r\n        byteCode.setNestedPositions(new int[][] { { 0, 4 } });\r\n    } else {\r\n        byteCode.setNestedPositions(new int[][] { { 0, 2 } });\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LabelForm\n  ByteCode\n  CodeAttribute\n  $r1 \u003d r0.getByteCodeTargets()\n  i0 \u003d $r1[0]\n  i1 \u003d r0.getByteCodeIndex()\n  i2 \u003d i1 + i0\n  $r3 \u003d List byteCodeOffsets\u003e\n  $r4 \u003d $r3.get(i2)\n  $r5 \u003d Integer) $r4\n  i3 \u003d $r5.intValue()\n  $r6 \u003d List byteCodeOffsets\u003e\n  $r7 \u003d $r6.get(i1)\n  $r8 \u003d Integer) $r7\n  i4 \u003d $r8.intValue()\n  $i5 \u003d i3 - i4\n  r0.setOperandSigned2Bytes($i5, 0)\n  $z0 \u003d LabelForm: boolean widened\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d newarray (int[])[1]\n  $r13 \u003d newarray (int)[2]\n  $r13[0] \u003d 0\n  $r13[1] \u003d 4\n  $r12[0] \u003d $r13\n  r0.setNestedPositions($r12)\n  goto B3\n}",
      "B2 {\n  $r10 \u003d newarray (int[])[1]\n  $r11 \u003d newarray (int)[2]\n  $r11[0] \u003d 0\n  $r11[1] \u003d 2\n  $r10[0] \u003d $r11\n  r0.setNestedPositions($r10)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.LookupSwitchForm",
    "methodName": "setByteCodeOperands",
    "signature": "void setByteCodeOperands(org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode,org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager,int)",
    "visibility": "public",
    "body": "{\r\n    final int caseCount \u003d operandManager.nextCaseCount();\r\n    final int defaultPc \u003d operandManager.nextLabel();\r\n    final int[] caseValues \u003d new int[caseCount];\r\n    Arrays.setAll(caseValues, i -\u003e operandManager.nextCaseValues());\r\n    final int[] casePcs \u003d new int[caseCount];\r\n    Arrays.setAll(casePcs, i -\u003e operandManager.nextLabel());\r\n    final int[] labelsArray \u003d new int[caseCount + 1];\r\n    labelsArray[0] \u003d defaultPc;\r\n    System.arraycopy(casePcs, 0, labelsArray, 1, caseCount + 1 - 1);\r\n    byteCode.setByteCodeTargets(labelsArray);\r\n    // All this gets dumped into the rewrite bytes of the\r\n    // poor bytecode.\r\n    // Unlike most byte codes, the LookupSwitch is a\r\n    // variable-sized bytecode. Because of this, the\r\n    // rewrite array has to be defined here individually\r\n    // for each bytecode, rather than in the ByteCodeForm\r\n    // class.\r\n    // First, there\u0027s the bytecode. Then there are 0-3\r\n    // bytes of padding so that the first (default)\r\n    // label is on a 4-byte offset.\r\n    final int padLength \u003d 3 - codeLength % 4;\r\n    final int rewriteSize \u003d // defaultbytes\r\n    1 + padLength + 4 + // npairs\r\n    4 + 4 * caseValues.length + 4 * casePcs.length;\r\n    final int[] newRewrite \u003d new int[rewriteSize];\r\n    int rewriteIndex \u003d 0;\r\n    // Fill in what we can now\r\n    // opcode\r\n    newRewrite[rewriteIndex++] \u003d byteCode.getOpcode();\r\n    // padding\r\n    for (int index \u003d 0; index \u003c padLength; index++) {\r\n        newRewrite[rewriteIndex++] \u003d 0;\r\n    }\r\n    // defaultbyte\r\n    // This gets overwritten by fixUpByteCodeTargets\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    // npairs\r\n    final int npairsIndex \u003d rewriteIndex;\r\n    setRewrite4Bytes(caseValues.length, npairsIndex, newRewrite);\r\n    rewriteIndex +\u003d 4;\r\n    // match-offset pairs\r\n    // The caseValues aren\u0027t overwritten, but the\r\n    // casePcs will get overwritten by fixUpByteCodeTargets\r\n    for (final int caseValue : caseValues) {\r\n        // match\r\n        setRewrite4Bytes(caseValue, rewriteIndex, newRewrite);\r\n        rewriteIndex +\u003d 4;\r\n        // offset\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n    }\r\n    byteCode.setRewrite(newRewrite);\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i23 \u003e\u003d i7) → B2 | else → B3",
      "B4 : If(i29 \u003e\u003d i19) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LookupSwitchForm\n  ByteCode\n  OperandManager\n  i5 :\u003d @parameter2: int\n  i0 \u003d r0.nextCaseCount()\n  i1 \u003d r0.nextLabel()\n  r1 \u003d newarray (int)[i0]\n  $r2 \u003d LookupSwitchForm$lambda_setByteCodeOperands_0__43.bootstrap$(r0)\n  Arrays.setAll(r1, $r2)\n  r3 \u003d newarray (int)[i0]\n  $r4 \u003d LookupSwitchForm$lambda_setByteCodeOperands_1__44.bootstrap$(r0)\n  Arrays.setAll(r3, $r4)\n  $i2 \u003d i0 + 1\n  r5 \u003d newarray (int)[$i2]\n  r5[0] \u003d i1\n  $i3 \u003d i0 + 1\n  $i4 \u003d $i3 - 1\n  System.arraycopy(r3, 0, r5, 1, $i4)\n  r6.setByteCodeTargets(r5)\n  $i6 \u003d i5 % 4\n  i7 \u003d 3 - $i6\n  $i8 \u003d 1 + i7\n  $i9 \u003d $i8 + 4\n  $i12 \u003d $i9 + 4\n  $i10 \u003d lengthof r1\n  $i11 \u003d 4 * $i10\n  $i15 \u003d $i12 + $i11\n  $i13 \u003d lengthof r3\n  $i14 \u003d 4 * $i13\n  i16 \u003d $i15 + $i14\n  r7 \u003d newarray (int)[i16]\n  i22 \u003d 1\n  $i17 \u003d r6.getOpcode()\n  r7[0] \u003d $i17\n  i23 \u003d 0\n}",
      "B1 {\n  if (i23 \u003e\u003d i7) goto B2 else B3\n}",
      "B2 {\n  $i21 \u003d i22\n  i22 \u003d i22 + 1\n  r7[$i21] \u003d 0\n  i23 \u003d i23 + 1\n  goto B1\n}",
      "B3 {\n  i24 \u003d i22 + 1\n  $i35 \u003d (int) -1\n  r7[i22] \u003d $i35\n  i25 \u003d i24 + 1\n  $i37 \u003d (int) -1\n  r7[i24] \u003d $i37\n  i26 \u003d i25 + 1\n  $i39 \u003d (int) -1\n  r7[i25] \u003d $i39\n  i27 \u003d i26 + 1\n  $i41 \u003d (int) -1\n  r7[i26] \u003d $i41\n  $i18 \u003d lengthof r1\n  r8.setRewrite4Bytes($i18, i27, r7)\n  i28 \u003d i27 + 4\n  i19 \u003d lengthof r1\n  i29 \u003d 0\n}",
      "B4 {\n  if (i29 \u003e\u003d i19) goto B5 else B6\n}",
      "B5 {\n  i20 \u003d r1[i29]\n  r8.setRewrite4Bytes(i20, i28, r7)\n  i30 \u003d i28 + 4\n  i31 \u003d i30 + 1\n  $i43 \u003d (int) -1\n  r7[i30] \u003d $i43\n  i32 \u003d i31 + 1\n  $i45 \u003d (int) -1\n  r7[i31] \u003d $i45\n  i33 \u003d i32 + 1\n  $i47 \u003d (int) -1\n  r7[i32] \u003d $i47\n  i28 \u003d i33 + 1\n  $i49 \u003d (int) -1\n  r7[i33] \u003d $i49\n  i29 \u003d i29 + 1\n  goto B4\n}",
      "B6 {\n  r6.setRewrite(r7)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LookupSwitchForm#setRewrite4Bytes(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.NarrowClassRefForm",
    "methodName": "nestedMustStartClassPool",
    "signature": "boolean nestedMustStartClassPool()",
    "visibility": "public",
    "body": "{\r\n    return !widened;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NarrowClassRefForm\n  $z0 \u003d NarrowClassRefForm: boolean widened\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.NewClassRefForm",
    "methodName": "setByteCodeOperands",
    "signature": "void setByteCodeOperands(org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode,org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager,int)",
    "visibility": "public",
    "body": "{\r\n    final int offset \u003d getOffset(operandManager);\r\n    if (offset \u003d\u003d 0) {\r\n        // Use current class\r\n        final SegmentConstantPool globalPool \u003d operandManager.globalConstantPool();\r\n        final ClassFileEntry[] nested \u003d { globalPool.getClassPoolEntry(operandManager.getCurrentClass()) };\r\n        byteCode.setNested(nested);\r\n        byteCode.setNestedPositions(new int[][] { { 0, 2 } });\r\n    } else {\r\n        // Look up the class in the classpool\r\n        try {\r\n            // Parent takes care of subtracting one from offset\r\n            // to adjust for 1-based global pool\r\n            setNestedEntries(byteCode, operandManager, offset);\r\n        } catch (final Pack200Exception ex) {\r\n            throw new Error(\"Got a pack200 exception. What to do?\");\r\n        }\r\n    }\r\n    operandManager.setNewClass(((CPClass) byteCode.getNestedClassFileEntries()[0]).getName());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NewClassRefForm\n  ByteCode\n  OperandManager\n  i1 :\u003d @parameter2: int\n  i0 \u003d r0.getOffset(r1)\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r14 \u003d r1.globalConstantPool()\n  $r7 \u003d ClassFileEntry)[1]\n  $r8 \u003d r1.getCurrentClass()\n  $r9 \u003d r14.getClassPoolEntry($r8)\n  $r7[0] \u003d $r9\n  r2.setNested($r7)\n  $r10 \u003d newarray (int[])[1]\n  $r11 \u003d newarray (int)[2]\n  $r11[0] \u003d 0\n  $r11[1] \u003d 2\n  $r10[0] \u003d $r11\n  r2.setNestedPositions($r10)\n  goto B4\n}",
      "B2 {\n  r0.setNestedEntries(r2, r1, i0)\n  goto B4\n}",
      "B3 {\n  $r12 :\u003d @caughtexception\n  $r13 \u003d Error\n  new Error(\"Got a pack200 exception. What to do?\")\n  throw $r13\n}",
      "B4 {\n  $r3 \u003d r2.getNestedClassFileEntries()\n  $r4 \u003d $r3[0]\n  $r5 \u003d CPClass) $r4\n  $r6 \u003d $r5.getName()\n  r1.setNewClass($r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NewClassRefForm#setNestedEntries(...3)",
        "body": "(source not found)"
      },
      {
        "name": "NewClassRefForm#getOffset(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.TableSwitchForm",
    "methodName": "setByteCodeOperands",
    "signature": "void setByteCodeOperands(org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode,org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager,int)",
    "visibility": "public",
    "body": "{\r\n    final int caseCount \u003d operandManager.nextCaseCount();\r\n    final int defaultPc \u003d operandManager.nextLabel();\r\n    int caseValue \u003d -1;\r\n    caseValue \u003d operandManager.nextCaseValues();\r\n    final int[] casePcs \u003d new int[caseCount];\r\n    Arrays.setAll(casePcs, i -\u003e operandManager.nextLabel());\r\n    final int[] labelsArray \u003d new int[caseCount + 1];\r\n    labelsArray[0] \u003d defaultPc;\r\n    System.arraycopy(casePcs, 0, labelsArray, 1, caseCount + 1 - 1);\r\n    byteCode.setByteCodeTargets(labelsArray);\r\n    final int lowValue \u003d caseValue;\r\n    final int highValue \u003d lowValue + caseCount - 1;\r\n    // All this gets dumped into the rewrite bytes of the\r\n    // poor bytecode.\r\n    // Unlike most byte codes, the TableSwitch is a\r\n    // variable-sized bytecode. Because of this, the\r\n    // rewrite array has to be defined here individually\r\n    // for each bytecode, rather than in the ByteCodeForm\r\n    // class.\r\n    // First, there\u0027s the bytecode. Then there are 0-3\r\n    // bytes of padding so that the first (default)\r\n    // label is on a 4-byte offset.\r\n    final int padLength \u003d 3 - codeLength % 4;\r\n    final int rewriteSize \u003d // defaultbytes\r\n    1 + padLength + 4 + // lowbyte\r\n    4 + // highbyte\r\n    4 + 4 * casePcs.length;\r\n    final int[] newRewrite \u003d new int[rewriteSize];\r\n    int rewriteIndex \u003d 0;\r\n    // Fill in what we can now\r\n    // opcode\r\n    newRewrite[rewriteIndex++] \u003d byteCode.getOpcode();\r\n    // padding\r\n    for (int index \u003d 0; index \u003c padLength; index++) {\r\n        newRewrite[rewriteIndex++] \u003d 0;\r\n    }\r\n    // defaultbyte\r\n    // This gets overwritten by fixUpByteCodeTargets\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    newRewrite[rewriteIndex++] \u003d -1;\r\n    // lowbyte\r\n    final int lowbyteIndex \u003d rewriteIndex;\r\n    setRewrite4Bytes(lowValue, lowbyteIndex, newRewrite);\r\n    rewriteIndex +\u003d 4;\r\n    // highbyte\r\n    final int highbyteIndex \u003d rewriteIndex;\r\n    setRewrite4Bytes(highValue, highbyteIndex, newRewrite);\r\n    rewriteIndex +\u003d 4;\r\n    // jump offsets\r\n    // The case_pcs will get overwritten by fixUpByteCodeTargets\r\n    for (int index \u003d 0; index \u003c caseCount; index++) {\r\n        // offset\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n        newRewrite[rewriteIndex++] \u003d -1;\r\n    }\r\n    byteCode.setRewrite(newRewrite);\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i21 \u003e\u003d i9) → B2 | else → B3",
      "B4 : If(i28 \u003e\u003d i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TableSwitchForm\n  ByteCode\n  OperandManager\n  i7 :\u003d @parameter2: int\n  i0 \u003d r0.nextCaseCount()\n  i1 \u003d r0.nextLabel()\n  i19 \u003d r0.nextCaseValues()\n  r1 \u003d newarray (int)[i0]\n  $r2 \u003d TableSwitchForm$lambda_setByteCodeOperands_0__45.bootstrap$(r0)\n  Arrays.setAll(r1, $r2)\n  $i2 \u003d i0 + 1\n  r3 \u003d newarray (int)[$i2]\n  r3[0] \u003d i1\n  $i3 \u003d i0 + 1\n  $i4 \u003d $i3 - 1\n  System.arraycopy(r1, 0, r3, 1, $i4)\n  r4.setByteCodeTargets(r3)\n  $i5 \u003d i19 + i0\n  i6 \u003d $i5 - 1\n  $i8 \u003d i7 % 4\n  i9 \u003d 3 - $i8\n  $i10 \u003d 1 + i9\n  $i11 \u003d $i10 + 4\n  $i12 \u003d $i11 + 4\n  $i15 \u003d $i12 + 4\n  $i13 \u003d lengthof r1\n  $i14 \u003d 4 * $i13\n  i16 \u003d $i15 + $i14\n  r5 \u003d newarray (int)[i16]\n  i20 \u003d 1\n  $i17 \u003d r4.getOpcode()\n  r5[0] \u003d $i17\n  i21 \u003d 0\n}",
      "B1 {\n  if (i21 \u003e\u003d i9) goto B2 else B3\n}",
      "B2 {\n  $i18 \u003d i20\n  i20 \u003d i20 + 1\n  r5[$i18] \u003d 0\n  i21 \u003d i21 + 1\n  goto B1\n}",
      "B3 {\n  i22 \u003d i20 + 1\n  $i33 \u003d (int) -1\n  r5[i20] \u003d $i33\n  i23 \u003d i22 + 1\n  $i35 \u003d (int) -1\n  r5[i22] \u003d $i35\n  i24 \u003d i23 + 1\n  $i37 \u003d (int) -1\n  r5[i23] \u003d $i37\n  i25 \u003d i24 + 1\n  $i39 \u003d (int) -1\n  r5[i24] \u003d $i39\n  r6.setRewrite4Bytes(i19, i25, r5)\n  i26 \u003d i25 + 4\n  r6.setRewrite4Bytes(i6, i26, r5)\n  i27 \u003d i26 + 4\n  i28 \u003d 0\n}",
      "B4 {\n  if (i28 \u003e\u003d i0) goto B5 else B6\n}",
      "B5 {\n  i29 \u003d i27 + 1\n  $i41 \u003d (int) -1\n  r5[i27] \u003d $i41\n  i30 \u003d i29 + 1\n  $i43 \u003d (int) -1\n  r5[i29] \u003d $i43\n  i31 \u003d i30 + 1\n  $i45 \u003d (int) -1\n  r5[i30] \u003d $i45\n  i27 \u003d i31 + 1\n  $i47 \u003d (int) -1\n  r5[i31] \u003d $i47\n  i28 \u003d i28 + 1\n  goto B4\n}",
      "B6 {\n  r4.setRewrite(r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TableSwitchForm#setRewrite4Bytes(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.forms.WideForm",
    "methodName": "setByteCodeOperands",
    "signature": "void setByteCodeOperands(org.apache.commons.compress.harmony.unpack200.bytecode.ByteCode,org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager,int)",
    "visibility": "public",
    "body": "{\r\n    final int instruction \u003d operandManager.nextWideByteCode();\r\n    if (instruction \u003d\u003d 132) {\r\n        setByteCodeOperandsFormat2(instruction, byteCode, operandManager, codeLength);\r\n    } else {\r\n        setByteCodeOperandsFormat1(instruction, byteCode, operandManager, codeLength);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 132) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  WideForm\n  ByteCode\n  OperandManager\n  i1 :\u003d @parameter2: int\n  i0 \u003d r0.nextWideByteCode()\n  if (i0 !\u003d 132) goto B1 else B2\n}",
      "B1 {\n  r1.setByteCodeOperandsFormat2(i0, r2, r0, i1)\n  goto B3\n}",
      "B2 {\n  r1.setByteCodeOperandsFormat1(i0, r2, r0, i1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WideForm#setByteCodeOperandsFormat2(...4)",
        "body": "{\r\n    final int local \u003d operandManager.nextLocal();\r\n    final int constWord \u003d operandManager.nextShort();\r\n    // Unlike most byte codes, the wide bytecode is a\r\n    // variable-sized bytecode. Because of this, the\r\n    // rewrite array has to be defined here individually\r\n    // for each bytecode, rather than in the ByteCodeForm\r\n    // class.\r\n    final int[] newRewrite \u003d new int[6];\r\n    int rewriteIndex \u003d 0;\r\n    // Fill in what we can now\r\n    // wide opcode\r\n    newRewrite[rewriteIndex++] \u003d byteCode.getOpcode();\r\n    // \"real\" instruction that is widened\r\n    newRewrite[rewriteIndex++] \u003d instruction;\r\n    // Index bytes\r\n    setRewrite2Bytes(local, rewriteIndex, newRewrite);\r\n    rewriteIndex +\u003d 2;\r\n    // constant bytes\r\n    setRewrite2Bytes(constWord, rewriteIndex, newRewrite);\r\n    // not strictly necessary, but just in case\r\n    rewriteIndex +\u003d 2;\r\n    // something comes along later\r\n    byteCode.setRewrite(newRewrite);\r\n}"
      },
      {
        "name": "WideForm#setByteCodeOperandsFormat1(...4)",
        "body": "{\r\n    // Even though this code is really similar to the\r\n    // code for setByteCodeOperandsFormat2, I\u0027ve left it\r\n    // distinct here. This is so changing one will\r\n    // not change the other - if there is a need to change,\r\n    // there\u0027s a good chance that the formats will\r\n    // differ, so an updater will not have to disentangle\r\n    // it.\r\n    final int local \u003d operandManager.nextLocal();\r\n    // Unlike most byte codes, the wide bytecode is a\r\n    // variable-sized bytecode. Because of this, the\r\n    // rewrite array has to be defined here individually\r\n    // for each bytecode, rather than in the ByteCodeForm\r\n    // class.\r\n    final int[] newRewrite \u003d new int[4];\r\n    int rewriteIndex \u003d 0;\r\n    // Fill in what we can now\r\n    // wide opcode\r\n    newRewrite[rewriteIndex++] \u003d byteCode.getOpcode();\r\n    // \"real\" instruction that is widened\r\n    newRewrite[rewriteIndex++] \u003d instruction;\r\n    // Index bytes\r\n    setRewrite2Bytes(local, rewriteIndex, newRewrite);\r\n    rewriteIndex +\u003d 2;\r\n    byteCode.setRewrite(newRewrite);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute",
    "methodName": "addInnerClassesEntry",
    "signature": "void addInnerClassesEntry(org.apache.commons.compress.harmony.unpack200.bytecode.CPClass,org.apache.commons.compress.harmony.unpack200.bytecode.CPClass,org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8,int)",
    "visibility": "public",
    "body": "{\r\n    if (innerClass !\u003d null) {\r\n        nestedClassFileEntries.add(innerClass);\r\n    }\r\n    if (outerClass !\u003d null) {\r\n        nestedClassFileEntries.add(outerClass);\r\n    }\r\n    if (innerName !\u003d null) {\r\n        nestedClassFileEntries.add(innerName);\r\n    }\r\n    addInnerClassesEntry(new InnerClassesEntry(innerClass, outerClass, innerName, flags));\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(r2 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  InnerClassesAttribute\n  CPClass\n  CPClass\n  CPUTF8\n  i0 :\u003d @parameter3: int\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d List nestedClassFileEntries\u003e\n  $r7.add(r0)\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d List nestedClassFileEntries\u003e\n  $r6.add(r1)\n}",
      "B4 {\n  if (r2 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r5 \u003d List nestedClassFileEntries\u003e\n  $r5.add(r2)\n}",
      "B6 {\n  $r4 \u003d InnerClassesAttribute$InnerClassesEntry\n  new InnerClassesAttribute$InnerClassesEntry(r0, r1, r2, i0)\n  r3.addInnerClassesEntry($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "InnerClassesAttribute#addInnerClassesEntry(...1)",
        "body": "{\r\n    innerClasses.add(innerClassesEntry);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!super.equals(obj) || this.getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final InnerClassesAttribute other \u003d (InnerClassesAttribute) obj;\r\n    if (getAttributeName() \u003d\u003d null) {\r\n        if (other.getAttributeName() !\u003d null) {\r\n            return false;\r\n        }\r\n    } else if (!getAttributeName().equals(other.getAttributeName())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($r5 !\u003d null) → B6 | else → B8",
      "B6 : If($r8 \u003d\u003d null) → B7 | else → B10",
      "B8 : If($z1 !\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  InnerClassesAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r0.equals(r1)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d InnerClassesAttribute) r1\n  $r5 \u003d r0.getAttributeName()\n  if ($r5 !\u003d null) goto B6 else B8\n}",
      "B6 {\n  $r8 \u003d r4.getAttributeName()\n  if ($r8 \u003d\u003d null) goto B7 else B10\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r7 \u003d r0.getAttributeName()\n  $r6 \u003d r4.getAttributeName()\n  $z1 \u003d $r7.equals($r6)\n  if ($z1 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "InnerClassesAttribute#getAttributeName(...0)",
        "body": "(source not found)"
      },
      {
        "name": "InnerClassesAttribute#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.InnerClassesAttribute",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final int PRIME \u003d 31;\r\n    int result \u003d super.hashCode();\r\n    result \u003d PRIME * result + (getAttributeName() \u003d\u003d null ? 0 : getAttributeName().hashCode());\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  InnerClassesAttribute\n  i2 \u003d r0.hashCode()\n  $i0 \u003d 31 * i2\n  $r1 \u003d r0.getAttributeName()\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i3 \u003d 0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.getAttributeName()\n  $i3 \u003d $r2.hashCode()\n}",
      "B3 {\n  $i1 \u003d $i0 + $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "InnerClassesAttribute#getAttributeName(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.LineNumberTableAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return this \u003d\u003d obj;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LineNumberTableAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTableAttribute",
    "methodName": "renumber",
    "signature": "void renumber(java.util.List)",
    "visibility": "public",
    "body": "{\r\n    // Remember the unrenumbered startPcs, since that\u0027s used later\r\n    // to calculate end position.\r\n    final int[] unrenumberedStartPcs \u003d Arrays.copyOf(startPcs, startPcs.length);\r\n    // Next renumber startPcs in place\r\n    super.renumber(byteCodeOffsets);\r\n    // lengths are BRANCH5 encoded, not BCI-encoded.\r\n    // In other words:\r\n    // startPc is BCI5 startPc\r\n    // endPc is byteCodeOffset[(index of startPc in byteCodeOffset) +\r\n    // (encoded length)]\r\n    // real length \u003d endPc - startPc\r\n    // special case if endPc is beyond end of bytecode array\r\n    final int maxSize \u003d codeLength;\r\n    // Iterate through the lengths and update each in turn.\r\n    // This is done in place in the lengths array.\r\n    for (int index \u003d 0; index \u003c lengths.length; index++) {\r\n        final int startPc \u003d startPcs[index];\r\n        int revisedLength \u003d -1;\r\n        final int encodedLength \u003d lengths[index];\r\n        // First get the index of the startPc in the byteCodeOffsets\r\n        final int indexOfStartPC \u003d unrenumberedStartPcs[index];\r\n        // Given the index of the startPc, we can now add\r\n        // the encodedLength to it to get the stop index.\r\n        final int stopIndex \u003d indexOfStartPC + encodedLength;\r\n        if (stopIndex \u003c 0) {\r\n            throw new Pack200Exception(\"Error renumbering bytecode indexes\");\r\n        }\r\n        // Length can either be an index into the byte code offsets, or one\r\n        // beyond the\r\n        // end of the byte code offsets. Need to determine which this is.\r\n        if (stopIndex \u003d\u003d byteCodeOffsets.size()) {\r\n            // Pointing to one past the end of the byte code array\r\n            revisedLength \u003d maxSize - startPc;\r\n        } else {\r\n            // We\u0027re indexed into the byte code array\r\n            final int stopValue \u003d byteCodeOffsets.get(stopIndex).intValue();\r\n            revisedLength \u003d stopValue - startPc;\r\n        }\r\n        lengths[index] \u003d revisedLength;\r\n    }\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d $i2) → B2 | else → B8",
      "B2 : If(i6 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(i6 !\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalVariableTableAttribute\n  List\n  $r2 \u003d LocalVariableTableAttribute: int[] startPcs\u003e\n  $r1 \u003d LocalVariableTableAttribute: int[] startPcs\u003e\n  $i0 \u003d lengthof $r1\n  r3 \u003d Arrays.copyOf($r2, $i0)\n  r0.renumber(r4)\n  i1 \u003d LocalVariableTableAttribute: int codeLength\u003e\n  i9 \u003d 0\n}",
      "B1 {\n  $r5 \u003d LocalVariableTableAttribute: int[] lengths\u003e\n  $i2 \u003d lengthof $r5\n  if (i9 \u003e\u003d $i2) goto B2 else B8\n}",
      "B2 {\n  $r6 \u003d LocalVariableTableAttribute: int[] startPcs\u003e\n  i3 \u003d $r6[i9]\n  $r7 \u003d LocalVariableTableAttribute: int[] lengths\u003e\n  i4 \u003d $r7[i9]\n  i5 \u003d r3[i9]\n  i6 \u003d i5 + i4\n  if (i6 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r11 \u003d Pack200Exception\n  new Pack200Exception(\"Error renumbering bytecode indexes\")\n  throw $r11\n}",
      "B4 {\n  $i7 \u003d r4.size()\n  if (i6 !\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  i10 \u003d i1 - i3\n  goto B7\n}",
      "B6 {\n  $r8 \u003d r4.get(i6)\n  $r9 \u003d Integer) $r8\n  i8 \u003d $r9.intValue()\n  i10 \u003d i8 - i3\n}",
      "B7 {\n  $r10 \u003d LocalVariableTableAttribute: int[] lengths\u003e\n  $r10[i9] \u003d i10\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B1",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.LocalVariableTypeTableAttribute",
    "methodName": "renumber",
    "signature": "void renumber(java.util.List)",
    "visibility": "public",
    "body": "{\r\n    // Remember the unrenumbered startPcs, since that\u0027s used later\r\n    // to calculate end position.\r\n    final int[] unrenumberedStartPcs \u003d Arrays.copyOf(startPcs, startPcs.length);\r\n    // Next renumber startPcs in place\r\n    super.renumber(byteCodeOffsets);\r\n    // lengths are BRANCH5 encoded, not BCI-encoded.\r\n    // In other words:\r\n    // startPc is BCI5 startPc\r\n    // endPc is byteCodeOffset[(index of startPc in byteCodeOffset) +\r\n    // (encoded length)]\r\n    // real length \u003d endPc - startPc\r\n    // special case if endPc is beyond end of bytecode array\r\n    final int maxSize \u003d codeLength;\r\n    // Iterate through the lengths and update each in turn.\r\n    // This is done in place in the lengths array.\r\n    for (int index \u003d 0; index \u003c lengths.length; index++) {\r\n        final int startPc \u003d startPcs[index];\r\n        int revisedLength \u003d -1;\r\n        final int encodedLength \u003d lengths[index];\r\n        // First get the index of the startPc in the byteCodeOffsets\r\n        final int indexOfStartPC \u003d unrenumberedStartPcs[index];\r\n        // Given the index of the startPc, we can now add\r\n        // the encodedLength to it to get the stop index.\r\n        final int stopIndex \u003d indexOfStartPC + encodedLength;\r\n        if (stopIndex \u003c 0) {\r\n            throw new Pack200Exception(\"Error renumbering bytecode indexes\");\r\n        }\r\n        // Length can either be an index into the byte code offsets, or one\r\n        // beyond the\r\n        // end of the byte code offsets. Need to determine which this is.\r\n        if (stopIndex \u003d\u003d byteCodeOffsets.size()) {\r\n            // Pointing to one past the end of the byte code array\r\n            revisedLength \u003d maxSize - startPc;\r\n        } else {\r\n            // We\u0027re indexed into the byte code array\r\n            final int stopValue \u003d byteCodeOffsets.get(stopIndex).intValue();\r\n            revisedLength \u003d stopValue - startPc;\r\n        }\r\n        lengths[index] \u003d revisedLength;\r\n    }\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d $i2) → B2 | else → B8",
      "B2 : If(i6 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(i6 !\u003d $i7) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LocalVariableTypeTableAttribute\n  List\n  $r2 \u003d LocalVariableTypeTableAttribute: int[] startPcs\u003e\n  $r1 \u003d LocalVariableTypeTableAttribute: int[] startPcs\u003e\n  $i0 \u003d lengthof $r1\n  r3 \u003d Arrays.copyOf($r2, $i0)\n  r0.renumber(r4)\n  i1 \u003d LocalVariableTypeTableAttribute: int codeLength\u003e\n  i9 \u003d 0\n}",
      "B1 {\n  $r5 \u003d LocalVariableTypeTableAttribute: int[] lengths\u003e\n  $i2 \u003d lengthof $r5\n  if (i9 \u003e\u003d $i2) goto B2 else B8\n}",
      "B2 {\n  $r6 \u003d LocalVariableTypeTableAttribute: int[] startPcs\u003e\n  i3 \u003d $r6[i9]\n  $r7 \u003d LocalVariableTypeTableAttribute: int[] lengths\u003e\n  i4 \u003d $r7[i9]\n  i5 \u003d r3[i9]\n  i6 \u003d i5 + i4\n  if (i6 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r11 \u003d Pack200Exception\n  new Pack200Exception(\"Error renumbering bytecode indexes\")\n  throw $r11\n}",
      "B4 {\n  $i7 \u003d r4.size()\n  if (i6 !\u003d $i7) goto B5 else B6\n}",
      "B5 {\n  i10 \u003d i1 - i3\n  goto B7\n}",
      "B6 {\n  $r8 \u003d r4.get(i6)\n  $r9 \u003d Integer) $r8\n  i8 \u003d $r9.intValue()\n  i10 \u003d i8 - i3\n}",
      "B7 {\n  $r10 \u003d LocalVariableTypeTableAttribute: int[] lengths\u003e\n  $r10[i9] \u003d i10\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B1",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.NewAttribute",
    "methodName": "renumber",
    "signature": "void renumber(java.util.List)",
    "visibility": "public",
    "body": "{\r\n    if (!renumbered) {\r\n        Object previous \u003d null;\r\n        for (final Object obj : body) {\r\n            if (obj instanceof BCIndex) {\r\n                final BCIndex bcIndex \u003d (BCIndex) obj;\r\n                bcIndex.setActualValue(byteCodeOffsets.get(bcIndex.index).intValue());\r\n            } else if (obj instanceof BCOffset) {\r\n                final BCOffset bcOffset \u003d (BCOffset) obj;\r\n                if (previous instanceof BCIndex) {\r\n                    final int index \u003d ((BCIndex) previous).index + bcOffset.offset;\r\n                    bcOffset.setIndex(index);\r\n                    bcOffset.setActualValue(byteCodeOffsets.get(index).intValue());\r\n                } else if (previous instanceof BCOffset) {\r\n                    final int index \u003d ((BCOffset) previous).index + bcOffset.offset;\r\n                    bcOffset.setIndex(index);\r\n                    bcOffset.setActualValue(byteCodeOffsets.get(index).intValue());\r\n                } else {\r\n                    // Not sure if this should be able to happen\r\n                    bcOffset.setActualValue(byteCodeOffsets.get(bcOffset.offset).intValue());\r\n                }\r\n            } else if (obj instanceof BCLength) {\r\n                // previous must be a BCIndex\r\n                final BCLength bcLength \u003d (BCLength) obj;\r\n                final BCIndex prevIndex \u003d (BCIndex) previous;\r\n                final int index \u003d prevIndex.index + bcLength.length;\r\n                final int actualLength \u003d byteCodeOffsets.get(index).intValue() - prevIndex.actualValue;\r\n                bcLength.setActualValue(actualLength);\r\n            }\r\n            previous \u003d obj;\r\n        }\r\n        renumbered \u003d true;\r\n    }\r\n}",
    "nodes": 17,
    "edges": 23,
    "cc": 8,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B16",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B15",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z3 \u003d\u003d false) → B6 | else → B12",
      "B6 : If($z5 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z6 \u003d\u003d false) → B9 | else → B10",
      "B12 : If($z4 \u003d\u003d false) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  NewAttribute\n  List\n  $z0 \u003d NewAttribute: boolean renumbered\u003e\n  if ($z0 !\u003d 0) goto B1 else B16\n}",
      "B1 {\n  r17 \u003d null\n  $r1 \u003d List body\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B2 {\n  $z1 \u003d r2.hasNext()\n  if ($z1 \u003d\u003d false) goto B3 else B15\n}",
      "B3 {\n  r3 \u003d r2.next()\n  $z2 \u003d NewAttribute$BCIndex\n  if ($z2 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  r18 \u003d NewAttribute$BCIndex) r3\n  $i14 \u003d NewAttribute$BCIndex.access$100(r18)\n  $r15 \u003d r4.get($i14)\n  $r16 \u003d Integer) $r15\n  $i15 \u003d $r16.intValue()\n  r18.setActualValue($i15)\n  goto B14\n}",
      "B5 {\n  $z3 \u003d NewAttribute$BCOffset\n  if ($z3 \u003d\u003d false) goto B6 else B12\n}",
      "B6 {\n  r19 \u003d NewAttribute$BCOffset) r3\n  $z5 \u003d NewAttribute$BCIndex\n  if ($z5 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r12 \u003d NewAttribute$BCIndex) r17\n  $i12 \u003d NewAttribute$BCIndex.access$100($r12)\n  $i11 \u003d NewAttribute$BCOffset.access$200(r19)\n  i16 \u003d $i12 + $i11\n  r19.setIndex(i16)\n  $r13 \u003d r4.get(i16)\n  $r14 \u003d Integer) $r13\n  $i13 \u003d $r14.intValue()\n  r19.setActualValue($i13)\n  goto B11\n}",
      "B8 {\n  $z6 \u003d NewAttribute$BCOffset\n  if ($z6 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r9 \u003d NewAttribute$BCOffset) r17\n  $i9 \u003d NewAttribute$BCOffset.access$300($r9)\n  $i8 \u003d NewAttribute$BCOffset.access$200(r19)\n  i17 \u003d $i9 + $i8\n  r19.setIndex(i17)\n  $r10 \u003d r4.get(i17)\n  $r11 \u003d Integer) $r10\n  $i10 \u003d $r11.intValue()\n  r19.setActualValue($i10)\n  goto B11\n}",
      "B10 {\n  $i6 \u003d NewAttribute$BCOffset.access$200(r19)\n  $r7 \u003d r4.get($i6)\n  $r8 \u003d Integer) $r7\n  $i7 \u003d $r8.intValue()\n  r19.setActualValue($i7)\n}",
      "B11 {\n  goto B14\n}",
      "B12 {\n  $z4 \u003d NewAttribute$BCLength\n  if ($z4 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  r20 \u003d NewAttribute$BCLength) r3\n  r21 \u003d NewAttribute$BCIndex) r17\n  $i1 \u003d NewAttribute$BCIndex.access$100(r21)\n  $i0 \u003d NewAttribute$BCLength.access$400(r20)\n  i2 \u003d $i1 + $i0\n  $r5 \u003d r4.get(i2)\n  $r6 \u003d Integer) $r5\n  $i4 \u003d $r6.intValue()\n  $i3 \u003d NewAttribute$BCIndex: int actualValue\u003e\n  i5 \u003d $i4 - $i3\n  r20.setActualValue(i5)\n}",
      "B14 {\n  r17 \u003d r3\n  goto B2\n}",
      "B15 {\n  NewAttribute: boolean renumbered\u003e \u003d 1\n}",
      "B16 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B16",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B15",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B14",
      "B5 --\u003e B6",
      "B5 --\u003e B12",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B2",
      "B15 --\u003e B16",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager",
    "methodName": "getCurrentClass",
    "signature": "java.lang.String getCurrentClass()",
    "visibility": "public",
    "body": "{\r\n    if (null \u003d\u003d currentClass) {\r\n        throw new Error(\"Current class not set yet\");\r\n    }\r\n    return currentClass;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(null !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  OperandManager\n  $r1 \u003d String currentClass\u003e\n  if (null !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Error\n  new Error(\"Current class not set yet\")\n  throw $r3\n}",
      "B2 {\n  $r2 \u003d String currentClass\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager",
    "methodName": "getNewClass",
    "signature": "java.lang.String getNewClass()",
    "visibility": "public",
    "body": "{\r\n    if (null \u003d\u003d newClass) {\r\n        throw new Error(\"New class not set yet\");\r\n    }\r\n    return newClass;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(null !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  OperandManager\n  $r1 \u003d String newClass\u003e\n  if (null !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Error\n  new Error(\"New class not set yet\")\n  throw $r3\n}",
      "B2 {\n  $r2 \u003d String newClass\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.OperandManager",
    "methodName": "getSuperClass",
    "signature": "java.lang.String getSuperClass()",
    "visibility": "public",
    "body": "{\r\n    if (null \u003d\u003d superClass) {\r\n        throw new Error(\"SuperClass not set yet\");\r\n    }\r\n    return superClass;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(null !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  OperandManager\n  $r1 \u003d String superClass\u003e\n  if (null !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Error\n  new Error(\"SuperClass not set yet\")\n  throw $r3\n}",
      "B2 {\n  $r2 \u003d String superClass\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.SourceFileAttribute",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (!super.equals(obj) || this.getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    final SourceFileAttribute other \u003d (SourceFileAttribute) obj;\r\n    return Objects.equals(name, other.name);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SourceFileAttribute\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r0.equals(r1)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d SourceFileAttribute) r1\n  $r6 \u003d CPUTF8 name\u003e\n  $r5 \u003d CPUTF8 name\u003e\n  $z1 \u003d Objects.equals($r6, $r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SourceFileAttribute#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.bytecode.SourceFileAttribute",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    final int PRIME \u003d 31;\r\n    int result \u003d super.hashCode();\r\n    result \u003d PRIME * result + (name \u003d\u003d null ? 0 : name.hashCode());\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SourceFileAttribute\n  i2 \u003d r0.hashCode()\n  $i0 \u003d 31 * i2\n  $r1 \u003d CPUTF8 name\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i3 \u003d 0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d CPUTF8 name\u003e\n  $i3 \u003d $r2.hashCode()\n}",
      "B3 {\n  $i1 \u003d $i0 + $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.ClassBands",
    "methodName": "getClassFlags",
    "signature": "long[] getClassFlags()",
    "visibility": "public",
    "body": "{\r\n    if (classAccessFlags \u003d\u003d null) {\r\n        long mask \u003d 0x7FFF;\r\n        for (int i \u003d 0; i \u003c 16; i++) {\r\n            final AttributeLayout layout \u003d attrMap.getAttributeLayout(i, AttributeLayout.CONTEXT_CLASS);\r\n            if (layout !\u003d null \u0026\u0026 !layout.isDefaultLayout()) {\r\n                mask \u0026\u003d ~(1 \u003c\u003c i);\r\n            }\r\n        }\r\n        classAccessFlags \u003d new long[classFlags.length];\r\n        for (int i \u003d 0; i \u003c classFlags.length; i++) {\r\n            classAccessFlags[i] \u003d classFlags[i] \u0026 mask;\r\n        }\r\n    }\r\n    return classAccessFlags;\r\n}",
    "nodes": 11,
    "edges": 15,
    "cc": 6,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B10",
      "B2 : If(i8 \u003e\u003d 16) → B3 | else → B7",
      "B3 : If(r9 \u003d\u003d null) → B4 | else → B6",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B8 : If(i9 \u003e\u003d $i1) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d ClassBands: long[] classAccessFlags\u003e\n  if ($r1 !\u003d null) goto B1 else B10\n}",
      "B1 {\n  l7 \u003d 32767L\n  i8 \u003d 0\n}",
      "B2 {\n  if (i8 \u003e\u003d 16) goto B3 else B7\n}",
      "B3 {\n  $r8 \u003d AttributeLayoutMap attrMap\u003e\n  r9 \u003d $r8.getAttributeLayout(i8, 0)\n  if (r9 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  $z0 \u003d r9.isDefaultLayout()\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i4 \u003d 1 \u003c\u003c i8\n  $i11 \u003d (int) -1\n  $i5 \u003d $i4 ^ $i11\n  $l6 \u003d (long) $i5\n  l7 \u003d l7 \u0026 $l6\n}",
      "B6 {\n  i8 \u003d i8 + 1\n  goto B2\n}",
      "B7 {\n  $r3 \u003d ClassBands: long[] classFlags\u003e\n  $i0 \u003d lengthof $r3\n  $r4 \u003d newarray (long)[$i0]\n  ClassBands: long[] classAccessFlags\u003e \u003d $r4\n  i9 \u003d 0\n}",
      "B8 {\n  $r5 \u003d ClassBands: long[] classFlags\u003e\n  $i1 \u003d lengthof $r5\n  if (i9 \u003e\u003d $i1) goto B9 else B10\n}",
      "B9 {\n  $r7 \u003d ClassBands: long[] classAccessFlags\u003e\n  $r6 \u003d ClassBands: long[] classFlags\u003e\n  $l2 \u003d $r6[i9]\n  $l3 \u003d $l2 \u0026 l7\n  $r7[i9] \u003d $l3\n  i9 \u003d i9 + 1\n  goto B8\n}",
      "B10 {\n  $r2 \u003d ClassBands: long[] classAccessFlags\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B8",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.ClassBands",
    "methodName": "getFieldFlags",
    "signature": "long[][] getFieldFlags()",
    "visibility": "public",
    "body": "{\r\n    if (fieldAccessFlags \u003d\u003d null) {\r\n        long mask \u003d 0x7FFF;\r\n        for (int i \u003d 0; i \u003c 16; i++) {\r\n            final AttributeLayout layout \u003d attrMap.getAttributeLayout(i, AttributeLayout.CONTEXT_FIELD);\r\n            if (layout !\u003d null \u0026\u0026 !layout.isDefaultLayout()) {\r\n                mask \u0026\u003d ~(1 \u003c\u003c i);\r\n            }\r\n        }\r\n        fieldAccessFlags \u003d new long[fieldFlags.length][];\r\n        for (int i \u003d 0; i \u003c fieldFlags.length; i++) {\r\n            fieldAccessFlags[i] \u003d new long[fieldFlags[i].length];\r\n            for (int j \u003d 0; j \u003c fieldFlags[i].length; j++) {\r\n                fieldAccessFlags[i][j] \u003d fieldFlags[i][j] \u0026 mask;\r\n            }\r\n        }\r\n    }\r\n    return fieldAccessFlags;\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B13",
      "B2 : If(i10 \u003e\u003d 16) → B3 | else → B7",
      "B3 : If(r17 \u003d\u003d null) → B4 | else → B6",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B8 : If(i11 \u003e\u003d $i1) → B9 | else → B13",
      "B10 : If(i12 \u003e\u003d $i3) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d ClassBands: long[][] fieldAccessFlags\u003e\n  if ($r1 !\u003d null) goto B1 else B13\n}",
      "B1 {\n  l9 \u003d 32767L\n  i10 \u003d 0\n}",
      "B2 {\n  if (i10 \u003e\u003d 16) goto B3 else B7\n}",
      "B3 {\n  $r16 \u003d AttributeLayoutMap attrMap\u003e\n  r17 \u003d $r16.getAttributeLayout(i10, 1)\n  if (r17 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  $z0 \u003d r17.isDefaultLayout()\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i6 \u003d 1 \u003c\u003c i10\n  $i14 \u003d (int) -1\n  $i7 \u003d $i6 ^ $i14\n  $l8 \u003d (long) $i7\n  l9 \u003d l9 \u0026 $l8\n}",
      "B6 {\n  i10 \u003d i10 + 1\n  goto B2\n}",
      "B7 {\n  $r3 \u003d ClassBands: long[][] fieldFlags\u003e\n  $i0 \u003d lengthof $r3\n  $r4 \u003d newarray (long[])[$i0]\n  ClassBands: long[][] fieldAccessFlags\u003e \u003d $r4\n  i11 \u003d 0\n}",
      "B8 {\n  $r5 \u003d ClassBands: long[][] fieldFlags\u003e\n  $i1 \u003d lengthof $r5\n  if (i11 \u003e\u003d $i1) goto B9 else B13\n}",
      "B9 {\n  $r9 \u003d ClassBands: long[][] fieldAccessFlags\u003e\n  $r6 \u003d ClassBands: long[][] fieldFlags\u003e\n  $r7 \u003d $r6[i11]\n  $i2 \u003d lengthof $r7\n  $r8 \u003d newarray (long)[$i2]\n  $r9[i11] \u003d $r8\n  i12 \u003d 0\n}",
      "B10 {\n  $r10 \u003d ClassBands: long[][] fieldFlags\u003e\n  $r11 \u003d $r10[i11]\n  $i3 \u003d lengthof $r11\n  if (i12 \u003e\u003d $i3) goto B11 else B12\n}",
      "B11 {\n  $r12 \u003d ClassBands: long[][] fieldAccessFlags\u003e\n  $r15 \u003d $r12[i11]\n  $r13 \u003d ClassBands: long[][] fieldFlags\u003e\n  $r14 \u003d $r13[i11]\n  $l4 \u003d $r14[i12]\n  $l5 \u003d $l4 \u0026 l9\n  $r15[i12] \u003d $l5\n  i12 \u003d i12 + 1\n  goto B10\n}",
      "B12 {\n  i11 \u003d i11 + 1\n  goto B8\n}",
      "B13 {\n  $r2 \u003d ClassBands: long[][] fieldAccessFlags\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B13",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B8",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.ClassBands",
    "methodName": "getMethodFlags",
    "signature": "long[][] getMethodFlags()",
    "visibility": "public",
    "body": "{\r\n    if (methodAccessFlags \u003d\u003d null) {\r\n        long mask \u003d 0x7FFF;\r\n        for (int i \u003d 0; i \u003c 16; i++) {\r\n            final AttributeLayout layout \u003d attrMap.getAttributeLayout(i, AttributeLayout.CONTEXT_METHOD);\r\n            if (layout !\u003d null \u0026\u0026 !layout.isDefaultLayout()) {\r\n                mask \u0026\u003d ~(1 \u003c\u003c i);\r\n            }\r\n        }\r\n        methodAccessFlags \u003d new long[methodFlags.length][];\r\n        for (int i \u003d 0; i \u003c methodFlags.length; i++) {\r\n            methodAccessFlags[i] \u003d new long[methodFlags[i].length];\r\n            for (int j \u003d 0; j \u003c methodFlags[i].length; j++) {\r\n                methodAccessFlags[i][j] \u003d methodFlags[i][j] \u0026 mask;\r\n            }\r\n        }\r\n    }\r\n    return methodAccessFlags;\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B13",
      "B2 : If(i10 \u003e\u003d 16) → B3 | else → B7",
      "B3 : If(r17 \u003d\u003d null) → B4 | else → B6",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B8 : If(i11 \u003e\u003d $i1) → B9 | else → B13",
      "B10 : If(i12 \u003e\u003d $i3) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ClassBands\n  $r1 \u003d ClassBands: long[][] methodAccessFlags\u003e\n  if ($r1 !\u003d null) goto B1 else B13\n}",
      "B1 {\n  l9 \u003d 32767L\n  i10 \u003d 0\n}",
      "B2 {\n  if (i10 \u003e\u003d 16) goto B3 else B7\n}",
      "B3 {\n  $r16 \u003d AttributeLayoutMap attrMap\u003e\n  r17 \u003d $r16.getAttributeLayout(i10, 2)\n  if (r17 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  $z0 \u003d r17.isDefaultLayout()\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i6 \u003d 1 \u003c\u003c i10\n  $i14 \u003d (int) -1\n  $i7 \u003d $i6 ^ $i14\n  $l8 \u003d (long) $i7\n  l9 \u003d l9 \u0026 $l8\n}",
      "B6 {\n  i10 \u003d i10 + 1\n  goto B2\n}",
      "B7 {\n  $r3 \u003d ClassBands: long[][] methodFlags\u003e\n  $i0 \u003d lengthof $r3\n  $r4 \u003d newarray (long[])[$i0]\n  ClassBands: long[][] methodAccessFlags\u003e \u003d $r4\n  i11 \u003d 0\n}",
      "B8 {\n  $r5 \u003d ClassBands: long[][] methodFlags\u003e\n  $i1 \u003d lengthof $r5\n  if (i11 \u003e\u003d $i1) goto B9 else B13\n}",
      "B9 {\n  $r9 \u003d ClassBands: long[][] methodAccessFlags\u003e\n  $r6 \u003d ClassBands: long[][] methodFlags\u003e\n  $r7 \u003d $r6[i11]\n  $i2 \u003d lengthof $r7\n  $r8 \u003d newarray (long)[$i2]\n  $r9[i11] \u003d $r8\n  i12 \u003d 0\n}",
      "B10 {\n  $r10 \u003d ClassBands: long[][] methodFlags\u003e\n  $r11 \u003d $r10[i11]\n  $i3 \u003d lengthof $r11\n  if (i12 \u003e\u003d $i3) goto B11 else B12\n}",
      "B11 {\n  $r12 \u003d ClassBands: long[][] methodAccessFlags\u003e\n  $r15 \u003d $r12[i11]\n  $r13 \u003d ClassBands: long[][] methodFlags\u003e\n  $r14 \u003d $r13[i11]\n  $l4 \u003d $r14[i12]\n  $l5 \u003d $l4 \u0026 l9\n  $r15[i12] \u003d $l5\n  i12 \u003d i12 + 1\n  goto B10\n}",
      "B12 {\n  i11 \u003d i11 + 1\n  goto B8\n}",
      "B13 {\n  $r2 \u003d ClassBands: long[][] methodAccessFlags\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B13",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B8",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.CpBands",
    "methodName": "cpClassValue",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.CPClass cpClassValue(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    CPClass cpString \u003d stringsToCPClass.get(string);\r\n    if (cpString \u003d\u003d null) {\r\n        final Integer index \u003d mapClass.get(string);\r\n        if (index !\u003d null) {\r\n            return cpClassValue(index.intValue());\r\n        }\r\n        cpString \u003d new CPClass(cpUTF8Value(string, false), -1);\r\n        stringsToCPClass.put(string, cpString);\r\n    }\r\n    return cpString;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r11 !\u003d null) → B1 | else → B4",
      "B1 : If(r6 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  $r2 \u003d Map stringsToCPClass\u003e\n  $r3 \u003d $r2.get(r1)\n  r11 \u003d CPClass) $r3\n  if (r11 !\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r4 \u003d Map mapClass\u003e\n  $r5 \u003d $r4.get(r1)\n  r6 \u003d Integer) $r5\n  if (r6 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $i0 \u003d r6.intValue()\n  $r10 \u003d r0.cpClassValue($i0)\n  return\n}",
      "B3 {\n  $r12 \u003d CPClass\n  $r8 \u003d r0.cpUTF8Value(r1, 0)\n  $i2 \u003d (int) -1\n  new CPClass($r8, $i2)\n  r11 \u003d $r12\n  $r9 \u003d Map stringsToCPClass\u003e\n  $r9.put(r1, $r12)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#cpUTF8Value(...2)",
        "body": "{\r\n    CPUTF8 cputf8 \u003d stringsToCPUTF8.get(string);\r\n    if (cputf8 \u003d\u003d null) {\r\n        Integer index \u003d null;\r\n        if (searchForIndex) {\r\n            index \u003d mapUTF8.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpUTF8Value(index.intValue());\r\n        }\r\n        if (searchForIndex) {\r\n            index \u003d mapSignature.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpSignatureValue(index.intValue());\r\n        }\r\n        cputf8 \u003d new CPUTF8(string, -1);\r\n        stringsToCPUTF8.put(string, cputf8);\r\n    }\r\n    return cputf8;\r\n}"
      },
      {
        "name": "CpBands#cpClassValue(...1)",
        "body": "{\r\n    final String string \u003d cpClass[index];\r\n    final int utf8Index \u003d cpClassInts[index];\r\n    final int globalIndex \u003d classOffset + index;\r\n    return stringsToCPClass.computeIfAbsent(string, k -\u003e new CPClass(cpUTF8Value(utf8Index), globalIndex));\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.CpBands",
    "methodName": "cpNameAndTypeValue",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.CPNameAndType cpNameAndTypeValue(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    CPNameAndType cpNameAndType \u003d descriptorsToCPNameAndTypes.get(descriptor);\r\n    if (cpNameAndType \u003d\u003d null) {\r\n        final Integer index \u003d mapDescriptor.get(descriptor);\r\n        if (index !\u003d null) {\r\n            return cpNameAndTypeValue(index.intValue());\r\n        }\r\n        final int colon \u003d descriptor.indexOf(\u0027:\u0027);\r\n        final String nameString \u003d descriptor.substring(0, colon);\r\n        final String descriptorString \u003d descriptor.substring(colon + 1);\r\n        final CPUTF8 name \u003d cpUTF8Value(nameString, true);\r\n        final CPUTF8 descriptorU \u003d cpUTF8Value(descriptorString, true);\r\n        cpNameAndType \u003d new CPNameAndType(name, descriptorU, -1 + descrOffset);\r\n        descriptorsToCPNameAndTypes.put(descriptor, cpNameAndType);\r\n    }\r\n    return cpNameAndType;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r14 !\u003d null) → B1 | else → B4",
      "B1 : If(r6 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  $r2 \u003d Map descriptorsToCPNameAndTypes\u003e\n  $r3 \u003d $r2.get(r1)\n  r14 \u003d CPNameAndType) $r3\n  if (r14 !\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r4 \u003d Map mapDescriptor\u003e\n  $r5 \u003d $r4.get(r1)\n  r6 \u003d Integer) $r5\n  if (r6 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $i4 \u003d r6.intValue()\n  $r13 \u003d r0.cpNameAndTypeValue($i4)\n  return\n}",
      "B3 {\n  i0 \u003d r1.indexOf(58)\n  r7 \u003d r1.substring(0, i0)\n  $i1 \u003d i0 + 1\n  r8 \u003d r1.substring($i1)\n  r9 \u003d r0.cpUTF8Value(r7, 1)\n  r10 \u003d r0.cpUTF8Value(r8, 1)\n  $r15 \u003d CPNameAndType\n  $i2 \u003d CpBands: int descrOffset\u003e\n  $i6 \u003d (int) -1\n  $i3 \u003d $i6 + $i2\n  new CPNameAndType(r9, r10, $i3)\n  r14 \u003d $r15\n  $r12 \u003d Map descriptorsToCPNameAndTypes\u003e\n  $r12.put(r1, $r15)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#cpUTF8Value(...2)",
        "body": "{\r\n    CPUTF8 cputf8 \u003d stringsToCPUTF8.get(string);\r\n    if (cputf8 \u003d\u003d null) {\r\n        Integer index \u003d null;\r\n        if (searchForIndex) {\r\n            index \u003d mapUTF8.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpUTF8Value(index.intValue());\r\n        }\r\n        if (searchForIndex) {\r\n            index \u003d mapSignature.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpSignatureValue(index.intValue());\r\n        }\r\n        cputf8 \u003d new CPUTF8(string, -1);\r\n        stringsToCPUTF8.put(string, cputf8);\r\n    }\r\n    return cputf8;\r\n}"
      },
      {
        "name": "CpBands#cpNameAndTypeValue(...1)",
        "body": "{\r\n    final String descriptor \u003d cpDescriptor[index];\r\n    return descriptorsToCPNameAndTypes.computeIfAbsent(descriptor, k -\u003e {\r\n        final int nameIndex \u003d cpDescriptorNameInts[index];\r\n        final int descriptorIndex \u003d cpDescriptorTypeInts[index];\r\n        final CPUTF8 name \u003d cpUTF8Value(nameIndex);\r\n        final CPUTF8 descriptorU \u003d cpSignatureValue(descriptorIndex);\r\n        return new CPNameAndType(name, descriptorU, index + descrOffset);\r\n    });\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.CpBands",
    "methodName": "cpSignatureValue",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8 cpSignatureValue(int)",
    "visibility": "public",
    "body": "{\r\n    final int globalIndex;\r\n    if (cpSignatureInts[index] !\u003d -1) {\r\n        globalIndex \u003d cpSignatureInts[index];\r\n    } else {\r\n        globalIndex \u003d index + signatureOffset;\r\n    }\r\n    return stringsToCPUTF8.computeIfAbsent(cpSignature[index], k -\u003e new CPUTF8(k, globalIndex));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  i0 :\u003d @parameter0: int\n  $r1 \u003d CpBands: int[] cpSignatureInts\u003e\n  $i1 \u003d $r1[i0]\n  $i5 \u003d (int) -1\n  if ($i1 \u003d\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d CpBands: int[] cpSignatureInts\u003e\n  i3 \u003d $r8[i0]\n  goto B3\n}",
      "B2 {\n  $i2 \u003d CpBands: int signatureOffset\u003e\n  i3 \u003d i0 + $i2\n}",
      "B3 {\n  $r3 \u003d Map stringsToCPUTF8\u003e\n  $r2 \u003d String[] cpSignature\u003e\n  $r4 \u003d $r2[i0]\n  $r5 \u003d CpBands$lambda_cpSignatureValue_6__54.bootstrap$(i3)\n  $r6 \u003d $r3.computeIfAbsent($r4, $r5)\n  $r7 \u003d CPUTF8) $r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.CpBands",
    "methodName": "cpUTF8Value",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8 cpUTF8Value(int)",
    "visibility": "public",
    "body": "{\r\n    final String string \u003d cpUTF8[index];\r\n    CPUTF8 cputf8 \u003d stringsToCPUTF8.get(string);\r\n    if (cputf8 \u003d\u003d null) {\r\n        cputf8 \u003d new CPUTF8(string, index);\r\n        stringsToCPUTF8.put(string, cputf8);\r\n    } else if (cputf8.getGlobalIndex() \u003e index) {\r\n        cputf8.setGlobalIndex(index);\r\n    }\r\n    return cputf8;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B2",
      "B2 : If($i1 \u003c\u003d i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  i0 :\u003d @parameter0: int\n  $r1 \u003d String[] cpUTF8\u003e\n  r2 \u003d $r1[i0]\n  $r3 \u003d Map stringsToCPUTF8\u003e\n  $r4 \u003d $r3.get(r2)\n  r7 \u003d CPUTF8) $r4\n  if (r7 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d CPUTF8\n  new CPUTF8(r2, i0)\n  r7 \u003d $r5\n  $r6 \u003d Map stringsToCPUTF8\u003e\n  $r6.put(r2, $r5)\n  goto B4\n}",
      "B2 {\n  $i1 \u003d r7.getGlobalIndex()\n  if ($i1 \u003c\u003d i0) goto B3 else B4\n}",
      "B3 {\n  r7.setGlobalIndex(i0)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.CpBands",
    "methodName": "cpUTF8Value",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.CPUTF8 cpUTF8Value(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    CPUTF8 cputf8 \u003d stringsToCPUTF8.get(string);\r\n    if (cputf8 \u003d\u003d null) {\r\n        Integer index \u003d null;\r\n        if (searchForIndex) {\r\n            index \u003d mapUTF8.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpUTF8Value(index.intValue());\r\n        }\r\n        if (searchForIndex) {\r\n            index \u003d mapSignature.get(string);\r\n        }\r\n        if (index !\u003d null) {\r\n            return cpSignatureValue(index.intValue());\r\n        }\r\n        cputf8 \u003d new CPUTF8(string, -1);\r\n        stringsToCPUTF8.put(string, cputf8);\r\n    }\r\n    return cputf8;\r\n}",
    "nodes": 11,
    "edges": 13,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r12 !\u003d null) → B1 | else → B10",
      "B1 : If(z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If(r13 \u003d\u003d null) → B4 | else → B5",
      "B5 : If(z0 \u003d\u003d false) → B6 | else → B7",
      "B7 : If(r13 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  CpBands\n  String\n  z0 :\u003d @parameter1: boolean\n  $r2 \u003d Map stringsToCPUTF8\u003e\n  $r3 \u003d $r2.get(r1)\n  r12 \u003d CPUTF8) $r3\n  if (r12 !\u003d null) goto B1 else B10\n}",
      "B1 {\n  r13 \u003d null\n  if (z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r10 \u003d Map mapUTF8\u003e\n  $r11 \u003d $r10.get(r1)\n  r13 \u003d Integer) $r11\n}",
      "B3 {\n  if (r13 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $i1 \u003d r13.intValue()\n  $r9 \u003d r0.cpUTF8Value($i1)\n  return\n}",
      "B5 {\n  if (z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d Map mapSignature\u003e\n  $r8 \u003d $r7.get(r1)\n  r13 \u003d Integer) $r8\n}",
      "B7 {\n  if (r13 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  $i0 \u003d r13.intValue()\n  $r6 \u003d r0.cpSignatureValue($i0)\n  return\n}",
      "B9 {\n  $r14 \u003d CPUTF8\n  $i3 \u003d (int) -1\n  new CPUTF8(r1, $i3)\n  r12 \u003d $r14\n  $r5 \u003d Map stringsToCPUTF8\u003e\n  $r5.put(r1, $r14)\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CpBands#cpSignatureValue(...1)",
        "body": "{\r\n    final int globalIndex;\r\n    if (cpSignatureInts[index] !\u003d -1) {\r\n        globalIndex \u003d cpSignatureInts[index];\r\n    } else {\r\n        globalIndex \u003d index + signatureOffset;\r\n    }\r\n    return stringsToCPUTF8.computeIfAbsent(cpSignature[index], k -\u003e new CPUTF8(k, globalIndex));\r\n}"
      },
      {
        "name": "CpBands#cpUTF8Value(...1)",
        "body": "{\r\n    final String string \u003d cpUTF8[index];\r\n    CPUTF8 cputf8 \u003d stringsToCPUTF8.get(string);\r\n    if (cputf8 \u003d\u003d null) {\r\n        cputf8 \u003d new CPUTF8(string, index);\r\n        stringsToCPUTF8.put(string, cputf8);\r\n    } else if (cputf8.getGlobalIndex() \u003e index) {\r\n        cputf8.setGlobalIndex(index);\r\n    }\r\n    return cputf8;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.FileBands",
    "methodName": "processFileBits",
    "signature": "void processFileBits()",
    "visibility": "public",
    "body": "{\r\n    // now read in the bytes\r\n    final int numberOfFiles \u003d header.getNumberOfFiles();\r\n    fileBits \u003d new byte[numberOfFiles][];\r\n    for (int i \u003d 0; i \u003c numberOfFiles; i++) {\r\n        final int size \u003d (int) fileSize[i];\r\n        fileBits[i] \u003d IOUtils.readRange(in, size);\r\n        final int read \u003d fileBits[i].length;\r\n        if (size !\u003d 0 \u0026\u0026 read \u003c size) {\r\n            throw new IOException(\"Expected to read \" + size + \" bytes but read \" + read);\r\n        }\r\n    }\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i0) → B2 | else → B6",
      "B2 : If(i2 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(i3 \u003e\u003d i2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileBands\n  $r1 \u003d SegmentHeader header\u003e\n  i0 \u003d $r1.getNumberOfFiles()\n  $r2 \u003d newarray (byte[])[i0]\n  FileBands: byte[][] fileBits\u003e \u003d $r2\n  i4 \u003d 0\n}",
      "B1 {\n  if (i4 \u003e\u003d i0) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d FileBands: long[] fileSize\u003e\n  $l1 \u003d $r3[i4]\n  i2 \u003d (int) $l1\n  $r5 \u003d FileBands: byte[][] fileBits\u003e\n  $r4 \u003d InputStream in\u003e\n  $r6 \u003d IOUtils.readRange($r4, i2)\n  $r5[i4] \u003d $r6\n  $r7 \u003d FileBands: byte[][] fileBits\u003e\n  $r8 \u003d $r7[i4]\n  i3 \u003d lengthof $r8\n  if (i2 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  if (i3 \u003e\u003d i2) goto B4 else B5\n}",
      "B4 {\n  $r9 \u003d IOException\n  $r10 \u003d StringBuilder\n  new StringBuilder()\n  $r11 \u003d $r10.append(\"Expected to read \")\n  $r12 \u003d $r11.append(i2)\n  $r13 \u003d $r12.append(\" bytes but read \")\n  $r14 \u003d $r13.append(i3)\n  $r15 \u003d $r14.toString()\n  new IOException($r15)\n  throw $r9\n}",
      "B5 {\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.FileBands",
    "methodName": "read",
    "signature": "void read(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final int numberOfFiles \u003d header.getNumberOfFiles();\r\n    final SegmentOptions options \u003d header.getOptions();\r\n    fileName \u003d parseReferences(\"file_name\", in, Codec.UNSIGNED5, numberOfFiles, cpUTF8);\r\n    fileSize \u003d parseFlags(\"file_size\", in, numberOfFiles, Codec.UNSIGNED5, options.hasFileSizeHi());\r\n    if (options.hasFileModtime()) {\r\n        fileModtime \u003d decodeBandInt(\"file_modtime\", in, Codec.DELTA5, numberOfFiles);\r\n    } else {\r\n        fileModtime \u003d new int[numberOfFiles];\r\n    }\r\n    if (options.hasFileOptions()) {\r\n        fileOptions \u003d decodeBandInt(\"file_options\", in, Codec.UNSIGNED5, numberOfFiles);\r\n    } else {\r\n        fileOptions \u003d new int[numberOfFiles];\r\n    }\r\n    // store for use by processFileBits(), which is called\r\n    this.in \u003d in;\r\n    // later\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z1 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FileBands\n  InputStream\n  $r1 \u003d SegmentHeader header\u003e\n  i0 \u003d $r1.getNumberOfFiles()\n  $r2 \u003d SegmentHeader header\u003e\n  r3 \u003d $r2.getOptions()\n  $r6 \u003d BHSDCodec UNSIGNED5\u003e\n  $r5 \u003d String[] cpUTF8\u003e\n  $r7 \u003d r0.parseReferences(\"file_name\", r4, $r6, i0, $r5)\n  String[] fileName\u003e \u003d $r7\n  $r8 \u003d BHSDCodec UNSIGNED5\u003e\n  $z0 \u003d r3.hasFileSizeHi()\n  $r9 \u003d r0.parseFlags(\"file_size\", r4, i0, $r8, $z0)\n  FileBands: long[] fileSize\u003e \u003d $r9\n  $z1 \u003d r3.hasFileModtime()\n  if ($z1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r14 \u003d BHSDCodec DELTA5\u003e\n  $r15 \u003d r0.decodeBandInt(\"file_modtime\", r4, $r14, i0)\n  FileBands: int[] fileModtime\u003e \u003d $r15\n  goto B3\n}",
      "B2 {\n  $r10 \u003d newarray (int)[i0]\n  FileBands: int[] fileModtime\u003e \u003d $r10\n}",
      "B3 {\n  $z2 \u003d r3.hasFileOptions()\n  if ($z2 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r12 \u003d BHSDCodec UNSIGNED5\u003e\n  $r13 \u003d r0.decodeBandInt(\"file_options\", r4, $r12, i0)\n  FileBands: int[] fileOptions\u003e \u003d $r13\n  goto B6\n}",
      "B5 {\n  $r11 \u003d newarray (int)[i0]\n  FileBands: int[] fileOptions\u003e \u003d $r11\n}",
      "B6 {\n  InputStream in\u003e \u003d r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FileBands#parseReferences(...5)",
        "body": "(source not found)"
      },
      {
        "name": "FileBands#parseFlags(...5)",
        "body": "(source not found)"
      },
      {
        "name": "FileBands#decodeBandInt(...4)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcBands",
    "methodName": "getRelevantIcTuples",
    "signature": "org.apache.commons.compress.harmony.unpack200.IcTuple[] getRelevantIcTuples(java.lang.String,org.apache.commons.compress.harmony.unpack200.bytecode.ClassConstantPool)",
    "visibility": "public",
    "body": "{\r\n    final Set\u003cIcTuple\u003e relevantTuplesContains \u003d new HashSet\u003c\u003e();\r\n    final List\u003cIcTuple\u003e relevantTuples \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cIcTuple\u003e relevantCandidates \u003d outerClassToTuples.get(className);\r\n    if (relevantCandidates !\u003d null) {\r\n        for (int index \u003d 0; index \u003c relevantCandidates.size(); index++) {\r\n            final IcTuple tuple \u003d relevantCandidates.get(index);\r\n            relevantTuplesContains.add(tuple);\r\n            relevantTuples.add(tuple);\r\n        }\r\n    }\r\n    final List\u003cClassFileEntry\u003e entries \u003d cp.entries();\r\n    // For every class constant in both ic_this_class and cp,\r\n    // add it to ic_relevant. Repeat until no more\r\n    // changes to ic_relevant.\r\n    for (int eIndex \u003d 0; eIndex \u003c entries.size(); eIndex++) {\r\n        final ConstantPoolEntry entry \u003d (ConstantPoolEntry) entries.get(eIndex);\r\n        if (entry instanceof CPClass) {\r\n            final CPClass clazz \u003d (CPClass) entry;\r\n            final IcTuple relevant \u003d thisClassToTuple.get(clazz.name);\r\n            if (relevant !\u003d null \u0026\u0026 relevantTuplesContains.add(relevant)) {\r\n                relevantTuples.add(relevant);\r\n            }\r\n        }\r\n    }\r\n    // Not part of spec: fix up by adding to relevantTuples the parents\r\n    // of inner classes which are themselves inner classes.\r\n    // i.e., I think that if Foo$Bar$Baz gets added, Foo$Bar needs to be\r\n    // added\r\n    // as well.\r\n    final List\u003cIcTuple\u003e tuplesToScan \u003d new ArrayList\u003c\u003e(relevantTuples);\r\n    final List\u003cIcTuple\u003e tuplesToAdd \u003d new ArrayList\u003c\u003e();\r\n    while (tuplesToScan.size() \u003e 0) {\r\n        tuplesToAdd.clear();\r\n        for (int index \u003d 0; index \u003c tuplesToScan.size(); index++) {\r\n            final IcTuple aRelevantTuple \u003d tuplesToScan.get(index);\r\n            final IcTuple relevant \u003d thisClassToTuple.get(aRelevantTuple.outerClassString());\r\n            if (relevant !\u003d null \u0026\u0026 !aRelevantTuple.outerIsAnonymous()) {\r\n                tuplesToAdd.add(relevant);\r\n            }\r\n        }\r\n        tuplesToScan.clear();\r\n        for (int index \u003d 0; index \u003c tuplesToAdd.size(); index++) {\r\n            final IcTuple tuple \u003d tuplesToAdd.get(index);\r\n            if (relevantTuplesContains.add(tuple)) {\r\n                relevantTuples.add(tuple);\r\n                tuplesToScan.add(tuple);\r\n            }\r\n        }\r\n    }\r\n    // End not part of the spec. Ugh.\r\n    // Now order the result as a subsequence of ic_all\r\n    relevantTuples.sort((arg0, arg1) -\u003e {\r\n        final int index1 \u003d arg0.getTupleIndex();\r\n        final Integer index2 \u003d Integer.valueOf(arg1.getTupleIndex());\r\n        return Integer.compare(index1, index2);\r\n    });\r\n    return relevantTuples.toArray(IcTuple.EMPTY_ARRAY);\r\n}",
    "nodes": 26,
    "edges": 37,
    "cc": 13,
    "flowSummary": [
      "B0 : If(r6 \u003d\u003d null) → B1 | else → B4",
      "B2 : If(i4 \u003e\u003d $i3) → B3 | else → B4",
      "B5 : If(i5 \u003e\u003d $i6) → B6 | else → B11",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B10",
      "B7 : If(r29 \u003d\u003d null) → B8 | else → B10",
      "B8 : If($z3 \u003d\u003d false) → B9 | else → B10",
      "B12 : If($i0 \u003c\u003d 0) → B13 | else → B25",
      "B14 : If(i7 \u003e\u003d $i1) → B15 | else → B19",
      "B15 : If(r19 \u003d\u003d null) → B16 | else → B18",
      "B16 : If($z1 !\u003d 0) → B17 | else → B18",
      "B20 : If(i8 \u003e\u003d $i2) → B21 | else → B24",
      "B21 : If($z0 \u003d\u003d false) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  String\n  ClassConstantPool\n  $r0 \u003d HashSet\n  new HashSet()\n  $r1 \u003d ArrayList\n  new ArrayList()\n  $r4 \u003d Map outerClassToTuples\u003e\n  $r5 \u003d $r4.get(r3)\n  r6 \u003d List) $r5\n  if (r6 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  i4 \u003d 0\n}",
      "B2 {\n  $i3 \u003d r6.size()\n  if (i4 \u003e\u003d $i3) goto B3 else B4\n}",
      "B3 {\n  $r25 \u003d r6.get(i4)\n  r26 \u003d IcTuple) $r25\n  $r0.add(r26)\n  $r1.add(r26)\n  i4 \u003d i4 + 1\n  goto B2\n}",
      "B4 {\n  $r24 \u003d r7.entries()\n  i5 \u003d 0\n}",
      "B5 {\n  $i6 \u003d $r24.size()\n  if (i5 \u003e\u003d $i6) goto B6 else B11\n}",
      "B6 {\n  $r20 \u003d $r24.get(i5)\n  r27 \u003d ConstantPoolEntry) $r20\n  $z2 \u003d CPClass\n  if ($z2 \u003d\u003d false) goto B7 else B10\n}",
      "B7 {\n  r28 \u003d CPClass) r27\n  $r22 \u003d Map thisClassToTuple\u003e\n  $r21 \u003d String name\u003e\n  $r23 \u003d $r22.get($r21)\n  r29 \u003d IcTuple) $r23\n  if (r29 \u003d\u003d null) goto B8 else B10\n}",
      "B8 {\n  $z3 \u003d $r0.add(r29)\n  if ($z3 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r1.add(r29)\n}",
      "B10 {\n  i5 \u003d i5 + 1\n  goto B5\n}",
      "B11 {\n  $r8 \u003d ArrayList\n  new ArrayList($r1)\n  $r9 \u003d ArrayList\n  new ArrayList()\n}",
      "B12 {\n  $i0 \u003d $r8.size()\n  if ($i0 \u003c\u003d 0) goto B13 else B25\n}",
      "B13 {\n  $r9.clear()\n  i7 \u003d 0\n}",
      "B14 {\n  $i1 \u003d $r8.size()\n  if (i7 \u003e\u003d $i1) goto B15 else B19\n}",
      "B15 {\n  $r15 \u003d $r8.get(i7)\n  r30 \u003d IcTuple) $r15\n  $r16 \u003d Map thisClassToTuple\u003e\n  $r17 \u003d r30.outerClassString()\n  $r18 \u003d $r16.get($r17)\n  r19 \u003d IcTuple) $r18\n  if (r19 \u003d\u003d null) goto B16 else B18\n}",
      "B16 {\n  $z1 \u003d r30.outerIsAnonymous()\n  if ($z1 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r9.add(r19)\n}",
      "B18 {\n  i7 \u003d i7 + 1\n  goto B14\n}",
      "B19 {\n  $r8.clear()\n  i8 \u003d 0\n}",
      "B20 {\n  $i2 \u003d $r9.size()\n  if (i8 \u003e\u003d $i2) goto B21 else B24\n}",
      "B21 {\n  $r14 \u003d $r9.get(i8)\n  r31 \u003d IcTuple) $r14\n  $z0 \u003d $r0.add(r31)\n  if ($z0 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $r1.add(r31)\n  $r8.add(r31)\n}",
      "B23 {\n  i8 \u003d i8 + 1\n  goto B20\n}",
      "B24 {\n  goto B12\n}",
      "B25 {\n  $r10 \u003d IcBands$lambda_getRelevantIcTuples_0__56.bootstrap$()\n  $r1.sort($r10)\n  $r11 \u003d IcTuple[] EMPTY_ARRAY\u003e\n  $r12 \u003d $r1.toArray($r11)\n  $r13 \u003d IcTuple[]) $r12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B5",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B25",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B19",
      "B15 --\u003e B16",
      "B15 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B14",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B24",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B20",
      "B24 --\u003e B12",
      "B25 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcBands",
    "methodName": "read",
    "signature": "void read(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    // Read IC bands\r\n    final int innerClassCount \u003d header.getInnerClassCount();\r\n    final int[] icThisClassInts \u003d decodeBandInt(\"ic_this_class\", in, Codec.UDELTA5, innerClassCount);\r\n    final String[] icThisClass \u003d getReferences(icThisClassInts, cpClass);\r\n    final int[] icFlags \u003d decodeBandInt(\"ic_flags\", in, Codec.UNSIGNED5, innerClassCount);\r\n    final int outerClasses \u003d SegmentUtils.countBit16(icFlags);\r\n    final int[] icOuterClassInts \u003d decodeBandInt(\"ic_outer_class\", in, Codec.DELTA5, outerClasses);\r\n    final String[] icOuterClass \u003d new String[outerClasses];\r\n    for (int i \u003d 0; i \u003c icOuterClass.length; i++) {\r\n        if (icOuterClassInts[i] \u003d\u003d 0) {\r\n            icOuterClass[i] \u003d null;\r\n        } else {\r\n            icOuterClass[i] \u003d cpClass[icOuterClassInts[i] - 1];\r\n        }\r\n    }\r\n    final int[] icNameInts \u003d decodeBandInt(\"ic_name\", in, Codec.DELTA5, outerClasses);\r\n    final String[] icName \u003d new String[outerClasses];\r\n    for (int i \u003d 0; i \u003c icName.length; i++) {\r\n        if (icNameInts[i] \u003d\u003d 0) {\r\n            icName[i] \u003d null;\r\n        } else {\r\n            icName[i] \u003d cpUTF8[icNameInts[i] - 1];\r\n        }\r\n    }\r\n    // Construct IC tuples\r\n    icAll \u003d new IcTuple[icThisClass.length];\r\n    int index \u003d 0;\r\n    for (int i \u003d 0; i \u003c icThisClass.length; i++) {\r\n        final String icTupleC \u003d icThisClass[i];\r\n        final int icTupleF \u003d icFlags[i];\r\n        String icTupleC2 \u003d null;\r\n        String icTupleN \u003d null;\r\n        final int cIndex \u003d icThisClassInts[i];\r\n        int c2Index \u003d -1;\r\n        int nIndex \u003d -1;\r\n        if ((icFlags[i] \u0026 1 \u003c\u003c 16) !\u003d 0) {\r\n            icTupleC2 \u003d icOuterClass[index];\r\n            icTupleN \u003d icName[index];\r\n            c2Index \u003d icOuterClassInts[index] - 1;\r\n            nIndex \u003d icNameInts[index] - 1;\r\n            index++;\r\n        }\r\n        icAll[i] \u003d new IcTuple(icTupleC, icTupleF, icTupleC2, icTupleN, cIndex, c2Index, nIndex, i);\r\n    }\r\n}",
    "nodes": 18,
    "edges": 23,
    "cc": 7,
    "flowSummary": [
      "B1 : If(i18 \u003e\u003d $i2) → B2 | else → B6",
      "B2 : If($i15 !\u003d 0) → B3 | else → B4",
      "B7 : If(i19 \u003e\u003d $i3) → B8 | else → B12",
      "B8 : If($i12 !\u003d 0) → B9 | else → B10",
      "B13 : If(i21 \u003e\u003d $i5) → B14 | else → B17",
      "B14 : If($i9 \u003d\u003d false) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  InputStream\n  $r1 \u003d SegmentHeader header\u003e\n  i0 \u003d $r1.getInnerClassCount()\n  $r3 \u003d BHSDCodec UDELTA5\u003e\n  r4 \u003d r0.decodeBandInt(\"ic_this_class\", r2, $r3, i0)\n  $r5 \u003d String[] cpClass\u003e\n  r6 \u003d r0.getReferences(r4, $r5)\n  $r7 \u003d BHSDCodec UNSIGNED5\u003e\n  r8 \u003d r0.decodeBandInt(\"ic_flags\", r2, $r7, i0)\n  i1 \u003d SegmentUtils.countBit16(r8)\n  $r9 \u003d BHSDCodec DELTA5\u003e\n  r10 \u003d r0.decodeBandInt(\"ic_outer_class\", r2, $r9, i1)\n  r11 \u003d String)[i1]\n  i18 \u003d 0\n}",
      "B1 {\n  $i2 \u003d lengthof r11\n  if (i18 \u003e\u003d $i2) goto B2 else B6\n}",
      "B2 {\n  $i15 \u003d r10[i18]\n  if ($i15 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  r11[i18] \u003d null\n  goto B5\n}",
      "B4 {\n  $r20 \u003d String[] cpClass\u003e\n  $i16 \u003d r10[i18]\n  $i17 \u003d $i16 - 1\n  $r21 \u003d $r20[$i17]\n  r11[i18] \u003d $r21\n}",
      "B5 {\n  i18 \u003d i18 + 1\n  goto B1\n}",
      "B6 {\n  $r12 \u003d BHSDCodec DELTA5\u003e\n  r22 \u003d r0.decodeBandInt(\"ic_name\", r2, $r12, i1)\n  r13 \u003d String)[i1]\n  i19 \u003d 0\n}",
      "B7 {\n  $i3 \u003d lengthof r13\n  if (i19 \u003e\u003d $i3) goto B8 else B12\n}",
      "B8 {\n  $i12 \u003d r22[i19]\n  if ($i12 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  r13[i19] \u003d null\n  goto B11\n}",
      "B10 {\n  $r18 \u003d String[] cpUTF8\u003e\n  $i13 \u003d r22[i19]\n  $i14 \u003d $i13 - 1\n  $r19 \u003d $r18[$i14]\n  r13[i19] \u003d $r19\n}",
      "B11 {\n  i19 \u003d i19 + 1\n  goto B7\n}",
      "B12 {\n  $i4 \u003d lengthof r6\n  $r14 \u003d IcTuple)[$i4]\n  IcTuple[] icAll\u003e \u003d $r14\n  i20 \u003d 0\n  i21 \u003d 0\n}",
      "B13 {\n  $i5 \u003d lengthof r6\n  if (i21 \u003e\u003d $i5) goto B14 else B17\n}",
      "B14 {\n  r15 \u003d r6[i21]\n  i6 \u003d r8[i21]\n  r23 \u003d null\n  r24 \u003d null\n  i7 \u003d r4[i21]\n  $i25 \u003d (int) -1\n  i22 \u003d $i25\n  $i27 \u003d (int) -1\n  i23 \u003d $i27\n  $i8 \u003d r8[i21]\n  $i9 \u003d $i8 \u0026 65536\n  if ($i9 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  r23 \u003d r11[i20]\n  r24 \u003d r13[i20]\n  $i10 \u003d r10[i20]\n  i22 \u003d $i10 - 1\n  $i11 \u003d r22[i20]\n  i23 \u003d $i11 - 1\n  i20 \u003d i20 + 1\n}",
      "B16 {\n  $r17 \u003d IcTuple[] icAll\u003e\n  $r25 \u003d IcTuple\n  new IcTuple(r15, i6, r23, r24, i7, i22, i23, i21)\n  $r17[i21] \u003d $r25\n  i21 \u003d i21 + 1\n  goto B13\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B7",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B13",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcBands#decodeBandInt(...4)",
        "body": "(source not found)"
      },
      {
        "name": "IcBands#getReferences(...2)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcBands",
    "methodName": "unpack",
    "signature": "void unpack()",
    "visibility": "public",
    "body": "{\r\n    final IcTuple[] allTuples \u003d getIcTuples();\r\n    thisClassToTuple \u003d new HashMap\u003c\u003e(allTuples.length);\r\n    outerClassToTuples \u003d new HashMap\u003c\u003e(allTuples.length);\r\n    for (final IcTuple tuple : allTuples) {\r\n        // generate mapping thisClassString -\u003e IcTuple\r\n        // presumably this relation is 1:1\r\n        //\r\n        final Object result \u003d thisClassToTuple.put(tuple.thisClassString(), tuple);\r\n        if (result !\u003d null) {\r\n            throw new Error(\"Collision detected in \u003cthisClassString, IcTuple\u003e mapping. \" + \"There are at least two inner clases with the same name.\");\r\n        }\r\n        // generate mapping outerClassString -\u003e IcTuple\r\n        // this relation is 1:M\r\n        // If it\u0027s not anon and the outer is not anon, it could be relevant\r\n        if (!tuple.isAnonymous() \u0026\u0026 !tuple.outerIsAnonymous() || tuple.nestedExplicitFlagSet()) {\r\n            // add tuple to corresponding bucket\r\n            final String key \u003d tuple.outerClassString();\r\n            outerClassToTuples.computeIfAbsent(key, k -\u003e new ArrayList\u003c\u003e()).add(tuple);\r\n        }\r\n    }\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i2) → B2 | else → B9",
      "B2 : If(r7 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  IcBands\n  r1 \u003d r0.getIcTuples()\n  $r2 \u003d HashMap\n  $i0 \u003d lengthof r1\n  new HashMap($i0)\n  Map thisClassToTuple\u003e \u003d $r2\n  $r3 \u003d HashMap\n  $i1 \u003d lengthof r1\n  new HashMap($i1)\n  Map outerClassToTuples\u003e \u003d $r3\n  i2 \u003d lengthof r1\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i2) goto B2 else B9\n}",
      "B2 {\n  r4 \u003d r1[i3]\n  $r5 \u003d Map thisClassToTuple\u003e\n  $r6 \u003d r4.thisClassString()\n  r7 \u003d $r5.put($r6, r4)\n  if (r7 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r13 \u003d Error\n  new Error(\"Collision detected in \u003cthisClassString, IcTuple\u003e mapping. There are at least two inner clases with the same name.\")\n  throw $r13\n}",
      "B4 {\n  $z0 \u003d r4.isAnonymous()\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z2 \u003d r4.outerIsAnonymous()\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d r4.nestedExplicitFlagSet()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r12 \u003d r4.outerClassString()\n  $r8 \u003d Map outerClassToTuples\u003e\n  $r9 \u003d IcBands$lambda_unpack_1__57.bootstrap$()\n  $r10 \u003d $r8.computeIfAbsent($r12, $r9)\n  $r11 \u003d List) $r10\n  $r11.add(r4)\n}",
      "B8 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B1",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcBands#getIcTuples(...0)",
        "body": "{\r\n    return icAll;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (object \u003d\u003d null || object.getClass() !\u003d this.getClass()) {\r\n        return false;\r\n    }\r\n    final IcTuple other \u003d (IcTuple) object;\r\n    return Objects.equals(C, other.C) \u0026\u0026 Objects.equals(C2, other.C2) \u0026\u0026 Objects.equals(N, other.N);\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($r3 \u003d\u003d $r2) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B7",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B7",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  Object\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  r4 \u003d IcTuple) r0\n  $r6 \u003d String C\u003e\n  $r5 \u003d String C\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  $r8 \u003d String C2\u003e\n  $r7 \u003d String C2\u003e\n  $z1 \u003d Objects.equals($r8, $r7)\n  if ($z1 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  $r10 \u003d String N\u003e\n  $r9 \u003d String N\u003e\n  $z2 \u003d Objects.equals($r10, $r9)\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z3 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z3 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcTuple#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (!hashCodeComputed) {\r\n        generateHashCode();\r\n    }\r\n    return cachedHashCode;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  $z0 \u003d IcTuple: boolean hashCodeComputed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.generateHashCode()\n}",
      "B2 {\n  $i0 \u003d IcTuple: int cachedHashCode\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcTuple#generateHashCode(...0)",
        "body": "{\r\n    hashCodeComputed \u003d true;\r\n    cachedHashCode \u003d 17;\r\n    if (C !\u003d null) {\r\n        cachedHashCode \u003d +C.hashCode();\r\n    }\r\n    if (C2 !\u003d null) {\r\n        cachedHashCode \u003d +C2.hashCode();\r\n    }\r\n    if (N !\u003d null) {\r\n        cachedHashCode \u003d +N.hashCode();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "innerBreakAtDollar",
    "signature": "java.lang.String[] innerBreakAtDollar(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final List\u003cString\u003e resultList \u003d new ArrayList\u003c\u003e();\r\n    int start \u003d 0;\r\n    int index \u003d 0;\r\n    while (index \u003c className.length()) {\r\n        if (className.charAt(index) \u003c\u003d \u0027$\u0027) {\r\n            resultList.add(className.substring(start, index));\r\n            start \u003d index + 1;\r\n        }\r\n        index++;\r\n        if (index \u003e\u003d className.length()) {\r\n            // Add the last element\r\n            resultList.add(className.substring(start));\r\n        }\r\n    }\r\n    return resultList.toArray(EMPTY_STRING_ARRAY);\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d $i4) → B2 | else → B6",
      "B2 : If($i5 \u003e 36) → B3 | else → B4",
      "B4 : If(i3 \u003c $i1) → B5 | else → B1"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  String\n  $r8 \u003d ArrayList\n  new ArrayList()\n  i2 \u003d 0\n  i3 \u003d 0\n}",
      "B1 {\n  $i4 \u003d r1.length()\n  if (i3 \u003e\u003d $i4) goto B2 else B6\n}",
      "B2 {\n  $c0 \u003d r1.charAt(i3)\n  $i5 \u003d (int) $c0\n  if ($i5 \u003e 36) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d r1.substring(i2, i3)\n  $r8.add($r6)\n  i2 \u003d i3 + 1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  $i1 \u003d r1.length()\n  if (i3 \u003c $i1) goto B5 else B1\n}",
      "B5 {\n  $r5 \u003d r1.substring(i2)\n  $r8.add($r5)\n  goto B1\n}",
      "B6 {\n  $r2 \u003d String[] EMPTY_STRING_ARRAY\u003e\n  $r3 \u003d $r8.toArray($r2)\n  $r4 \u003d String[]) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B1",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "nestedExplicitFlagSet",
    "signature": "boolean nestedExplicitFlagSet()",
    "visibility": "public",
    "body": "{\r\n    return (F \u0026 NESTED_CLASS_FLAG) \u003d\u003d NESTED_CLASS_FLAG;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 !\u003d 65536) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  $i0 \u003d IcTuple: int F\u003e\n  $i1 \u003d $i0 \u0026 65536\n  if ($i1 !\u003d 65536) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "nullSafeEquals",
    "signature": "boolean nullSafeEquals(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (null \u003d\u003d stringOne) {\r\n        return null \u003d\u003d stringTwo;\r\n    }\r\n    return stringOne.equals(stringTwo);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(null !\u003d r0) → B1 | else → B5",
      "B1 : If(null !\u003d r1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  String\n  String\n  if (null !\u003d r0) goto B1 else B5\n}",
      "B1 {\n  if (null !\u003d r1) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d r0.equals(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "predicted",
    "signature": "boolean predicted()",
    "visibility": "public",
    "body": "{\r\n    return predictOuter || predictSimple;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  $z0 \u003d IcTuple: boolean predictOuter\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d IcTuple: boolean predictSimple\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "thisClassIndex",
    "signature": "int thisClassIndex()",
    "visibility": "public",
    "body": "{\r\n    if (predicted()) {\r\n        return cIndex;\r\n    }\r\n    return -1;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  $z0 \u003d r0.predicted()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d IcTuple: int cIndex\u003e\n  return\n}",
      "B2 {\n  $i2 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcTuple#predicted(...0)",
        "body": "{\r\n    return predictOuter || predictSimple;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.IcTuple",
    "methodName": "thisClassString",
    "signature": "java.lang.String thisClassString()",
    "visibility": "public",
    "body": "{\r\n    if (predicted()) {\r\n        return C;\r\n    }\r\n    // TODO: this may not be right. What if I\r\n    // get a class like Foo#Bar$Baz$Bug?\r\n    return C2 + \"$\" + N;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IcTuple\n  $z0 \u003d r0.predicted()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d String C\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d StringBuilder\n  new StringBuilder()\n  $r2 \u003d String C2\u003e\n  $r3 \u003d $r1.append($r2)\n  $r5 \u003d $r3.append(\"$\")\n  $r4 \u003d String N\u003e\n  $r6 \u003d $r5.append($r4)\n  $r7 \u003d $r6.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IcTuple#predicted(...0)",
        "body": "{\r\n    return predictOuter || predictSimple;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.MetadataBandGroup",
    "methodName": "getAttributes",
    "signature": "java.util.List getAttributes()",
    "visibility": "public",
    "body": "{\r\n    // TODO: Optimize iterators!\r\n    if (attributes \u003d\u003d null) {\r\n        attributes \u003d new ArrayList\u003c\u003e();\r\n        if (name_RU !\u003d null) {\r\n            final Iterator\u003cCPUTF8\u003e name_RU_Iterator \u003d Arrays.asList(name_RU).iterator();\r\n            if (!type.equals(\"AD\")) {\r\n                T_index \u003d 0;\r\n            }\r\n            caseI_KI_Index \u003d 0;\r\n            caseD_KD_Index \u003d 0;\r\n            caseF_KF_Index \u003d 0;\r\n            caseJ_KJ_Index \u003d 0;\r\n            casec_RS_Index \u003d 0;\r\n            caseet_RS_Index \u003d 0;\r\n            caseec_RU_Index \u003d 0;\r\n            cases_RU_Index \u003d 0;\r\n            casearray_N_Index \u003d 0;\r\n            nesttype_RS_Index \u003d 0;\r\n            nestpair_N_Index \u003d 0;\r\n            nestname_RU_Iterator \u003d Arrays.asList(nestname_RU).iterator();\r\n            if (type.equals(\"RVA\") || type.equals(\"RIA\")) {\r\n                for (int i \u003d 0; i \u003c anno_N.length; i++) {\r\n                    attributes.add(getAttribute(anno_N[i], type_RS[i], pair_N[i], name_RU_Iterator));\r\n                }\r\n            } else if (type.equals(\"RVPA\") || type.equals(\"RIPA\")) {\r\n                anno_N_Index \u003d 0;\r\n                pair_N_Index \u003d 0;\r\n                for (final int element : param_NB) {\r\n                    attributes.add(getParameterAttribute(element, name_RU_Iterator));\r\n                }\r\n            }\r\n        } else if (type.equals(\"AD\")) {\r\n            for (final int element : T) {\r\n                attributes.add(new AnnotationDefaultAttribute(new ElementValue(element, getNextValue(element))));\r\n            }\r\n        }\r\n    }\r\n    return attributes;\r\n}",
    "nodes": 21,
    "edges": 31,
    "cc": 12,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B20",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B16",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4",
      "B4 : If($z2 !\u003d 0) → B5 | else → B6",
      "B5 : If($z3 \u003d\u003d false) → B6 | else → B10",
      "B7 : If(i3 \u003e\u003d $i4) → B8 | else → B9",
      "B10 : If($z4 !\u003d 0) → B11 | else → B12",
      "B11 : If($z5 \u003d\u003d false) → B12 | else → B15",
      "B13 : If(i5 \u003e\u003d $i2) → B14 | else → B15",
      "B16 : If($z0 \u003d\u003d false) → B17 | else → B20",
      "B18 : If(i7 \u003e\u003d i6) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  MetadataBandGroup\n  $r1 \u003d List attributes\u003e\n  if ($r1 !\u003d null) goto B1 else B20\n}",
      "B1 {\n  $r2 \u003d ArrayList\n  new ArrayList()\n  List attributes\u003e \u003d $r2\n  $r3 \u003d CPUTF8[] name_RU\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B16\n}",
      "B2 {\n  $r9 \u003d CPUTF8[] name_RU\u003e\n  $r10 \u003d Arrays.asList($r9)\n  r29 \u003d $r10.iterator()\n  $r11 \u003d String type\u003e\n  $z1 \u003d $r11.equals(\"AD\")\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  MetadataBandGroup: int T_index\u003e \u003d 0\n}",
      "B4 {\n  MetadataBandGroup: int caseI_KI_Index\u003e \u003d 0\n  MetadataBandGroup: int caseD_KD_Index\u003e \u003d 0\n  MetadataBandGroup: int caseF_KF_Index\u003e \u003d 0\n  MetadataBandGroup: int caseJ_KJ_Index\u003e \u003d 0\n  MetadataBandGroup: int casec_RS_Index\u003e \u003d 0\n  MetadataBandGroup: int caseet_RS_Index\u003e \u003d 0\n  MetadataBandGroup: int caseec_RU_Index\u003e \u003d 0\n  MetadataBandGroup: int cases_RU_Index\u003e \u003d 0\n  MetadataBandGroup: int casearray_N_Index\u003e \u003d 0\n  MetadataBandGroup: int nesttype_RS_Index\u003e \u003d 0\n  MetadataBandGroup: int nestpair_N_Index\u003e \u003d 0\n  $r12 \u003d CPUTF8[] nestname_RU\u003e\n  $r13 \u003d Arrays.asList($r12)\n  $r14 \u003d $r13.iterator()\n  Iterator nestname_RU_Iterator\u003e \u003d $r14\n  $r15 \u003d String type\u003e\n  $z2 \u003d $r15.equals(\"RVA\")\n  if ($z2 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r23 \u003d String type\u003e\n  $z3 \u003d $r23.equals(\"RIA\")\n  if ($z3 \u003d\u003d false) goto B6 else B10\n}",
      "B6 {\n  i3 \u003d 0\n}",
      "B7 {\n  $r30 \u003d MetadataBandGroup: int[] anno_N\u003e\n  $i4 \u003d lengthof $r30\n  if (i3 \u003e\u003d $i4) goto B8 else B9\n}",
      "B8 {\n  $r21 \u003d List attributes\u003e\n  $r16 \u003d MetadataBandGroup: int[] anno_N\u003e\n  $i0 \u003d $r16[i3]\n  $r17 \u003d CPUTF8[][] type_RS\u003e\n  $r20 \u003d $r17[i3]\n  $r18 \u003d MetadataBandGroup: int[][] pair_N\u003e\n  $r19 \u003d $r18[i3]\n  $r22 \u003d r0.getAttribute($i0, $r20, $r19, r29)\n  $r21.add($r22)\n  i3 \u003d i3 + 1\n  goto B7\n}",
      "B9 {\n  goto B15\n}",
      "B10 {\n  $r24 \u003d String type\u003e\n  $z4 \u003d $r24.equals(\"RVPA\")\n  if ($z4 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $r27 \u003d String type\u003e\n  $z5 \u003d $r27.equals(\"RIPA\")\n  if ($z5 \u003d\u003d false) goto B12 else B15\n}",
      "B12 {\n  MetadataBandGroup: int anno_N_Index\u003e \u003d 0\n  MetadataBandGroup: int pair_N_Index\u003e \u003d 0\n  $r28 \u003d MetadataBandGroup: int[] param_NB\u003e\n  $i2 \u003d lengthof $r28\n  i5 \u003d 0\n}",
      "B13 {\n  if (i5 \u003e\u003d $i2) goto B14 else B15\n}",
      "B14 {\n  i1 \u003d $r28[i5]\n  $r25 \u003d List attributes\u003e\n  $r26 \u003d r0.getParameterAttribute(i1, r29)\n  $r25.add($r26)\n  i5 \u003d i5 + 1\n  goto B13\n}",
      "B15 {\n  goto B20\n}",
      "B16 {\n  $r4 \u003d String type\u003e\n  $z0 \u003d $r4.equals(\"AD\")\n  if ($z0 \u003d\u003d false) goto B17 else B20\n}",
      "B17 {\n  r31 \u003d MetadataBandGroup: int[] T\u003e\n  i6 \u003d lengthof r31\n  i7 \u003d 0\n}",
      "B18 {\n  if (i7 \u003e\u003d i6) goto B19 else B20\n}",
      "B19 {\n  i8 \u003d r31[i7]\n  $r7 \u003d List attributes\u003e\n  $r5 \u003d AnnotationDefaultAttribute\n  $r6 \u003d AnnotationsAttribute$ElementValue\n  $r8 \u003d r0.getNextValue(i8)\n  new AnnotationsAttribute$ElementValue(i8, $r8)\n  new AnnotationDefaultAttribute($r6)\n  $r7.add($r5)\n  i7 \u003d i7 + 1\n  goto B18\n}",
      "B20 {\n  $r32 \u003d List attributes\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B20",
      "B1 --\u003e B2",
      "B1 --\u003e B16",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B13",
      "B15 --\u003e B20",
      "B16 --\u003e B17",
      "B16 --\u003e B20",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B18",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MetadataBandGroup#getAttribute(...4)",
        "body": "{\r\n    final Annotation[] annotations \u003d new Annotation[numAnnotations];\r\n    Arrays.setAll(annotations, i -\u003e getAnnotation(types[i], pairCounts[i], namesIterator));\r\n    return new RuntimeVisibleorInvisibleAnnotationsAttribute(type.equals(\"RVA\") ? rvaUTF8 : riaUTF8, annotations);\r\n}"
      },
      {
        "name": "MetadataBandGroup#getNextValue(...1)",
        "body": "{\r\n    switch(t) {\r\n        case \u0027B\u0027:\r\n        case \u0027C\u0027:\r\n        case \u0027I\u0027:\r\n        case \u0027S\u0027:\r\n        case \u0027Z\u0027:\r\n            return caseI_KI[caseI_KI_Index++];\r\n        case \u0027D\u0027:\r\n            return caseD_KD[caseD_KD_Index++];\r\n        case \u0027F\u0027:\r\n            return caseF_KF[caseF_KF_Index++];\r\n        case \u0027J\u0027:\r\n            return caseJ_KJ[caseJ_KJ_Index++];\r\n        case \u0027c\u0027:\r\n            return casec_RS[casec_RS_Index++];\r\n        case \u0027e\u0027:\r\n            // TODO: check this - it may not work if the first string already\r\n            // has a colon in it\r\n            final String enumString \u003d caseet_RS[caseet_RS_Index++] + \":\" + caseec_RU[caseec_RU_Index++];\r\n            return cpBands.cpNameAndTypeValue(enumString);\r\n        case \u0027s\u0027:\r\n            return cases_RU[cases_RU_Index++];\r\n        case \u0027[\u0027:\r\n            final int arraySize \u003d casearray_N[casearray_N_Index++];\r\n            final ElementValue[] nestedArray \u003d new ElementValue[arraySize];\r\n            for (int i \u003d 0; i \u003c arraySize; i++) {\r\n                final int nextT \u003d T[T_index++];\r\n                nestedArray[i] \u003d new ElementValue(nextT, getNextValue(nextT));\r\n            }\r\n            return nestedArray;\r\n        case \u0027@\u0027:\r\n            final CPUTF8 type \u003d nesttype_RS[nesttype_RS_Index++];\r\n            final int numPairs \u003d nestpair_N[nestpair_N_Index++];\r\n            return getAnnotation(type, numPairs, nestname_RU_Iterator);\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "MetadataBandGroup#getParameterAttribute(...2)",
        "body": "{\r\n    final ParameterAnnotation[] parameterAnnotations \u003d new ParameterAnnotation[numParameters];\r\n    for (int i \u003d 0; i \u003c numParameters; i++) {\r\n        final int numAnnotations \u003d anno_N[anno_N_Index++];\r\n        final int[] pairCounts \u003d pair_N[pair_N_Index++];\r\n        final Annotation[] annotations \u003d new Annotation[numAnnotations];\r\n        Arrays.setAll(annotations, j -\u003e getAnnotation(type_RS[anno_N_Index - 1][j], pairCounts[j], namesIterator));\r\n        parameterAnnotations[i] \u003d new ParameterAnnotation(annotations);\r\n    }\r\n    return new RuntimeVisibleorInvisibleParameterAnnotationsAttribute(type.equals(\"RVPA\") ? rvpaUTF8 : ripaUTF8, parameterAnnotations);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.NewAttributeBands",
    "methodName": "getCodec",
    "signature": "org.apache.commons.compress.harmony.pack200.BHSDCodec getCodec(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (layoutElement.indexOf(\u0027O\u0027) \u003e\u003d 0) {\r\n        return Codec.BRANCH5;\r\n    }\r\n    if (layoutElement.indexOf(\u0027P\u0027) \u003e\u003d 0) {\r\n        return Codec.BCI5;\r\n    }\r\n    if (//$NON-NLS-1$\r\n    layoutElement.indexOf(\u0027S\u0027) \u003e\u003d 0 \u0026\u0026 !layoutElement.contains(\"KS\") \u0026\u0026 !layoutElement.contains(\"RS\")) {\r\n        //$NON-NLS-1$\r\n        return Codec.SIGNED5;\r\n    }\r\n    if (layoutElement.indexOf(\u0027B\u0027) \u003e\u003d 0) {\r\n        return Codec.BYTE1;\r\n    }\r\n    return Codec.UNSIGNED5;\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($i1 \u003c 0) → B3 | else → B4",
      "B4 : If($i2 \u003c 0) → B5 | else → B8",
      "B5 : If($z0 !\u003d 0) → B6 | else → B8",
      "B6 : If($z1 !\u003d 0) → B7 | else → B8",
      "B8 : If($i3 \u003c 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  String\n  $i0 \u003d r0.indexOf(79)\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d BHSDCodec BRANCH5\u003e\n  return\n}",
      "B2 {\n  $i1 \u003d r0.indexOf(80)\n  if ($i1 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d BHSDCodec BCI5\u003e\n  return\n}",
      "B4 {\n  $i2 \u003d r0.indexOf(83)\n  if ($i2 \u003c 0) goto B5 else B8\n}",
      "B5 {\n  $z0 \u003d r0.contains(\"KS\")\n  if ($z0 !\u003d 0) goto B6 else B8\n}",
      "B6 {\n  $z1 \u003d r0.contains(\"RS\")\n  if ($z1 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  $r3 \u003d BHSDCodec SIGNED5\u003e\n  return\n}",
      "B8 {\n  $i3 \u003d r0.indexOf(66)\n  if ($i3 \u003c 0) goto B9 else B10\n}",
      "B9 {\n  $r2 \u003d BHSDCodec BYTE1\u003e\n  return\n}",
      "B10 {\n  $r1 \u003d BHSDCodec UNSIGNED5\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.NewAttributeBands",
    "methodName": "parseAttributes",
    "signature": "java.util.List parseAttributes(java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    for (final AttributeLayoutElement element : attributeLayoutElements) {\r\n        element.readBands(in, occurrenceCount);\r\n    }\r\n    final List\u003cAttribute\u003e attributes \u003d new ArrayList\u003c\u003e(occurrenceCount);\r\n    for (int i \u003d 0; i \u003c occurrenceCount; i++) {\r\n        attributes.add(getOneAttribute(i, attributeLayoutElements));\r\n    }\r\n    return attributes;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(i1 \u003e\u003d i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  InputStream\n  i0 :\u003d @parameter1: int\n  $r1 \u003d List attributeLayoutElements\u003e\n  r7 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r7.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d r7.next()\n  r8 \u003d NewAttributeBands$AttributeLayoutElement) $r5\n  r8.readBands(r6, i0)\n  goto B1\n}",
      "B3 {\n  $r2 \u003d ArrayList\n  new ArrayList(i0)\n  i1 \u003d 0\n}",
      "B4 {\n  if (i1 \u003e\u003d i0) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d List attributeLayoutElements\u003e\n  $r4 \u003d r0.getOneAttribute(i1, $r3)\n  $r2.add($r4)\n  i1 \u003d i1 + 1\n  goto B4\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NewAttributeBands#getOneAttribute(...2)",
        "body": "{\r\n    final NewAttribute attribute \u003d new NewAttribute(segment.getCpBands().cpUTF8Value(attributeLayout.getName()), attributeLayout.getIndex());\r\n    for (final AttributeLayoutElement element : elements) {\r\n        element.addToAttribute(index, attribute);\r\n    }\r\n    return attribute;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.NewAttributeBands",
    "methodName": "setBackwardsCalls",
    "signature": "void setBackwardsCalls(int[])",
    "visibility": "public",
    "body": "{\r\n    int index \u003d 0;\r\n    parseLayout();\r\n    for (final AttributeLayoutElement element : attributeLayoutElements) {\r\n        if (element instanceof Callable \u0026\u0026 ((Callable) element).isBackwardsCallable()) {\r\n            ((Callable) element).addCount(backwardsCalls[index]);\r\n            index++;\r\n        }\r\n    }\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  NewAttributeBands\n  r6 :\u003d @parameter0: int[]\n  i1 \u003d 0\n  r0.parseLayout()\n  $r1 \u003d List attributeLayoutElements\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r3 \u003d r2.next()\n  r4 \u003d NewAttributeBands$AttributeLayoutElement) $r3\n  $z1 \u003d NewAttributeBands$Callable\n  if ($z1 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r5 \u003d NewAttributeBands$Callable) r4\n  $z2 \u003d $r5.isBackwardsCallable()\n  if ($z2 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r7 \u003d NewAttributeBands$Callable) r4\n  $i0 \u003d r6[i1]\n  $r7.addCount($i0)\n  i1 \u003d i1 + 1\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NewAttributeBands#parseLayout(...0)",
        "body": "{\r\n    if (attributeLayoutElements \u003d\u003d null) {\r\n        attributeLayoutElements \u003d new ArrayList\u003c\u003e();\r\n        final StringReader stream \u003d new StringReader(attributeLayout.getLayout());\r\n        AttributeLayoutElement e;\r\n        while ((e \u003d readNextAttributeElement(stream)) !\u003d null) {\r\n            attributeLayoutElements.add(e);\r\n        }\r\n        resolveCalls();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Pack200UnpackerAdapter",
    "methodName": "unpack",
    "signature": "void unpack(java.io.File,java.util.jar.JarOutputStream)",
    "visibility": "public",
    "body": "{\r\n    if (file \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify input file.\");\r\n    }\r\n    if (out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify output stream.\");\r\n    }\r\n    final long size \u003d file.length();\r\n    final int bufferSize \u003d size \u003e 0 \u0026\u0026 size \u003c DEFAULT_BUFFER_SIZE ? (int) size : DEFAULT_BUFFER_SIZE;\r\n    try (InputStream in \u003d new BufferedInputStream(Files.newInputStream(file.toPath()), bufferSize)) {\r\n        unpack(in, out);\r\n    }\r\n}",
    "nodes": 13,
    "edges": 13,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If($i4 \u003c\u003d 0) → B5 | else → B7",
      "B5 : If($i5 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Pack200UnpackerAdapter\n  File\n  JarOutputStream\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must specify input file.\")\n  throw $r11\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Must specify output stream.\")\n  throw $r12\n}",
      "B4 {\n  l0 \u003d r0.length()\n  $b1 \u003d l0 cmp 0L\n  $i4 \u003d (int) $b1\n  if ($i4 \u003c\u003d 0) goto B5 else B7\n}",
      "B5 {\n  $b2 \u003d l0 cmp 8192L\n  $i5 \u003d (int) $b2\n  if ($i5 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d (int) l0\n  goto B8\n}",
      "B7 {\n  $i3 \u003d 8192\n}",
      "B8 {\n  $r13 \u003d BufferedInputStream\n  $r8 \u003d r0.toPath()\n  $r9 \u003d OpenOption)[0]\n  $r10 \u003d Files.newInputStream($r8, $r9)\n  new BufferedInputStream($r10, $i3)\n  r2.unpack($r13, r1)\n  $r13.close()\n  goto B12\n}",
      "B9 {\n  $r6 :\u003d @caughtexception\n  $r13.close()\n  goto B11\n}",
      "B10 {\n  $r5 :\u003d @caughtexception\n  $r6.addSuppressed($r5)\n}",
      "B11 {\n  throw $r6\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B12",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Pack200UnpackerAdapter#unpack(...2)",
        "body": "{\r\n    if (file \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify input file.\");\r\n    }\r\n    if (out \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"Must specify output stream.\");\r\n    }\r\n    final long size \u003d file.length();\r\n    final int bufferSize \u003d size \u003e 0 \u0026\u0026 size \u003c DEFAULT_BUFFER_SIZE ? (int) size : DEFAULT_BUFFER_SIZE;\r\n    try (InputStream in \u003d new BufferedInputStream(Files.newInputStream(file.toPath()), bufferSize)) {\r\n        unpack(in, out);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Segment",
    "methodName": "log",
    "signature": "void log(int,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (logLevel \u003e\u003d messageLevel \u0026\u0026 logPrintWriter !\u003d null) {\r\n        logPrintWriter.println(message);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 \u003c i0) → B1 | else → B3",
      "B1 : If($r1 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Segment\n  i0 :\u003d @parameter0: int\n  String\n  $i1 \u003d Segment: int logLevel\u003e\n  if ($i1 \u003c i0) goto B1 else B3\n}",
      "B1 {\n  $r1 \u003d PrintWriter logPrintWriter\u003e\n  if ($r1 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d PrintWriter logPrintWriter\u003e\n  $r3.println(r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Segment",
    "methodName": "setLogStream",
    "signature": "void setLogStream(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    this.logPrintWriter \u003d logStream !\u003d null ? new PrintWriter(new OutputStreamWriter(logStream, Charset.defaultCharset()), false) : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Segment\n  OutputStream\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d PrintWriter\n  $r2 \u003d OutputStreamWriter\n  $r3 \u003d Charset.defaultCharset()\n  new OutputStreamWriter(r1, $r3)\n  new PrintWriter($r2, 0)\n  goto B3\n}",
      "B2 {\n  $r4 \u003d null\n}",
      "B3 {\n  PrintWriter logPrintWriter\u003e \u003d $r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.Segment",
    "methodName": "writeJar",
    "signature": "void writeJar(java.util.jar.JarOutputStream)",
    "visibility": "public",
    "body": "{\r\n    final String[] fileName \u003d fileBands.getFileName();\r\n    final int[] fileModtime \u003d fileBands.getFileModtime();\r\n    final long[] fileSize \u003d fileBands.getFileSize();\r\n    final byte[][] fileBits \u003d fileBands.getFileBits();\r\n    // now write the files out\r\n    int classNum \u003d 0;\r\n    final int numberOfFiles \u003d header.getNumberOfFiles();\r\n    final long archiveModtime \u003d header.getArchiveModtime();\r\n    for (int i \u003d 0; i \u003c numberOfFiles; i++) {\r\n        final String name \u003d fileName[i];\r\n        // For Pack200 archives, modtime is in seconds\r\n        // from the epoch. JarEntries need it to be in\r\n        // milliseconds from the epoch.\r\n        // Even though we\u0027re adding two longs and multiplying\r\n        // by 1000, we won\u0027t overflow because both longs are\r\n        // always under 2^32.\r\n        final long modtime \u003d 1000 * (archiveModtime + fileModtime[i]);\r\n        final boolean deflate \u003d fileDeflate[i];\r\n        final JarEntry entry \u003d new JarEntry(name);\r\n        if (deflate) {\r\n            entry.setMethod(ZipEntry.DEFLATED);\r\n        } else {\r\n            entry.setMethod(ZipEntry.STORED);\r\n            final CRC32 crc \u003d new CRC32();\r\n            if (fileIsClass[i]) {\r\n                crc.update(classFilesContents[classNum]);\r\n                entry.setSize(classFilesContents[classNum].length);\r\n            } else {\r\n                crc.update(fileBits[i]);\r\n                entry.setSize(fileSize[i]);\r\n            }\r\n            entry.setCrc(crc.getValue());\r\n        }\r\n        // On Windows at least, need to correct for timezone\r\n        entry.setTime(modtime - TimeZone.getDefault().getRawOffset());\r\n        out.putNextEntry(entry);\r\n        // write to output stream\r\n        if (fileIsClass[i]) {\r\n            entry.setSize(classFilesContents[classNum].length);\r\n            out.write(classFilesContents[classNum]);\r\n            classNum++;\r\n        } else {\r\n            entry.setSize(fileSize[i]);\r\n            out.write(fileBits[i]);\r\n        }\r\n    }\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B1 : If(i14 \u003e\u003d i0) → B2 | else → B12",
      "B2 : If(z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  Segment\n  JarOutputStream\n  $r1 \u003d FileBands fileBands\u003e\n  r2 \u003d $r1.getFileName()\n  $r3 \u003d FileBands fileBands\u003e\n  r4 \u003d $r3.getFileModtime()\n  $r5 \u003d FileBands fileBands\u003e\n  r6 \u003d $r5.getFileSize()\n  $r7 \u003d FileBands fileBands\u003e\n  r8 \u003d $r7.getFileBits()\n  i13 \u003d 0\n  $r9 \u003d SegmentHeader header\u003e\n  i0 \u003d $r9.getNumberOfFiles()\n  $r10 \u003d SegmentHeader header\u003e\n  l1 \u003d $r10.getArchiveModtime()\n  i14 \u003d 0\n}",
      "B1 {\n  if (i14 \u003e\u003d i0) goto B2 else B12\n}",
      "B2 {\n  r11 \u003d r2[i14]\n  $i2 \u003d r4[i14]\n  $l3 \u003d (long) $i2\n  $l4 \u003d l1 + $l3\n  l5 \u003d 1000L * $l4\n  $r12 \u003d Segment: boolean[] fileDeflate\u003e\n  z0 \u003d $r12[i14]\n  $r13 \u003d JarEntry\n  new JarEntry(r11)\n  if (z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r13.setMethod(8)\n  goto B8\n}",
      "B4 {\n  $r13.setMethod(0)\n  $r14 \u003d CRC32\n  new CRC32()\n  $r15 \u003d Segment: boolean[] fileIsClass\u003e\n  $z1 \u003d $r15[i14]\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r23 \u003d Segment: byte[][] classFilesContents\u003e\n  $r24 \u003d $r23[i13]\n  $r14.update($r24)\n  $r25 \u003d Segment: byte[][] classFilesContents\u003e\n  $r26 \u003d $r25[i13]\n  $i11 \u003d lengthof $r26\n  $l12 \u003d (long) $i11\n  $r13.setSize($l12)\n  goto B7\n}",
      "B6 {\n  $r16 \u003d r8[i14]\n  $r14.update($r16)\n  $l6 \u003d r6[i14]\n  $r13.setSize($l6)\n}",
      "B7 {\n  $l7 \u003d $r14.getValue()\n  $r13.setCrc($l7)\n}",
      "B8 {\n  $r27 \u003d TimeZone.getDefault()\n  $i15 \u003d $r27.getRawOffset()\n  $l16 \u003d (long) $i15\n  $l17 \u003d l5 - $l16\n  $r13.setTime($l17)\n  r17.putNextEntry($r13)\n  $r28 \u003d Segment: boolean[] fileIsClass\u003e\n  $z2 \u003d $r28[i14]\n  if ($z2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r19 \u003d Segment: byte[][] classFilesContents\u003e\n  $r20 \u003d $r19[i13]\n  $i9 \u003d lengthof $r20\n  $l10 \u003d (long) $i9\n  $r13.setSize($l10)\n  $r21 \u003d Segment: byte[][] classFilesContents\u003e\n  $r22 \u003d $r21[i13]\n  r17.write($r22)\n  i13 \u003d i13 + 1\n  goto B11\n}",
      "B10 {\n  $l8 \u003d r6[i14]\n  $r13.setSize($l8)\n  $r18 \u003d r8[i14]\n  r17.write($r18)\n}",
      "B11 {\n  i14 \u003d i14 + 1\n  goto B1\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B1",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPool",
    "methodName": "getClassPoolEntry",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry getClassPoolEntry(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int index \u003d matchSpecificPoolEntryIndex(bands.getCpClass(), name, 0);\r\n    return index \u003d\u003d -1 ? null : getConstantPoolEntry(CP_CLASS, index);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPool\n  String\n  $r1 \u003d CpBands bands\u003e\n  $r3 \u003d $r1.getCpClass()\n  i0 \u003d r0.matchSpecificPoolEntryIndex($r3, r2, 0)\n  $i3 \u003d (int) -1\n  if (i0 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d null\n  goto B3\n}",
      "B2 {\n  $l1 \u003d (long) i0\n  $r4 \u003d r0.getConstantPoolEntry(7, $l1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentConstantPool#matchSpecificPoolEntryIndex(...3)",
        "body": "{\r\n    return matchSpecificPoolEntryIndex(nameArray, nameArray, compareString, REGEX_MATCH_ALL, desiredIndex);\r\n}"
      },
      {
        "name": "SegmentConstantPool#getConstantPoolEntry(...2)",
        "body": "{\r\n    if (index \u003d\u003d -1) {\r\n        return null;\r\n    }\r\n    final int actualIndex \u003d toIndex(index);\r\n    switch(type) {\r\n        case UTF_8:\r\n            return bands.cpUTF8Value(actualIndex);\r\n        case CP_INT:\r\n            return bands.cpIntegerValue(actualIndex);\r\n        case CP_FLOAT:\r\n            return bands.cpFloatValue(actualIndex);\r\n        case CP_LONG:\r\n            return bands.cpLongValue(actualIndex);\r\n        case CP_DOUBLE:\r\n            return bands.cpDoubleValue(actualIndex);\r\n        case CP_STRING:\r\n            return bands.cpStringValue(actualIndex);\r\n        case CP_CLASS:\r\n            return bands.cpClassValue(actualIndex);\r\n        case SIGNATURE:\r\n            throw new Pack200Exception(\"Type SIGNATURE is not supported yet: \" + SIGNATURE);\r\n        // return null /* new CPSignature(bands.getCpSignature()[index]) */;\r\n        case CP_DESCR:\r\n            throw new Pack200Exception(\"Type CP_DESCR is not supported yet: \" + CP_DESCR);\r\n        // return null /* new CPDescriptor(bands.getCpDescriptor()[index])\r\n        // */;\r\n        case CP_FIELD:\r\n            return bands.cpFieldValue(actualIndex);\r\n        case CP_METHOD:\r\n            return bands.cpMethodValue(actualIndex);\r\n        case CP_IMETHOD:\r\n            return bands.cpIMethodValue(actualIndex);\r\n        default:\r\n            break;\r\n    }\r\n    // etc\r\n    throw new Pack200Exception(\"Type is not supported yet: \" + type);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPool",
    "methodName": "getClassSpecificPoolEntry",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry getClassSpecificPoolEntry(int,long,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final String[] array;\r\n    switch(cp) {\r\n        case CP_FIELD:\r\n            array \u003d bands.getCpFieldClass();\r\n            break;\r\n        case CP_METHOD:\r\n            array \u003d bands.getCpMethodClass();\r\n            break;\r\n        case CP_IMETHOD:\r\n            array \u003d bands.getCpIMethodClass();\r\n            break;\r\n        default:\r\n            throw new Pack200Exception(\"Type is not supported yet: \" + cp);\r\n    }\r\n    return getConstantPoolEntry(cp, matchSpecificPoolEntryIndex(array, desiredClassName, toIndex(desiredIndex)));\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPool\n  i0 :\u003d @parameter0: int\n  l1 :\u003d @parameter1: long\n  String\n  Pack200Exception; }\n}",
      "B1 {\n  $r4 \u003d CpBands bands\u003e\n  r10 \u003d $r4.getCpFieldClass()\n  goto B5\n}",
      "B2 {\n  $r3 \u003d CpBands bands\u003e\n  r10 \u003d $r3.getCpMethodClass()\n  goto B5\n}",
      "B3 {\n  $r1 \u003d CpBands bands\u003e\n  r10 \u003d $r1.getCpIMethodClass()\n  goto B5\n}",
      "B4 {\n  $r5 \u003d Pack200Exception\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $r7 \u003d $r6.append(\"Type is not supported yet: \")\n  $r8 \u003d $r7.append(i0)\n  $r9 \u003d $r8.toString()\n  new Pack200Exception($r9)\n  throw $r5\n}",
      "B5 {\n  $i2 \u003d SegmentConstantPool.toIndex(l1)\n  $i3 \u003d r0.matchSpecificPoolEntryIndex(r10, r2, $i2)\n  $l4 \u003d (long) $i3\n  $r11 \u003d r0.getConstantPoolEntry(i0, $l4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B1 --\u003e B5",
      "B2 --\u003e B5",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentConstantPool#toIndex(...1)",
        "body": "{\r\n    if (index \u003c 0) {\r\n        throw new Pack200Exception(\"Cannot have a negative index.\");\r\n    }\r\n    return toIntExact(index);\r\n}"
      },
      {
        "name": "SegmentConstantPool#matchSpecificPoolEntryIndex(...3)",
        "body": "{\r\n    return matchSpecificPoolEntryIndex(nameArray, nameArray, compareString, REGEX_MATCH_ALL, desiredIndex);\r\n}"
      },
      {
        "name": "SegmentConstantPool#getConstantPoolEntry(...2)",
        "body": "{\r\n    if (index \u003d\u003d -1) {\r\n        return null;\r\n    }\r\n    final int actualIndex \u003d toIndex(index);\r\n    switch(type) {\r\n        case UTF_8:\r\n            return bands.cpUTF8Value(actualIndex);\r\n        case CP_INT:\r\n            return bands.cpIntegerValue(actualIndex);\r\n        case CP_FLOAT:\r\n            return bands.cpFloatValue(actualIndex);\r\n        case CP_LONG:\r\n            return bands.cpLongValue(actualIndex);\r\n        case CP_DOUBLE:\r\n            return bands.cpDoubleValue(actualIndex);\r\n        case CP_STRING:\r\n            return bands.cpStringValue(actualIndex);\r\n        case CP_CLASS:\r\n            return bands.cpClassValue(actualIndex);\r\n        case SIGNATURE:\r\n            throw new Pack200Exception(\"Type SIGNATURE is not supported yet: \" + SIGNATURE);\r\n        // return null /* new CPSignature(bands.getCpSignature()[index]) */;\r\n        case CP_DESCR:\r\n            throw new Pack200Exception(\"Type CP_DESCR is not supported yet: \" + CP_DESCR);\r\n        // return null /* new CPDescriptor(bands.getCpDescriptor()[index])\r\n        // */;\r\n        case CP_FIELD:\r\n            return bands.cpFieldValue(actualIndex);\r\n        case CP_METHOD:\r\n            return bands.cpMethodValue(actualIndex);\r\n        case CP_IMETHOD:\r\n            return bands.cpIMethodValue(actualIndex);\r\n        default:\r\n            break;\r\n    }\r\n    // etc\r\n    throw new Pack200Exception(\"Type is not supported yet: \" + type);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPool",
    "methodName": "getConstantPoolEntry",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry getConstantPoolEntry(int,long)",
    "visibility": "public",
    "body": "{\r\n    if (index \u003d\u003d -1) {\r\n        return null;\r\n    }\r\n    final int actualIndex \u003d toIndex(index);\r\n    switch(type) {\r\n        case UTF_8:\r\n            return bands.cpUTF8Value(actualIndex);\r\n        case CP_INT:\r\n            return bands.cpIntegerValue(actualIndex);\r\n        case CP_FLOAT:\r\n            return bands.cpFloatValue(actualIndex);\r\n        case CP_LONG:\r\n            return bands.cpLongValue(actualIndex);\r\n        case CP_DOUBLE:\r\n            return bands.cpDoubleValue(actualIndex);\r\n        case CP_STRING:\r\n            return bands.cpStringValue(actualIndex);\r\n        case CP_CLASS:\r\n            return bands.cpClassValue(actualIndex);\r\n        case SIGNATURE:\r\n            throw new Pack200Exception(\"Type SIGNATURE is not supported yet: \" + SIGNATURE);\r\n        // return null /* new CPSignature(bands.getCpSignature()[index]) */;\r\n        case CP_DESCR:\r\n            throw new Pack200Exception(\"Type CP_DESCR is not supported yet: \" + CP_DESCR);\r\n        // return null /* new CPDescriptor(bands.getCpDescriptor()[index])\r\n        // */;\r\n        case CP_FIELD:\r\n            return bands.cpFieldValue(actualIndex);\r\n        case CP_METHOD:\r\n            return bands.cpMethodValue(actualIndex);\r\n        case CP_IMETHOD:\r\n            return bands.cpIMethodValue(actualIndex);\r\n        default:\r\n            break;\r\n    }\r\n    // etc\r\n    throw new Pack200Exception(\"Type is not supported yet: \" + type);\r\n}",
    "nodes": 16,
    "edges": 15,
    "cc": 1,
    "flowSummary": [
      "B0 : If($b1 !\u003d 0) → B1 | else → B2",
      "B2 : If(switch-on i3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPool\n  i3 :\u003d @parameter0: int\n  l0 :\u003d @parameter1: long\n  $b1 \u003d l0 cmp -1L\n  if ($b1 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i2 \u003d SegmentConstantPool.toIndex(l0)\n  Pack200Exception; }\n}",
      "B3 {\n  $r21 \u003d CpBands bands\u003e\n  $r22 \u003d $r21.cpUTF8Value(i2)\n  return\n}",
      "B4 {\n  $r19 \u003d CpBands bands\u003e\n  $r20 \u003d $r19.cpIntegerValue(i2)\n  return\n}",
      "B5 {\n  $r17 \u003d CpBands bands\u003e\n  $r18 \u003d $r17.cpFloatValue(i2)\n  return\n}",
      "B6 {\n  $r15 \u003d CpBands bands\u003e\n  $r16 \u003d $r15.cpLongValue(i2)\n  return\n}",
      "B7 {\n  $r13 \u003d CpBands bands\u003e\n  $r14 \u003d $r13.cpDoubleValue(i2)\n  return\n}",
      "B8 {\n  $r11 \u003d CpBands bands\u003e\n  $r12 \u003d $r11.cpStringValue(i2)\n  return\n}",
      "B9 {\n  $r9 \u003d CpBands bands\u003e\n  $r10 \u003d $r9.cpClassValue(i2)\n  return\n}",
      "B10 {\n  $r8 \u003d Pack200Exception\n  new Pack200Exception(\"Type SIGNATURE is not supported yet: 8\")\n  throw $r8\n}",
      "B11 {\n  $r7 \u003d Pack200Exception\n  new Pack200Exception(\"Type CP_DESCR is not supported yet: 9\")\n  throw $r7\n}",
      "B12 {\n  $r5 \u003d CpBands bands\u003e\n  $r6 \u003d $r5.cpFieldValue(i2)\n  return\n}",
      "B13 {\n  $r3 \u003d CpBands bands\u003e\n  $r4 \u003d $r3.cpMethodValue(i2)\n  return\n}",
      "B14 {\n  $r1 \u003d CpBands bands\u003e\n  $r2 \u003d $r1.cpIMethodValue(i2)\n  return\n}",
      "B15 {\n  $r23 \u003d Pack200Exception\n  $r24 \u003d StringBuilder\n  new StringBuilder()\n  $r25 \u003d $r24.append(\"Type is not supported yet: \")\n  $r26 \u003d $r25.append(i3)\n  $r27 \u003d $r26.toString()\n  new Pack200Exception($r27)\n  throw $r23\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B2 --\u003e B6",
      "B2 --\u003e B7",
      "B2 --\u003e B8",
      "B2 --\u003e B9",
      "B2 --\u003e B10",
      "B2 --\u003e B11",
      "B2 --\u003e B12",
      "B2 --\u003e B13",
      "B2 --\u003e B14",
      "B2 --\u003e B15",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentConstantPool#toIndex(...1)",
        "body": "{\r\n    if (index \u003c 0) {\r\n        throw new Pack200Exception(\"Cannot have a negative index.\");\r\n    }\r\n    return toIntExact(index);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPool",
    "methodName": "getInitMethodPoolEntry",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ConstantPoolEntry getInitMethodPoolEntry(int,long,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (cp !\u003d CP_METHOD) {\r\n        throw new Pack200Exception(\"Nothing but CP_METHOD can be an \u003cinit\u003e\");\r\n    }\r\n    final int realIndex \u003d matchSpecificPoolEntryIndex(bands.getCpMethodClass(), bands.getCpMethodDescriptor(), desiredClassName, REGEX_MATCH_INIT, toIndex(value));\r\n    return getConstantPoolEntry(cp, realIndex);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d 11) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPool\n  i0 :\u003d @parameter0: int\n  l1 :\u003d @parameter1: long\n  String\n  if (i0 \u003d\u003d 11) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d Pack200Exception\n  new Pack200Exception(\"Nothing but CP_METHOD can be an \u003cinit\u003e\")\n  throw $r7\n}",
      "B2 {\n  $r1 \u003d CpBands bands\u003e\n  $r5 \u003d $r1.getCpMethodClass()\n  $r2 \u003d CpBands bands\u003e\n  $r4 \u003d $r2.getCpMethodDescriptor()\n  $i2 \u003d SegmentConstantPool.toIndex(l1)\n  i3 \u003d r0.matchSpecificPoolEntryIndex($r5, $r4, r3, \"^\u003cinit\u003e.*\", $i2)\n  $l4 \u003d (long) i3\n  $r6 \u003d r0.getConstantPoolEntry(i0, $l4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentConstantPool#toIndex(...1)",
        "body": "{\r\n    if (index \u003c 0) {\r\n        throw new Pack200Exception(\"Cannot have a negative index.\");\r\n    }\r\n    return toIntExact(index);\r\n}"
      },
      {
        "name": "SegmentConstantPool#matchSpecificPoolEntryIndex(...5)",
        "body": "{\r\n    int instanceCount \u003d -1;\r\n    final List\u003cInteger\u003e indexList \u003d arrayCache.indexesForArrayKey(primaryArray, primaryCompareString);\r\n    if (indexList.isEmpty()) {\r\n        // Primary key not found, no chance of finding secondary\r\n        return -1;\r\n    }\r\n    for (final Integer element : indexList) {\r\n        final int arrayIndex \u003d element.intValue();\r\n        if (regexMatches(secondaryCompareRegex, secondaryArray[arrayIndex])) {\r\n            instanceCount++;\r\n            if (instanceCount \u003d\u003d desiredIndex) {\r\n                return arrayIndex;\r\n            }\r\n        }\r\n    }\r\n    // We didn\u0027t return in the for loop, so the desiredMatch\r\n    // with desiredIndex must not exist in the arrays.\r\n    return -1;\r\n}"
      },
      {
        "name": "SegmentConstantPool#getConstantPoolEntry(...2)",
        "body": "{\r\n    if (index \u003d\u003d -1) {\r\n        return null;\r\n    }\r\n    final int actualIndex \u003d toIndex(index);\r\n    switch(type) {\r\n        case UTF_8:\r\n            return bands.cpUTF8Value(actualIndex);\r\n        case CP_INT:\r\n            return bands.cpIntegerValue(actualIndex);\r\n        case CP_FLOAT:\r\n            return bands.cpFloatValue(actualIndex);\r\n        case CP_LONG:\r\n            return bands.cpLongValue(actualIndex);\r\n        case CP_DOUBLE:\r\n            return bands.cpDoubleValue(actualIndex);\r\n        case CP_STRING:\r\n            return bands.cpStringValue(actualIndex);\r\n        case CP_CLASS:\r\n            return bands.cpClassValue(actualIndex);\r\n        case SIGNATURE:\r\n            throw new Pack200Exception(\"Type SIGNATURE is not supported yet: \" + SIGNATURE);\r\n        // return null /* new CPSignature(bands.getCpSignature()[index]) */;\r\n        case CP_DESCR:\r\n            throw new Pack200Exception(\"Type CP_DESCR is not supported yet: \" + CP_DESCR);\r\n        // return null /* new CPDescriptor(bands.getCpDescriptor()[index])\r\n        // */;\r\n        case CP_FIELD:\r\n            return bands.cpFieldValue(actualIndex);\r\n        case CP_METHOD:\r\n            return bands.cpMethodValue(actualIndex);\r\n        case CP_IMETHOD:\r\n            return bands.cpIMethodValue(actualIndex);\r\n        default:\r\n            break;\r\n    }\r\n    // etc\r\n    throw new Pack200Exception(\"Type is not supported yet: \" + type);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPool",
    "methodName": "getValue",
    "signature": "org.apache.commons.compress.harmony.unpack200.bytecode.ClassFileEntry getValue(int,long)",
    "visibility": "public",
    "body": "{\r\n    final int index \u003d (int) longIndex;\r\n    if (index \u003d\u003d -1) {\r\n        return null;\r\n    }\r\n    if (index \u003c 0) {\r\n        throw new Pack200Exception(\"Cannot have a negative range\");\r\n    }\r\n    switch(cp) {\r\n        case UTF_8:\r\n            return bands.cpUTF8Value(index);\r\n        case CP_INT:\r\n            return bands.cpIntegerValue(index);\r\n        case CP_FLOAT:\r\n            return bands.cpFloatValue(index);\r\n        case CP_LONG:\r\n            return bands.cpLongValue(index);\r\n        case CP_DOUBLE:\r\n            return bands.cpDoubleValue(index);\r\n        case CP_STRING:\r\n            return bands.cpStringValue(index);\r\n        case CP_CLASS:\r\n            return bands.cpClassValue(index);\r\n        case SIGNATURE:\r\n            return bands.cpSignatureValue(index);\r\n        case CP_DESCR:\r\n            return bands.cpNameAndTypeValue(index);\r\n        default:\r\n            break;\r\n    }\r\n    throw new Error(\"Tried to get a value I don\u0027t know about: \" + cp);\r\n}",
    "nodes": 15,
    "edges": 14,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 !\u003d $i4) → B1 | else → B2",
      "B2 : If(i1 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(switch-on i2) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPool\n  i2 :\u003d @parameter0: int\n  l0 :\u003d @parameter1: long\n  i1 \u003d (int) l0\n  $i4 \u003d (int) -1\n  if (i1 !\u003d $i4) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (i1 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r25 \u003d Pack200Exception\n  new Pack200Exception(\"Cannot have a negative range\")\n  throw $r25\n}",
      "B4 {\n  Error; }\n}",
      "B5 {\n  $r17 \u003d CpBands bands\u003e\n  $r18 \u003d $r17.cpUTF8Value(i1)\n  return\n}",
      "B6 {\n  $r15 \u003d CpBands bands\u003e\n  $r16 \u003d $r15.cpIntegerValue(i1)\n  return\n}",
      "B7 {\n  $r13 \u003d CpBands bands\u003e\n  $r14 \u003d $r13.cpFloatValue(i1)\n  return\n}",
      "B8 {\n  $r11 \u003d CpBands bands\u003e\n  $r12 \u003d $r11.cpLongValue(i1)\n  return\n}",
      "B9 {\n  $r9 \u003d CpBands bands\u003e\n  $r10 \u003d $r9.cpDoubleValue(i1)\n  return\n}",
      "B10 {\n  $r7 \u003d CpBands bands\u003e\n  $r8 \u003d $r7.cpStringValue(i1)\n  return\n}",
      "B11 {\n  $r5 \u003d CpBands bands\u003e\n  $r6 \u003d $r5.cpClassValue(i1)\n  return\n}",
      "B12 {\n  $r3 \u003d CpBands bands\u003e\n  $r4 \u003d $r3.cpSignatureValue(i1)\n  return\n}",
      "B13 {\n  $r1 \u003d CpBands bands\u003e\n  $r2 \u003d $r1.cpNameAndTypeValue(i1)\n  return\n}",
      "B14 {\n  $r27 \u003d Error\n  $r26 \u003d StringBuilder\n  new StringBuilder()\n  $r21 \u003d $r26.append(\"Tried to get a value I don\\\u0027t know about: \")\n  $r22 \u003d $r21.append(i2)\n  $r23 \u003d $r22.toString()\n  new Error($r23)\n  throw $r27\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B4 --\u003e B7",
      "B4 --\u003e B8",
      "B4 --\u003e B9",
      "B4 --\u003e B10",
      "B4 --\u003e B11",
      "B4 --\u003e B12",
      "B4 --\u003e B13",
      "B4 --\u003e B14",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentConstantPoolArrayCache",
    "methodName": "indexesForArrayKey",
    "signature": "java.util.List indexesForArrayKey(java.lang.String[],java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (!arrayIsCached(array)) {\r\n        cacheArray(array);\r\n    }\r\n    // If the search is one we\u0027ve just done, don\u0027t even\r\n    // bother looking and return the last indices. This\r\n    // is a second cache within the cache. This is\r\n    // efficient because we are usually looking for\r\n    // several secondary elements with the same primary\r\n    // key.\r\n    if (lastArray \u003d\u003d array \u0026\u0026 lastKey \u003d\u003d key) {\r\n        return lastIndexes;\r\n    }\r\n    // Remember the last thing we found.\r\n    lastArray \u003d array;\r\n    lastKey \u003d key;\r\n    lastIndexes \u003d knownArrays.get(array).indexesForKey(key);\r\n    return lastIndexes;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 !\u003d r1) → B3 | else → B5",
      "B3 : If($r9 !\u003d r3) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SegmentConstantPoolArrayCache\n  String[]\n  String\n  $z0 \u003d r0.arrayIsCached(r1)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.cacheArray(r1)\n}",
      "B2 {\n  $r2 \u003d String[] lastArray\u003e\n  if ($r2 !\u003d r1) goto B3 else B5\n}",
      "B3 {\n  $r9 \u003d String lastKey\u003e\n  if ($r9 !\u003d r3) goto B4 else B5\n}",
      "B4 {\n  $r10 \u003d List lastIndexes\u003e\n  return\n}",
      "B5 {\n  String[] lastArray\u003e \u003d r1\n  String lastKey\u003e \u003d r3\n  $r4 \u003d IdentityHashMap knownArrays\u003e\n  $r5 \u003d $r4.get(r1)\n  $r6 \u003d SegmentConstantPoolArrayCache$CachedArray) $r5\n  $r7 \u003d $r6.indexesForKey(r3)\n  List lastIndexes\u003e \u003d $r7\n  $r8 \u003d List lastIndexes\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentConstantPoolArrayCache#cacheArray(...1)",
        "body": "{\r\n    if (arrayIsCached(array)) {\r\n        throw new IllegalArgumentException(\"Trying to cache an array that already exists\");\r\n    }\r\n    knownArrays.put(array, new CachedArray(array));\r\n    // Invalidate the cache-within-a-cache\r\n    lastArray \u003d null;\r\n}"
      },
      {
        "name": "SegmentConstantPoolArrayCache#arrayIsCached(...1)",
        "body": "{\r\n    final CachedArray cachedArray \u003d knownArrays.get(array);\r\n    return !(cachedArray \u003d\u003d null || cachedArray.lastKnownSize() !\u003d array.length);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentHeader",
    "methodName": "getBandHeadersInputStream",
    "signature": "java.io.InputStream getBandHeadersInputStream()",
    "visibility": "public",
    "body": "{\r\n    if (bandHeadersInputStream \u003d\u003d null) {\r\n        bandHeadersInputStream \u003d new ByteArrayInputStream(EMPTY_BYTE_ARRAY);\r\n    }\r\n    return bandHeadersInputStream;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentHeader\n  $r1 \u003d InputStream bandHeadersInputStream\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ByteArrayInputStream\n  $r4 \u003d SegmentHeader: byte[] EMPTY_BYTE_ARRAY\u003e\n  new ByteArrayInputStream($r4)\n  InputStream bandHeadersInputStream\u003e \u003d $r3\n}",
      "B2 {\n  $r2 \u003d InputStream bandHeadersInputStream\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentHeader",
    "methodName": "read",
    "signature": "void read(java.io.InputStream)",
    "visibility": "public",
    "body": "{\r\n    final int[] word \u003d decodeScalar(\"archive_magic_word\", in, Codec.BYTE1, magic.length);\r\n    for (int m \u003d 0; m \u003c magic.length; m++) {\r\n        if (word[m] !\u003d magic[m]) {\r\n            throw new Error(\"Bad header\");\r\n        }\r\n    }\r\n    setArchiveMinorVersion(decodeScalar(\"archive_minver\", in, Codec.UNSIGNED5));\r\n    setArchiveMajorVersion(decodeScalar(\"archive_majver\", in, Codec.UNSIGNED5));\r\n    options \u003d new SegmentOptions(decodeScalar(\"archive_options\", in, Codec.UNSIGNED5));\r\n    parseArchiveFileCounts(in);\r\n    parseArchiveSpecialCounts(in);\r\n    parseCpCounts(in);\r\n    parseClassCounts(in);\r\n    if (getBandHeadersSize() \u003e 0) {\r\n        setBandHeadersData(IOUtils.readRange(in, getBandHeadersSize()));\r\n    }\r\n    archiveSizeOffset -\u003d in.available();\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i12 \u003e\u003d $i1) → B2 | else → B5",
      "B2 : If($i11 \u003d\u003d $i10) → B3 | else → B4",
      "B5 : If($i5 \u003c\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  SegmentHeader\n  InputStream\n  $r3 \u003d BHSDCodec BYTE1\u003e\n  $r2 \u003d SegmentHeader: int[] magic\u003e\n  $i0 \u003d lengthof $r2\n  r4 \u003d r0.decodeScalar(\"archive_magic_word\", r1, $r3, $i0)\n  i12 \u003d 0\n}",
      "B1 {\n  $r5 \u003d SegmentHeader: int[] magic\u003e\n  $i1 \u003d lengthof $r5\n  if (i12 \u003e\u003d $i1) goto B2 else B5\n}",
      "B2 {\n  $i11 \u003d r4[i12]\n  $r11 \u003d SegmentHeader: int[] magic\u003e\n  $i10 \u003d $r11[i12]\n  if ($i11 \u003d\u003d $i10) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d Error\n  new Error(\"Bad header\")\n  throw $r12\n}",
      "B4 {\n  i12 \u003d i12 + 1\n  goto B1\n}",
      "B5 {\n  $r6 \u003d BHSDCodec UNSIGNED5\u003e\n  $i2 \u003d r0.decodeScalar(\"archive_minver\", r1, $r6)\n  r0.setArchiveMinorVersion($i2)\n  $r7 \u003d BHSDCodec UNSIGNED5\u003e\n  $i3 \u003d r0.decodeScalar(\"archive_majver\", r1, $r7)\n  r0.setArchiveMajorVersion($i3)\n  $r8 \u003d SegmentOptions\n  $r9 \u003d BHSDCodec UNSIGNED5\u003e\n  $i4 \u003d r0.decodeScalar(\"archive_options\", r1, $r9)\n  new SegmentOptions($i4)\n  SegmentOptions options\u003e \u003d $r8\n  r0.parseArchiveFileCounts(r1)\n  r0.parseArchiveSpecialCounts(r1)\n  r0.parseCpCounts(r1)\n  r0.parseClassCounts(r1)\n  $i5 \u003d r0.getBandHeadersSize()\n  if ($i5 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $i9 \u003d r0.getBandHeadersSize()\n  $r10 \u003d IOUtils.readRange(r1, $i9)\n  r0.setBandHeadersData($r10)\n}",
      "B7 {\n  $i6 \u003d SegmentHeader: int archiveSizeOffset\u003e\n  $i7 \u003d r1.available()\n  $i8 \u003d $i6 - $i7\n  SegmentHeader: int archiveSizeOffset\u003e \u003d $i8\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SegmentHeader#parseArchiveFileCounts(...1)",
        "body": "{\r\n    if (options.hasArchiveFileCounts()) {\r\n        setArchiveSize((long) decodeScalar(\"archive_size_hi\", in, Codec.UNSIGNED5) \u003c\u003c 32 | decodeScalar(\"archive_size_lo\", in, Codec.UNSIGNED5));\r\n        archiveSizeOffset \u003d in.available();\r\n        setSegmentsRemaining(decodeScalar(\"archive_next_count\", in, Codec.UNSIGNED5));\r\n        setArchiveModtime(decodeScalar(\"archive_modtime\", in, Codec.UNSIGNED5));\r\n        numberOfFiles \u003d decodeScalar(\"file_count\", in, Codec.UNSIGNED5);\r\n    }\r\n}"
      },
      {
        "name": "SegmentHeader#parseArchiveSpecialCounts(...1)",
        "body": "{\r\n    if (getOptions().hasSpecialFormats()) {\r\n        bandHeadersSize \u003d decodeScalar(\"band_headers_size\", in, Codec.UNSIGNED5);\r\n        setAttributeDefinitionCount(decodeScalar(\"attr_definition_count\", in, Codec.UNSIGNED5));\r\n    }\r\n}"
      },
      {
        "name": "SegmentHeader#decodeScalar(...3)",
        "body": "{\r\n    final int ret \u003d codec.decode(in);\r\n    segment.log(Segment.LOG_LEVEL_VERBOSE, \"Parsed #\" + name + \" as \" + ret);\r\n    return ret;\r\n}"
      },
      {
        "name": "SegmentHeader#decodeScalar(...4)",
        "body": "{\r\n    segment.log(Segment.LOG_LEVEL_VERBOSE, \"Parsed #\" + name + \" (\" + n + \")\");\r\n    return codec.decodeInts(n, in);\r\n}"
      },
      {
        "name": "SegmentHeader#parseCpCounts(...1)",
        "body": "{\r\n    cpUTF8Count \u003d decodeScalar(\"cp_Utf8_count\", in, Codec.UNSIGNED5);\r\n    if (getOptions().hasCPNumberCounts()) {\r\n        cpIntCount \u003d decodeScalar(\"cp_Int_count\", in, Codec.UNSIGNED5);\r\n        cpFloatCount \u003d decodeScalar(\"cp_Float_count\", in, Codec.UNSIGNED5);\r\n        cpLongCount \u003d decodeScalar(\"cp_Long_count\", in, Codec.UNSIGNED5);\r\n        cpDoubleCount \u003d decodeScalar(\"cp_Double_count\", in, Codec.UNSIGNED5);\r\n    }\r\n    cpStringCount \u003d decodeScalar(\"cp_String_count\", in, Codec.UNSIGNED5);\r\n    cpClassCount \u003d decodeScalar(\"cp_Class_count\", in, Codec.UNSIGNED5);\r\n    cpSignatureCount \u003d decodeScalar(\"cp_Signature_count\", in, Codec.UNSIGNED5);\r\n    cpDescriptorCount \u003d decodeScalar(\"cp_Descr_count\", in, Codec.UNSIGNED5);\r\n    cpFieldCount \u003d decodeScalar(\"cp_Field_count\", in, Codec.UNSIGNED5);\r\n    cpMethodCount \u003d decodeScalar(\"cp_Method_count\", in, Codec.UNSIGNED5);\r\n    cpIMethodCount \u003d decodeScalar(\"cp_Imethod_count\", in, Codec.UNSIGNED5);\r\n}"
      },
      {
        "name": "SegmentHeader#setArchiveMinorVersion(...1)",
        "body": "{\r\n    if (version !\u003d 7) {\r\n        throw new Pack200Exception(\"Invalid segment minor version\");\r\n    }\r\n    archiveMinor \u003d version;\r\n}"
      },
      {
        "name": "SegmentHeader#parseClassCounts(...1)",
        "body": "{\r\n    innerClassCount \u003d decodeScalar(\"ic_count\", in, Codec.UNSIGNED5);\r\n    defaultClassMinorVersion \u003d decodeScalar(\"default_class_minver\", in, Codec.UNSIGNED5);\r\n    defaultClassMajorVersion \u003d decodeScalar(\"default_class_majver\", in, Codec.UNSIGNED5);\r\n    classCount \u003d decodeScalar(\"class_count\", in, Codec.UNSIGNED5);\r\n}"
      },
      {
        "name": "SegmentHeader#setBandHeadersData(...1)",
        "body": "{\r\n    this.bandHeadersInputStream \u003d new ByteArrayInputStream(bandHeaders);\r\n}"
      },
      {
        "name": "SegmentHeader#setArchiveMajorVersion(...1)",
        "body": "{\r\n    if (version !\u003d 150) {\r\n        throw new Pack200Exception(\"Invalid segment major version: \" + version);\r\n    }\r\n    archiveMajor \u003d version;\r\n}"
      },
      {
        "name": "SegmentHeader#getBandHeadersSize(...0)",
        "body": "{\r\n    return bandHeadersSize;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasAllCodeFlags",
    "signature": "boolean hasAllCodeFlags()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_ALL_CODE_FLAGS) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 4\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasArchiveFileCounts",
    "signature": "boolean hasArchiveFileCounts()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_FILE_HEADERS) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 16\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasClassFlagsHi",
    "signature": "boolean hasClassFlagsHi()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_CLASS_FLAGS_HI) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 512\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasCodeFlagsHi",
    "signature": "boolean hasCodeFlagsHi()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_CODE_FLAGS_HI) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 1024\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasCPNumberCounts",
    "signature": "boolean hasCPNumberCounts()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_CP_NUMBERS) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 2\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasFieldFlagsHi",
    "signature": "boolean hasFieldFlagsHi()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_FIELD_FLAGS_HI) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 1024\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasFileModtime",
    "signature": "boolean hasFileModtime()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_FILE_MODTIME) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 64\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasFileOptions",
    "signature": "boolean hasFileOptions()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_FILE_OPTIONS) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 128\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasFileSizeHi",
    "signature": "boolean hasFileSizeHi()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_FILE_SIZE_HI) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 256\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasMethodFlagsHi",
    "signature": "boolean hasMethodFlagsHi()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_METHOD_FLAGS_HI) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 2048\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "hasSpecialFormats",
    "signature": "boolean hasSpecialFormats()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 HAVE_SPECIAL_FORMATS) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentOptions",
    "methodName": "shouldDeflate",
    "signature": "boolean shouldDeflate()",
    "visibility": "public",
    "body": "{\r\n    return (options \u0026 DEFLATE_HINT) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SegmentOptions\n  $i0 \u003d SegmentOptions: int options\u003e\n  $i1 \u003d $i0 \u0026 32\n  if ($i1 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentUtils",
    "methodName": "countBit16",
    "signature": "int countBit16(int[])",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (final int flag : flags) {\r\n        if ((flag \u0026 1 \u003c\u003c 16) !\u003d 0) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($i2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: int[]\n  i3 \u003d 0\n  i0 \u003d lengthof r0\n  i4 \u003d 0\n}",
      "B1 {\n  if (i4 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  i1 \u003d r0[i4]\n  $i2 \u003d i1 \u0026 65536\n  if ($i2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i3 \u003d i3 + 1\n}",
      "B4 {\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentUtils",
    "methodName": "countBit16",
    "signature": "int countBit16(long[])",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (final long flag : flags) {\r\n        if ((flag \u0026 1 \u003c\u003c 16) !\u003d 0) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($b3 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: long[]\n  i4 \u003d 0\n  i0 \u003d lengthof r0\n  i5 \u003d 0\n}",
      "B1 {\n  if (i5 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  l1 \u003d r0[i5]\n  $l2 \u003d l1 \u0026 65536L\n  $b3 \u003d $l2 cmp 0L\n  if ($b3 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i4 \u003d i4 + 1\n}",
      "B4 {\n  i5 \u003d i5 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentUtils",
    "methodName": "countBit16",
    "signature": "int countBit16(long[][])",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (final long flag : flags) {\r\n        if ((flag \u0026 1 \u003c\u003c 16) !\u003d 0) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B1 : If(i6 \u003e\u003d i0) → B2 | else → B8",
      "B3 : If(i7 \u003e\u003d i1) → B4 | else → B7",
      "B4 : If($b4 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: long[][]\n  i5 \u003d 0\n  i0 \u003d lengthof r0\n  i6 \u003d 0\n}",
      "B1 {\n  if (i6 \u003e\u003d i0) goto B2 else B8\n}",
      "B2 {\n  r1 \u003d r0[i6]\n  i1 \u003d lengthof r1\n  i7 \u003d 0\n}",
      "B3 {\n  if (i7 \u003e\u003d i1) goto B4 else B7\n}",
      "B4 {\n  l2 \u003d r1[i7]\n  $l3 \u003d l2 \u0026 65536L\n  $b4 \u003d $l3 cmp 0L\n  if ($b4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  i5 \u003d i5 + 1\n}",
      "B6 {\n  i7 \u003d i7 + 1\n  goto B3\n}",
      "B7 {\n  i6 \u003d i6 + 1\n  goto B1\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e B1",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentUtils",
    "methodName": "countMatches",
    "signature": "int countMatches(long[],org.apache.commons.compress.harmony.unpack200.IMatcher)",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (final long flag : flags) {\r\n        if (matcher.matches(flag)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: long[]\n  IMatcher\n  i2 \u003d 0\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  l1 \u003d r0[i3]\n  $z0 \u003d r1.matches(l1)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i2 \u003d i2 + 1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.harmony.unpack200.SegmentUtils",
    "methodName": "countMatches",
    "signature": "int countMatches(long[][],org.apache.commons.compress.harmony.unpack200.IMatcher)",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (final long flag : flags) {\r\n        if (matcher.matches(flag)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: long[][]\n  IMatcher\n  i2 \u003d 0\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r1 \u003d r0[i3]\n  $i1 \u003d SegmentUtils.countMatches(r1, r2)\n  i2 \u003d i2 + $i1\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.parallel.FileBasedScatterGatherBackingStore",
    "methodName": "closeForWriting",
    "signature": "void closeForWriting()",
    "visibility": "public",
    "body": "{\r\n    if (!closed) {\r\n        outputStream.close();\r\n        closed \u003d true;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FileBasedScatterGatherBackingStore\n  $z0 \u003d FileBasedScatterGatherBackingStore: boolean closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d OutputStream outputStream\u003e\n  $r1.close()\n  FileBasedScatterGatherBackingStore: boolean closed\u003e \u003d 1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ArchiveUtils",
    "methodName": "isArrayZero",
    "signature": "boolean isArrayZero(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    for (int i \u003d 0; i \u003c size; i++) {\r\n        if (a[i] !\u003d 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i2 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($b1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i2 \u003d 0\n}",
      "B1 {\n  if (i2 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $b1 \u003d r0[i2]\n  if ($b1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i2 \u003d i2 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ArchiveUtils",
    "methodName": "isEqual",
    "signature": "boolean isEqual(byte[],int,int,byte[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    final int minLen \u003d Math.min(length1, length2);\r\n    for (int i \u003d 0; i \u003c minLen; i++) {\r\n        if (buffer1[offset1 + i] !\u003d buffer2[offset2 + i]) {\r\n            return false;\r\n        }\r\n    }\r\n    if (length1 \u003d\u003d length2) {\r\n        return true;\r\n    }\r\n    if (ignoreTrailingNulls) {\r\n        if (length1 \u003e length2) {\r\n            for (int i \u003d length2; i \u003c length1; i++) {\r\n                if (buffer1[offset1 + i] !\u003d 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            for (int i \u003d length1; i \u003c length2; i++) {\r\n                if (buffer2[offset2 + i] !\u003d 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "nodes": 22,
    "edges": 25,
    "cc": 5,
    "flowSummary": [
      "B1 : If(i13 \u003e\u003d i2) → B2 | else → B5",
      "B2 : If($i16 \u003d\u003d $i17) → B3 | else → B4",
      "B5 : If(i0 !\u003d i1) → B6 | else → B7",
      "B7 : If(z0 \u003d\u003d false) → B8 | else → B21",
      "B8 : If(i0 \u003c\u003d i1) → B9 | else → B15",
      "B10 : If(i14 \u003e\u003d i0) → B11 | else → B14",
      "B11 : If($b8 \u003d\u003d false) → B12 | else → B13",
      "B16 : If(i15 \u003e\u003d i1) → B17 | else → B20",
      "B17 : If($b5 \u003d\u003d false) → B18 | else → B19"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: byte[]\n  i6 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  r0 :\u003d @parameter3: byte[]\n  i3 :\u003d @parameter4: int\n  i1 :\u003d @parameter5: int\n  z0 :\u003d @parameter6: boolean\n  i2 \u003d Math.min(i0, i1)\n  i13 \u003d 0\n}",
      "B1 {\n  if (i13 \u003e\u003d i2) goto B2 else B5\n}",
      "B2 {\n  $i9 \u003d i6 + i13\n  $b12 \u003d r1[$i9]\n  $i10 \u003d i3 + i13\n  $b11 \u003d r0[$i10]\n  $i16 \u003d (int) $b12\n  $i17 \u003d (int) $b11\n  if ($i16 \u003d\u003d $i17) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i13 \u003d i13 + 1\n  goto B1\n}",
      "B5 {\n  if (i0 !\u003d i1) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  if (z0 \u003d\u003d false) goto B8 else B21\n}",
      "B8 {\n  if (i0 \u003c\u003d i1) goto B9 else B15\n}",
      "B9 {\n  i14 \u003d i1\n}",
      "B10 {\n  if (i14 \u003e\u003d i0) goto B11 else B14\n}",
      "B11 {\n  $i7 \u003d i6 + i14\n  $b8 \u003d r1[$i7]\n  if ($b8 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  return\n}",
      "B13 {\n  i14 \u003d i14 + 1\n  goto B10\n}",
      "B14 {\n  goto B20\n}",
      "B15 {\n  i15 \u003d i0\n}",
      "B16 {\n  if (i15 \u003e\u003d i1) goto B17 else B20\n}",
      "B17 {\n  $i4 \u003d i3 + i15\n  $b5 \u003d r0[$i4]\n  if ($b5 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  return\n}",
      "B19 {\n  i15 \u003d i15 + 1\n  goto B16\n}",
      "B20 {\n  return\n}",
      "B21 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B21",
      "B8 --\u003e B9",
      "B8 --\u003e B15",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B10",
      "B14 --\u003e B20",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B20",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B16",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ArchiveUtils",
    "methodName": "sanitize",
    "signature": "java.lang.String sanitize(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final char[] cs \u003d s.toCharArray();\r\n    final char[] chars \u003d cs.length \u003c\u003d MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH);\r\n    if (cs.length \u003e MAX_SANITIZED_NAME_LENGTH) {\r\n        Arrays.fill(chars, MAX_SANITIZED_NAME_LENGTH - 3, MAX_SANITIZED_NAME_LENGTH, \u0027.\u0027);\r\n    }\r\n    final StringBuilder sb \u003d new StringBuilder();\r\n    for (final char c : chars) {\r\n        if (!Character.isISOControl(c)) {\r\n            final Character.UnicodeBlock block \u003d Character.UnicodeBlock.of(c);\r\n            if (block !\u003d null \u0026\u0026 block !\u003d Character.UnicodeBlock.SPECIALS) {\r\n                sb.append(c);\r\n                continue;\r\n            }\r\n        }\r\n        sb.append(\u0027?\u0027);\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If($i0 \u003e 255) → B1 | else → B2",
      "B3 : If($i1 \u003c\u003d 255) → B4 | else → B5",
      "B6 : If(i4 \u003e\u003d $i3) → B7 | else → B13",
      "B7 : If($z0 !\u003d 0) → B8 | else → B11",
      "B8 : If(r5 \u003d\u003d null) → B9 | else → B11",
      "B9 : If(r5 \u003d\u003d $r6) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  String\n  r1 \u003d r0.toCharArray()\n  $i0 \u003d lengthof r1\n  if ($i0 \u003e 255) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r7 \u003d Arrays.copyOf(r1, 255)\n}",
      "B3 {\n  r2 \u003d $r7\n  $i1 \u003d lengthof r1\n  if ($i1 \u003c\u003d 255) goto B4 else B5\n}",
      "B4 {\n  Arrays.fill($r7, 252, 255, 46)\n}",
      "B5 {\n  $r3 \u003d StringBuilder\n  new StringBuilder()\n  $i3 \u003d lengthof r2\n  i4 \u003d 0\n}",
      "B6 {\n  if (i4 \u003e\u003d $i3) goto B7 else B13\n}",
      "B7 {\n  c2 \u003d r2[i4]\n  $z0 \u003d Character.isISOControl(c2)\n  if ($z0 !\u003d 0) goto B8 else B11\n}",
      "B8 {\n  r5 \u003d Character$UnicodeBlock.of(c2)\n  if (r5 \u003d\u003d null) goto B9 else B11\n}",
      "B9 {\n  $r6 \u003d Character$UnicodeBlock SPECIALS\u003e\n  if (r5 \u003d\u003d $r6) goto B10 else B11\n}",
      "B10 {\n  $r3.append(c2)\n  goto B12\n}",
      "B11 {\n  $r3.append(63)\n}",
      "B12 {\n  i4 \u003d i4 + 1\n  goto B6\n}",
      "B13 {\n  $r4 \u003d $r3.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B6",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ArchiveUtils",
    "methodName": "toString",
    "signature": "java.lang.String toString(org.apache.commons.compress.archivers.ArchiveEntry)",
    "visibility": "public",
    "body": "{\r\n    final StringBuilder sb \u003d new StringBuilder();\r\n    // c.f. \"ls -l\" output\r\n    sb.append(entry.isDirectory() ? \u0027d\u0027 : \u0027-\u0027);\r\n    final String size \u003d Long.toString(entry.getSize());\r\n    sb.append(\u0027 \u0027);\r\n    // Pad output to 7 places, leading spaces\r\n    for (int i \u003d 7; i \u003e size.length(); i--) {\r\n        sb.append(\u0027 \u0027);\r\n    }\r\n    sb.append(size);\r\n    sb.append(\u0027 \u0027).append(entry.getName());\r\n    return sb.toString();\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B4 : If(i2 \u003c\u003d $i3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ArchiveEntry\n  $r6 \u003d StringBuilder\n  new StringBuilder()\n  $z0 \u003d r1.isDirectory()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $c1 \u003d 100\n  goto B3\n}",
      "B2 {\n  $c1 \u003d 45\n}",
      "B3 {\n  $r6.append($c1)\n  $l0 \u003d r1.getSize()\n  $r5 \u003d Long.toString($l0)\n  $r6.append(32)\n  i2 \u003d 7\n}",
      "B4 {\n  $i3 \u003d $r5.length()\n  if (i2 \u003c\u003d $i3) goto B5 else B6\n}",
      "B5 {\n  $r6.append(32)\n  $i5 \u003d (int) -1\n  i2 \u003d i2 + $i5\n  goto B4\n}",
      "B6 {\n  $r6.append($r5)\n  $r3 \u003d $r6.append(32)\n  $r2 \u003d r1.getName()\n  $r3.append($r2)\n  $r4 \u003d $r6.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B4",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.BitInputStream",
    "methodName": "alignWithByteBoundary",
    "signature": "void alignWithByteBoundary()",
    "visibility": "public",
    "body": "{\r\n    final int toSkip \u003d bitsCachedSize % Byte.SIZE;\r\n    if (toSkip \u003e 0) {\r\n        readCachedBits(toSkip);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BitInputStream\n  $i0 \u003d BitInputStream: int bitsCachedSize\u003e\n  i1 \u003d $i0 % 8\n  if (i1 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r0.readCachedBits(i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BitInputStream#readCachedBits(...1)",
        "body": "{\r\n    final long bitsOut;\r\n    if (byteOrder \u003d\u003d ByteOrder.LITTLE_ENDIAN) {\r\n        bitsOut \u003d bitsCached \u0026 MASKS[count];\r\n        bitsCached \u003e\u003e\u003e\u003d count;\r\n    } else {\r\n        bitsOut \u003d bitsCached \u003e\u003e bitsCachedSize - count \u0026 MASKS[count];\r\n    }\r\n    bitsCachedSize -\u003d count;\r\n    return bitsOut;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.BitInputStream",
    "methodName": "readBits",
    "signature": "long readBits(int)",
    "visibility": "public",
    "body": "{\r\n    if (count \u003c 0 || count \u003e MAXIMUM_CACHE_SIZE) {\r\n        throw new IOException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\r\n    }\r\n    if (ensureCache(count)) {\r\n        return -1;\r\n    }\r\n    if (bitsCachedSize \u003c count) {\r\n        return processBitsGreater57(count);\r\n    }\r\n    return readCachedBits(count);\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B2",
      "B1 : If(i0 \u003c\u003d 63) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($i1 \u003e\u003d i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  BitInputStream\n  i0 :\u003d @parameter0: int\n  if (i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003c\u003d 63) goto B2 else B3\n}",
      "B2 {\n  $r0 \u003d IOException\n  new IOException(\"count must not be negative or greater than 63\")\n  throw $r0\n}",
      "B3 {\n  $z0 \u003d r1.ensureCache(i0)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d BitInputStream: int bitsCachedSize\u003e\n  if ($i1 \u003e\u003d i0) goto B6 else B7\n}",
      "B6 {\n  $l3 \u003d r1.processBitsGreater57(i0)\n  return\n}",
      "B7 {\n  $l2 \u003d r1.readCachedBits(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BitInputStream#processBitsGreater57(...1)",
        "body": "{\r\n    final long bitsOut;\r\n    final int overflowBits;\r\n    long overflow \u003d 0L;\r\n    // bitsCachedSize \u003e\u003d 57 and left-shifting it 8 bits would cause an overflow\r\n    final int bitsToAddCount \u003d count - bitsCachedSize;\r\n    overflowBits \u003d Byte.SIZE - bitsToAddCount;\r\n    final long nextByte \u003d in.read();\r\n    if (nextByte \u003c 0) {\r\n        return nextByte;\r\n    }\r\n    if (byteOrder \u003d\u003d ByteOrder.LITTLE_ENDIAN) {\r\n        final long bitsToAdd \u003d nextByte \u0026 MASKS[bitsToAddCount];\r\n        bitsCached |\u003d bitsToAdd \u003c\u003c bitsCachedSize;\r\n        overflow \u003d nextByte \u003e\u003e\u003e bitsToAddCount \u0026 MASKS[overflowBits];\r\n    } else {\r\n        bitsCached \u003c\u003c\u003d bitsToAddCount;\r\n        final long bitsToAdd \u003d nextByte \u003e\u003e\u003e overflowBits \u0026 MASKS[bitsToAddCount];\r\n        bitsCached |\u003d bitsToAdd;\r\n        overflow \u003d nextByte \u0026 MASKS[overflowBits];\r\n    }\r\n    bitsOut \u003d bitsCached \u0026 MASKS[count];\r\n    bitsCached \u003d overflow;\r\n    bitsCachedSize \u003d overflowBits;\r\n    return bitsOut;\r\n}"
      },
      {
        "name": "BitInputStream#readCachedBits(...1)",
        "body": "{\r\n    final long bitsOut;\r\n    if (byteOrder \u003d\u003d ByteOrder.LITTLE_ENDIAN) {\r\n        bitsOut \u003d bitsCached \u0026 MASKS[count];\r\n        bitsCached \u003e\u003e\u003e\u003d count;\r\n    } else {\r\n        bitsOut \u003d bitsCached \u003e\u003e bitsCachedSize - count \u0026 MASKS[count];\r\n    }\r\n    bitsCachedSize -\u003d count;\r\n    return bitsOut;\r\n}"
      },
      {
        "name": "BitInputStream#ensureCache(...1)",
        "body": "{\r\n    while (bitsCachedSize \u003c count \u0026\u0026 bitsCachedSize \u003c 57) {\r\n        final long nextByte \u003d in.read();\r\n        if (nextByte \u003c 0) {\r\n            return true;\r\n        }\r\n        if (byteOrder \u003d\u003d ByteOrder.LITTLE_ENDIAN) {\r\n            bitsCached |\u003d nextByte \u003c\u003c bitsCachedSize;\r\n        } else {\r\n            bitsCached \u003c\u003c\u003d Byte.SIZE;\r\n            bitsCached |\u003d nextByte;\r\n        }\r\n        bitsCachedSize +\u003d Byte.SIZE;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "fromLittleEndian",
    "signature": "long fromLittleEndian(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    checkReadLength(length);\r\n    long l \u003d 0;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        l |\u003d (bytes[off + i] \u0026 0xffL) \u003c\u003c 8 * i;\r\n    }\r\n    return l;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i9 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  ByteUtils.checkReadLength(i0)\n  l8 \u003d 0L\n  i9 \u003d 0\n}",
      "B1 {\n  if (i9 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d i1 + i9\n  $b3 \u003d r0[$i2]\n  $l4 \u003d (long) $b3\n  $l6 \u003d $l4 \u0026 255L\n  $i5 \u003d 8 * i9\n  $l7 \u003d $l6 \u003c\u003c $i5\n  l8 \u003d l8 | $l7\n  i9 \u003d i9 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteUtils#checkReadLength(...1)",
        "body": "{\r\n    if (length \u003e 8) {\r\n        throw new IllegalArgumentException(\"Can\u0027t read more than eight bytes into a long value\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "fromLittleEndian",
    "signature": "long fromLittleEndian(org.apache.commons.compress.utils.ByteUtils$ByteSupplier,int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($b3 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteUtils$ByteSupplier\n  i0 :\u003d @parameter1: int\n  ByteUtils.checkReadLength(i0)\n  l6 \u003d 0L\n  i7 \u003d 0\n}",
      "B1 {\n  if (i7 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $i1 \u003d r0.getAsByte()\n  l2 \u003d (long) $i1\n  $b3 \u003d l2 cmp -1L\n  if ($b3 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d IOException\n  new IOException(\"Premature end of data\")\n  throw $r1\n}",
      "B4 {\n  $i4 \u003d i7 * 8\n  $l5 \u003d l2 \u003c\u003c $i4\n  l6 \u003d l6 | $l5\n  i7 \u003d i7 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "fromLittleEndian",
    "signature": "long fromLittleEndian(java.io.DataInput,int)",
    "visibility": "public",
    "body": "{\r\n    // somewhat duplicates the ByteSupplier version in order to save the creation of a wrapper object\r\n    checkReadLength(length);\r\n    long l \u003d 0;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        final long b \u003d in.readUnsignedByte();\r\n        l |\u003d b \u003c\u003c i * 8;\r\n    }\r\n    return l;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i6 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DataInput\n  i0 :\u003d @parameter1: int\n  ByteUtils.checkReadLength(i0)\n  l5 \u003d 0L\n  i6 \u003d 0\n}",
      "B1 {\n  if (i6 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  $i1 \u003d r0.readUnsignedByte()\n  l2 \u003d (long) $i1\n  $i3 \u003d i6 * 8\n  $l4 \u003d l2 \u003c\u003c $i3\n  l5 \u003d l5 | $l4\n  i6 \u003d i6 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteUtils#checkReadLength(...1)",
        "body": "{\r\n    if (length \u003e 8) {\r\n        throw new IllegalArgumentException(\"Can\u0027t read more than eight bytes into a long value\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "fromLittleEndian",
    "signature": "long fromLittleEndian(java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    // somewhat duplicates the ByteSupplier version in order to save the creation of a wrapper object\r\n    checkReadLength(length);\r\n    long l \u003d 0;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        final long b \u003d in.read();\r\n        if (b \u003d\u003d -1) {\r\n            throw new IOException(\"Premature end of data\");\r\n        }\r\n        l |\u003d b \u003c\u003c i * 8;\r\n    }\r\n    return l;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($b3 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  InputStream\n  i0 :\u003d @parameter1: int\n  ByteUtils.checkReadLength(i0)\n  l6 \u003d 0L\n  i7 \u003d 0\n}",
      "B1 {\n  if (i7 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $i1 \u003d r0.read()\n  l2 \u003d (long) $i1\n  $b3 \u003d l2 cmp -1L\n  if ($b3 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d IOException\n  new IOException(\"Premature end of data\")\n  throw $r1\n}",
      "B4 {\n  $i4 \u003d i7 * 8\n  $l5 \u003d l2 \u003c\u003c $i4\n  l6 \u003d l6 | $l5\n  i7 \u003d i7 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteUtils#checkReadLength(...1)",
        "body": "{\r\n    if (length \u003e 8) {\r\n        throw new IllegalArgumentException(\"Can\u0027t read more than eight bytes into a long value\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "toLittleEndian",
    "signature": "void toLittleEndian(byte[],long,int,int)",
    "visibility": "public",
    "body": "{\r\n    long num \u003d value;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        b[off + i] \u003d (byte) (num \u0026 0xff);\r\n        num \u003e\u003e\u003d 8;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i8 \u003e\u003d i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: byte[]\n  l0 :\u003d @parameter1: long\n  i2 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  l7 \u003d l0\n  i8 \u003d 0\n}",
      "B1 {\n  if (i8 \u003e\u003d i1) goto B2 else B3\n}",
      "B2 {\n  $i6 \u003d i2 + i8\n  $l3 \u003d l7 \u0026 255L\n  $i4 \u003d (int) $l3\n  $b5 \u003d (byte) $i4\n  r0[$i6] \u003d $b5\n  l7 \u003d l7 \u003e\u003e 8\n  i8 \u003d i8 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "toLittleEndian",
    "signature": "void toLittleEndian(org.apache.commons.compress.utils.ByteUtils$ByteConsumer,long,int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ByteUtils$ByteConsumer\n  l0 :\u003d @parameter1: long\n  i1 :\u003d @parameter2: int\n  l4 \u003d l0\n  i5 \u003d 0\n}",
      "B1 {\n  if (i5 \u003e\u003d i1) goto B2 else B3\n}",
      "B2 {\n  $l2 \u003d l4 \u0026 255L\n  $i3 \u003d (int) $l2\n  r0.accept($i3)\n  l4 \u003d l4 \u003e\u003e 8\n  i5 \u003d i5 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "toLittleEndian",
    "signature": "void toLittleEndian(java.io.DataOutput,long,int)",
    "visibility": "public",
    "body": "{\r\n    // somewhat duplicates the ByteConsumer version in order to save the creation of a wrapper object\r\n    long num \u003d value;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        out.write((int) (num \u0026 0xff));\r\n        num \u003e\u003e\u003d 8;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  DataOutput\n  l0 :\u003d @parameter1: long\n  i1 :\u003d @parameter2: int\n  l4 \u003d l0\n  i5 \u003d 0\n}",
      "B1 {\n  if (i5 \u003e\u003d i1) goto B2 else B3\n}",
      "B2 {\n  $l2 \u003d l4 \u0026 255L\n  $i3 \u003d (int) $l2\n  r0.write($i3)\n  l4 \u003d l4 \u003e\u003e 8\n  i5 \u003d i5 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ByteUtils",
    "methodName": "toLittleEndian",
    "signature": "void toLittleEndian(java.io.OutputStream,long,int)",
    "visibility": "public",
    "body": "{\r\n    // somewhat duplicates the ByteConsumer version in order to save the creation of a wrapper object\r\n    long num \u003d value;\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        out.write((int) (num \u0026 0xff));\r\n        num \u003e\u003e\u003d 8;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  OutputStream\n  l0 :\u003d @parameter1: long\n  i1 :\u003d @parameter2: int\n  l4 \u003d l0\n  i5 \u003d 0\n}",
      "B1 {\n  if (i5 \u003e\u003d i1) goto B2 else B3\n}",
      "B2 {\n  $l2 \u003d l4 \u0026 255L\n  $i3 \u003d (int) $l2\n  r0.write($i3)\n  l4 \u003d l4 \u003e\u003e 8\n  i5 \u003d i5 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.Charsets",
    "methodName": "toCharset",
    "signature": "java.nio.charset.Charset toCharset(java.nio.charset.Charset)",
    "visibility": "public",
    "body": "{\r\n    return charset \u003d\u003d null ? Charset.defaultCharset() : charset;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Charset\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Charset.defaultCharset()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.Charsets",
    "methodName": "toCharset",
    "signature": "java.nio.charset.Charset toCharset(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return charset \u003d\u003d null ? Charset.defaultCharset() : Charset.forName(charset);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Charset.defaultCharset()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d Charset.forName(r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    if (remaining \u003c\u003d 0) {\r\n        return -1;\r\n    }\r\n    final int data \u003d super.read();\r\n    if (data \u003e\u003d 0) {\r\n        --remaining;\r\n    }\r\n    verify();\r\n    return data;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i5 \u003e 0) → B1 | else → B2",
      "B2 : If(i2 \u003c 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ChecksumVerifyingInputStream\n  $l0 \u003d ChecksumVerifyingInputStream: long remaining\u003e\n  $b1 \u003d $l0 cmp 0L\n  $i5 \u003d (int) $b1\n  if ($i5 \u003e 0) goto B1 else B2\n}",
      "B1 {\n  $i7 \u003d (int) -1\n  return\n}",
      "B2 {\n  i2 \u003d r0.read()\n  if (i2 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $l3 \u003d ChecksumVerifyingInputStream: long remaining\u003e\n  $l4 \u003d $l3 - 1L\n  ChecksumVerifyingInputStream: long remaining\u003e \u003d $l4\n}",
      "B4 {\n  r0.verify()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ChecksumVerifyingInputStream#verify(...0)",
        "body": "{\r\n    if (remaining \u003c\u003d 0 \u0026\u0026 expected !\u003d getChecksum().getValue()) {\r\n        throw new IOException(\"Checksum verification failed\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final int readCount \u003d super.read(b, off, len);\r\n    if (readCount \u003e\u003d 0) {\r\n        remaining -\u003d readCount;\r\n    }\r\n    verify();\r\n    return readCount;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i2 \u003c 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ChecksumVerifyingInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i2 \u003d r0.read(r1, i1, i0)\n  if (i2 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $l4 \u003d ChecksumVerifyingInputStream: long remaining\u003e\n  $l3 \u003d (long) i2\n  $l5 \u003d $l4 - $l3\n  ChecksumVerifyingInputStream: long remaining\u003e \u003d $l5\n}",
      "B4 {\n  r0.verify()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ChecksumVerifyingInputStream#verify(...0)",
        "body": "{\r\n    if (remaining \u003c\u003d 0 \u0026\u0026 expected !\u003d getChecksum().getValue()) {\r\n        throw new IOException(\"Checksum verification failed\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.CountingInputStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    final int r \u003d in.read();\r\n    if (r \u003e\u003d 0) {\r\n        count(1);\r\n    }\r\n    return r;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CountingInputStream\n  $r1 \u003d InputStream in\u003e\n  i0 \u003d $r1.read()\n  if (i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.count(1L)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CountingInputStream#count(...1)",
        "body": "{\r\n    if (read !\u003d -1) {\r\n        bytesRead +\u003d read;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.CountingInputStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003d\u003d 0) {\r\n        return 0;\r\n    }\r\n    final int r \u003d in.read(b, off, len);\r\n    if (r \u003e\u003d 0) {\r\n        count(r);\r\n    }\r\n    return r;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i2 \u003c 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CountingInputStream\n  r1 :\u003d @parameter0: byte[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d InputStream in\u003e\n  i2 \u003d $r2.read(r1, i1, i0)\n  if (i2 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $l3 \u003d (long) i2\n  r0.count($l3)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CountingInputStream#count(...1)",
        "body": "{\r\n    if (read !\u003d -1) {\r\n        bytesRead +\u003d read;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.FileNameUtils",
    "methodName": "getBaseName",
    "signature": "java.lang.String getBaseName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (fileName \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return FilenameUtils.removeExtension(new File(fileName).getName());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d File\n  new File(r0)\n  $r2 \u003d $r1.getName()\n  $r3 \u003d FilenameUtils.removeExtension($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (closed.compareAndSet(false, true)) {\r\n        try {\r\n            flushBlock();\r\n        } finally {\r\n            out.close();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  $r1 \u003d AtomicBoolean closed\u003e\n  $z0 \u003d $r1.compareAndSet(0, 1)\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  r0.flushBlock()\n  $r2 \u003d WritableByteChannel out\u003e\n  $r2.close()\n  goto B3\n}",
      "B2 {\n  $r3 :\u003d @caughtexception\n  $r4 \u003d WritableByteChannel out\u003e\n  $r4.close()\n  throw $r3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedLengthBlockOutputStream#flushBlock(...0)",
        "body": "{\r\n    if (buffer.position() !\u003d 0) {\r\n        padBlock();\r\n        writeBlock();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "flushBlock",
    "signature": "void flushBlock()",
    "visibility": "public",
    "body": "{\r\n    if (buffer.position() !\u003d 0) {\r\n        padBlock();\r\n        writeBlock();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  $r1 \u003d ByteBuffer buffer\u003e\n  $i0 \u003d $r1.position()\n  if ($i0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.padBlock()\n  r0.writeBlock()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedLengthBlockOutputStream#padBlock(...0)",
        "body": "{\r\n    buffer.order(ByteOrder.nativeOrder());\r\n    int bytesToWrite \u003d buffer.remaining();\r\n    if (bytesToWrite \u003e 8) {\r\n        final int align \u003d buffer.position() \u0026 7;\r\n        if (align !\u003d 0) {\r\n            final int limit \u003d 8 - align;\r\n            for (int i \u003d 0; i \u003c limit; i++) {\r\n                buffer.put((byte) 0);\r\n            }\r\n            bytesToWrite -\u003d limit;\r\n        }\r\n        while (bytesToWrite \u003e\u003d 8) {\r\n            buffer.putLong(0L);\r\n            bytesToWrite -\u003d 8;\r\n        }\r\n    }\r\n    while (buffer.hasRemaining()) {\r\n        buffer.put((byte) 0);\r\n    }\r\n}"
      },
      {
        "name": "FixedLengthBlockOutputStream#writeBlock(...0)",
        "body": "{\r\n    buffer.flip();\r\n    final int i \u003d out.write(buffer);\r\n    final boolean hasRemaining \u003d buffer.hasRemaining();\r\n    if (i !\u003d blockSize || hasRemaining) {\r\n        throw new IOException(String.format(\"Failed to write %,d bytes atomically. Only wrote  %,d\", blockSize, i));\r\n    }\r\n    buffer.clear();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "isOpen",
    "signature": "boolean isOpen()",
    "visibility": "public",
    "body": "{\r\n    if (!out.isOpen()) {\r\n        closed.set(true);\r\n    }\r\n    return !closed.get();\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  $r1 \u003d WritableByteChannel out\u003e\n  $z0 \u003d $r1.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d AtomicBoolean closed\u003e\n  $r3.set(1)\n}",
      "B2 {\n  $r2 \u003d AtomicBoolean closed\u003e\n  $z1 \u003d $r2.get()\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z2 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z2 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    int off \u003d offset;\r\n    int len \u003d length;\r\n    while (len \u003e 0) {\r\n        final int n \u003d Math.min(len, buffer.remaining());\r\n        buffer.put(b, off, n);\r\n        maybeFlush();\r\n        len -\u003d n;\r\n        off +\u003d n;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B3 : If(i5 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r4\n}",
      "B2 {\n  i4 \u003d i0\n  i5 \u003d i1\n}",
      "B3 {\n  if (i5 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r1 \u003d ByteBuffer buffer\u003e\n  $i2 \u003d $r1.remaining()\n  i3 \u003d Math.min(i5, $i2)\n  $r3 \u003d ByteBuffer buffer\u003e\n  $r3.put(r2, i4, i3)\n  r0.maybeFlush()\n  i5 \u003d i5 - i3\n  i4 \u003d i4 + i3\n  goto B3\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedLengthBlockOutputStream#isOpen(...0)",
        "body": "{\r\n    if (!out.isOpen()) {\r\n        closed.set(true);\r\n    }\r\n    return !closed.get();\r\n}"
      },
      {
        "name": "FixedLengthBlockOutputStream#maybeFlush(...0)",
        "body": "{\r\n    if (!buffer.hasRemaining()) {\r\n        writeBlock();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "write",
    "signature": "int write(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    final int srcRemaining \u003d src.remaining();\r\n    if (srcRemaining \u003e\u003d buffer.remaining()) {\r\n        int srcLeft \u003d srcRemaining;\r\n        final int savedLimit \u003d src.limit();\r\n        // If we\u0027re not at the start of buffer, we have some bytes already buffered\r\n        // fill up the reset of buffer and write the block.\r\n        if (buffer.position() !\u003d 0) {\r\n            final int n \u003d buffer.remaining();\r\n            src.limit(src.position() + n);\r\n            buffer.put(src);\r\n            writeBlock();\r\n            srcLeft -\u003d n;\r\n        }\r\n        // whilst we have enough bytes in src for complete blocks,\r\n        // write them directly from src without copying them to buffer\r\n        while (srcLeft \u003e\u003d blockSize) {\r\n            src.limit(src.position() + blockSize);\r\n            out.write(src);\r\n            srcLeft -\u003d blockSize;\r\n        }\r\n        // copy any remaining bytes into buffer\r\n        src.limit(savedLimit);\r\n    }\r\n    // if we don\u0027t have enough bytes in src to fill up a block we must buffer\r\n    buffer.put(src);\r\n    return srcRemaining;\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003c $i1) → B3 | else → B8",
      "B3 : If($i3 \u003d\u003d false) → B4 | else → B5",
      "B5 : If(i11 \u003c $i12) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  ByteBuffer\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r8\n}",
      "B2 {\n  i0 \u003d r1.remaining()\n  $r2 \u003d ByteBuffer buffer\u003e\n  $i1 \u003d $r2.remaining()\n  if (i0 \u003c $i1) goto B3 else B8\n}",
      "B3 {\n  i11 \u003d i0\n  i2 \u003d r1.limit()\n  $r4 \u003d ByteBuffer buffer\u003e\n  $i3 \u003d $r4.position()\n  if ($i3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r6 \u003d ByteBuffer buffer\u003e\n  i8 \u003d $r6.remaining()\n  $i9 \u003d r1.position()\n  $i10 \u003d $i9 + i8\n  r1.limit($i10)\n  $r7 \u003d ByteBuffer buffer\u003e\n  $r7.put(r1)\n  r0.writeBlock()\n  i11 \u003d i0 - i8\n}",
      "B5 {\n  $i12 \u003d FixedLengthBlockOutputStream: int blockSize\u003e\n  if (i11 \u003c $i12) goto B6 else B7\n}",
      "B6 {\n  $i5 \u003d r1.position()\n  $i4 \u003d FixedLengthBlockOutputStream: int blockSize\u003e\n  $i6 \u003d $i5 + $i4\n  r1.limit($i6)\n  $r5 \u003d WritableByteChannel out\u003e\n  $r5.write(r1)\n  $i7 \u003d FixedLengthBlockOutputStream: int blockSize\u003e\n  i11 \u003d i11 - $i7\n  goto B5\n}",
      "B7 {\n  r1.limit(i2)\n}",
      "B8 {\n  $r3 \u003d ByteBuffer buffer\u003e\n  $r3.put(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B5",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedLengthBlockOutputStream#isOpen(...0)",
        "body": "{\r\n    if (!out.isOpen()) {\r\n        closed.set(true);\r\n    }\r\n    return !closed.get();\r\n}"
      },
      {
        "name": "FixedLengthBlockOutputStream#writeBlock(...0)",
        "body": "{\r\n    buffer.flip();\r\n    final int i \u003d out.write(buffer);\r\n    final boolean hasRemaining \u003d buffer.hasRemaining();\r\n    if (i !\u003d blockSize || hasRemaining) {\r\n        throw new IOException(String.format(\"Failed to write %,d bytes atomically. Only wrote  %,d\", blockSize, i));\r\n    }\r\n    buffer.clear();\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.FixedLengthBlockOutputStream",
    "methodName": "write",
    "signature": "void write(int)",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    buffer.put((byte) b);\r\n    maybeFlush();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FixedLengthBlockOutputStream\n  i0 :\u003d @parameter0: int\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d ByteBuffer buffer\u003e\n  $b1 \u003d (byte) i0\n  $r1.put($b1)\n  r0.maybeFlush()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FixedLengthBlockOutputStream#isOpen(...0)",
        "body": "{\r\n    if (!out.isOpen()) {\r\n        closed.set(true);\r\n    }\r\n    return !closed.get();\r\n}"
      },
      {
        "name": "FixedLengthBlockOutputStream#maybeFlush(...0)",
        "body": "{\r\n    if (!buffer.hasRemaining()) {\r\n        writeBlock();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.IOUtils",
    "methodName": "copyRange",
    "signature": "long copyRange(java.io.InputStream,long,java.io.OutputStream,int)",
    "visibility": "public",
    "body": "{\r\n    if (bufferSize \u003c 1) {\r\n        throw new IllegalArgumentException(\"bufferSize must be bigger than 0\");\r\n    }\r\n    final byte[] buffer \u003d new byte[(int) Math.min(bufferSize, Math.max(0, length))];\r\n    return org.apache.commons.io.IOUtils.copyLarge(input, output !\u003d null ? output : NullOutputStream.INSTANCE, 0, length, buffer);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If(r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  InputStream\n  l1 :\u003d @parameter1: long\n  OutputStream\n  i0 :\u003d @parameter3: int\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"bufferSize must be bigger than 0\")\n  throw $r3\n}",
      "B2 {\n  $l3 \u003d (long) i0\n  $l2 \u003d Math.max(0L, l1)\n  $l4 \u003d Math.min($l3, $l2)\n  $i5 \u003d (int) $l4\n  r0 \u003d newarray (byte)[$i5]\n  if (r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d r2\n  goto B5\n}",
      "B4 {\n  $r4 \u003d NullOutputStream INSTANCE\u003e\n}",
      "B5 {\n  $l6 \u003d IOUtils.copyLarge(r1, $r4, 0L, l1, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.IOUtils",
    "methodName": "read",
    "signature": "int read(java.io.File,byte[])",
    "visibility": "public",
    "body": "{\r\n    try (InputStream inputStream \u003d Files.newInputStream(file.toPath())) {\r\n        return readFully(inputStream, array, 0, array.length);\r\n    }\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(r3 \u003d\u003d null) → B4 | else → B6"
    ],
    "blockList": [
      "B0 {\n  File\n  r4 :\u003d @parameter1: byte[]\n  $r2 \u003d r0.toPath()\n  $r1 \u003d OpenOption)[0]\n  r3 \u003d Files.newInputStream($r2, $r1)\n  $i0 \u003d lengthof r4\n  i1 \u003d IOUtils.readFully(r3, r4, 0, $i0)\n  if (r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3.close()\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r6 :\u003d @caughtexception\n  if (r3 \u003d\u003d null) goto B4 else B6\n}",
      "B4 {\n  r3.close()\n  goto B6\n}",
      "B5 {\n  $r5 :\u003d @caughtexception\n  $r6.addSuppressed($r5)\n}",
      "B6 {\n  throw $r6\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOUtils#readFully(...4)",
        "body": "{\r\n    if (length \u003c 0 || offset \u003c 0 || length + offset \u003e array.length || length + offset \u003c 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return org.apache.commons.io.IOUtils.read(input, array, offset, length);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.IOUtils",
    "methodName": "readFully",
    "signature": "int readFully(java.io.InputStream,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003c 0 || offset \u003c 0 || length + offset \u003e array.length || length + offset \u003c 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return org.apache.commons.io.IOUtils.read(input, array, offset, length);\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 \u003c 0) → B1 | else → B4",
      "B1 : If(i1 \u003c 0) → B2 | else → B4",
      "B2 : If($i3 \u003e $i2) → B3 | else → B4",
      "B3 : If($i4 \u003e\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  InputStream\n  r0 :\u003d @parameter1: byte[]\n  i1 :\u003d @parameter2: int\n  i0 :\u003d @parameter3: int\n  if (i0 \u003c 0) goto B1 else B4\n}",
      "B1 {\n  if (i1 \u003c 0) goto B2 else B4\n}",
      "B2 {\n  $i3 \u003d i0 + i1\n  $i2 \u003d lengthof r0\n  if ($i3 \u003e $i2) goto B3 else B4\n}",
      "B3 {\n  $i4 \u003d i0 + i1\n  if ($i4 \u003e\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r2 \u003d IndexOutOfBoundsException\n  new IndexOutOfBoundsException()\n  throw $r2\n}",
      "B5 {\n  $i5 \u003d IOUtils.read(r1, r0, i1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.IOUtils",
    "methodName": "readFully",
    "signature": "void readFully(java.nio.channels.ReadableByteChannel,java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    final int expectedLength \u003d byteBuffer.remaining();\r\n    final int read \u003d org.apache.commons.io.IOUtils.read(channel, byteBuffer);\r\n    if (read \u003c expectedLength) {\r\n        throw new EOFException();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReadableByteChannel\n  ByteBuffer\n  i0 \u003d r0.remaining()\n  i1 \u003d IOUtils.read(r1, r0)\n  if (i1 \u003e\u003d i0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d EOFException\n  new EOFException()\n  throw $r2\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.IOUtils",
    "methodName": "readRange",
    "signature": "byte[] readRange(java.nio.channels.ReadableByteChannel,int)",
    "visibility": "public",
    "body": "{\r\n    final ByteArrayOutputStream output \u003d new ByteArrayOutputStream();\r\n    final ByteBuffer byteBuffer \u003d ByteBuffer.allocate(Math.min(length, org.apache.commons.io.IOUtils.DEFAULT_BUFFER_SIZE));\r\n    int read \u003d 0;\r\n    while (read \u003c length) {\r\n        // Make sure we never read more than len bytes\r\n        byteBuffer.limit(Math.min(length - read, byteBuffer.capacity()));\r\n        final int readCount \u003d input.read(byteBuffer);\r\n        if (readCount \u003c\u003d 0) {\r\n            break;\r\n        }\r\n        output.write(byteBuffer.array(), 0, readCount);\r\n        byteBuffer.rewind();\r\n        read +\u003d readCount;\r\n    }\r\n    return output.toByteArray();\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i6 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If(i5 \u003e 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ReadableByteChannel\n  i0 :\u003d @parameter1: int\n  $r0 \u003d ByteArrayOutputStream\n  new ByteArrayOutputStream()\n  $i1 \u003d Math.min(i0, 8192)\n  r1 \u003d ByteBuffer.allocate($i1)\n  i6 \u003d 0\n}",
      "B1 {\n  if (i6 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $i3 \u003d i0 - i6\n  $i2 \u003d r1.capacity()\n  $i4 \u003d Math.min($i3, $i2)\n  r1.limit($i4)\n  i5 \u003d r3.read(r1)\n  if (i5 \u003e 0) goto B3 else B4\n}",
      "B3 {\n  goto B5\n}",
      "B4 {\n  $r4 \u003d r1.array()\n  $r0.write($r4, 0, i5)\n  r1.rewind()\n  i6 \u003d i6 + i5\n  goto B1\n}",
      "B5 {\n  $r2 \u003d $r0.toByteArray()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.Iterators",
    "methodName": "addAll",
    "signature": "boolean addAll(java.util.Collection,java.util.Iterator)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(collection);\r\n    Objects.requireNonNull(iterator);\r\n    boolean wasModified \u003d false;\r\n    while (iterator.hasNext()) {\r\n        wasModified |\u003d collection.add(iterator.next());\r\n    }\r\n    return wasModified;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Collection\n  Iterator\n  Objects.requireNonNull(r0)\n  Objects.requireNonNull(r1)\n  z2 \u003d 0\n}",
      "B1 {\n  $z0 \u003d r1.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d r1.next()\n  $z1 \u003d r0.add($r2)\n  z2 \u003d z2 | $z1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "forFiles",
    "signature": "java.nio.channels.SeekableByteChannel forFiles(java.io.File[])",
    "visibility": "public",
    "body": "{\r\n    final List\u003cPath\u003e paths \u003d new ArrayList\u003c\u003e();\r\n    for (final File f : Objects.requireNonNull(files, \"files\")) {\r\n        paths.add(f.toPath());\r\n    }\r\n    return forPaths(paths.toArray(EMPTY_PATH_ARRAY));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  File[]\n  $r0 \u003d ArrayList\n  new ArrayList()\n  $r2 \u003d Objects.requireNonNull(r1, \"files\")\n  r3 \u003d File[]) $r2\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r8 \u003d r3[i1]\n  $r9 \u003d r8.toPath()\n  $r0.add($r9)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  $r4 \u003d Path[] EMPTY_PATH_ARRAY\u003e\n  $r5 \u003d $r0.toArray($r4)\n  $r6 \u003d Path[]) $r5\n  $r7 \u003d MultiReadOnlySeekableByteChannel.forPaths($r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MultiReadOnlySeekableByteChannel#forPaths(...1)",
        "body": "{\r\n    final List\u003cSeekableByteChannel\u003e channels \u003d new ArrayList\u003c\u003e();\r\n    for (final Path path : Objects.requireNonNull(paths, \"paths\")) {\r\n        channels.add(Files.newByteChannel(path, StandardOpenOption.READ));\r\n    }\r\n    if (channels.size() \u003d\u003d 1) {\r\n        return channels.get(0);\r\n    }\r\n    return new MultiReadOnlySeekableByteChannel(channels);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "forPaths",
    "signature": "java.nio.channels.SeekableByteChannel forPaths(java.nio.file.Path[])",
    "visibility": "public",
    "body": "{\r\n    final List\u003cSeekableByteChannel\u003e channels \u003d new ArrayList\u003c\u003e();\r\n    for (final Path path : Objects.requireNonNull(paths, \"paths\")) {\r\n        channels.add(Files.newByteChannel(path, StandardOpenOption.READ));\r\n    }\r\n    if (channels.size() \u003d\u003d 1) {\r\n        return channels.get(0);\r\n    }\r\n    return new MultiReadOnlySeekableByteChannel(channels);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i2 \u003e\u003d i0) → B2 | else → B3",
      "B3 : If($i1 !\u003d 1) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Path[]\n  $r0 \u003d ArrayList\n  new ArrayList()\n  $r2 \u003d Objects.requireNonNull(r1, \"paths\")\n  r3 \u003d Path[]) $r2\n  i0 \u003d lengthof r3\n  i2 \u003d 0\n}",
      "B1 {\n  if (i2 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r7 \u003d r3[i2]\n  $r8 \u003d OpenOption)[1]\n  $r9 \u003d StandardOpenOption READ\u003e\n  $r8[0] \u003d $r9\n  $r10 \u003d Files.newByteChannel(r7, $r8)\n  $r0.add($r10)\n  i2 \u003d i2 + 1\n  goto B1\n}",
      "B3 {\n  $i1 \u003d $r0.size()\n  if ($i1 !\u003d 1) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d $r0.get(0)\n  $r6 \u003d SeekableByteChannel) $r5\n  return\n}",
      "B5 {\n  $r4 \u003d MultiReadOnlySeekableByteChannel\n  new MultiReadOnlySeekableByteChannel($r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "forSeekableByteChannels",
    "signature": "java.nio.channels.SeekableByteChannel forSeekableByteChannels(java.nio.channels.SeekableByteChannel[])",
    "visibility": "public",
    "body": "{\r\n    if (Objects.requireNonNull(channels, \"channels\").length \u003d\u003d 1) {\r\n        return channels[0];\r\n    }\r\n    return new MultiReadOnlySeekableByteChannel(Arrays.asList(channels));\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 !\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SeekableByteChannel[]\n  $r1 \u003d Objects.requireNonNull(r0, \"channels\")\n  $r2 \u003d SeekableByteChannel[]) $r1\n  $i0 \u003d lengthof $r2\n  if ($i0 !\u003d 1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0[0]\n  return\n}",
      "B2 {\n  $r3 \u003d MultiReadOnlySeekableByteChannel\n  $r4 \u003d Arrays.asList(r0)\n  new MultiReadOnlySeekableByteChannel($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    IOException first \u003d null;\r\n    for (final SeekableByteChannel ch : channelList) {\r\n        try {\r\n            ch.close();\r\n        } catch (final IOException ex) {\r\n            if (first \u003d\u003d null) {\r\n                first \u003d ex;\r\n            }\r\n        }\r\n    }\r\n    if (first !\u003d null) {\r\n        throw new IOException(\"failed to close wrapped channel\", first);\r\n    }\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B6",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B6 : If(r7 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  MultiReadOnlySeekableByteChannel\n  r7 \u003d null\n  $r1 \u003d List channelList\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B1 {\n  $z0 \u003d r2.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B6\n}",
      "B2 {\n  $r4 \u003d r2.next()\n  r5 \u003d SeekableByteChannel) $r4\n  r5.close()\n  goto B5\n}",
      "B3 {\n  $r6 :\u003d @caughtexception\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  r7 \u003d $r6\n}",
      "B5 {\n  goto B1\n}",
      "B6 {\n  if (r7 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r3 \u003d IOException\n  new IOException(\"failed to close wrapped channel\", r7)\n  throw $r3\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B1",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "position",
    "signature": "java.nio.channels.SeekableByteChannel position(long)",
    "visibility": "public",
    "body": "{\r\n    if (newPosition \u003c 0) {\r\n        throw new IllegalArgumentException(\"Negative position: \" + newPosition);\r\n    }\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    globalPosition \u003d newPosition;\r\n    long pos \u003d newPosition;\r\n    for (int i \u003d 0; i \u003c channelList.size(); i++) {\r\n        final SeekableByteChannel currentChannel \u003d channelList.get(i);\r\n        final long size \u003d currentChannel.size();\r\n        final long newChannelPos;\r\n        if (pos \u003d\u003d -1L) {\r\n            // Position is already set for the correct channel,\r\n            // the rest of the channels get reset to 0\r\n            newChannelPos \u003d 0;\r\n        } else if (pos \u003c\u003d size) {\r\n            // This channel is where we want to be\r\n            currentChannelIdx \u003d i;\r\n            final long tmp \u003d pos;\r\n            // Mark pos as already being set\r\n            pos \u003d -1L;\r\n            newChannelPos \u003d tmp;\r\n        } else {\r\n            // newPosition is past this channel. Set channel\r\n            // position to the end and substract channel size from\r\n            // pos\r\n            pos -\u003d size;\r\n            newChannelPos \u003d size;\r\n        }\r\n        currentChannel.position(newChannelPos);\r\n    }\r\n    return this;\r\n}",
    "nodes": 13,
    "edges": 15,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i10 \u003e\u003d 0) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B5 : If(i8 \u003e\u003d $i2) → B6 | else → B12",
      "B6 : If($b4 !\u003d 0) → B7 | else → B8",
      "B8 : If($i11 \u003e 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  MultiReadOnlySeekableByteChannel\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i10 \u003d (int) $b1\n  if ($i10 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d IllegalArgumentException\n  $r11 \u003d StringBuilder\n  new StringBuilder()\n  $r8 \u003d $r11.append(\"Negative position: \")\n  $r9 \u003d $r8.append(l0)\n  $r10 \u003d $r9.toString()\n  new IllegalArgumentException($r10)\n  throw $r12\n}",
      "B2 {\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r13 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r13\n}",
      "B4 {\n  MultiReadOnlySeekableByteChannel: long globalPosition\u003e \u003d l0\n  l7 \u003d l0\n  i8 \u003d 0\n}",
      "B5 {\n  $r1 \u003d List channelList\u003e\n  $i2 \u003d $r1.size()\n  if (i8 \u003e\u003d $i2) goto B6 else B12\n}",
      "B6 {\n  $r2 \u003d List channelList\u003e\n  $r3 \u003d $r2.get(i8)\n  r4 \u003d SeekableByteChannel) $r3\n  l3 \u003d r4.size()\n  $b4 \u003d l7 cmp -1L\n  if ($b4 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  l9 \u003d 0L\n  goto B11\n}",
      "B8 {\n  $b5 \u003d l7 cmp l3\n  $i11 \u003d (int) $b5\n  if ($i11 \u003e 0) goto B9 else B10\n}",
      "B9 {\n  MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e \u003d i8\n  l6 \u003d l7\n  l7 \u003d -1L\n  l9 \u003d l6\n  goto B11\n}",
      "B10 {\n  l7 \u003d l7 - l3\n  l9 \u003d l3\n}",
      "B11 {\n  r4.position(l9)\n  i8 \u003d i8 + 1\n  goto B5\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B12",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B5",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MultiReadOnlySeekableByteChannel#isOpen(...0)",
        "body": "{\r\n    return channelList.stream().allMatch(SeekableByteChannel::isOpen);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "position",
    "signature": "java.nio.channels.SeekableByteChannel position(long,long)",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    long globalPosition \u003d relativeOffset;\r\n    for (int i \u003d 0; i \u003c channelNumber; i++) {\r\n        globalPosition +\u003d channelList.get(i).size();\r\n    }\r\n    return position(globalPosition);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B3 : If($i7 \u003e\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MultiReadOnlySeekableByteChannel\n  l1 :\u003d @parameter0: long\n  l0 :\u003d @parameter1: long\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r6\n}",
      "B2 {\n  l5 \u003d l0\n  i6 \u003d 0\n}",
      "B3 {\n  $l2 \u003d (long) i6\n  $b3 \u003d $l2 cmp l1\n  $i7 \u003d (int) $b3\n  if ($i7 \u003e\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r2 \u003d List channelList\u003e\n  $r3 \u003d $r2.get(i6)\n  $r4 \u003d SeekableByteChannel) $r3\n  $l4 \u003d $r4.size()\n  l5 \u003d l5 + $l4\n  i6 \u003d i6 + 1\n  goto B3\n}",
      "B5 {\n  $r1 \u003d r0.position(l5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MultiReadOnlySeekableByteChannel#isOpen(...0)",
        "body": "{\r\n    return channelList.stream().allMatch(SeekableByteChannel::isOpen);\r\n}"
      },
      {
        "name": "MultiReadOnlySeekableByteChannel#position(...1)",
        "body": "{\r\n    if (newPosition \u003c 0) {\r\n        throw new IllegalArgumentException(\"Negative position: \" + newPosition);\r\n    }\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    globalPosition \u003d newPosition;\r\n    long pos \u003d newPosition;\r\n    for (int i \u003d 0; i \u003c channelList.size(); i++) {\r\n        final SeekableByteChannel currentChannel \u003d channelList.get(i);\r\n        final long size \u003d currentChannel.size();\r\n        final long newChannelPos;\r\n        if (pos \u003d\u003d -1L) {\r\n            // Position is already set for the correct channel,\r\n            // the rest of the channels get reset to 0\r\n            newChannelPos \u003d 0;\r\n        } else if (pos \u003c\u003d size) {\r\n            // This channel is where we want to be\r\n            currentChannelIdx \u003d i;\r\n            final long tmp \u003d pos;\r\n            // Mark pos as already being set\r\n            pos \u003d -1L;\r\n            newChannelPos \u003d tmp;\r\n        } else {\r\n            // newPosition is past this channel. Set channel\r\n            // position to the end and substract channel size from\r\n            // pos\r\n            pos -\u003d size;\r\n            newChannelPos \u003d size;\r\n        }\r\n        currentChannel.position(newChannelPos);\r\n    }\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "read",
    "signature": "int read(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    if (!dst.hasRemaining()) {\r\n        return 0;\r\n    }\r\n    int totalBytesRead \u003d 0;\r\n    while (dst.hasRemaining() \u0026\u0026 currentChannelIdx \u003c channelList.size()) {\r\n        final SeekableByteChannel currentChannel \u003d channelList.get(currentChannelIdx);\r\n        final int newBytesRead \u003d currentChannel.read(dst);\r\n        if (newBytesRead \u003d\u003d -1) {\r\n            // EOF for this channel -- advance to next channel idx\r\n            currentChannelIdx +\u003d 1;\r\n            continue;\r\n        }\r\n        if (currentChannel.position() \u003e\u003d currentChannel.size()) {\r\n            // we are at the end of the current channel\r\n            currentChannelIdx++;\r\n        }\r\n        totalBytesRead +\u003d newBytesRead;\r\n    }\r\n    if (totalBytesRead \u003e 0) {\r\n        globalPosition +\u003d totalBytesRead;\r\n        return totalBytesRead;\r\n    }\r\n    return -1;\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z1 !\u003d 0) → B3 | else → B4",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B12",
      "B6 : If($i3 \u003e\u003d $i4) → B7 | else → B12",
      "B7 : If(i6 !\u003d $i16) → B8 | else → B9",
      "B9 : If($i17 \u003c 0) → B10 | else → B11",
      "B12 : If(i14 \u003c\u003d 0) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  MultiReadOnlySeekableByteChannel\n  ByteBuffer\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r7\n}",
      "B2 {\n  $z1 \u003d r1.hasRemaining()\n  if ($z1 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i14 \u003d 0\n}",
      "B5 {\n  $z2 \u003d r1.hasRemaining()\n  if ($z2 \u003d\u003d false) goto B6 else B12\n}",
      "B6 {\n  $i3 \u003d MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e\n  $r2 \u003d List channelList\u003e\n  $i4 \u003d $r2.size()\n  if ($i3 \u003e\u003d $i4) goto B7 else B12\n}",
      "B7 {\n  $r3 \u003d List channelList\u003e\n  $i5 \u003d MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e\n  $r4 \u003d $r3.get($i5)\n  r5 \u003d SeekableByteChannel) $r4\n  i6 \u003d r5.read(r1)\n  $i16 \u003d (int) -1\n  if (i6 !\u003d $i16) goto B8 else B9\n}",
      "B8 {\n  $i12 \u003d MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e\n  $i13 \u003d $i12 + 1\n  MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e \u003d $i13\n  goto B5\n}",
      "B9 {\n  $l8 \u003d r5.position()\n  $l7 \u003d r5.size()\n  $b9 \u003d $l8 cmp $l7\n  $i17 \u003d (int) $b9\n  if ($i17 \u003c 0) goto B10 else B11\n}",
      "B10 {\n  $i10 \u003d MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e\n  $i11 \u003d $i10 + 1\n  MultiReadOnlySeekableByteChannel: int currentChannelIdx\u003e \u003d $i11\n}",
      "B11 {\n  i14 \u003d i14 + i6\n  goto B5\n}",
      "B12 {\n  if (i14 \u003c\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $l1 \u003d MultiReadOnlySeekableByteChannel: long globalPosition\u003e\n  $l0 \u003d (long) i14\n  $l2 \u003d $l1 + $l0\n  MultiReadOnlySeekableByteChannel: long globalPosition\u003e \u003d $l2\n  return\n}",
      "B14 {\n  $i19 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B12",
      "B6 --\u003e B7",
      "B6 --\u003e B12",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B5",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B5",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MultiReadOnlySeekableByteChannel#isOpen(...0)",
        "body": "{\r\n    return channelList.stream().allMatch(SeekableByteChannel::isOpen);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel",
    "methodName": "size",
    "signature": "long size()",
    "visibility": "public",
    "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n    long acc \u003d 0;\r\n    for (final SeekableByteChannel ch : channelList) {\r\n        acc +\u003d ch.size();\r\n    }\r\n    return acc;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MultiReadOnlySeekableByteChannel\n  $z0 \u003d r0.isOpen()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d ClosedChannelException\n  new ClosedChannelException()\n  throw $r5\n}",
      "B2 {\n  l1 \u003d 0L\n  $r1 \u003d List channelList\u003e\n  r2 \u003d $r1.iterator()\n}",
      "B3 {\n  $z1 \u003d r2.hasNext()\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d r2.next()\n  r4 \u003d SeekableByteChannel) $r3\n  $l0 \u003d r4.size()\n  l1 \u003d l1 + $l0\n  goto B3\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MultiReadOnlySeekableByteChannel#isOpen(...0)",
        "body": "{\r\n    return channelList.stream().allMatch(SeekableByteChannel::isOpen);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.SeekableInMemoryByteChannel",
    "methodName": "isOpen",
    "signature": "boolean isOpen()",
    "visibility": "public",
    "body": "{\r\n    return !closed.get();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SeekableInMemoryByteChannel\n  $r1 \u003d AtomicBoolean closed\u003e\n  $z0 \u003d $r1.get()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.SeekableInMemoryByteChannel",
    "methodName": "position",
    "signature": "java.nio.channels.SeekableByteChannel position(long)",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    if (newPosition \u003c 0L || newPosition \u003e Integer.MAX_VALUE) {\r\n        throw new IOException(\"Position must be in range [0..\" + Integer.MAX_VALUE + \"]\");\r\n    }\r\n    position \u003d (int) newPosition;\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 \u003c 0) → B1 | else → B2",
      "B1 : If($i5 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  SeekableInMemoryByteChannel\n  l0 :\u003d @parameter0: long\n  r0.ensureOpen()\n  $b1 \u003d l0 cmp 0L\n  $i4 \u003d (int) $b1\n  if ($i4 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $b2 \u003d l0 cmp 2147483647L\n  $i5 \u003d (int) $b2\n  if ($i5 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d IOException\n  new IOException(\"Position must be in range 0..2147483647\")\n  throw $r2\n}",
      "B3 {\n  $i3 \u003d (int) l0\n  SeekableInMemoryByteChannel: int position\u003e \u003d $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SeekableInMemoryByteChannel#ensureOpen(...0)",
        "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.SeekableInMemoryByteChannel",
    "methodName": "read",
    "signature": "int read(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    int wanted \u003d buf.remaining();\r\n    final int possible \u003d size - position;\r\n    if (possible \u003c\u003d 0) {\r\n        return -1;\r\n    }\r\n    if (wanted \u003e possible) {\r\n        wanted \u003d possible;\r\n    }\r\n    buf.put(data, position, wanted);\r\n    position +\u003d wanted;\r\n    return wanted;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 \u003e 0) → B1 | else → B2",
      "B2 : If(i6 \u003c\u003d i2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SeekableInMemoryByteChannel\n  ByteBuffer\n  r0.ensureOpen()\n  i6 \u003d r1.remaining()\n  $i1 \u003d SeekableInMemoryByteChannel: int size\u003e\n  $i0 \u003d SeekableInMemoryByteChannel: int position\u003e\n  i2 \u003d $i1 - $i0\n  if (i2 \u003e 0) goto B1 else B2\n}",
      "B1 {\n  $i8 \u003d (int) -1\n  return\n}",
      "B2 {\n  if (i6 \u003c\u003d i2) goto B3 else B4\n}",
      "B3 {\n  i6 \u003d i2\n}",
      "B4 {\n  $r2 \u003d SeekableInMemoryByteChannel: byte[] data\u003e\n  $i3 \u003d SeekableInMemoryByteChannel: int position\u003e\n  r1.put($r2, $i3, i6)\n  $i4 \u003d SeekableInMemoryByteChannel: int position\u003e\n  $i5 \u003d $i4 + i6\n  SeekableInMemoryByteChannel: int position\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SeekableInMemoryByteChannel#ensureOpen(...0)",
        "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.SeekableInMemoryByteChannel",
    "methodName": "truncate",
    "signature": "java.nio.channels.SeekableByteChannel truncate(long)",
    "visibility": "public",
    "body": "{\r\n    if (newSize \u003c 0L || newSize \u003e Integer.MAX_VALUE) {\r\n        throw new IllegalArgumentException(\"Size must be range [0..\" + Integer.MAX_VALUE + \"]\");\r\n    }\r\n    if (size \u003e newSize) {\r\n        size \u003d (int) newSize;\r\n    }\r\n    if (position \u003e newSize) {\r\n        position \u003d (int) newSize;\r\n    }\r\n    return this;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i11 \u003c 0) → B1 | else → B2",
      "B1 : If($i12 \u003c\u003d 0) → B2 | else → B3",
      "B3 : If($i13 \u003c\u003d 0) → B4 | else → B5",
      "B5 : If($i14 \u003c\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  SeekableInMemoryByteChannel\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i11 \u003d (int) $b1\n  if ($i11 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $b2 \u003d l0 cmp 2147483647L\n  $i12 \u003d (int) $b2\n  if ($i12 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Size must be range 0..2147483647\")\n  throw $r2\n}",
      "B3 {\n  $i3 \u003d SeekableInMemoryByteChannel: int size\u003e\n  $l4 \u003d (long) $i3\n  $b5 \u003d $l4 cmp l0\n  $i13 \u003d (int) $b5\n  if ($i13 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i10 \u003d (int) l0\n  SeekableInMemoryByteChannel: int size\u003e \u003d $i10\n}",
      "B5 {\n  $i6 \u003d SeekableInMemoryByteChannel: int position\u003e\n  $l7 \u003d (long) $i6\n  $b8 \u003d $l7 cmp l0\n  $i14 \u003d (int) $b8\n  if ($i14 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $i9 \u003d (int) l0\n  SeekableInMemoryByteChannel: int position\u003e \u003d $i9\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.SeekableInMemoryByteChannel",
    "methodName": "write",
    "signature": "int write(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    ensureOpen();\r\n    int wanted \u003d b.remaining();\r\n    final int possibleWithoutResize \u003d size - position;\r\n    if (wanted \u003e possibleWithoutResize) {\r\n        final int newSize \u003d position + wanted;\r\n        if (newSize \u003c 0) {\r\n            // overflow\r\n            resize(Integer.MAX_VALUE);\r\n            wanted \u003d Integer.MAX_VALUE - position;\r\n        } else {\r\n            resize(newSize);\r\n        }\r\n    }\r\n    b.get(data, position, wanted);\r\n    position +\u003d wanted;\r\n    if (size \u003c position) {\r\n        size \u003d position;\r\n    }\r\n    return wanted;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i7 \u003c\u003d i2) → B1 | else → B4",
      "B1 : If(i5 \u003e\u003d 0) → B2 | else → B3",
      "B4 : If($i11 \u003e\u003d $i12) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  SeekableInMemoryByteChannel\n  ByteBuffer\n  r0.ensureOpen()\n  i7 \u003d r1.remaining()\n  $i1 \u003d SeekableInMemoryByteChannel: int size\u003e\n  $i0 \u003d SeekableInMemoryByteChannel: int position\u003e\n  i2 \u003d $i1 - $i0\n  if (i7 \u003c\u003d i2) goto B1 else B4\n}",
      "B1 {\n  $i4 \u003d SeekableInMemoryByteChannel: int position\u003e\n  i5 \u003d $i4 + i7\n  if (i5 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  r0.resize(2147483647)\n  $i6 \u003d SeekableInMemoryByteChannel: int position\u003e\n  i7 \u003d 2147483647 - $i6\n  goto B4\n}",
      "B3 {\n  r0.resize(i5)\n}",
      "B4 {\n  $r2 \u003d SeekableInMemoryByteChannel: byte[] data\u003e\n  $i8 \u003d SeekableInMemoryByteChannel: int position\u003e\n  r1.get($r2, $i8, i7)\n  $i9 \u003d SeekableInMemoryByteChannel: int position\u003e\n  $i10 \u003d $i9 + i7\n  SeekableInMemoryByteChannel: int position\u003e \u003d $i10\n  $i11 \u003d SeekableInMemoryByteChannel: int size\u003e\n  $i12 \u003d SeekableInMemoryByteChannel: int position\u003e\n  if ($i11 \u003e\u003d $i12) goto B5 else B6\n}",
      "B5 {\n  $i3 \u003d SeekableInMemoryByteChannel: int position\u003e\n  SeekableInMemoryByteChannel: int size\u003e \u003d $i3\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SeekableInMemoryByteChannel#ensureOpen(...0)",
        "body": "{\r\n    if (!isOpen()) {\r\n        throw new ClosedChannelException();\r\n    }\r\n}"
      },
      {
        "name": "SeekableInMemoryByteChannel#resize(...1)",
        "body": "{\r\n    int len \u003d data.length;\r\n    if (len \u003c\u003d 0) {\r\n        len \u003d 1;\r\n    }\r\n    if (newLength \u003c NAIVE_RESIZE_LIMIT) {\r\n        while (len \u003c newLength) {\r\n            len \u003c\u003c\u003d 1;\r\n        }\r\n    } else {\r\n        // avoid overflow\r\n        len \u003d newLength;\r\n    }\r\n    data \u003d Arrays.copyOf(data, len);\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.ServiceLoaderIterator",
    "methodName": "hasNext",
    "signature": "boolean hasNext()",
    "visibility": "public",
    "body": "{\r\n    while (nextServiceLoader \u003d\u003d null) {\r\n        try {\r\n            if (!serviceLoaderIterator.hasNext()) {\r\n                return false;\r\n            }\r\n            nextServiceLoader \u003d serviceLoaderIterator.next();\r\n        } catch (final ServiceConfigurationError e) {\r\n            if (e.getCause() instanceof SecurityException) {\r\n                // Ignore security exceptions\r\n                // TODO Log?\r\n                continue;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 9,
    "edges": 9,
    "cc": 2,
    "flowSummary": [
      "B1 : If($r6 !\u003d null) → B2 | else → B8",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ServiceLoaderIterator\n}",
      "B1 {\n  $r6 \u003d Object nextServiceLoader\u003e\n  if ($r6 !\u003d null) goto B2 else B8\n}",
      "B2 {\n  $r1 \u003d Iterator serviceLoaderIterator\u003e\n  $z0 \u003d $r1.hasNext()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d Iterator serviceLoaderIterator\u003e\n  $r3 \u003d $r2.next()\n  Object nextServiceLoader\u003e \u003d $r3\n  goto B1\n}",
      "B5 {\n  $r4 :\u003d @caughtexception\n  $r5 \u003d $r4.getCause()\n  $z1 \u003d SecurityException\n  if ($z1 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  goto B1\n}",
      "B7 {\n  throw $r4\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B1",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.ServiceLoaderIterator",
    "methodName": "next",
    "signature": "java.lang.Object next()",
    "visibility": "public",
    "body": "{\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException(\"No more elements for service \" + service.getName());\r\n    }\r\n    final E tempNext \u003d nextServiceLoader;\r\n    nextServiceLoader \u003d null;\r\n    return tempNext;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ServiceLoaderIterator\n  $z0 \u003d r0.hasNext()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NoSuchElementException\n  $r3 \u003d StringBuilder\n  new StringBuilder()\n  $r6 \u003d $r3.append(\"No more elements for service \")\n  $r4 \u003d Class service\u003e\n  $r5 \u003d $r4.getName()\n  $r7 \u003d $r6.append($r5)\n  $r8 \u003d $r7.toString()\n  new NoSuchElementException($r8)\n  throw $r2\n}",
      "B2 {\n  r1 \u003d Object nextServiceLoader\u003e\n  Object nextServiceLoader\u003e \u003d null\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ServiceLoaderIterator#hasNext(...0)",
        "body": "{\r\n    while (nextServiceLoader \u003d\u003d null) {\r\n        try {\r\n            if (!serviceLoaderIterator.hasNext()) {\r\n                return false;\r\n            }\r\n            nextServiceLoader \u003d serviceLoaderIterator.next();\r\n        } catch (final ServiceConfigurationError e) {\r\n            if (e.getCause() instanceof SecurityException) {\r\n                // Ignore security exceptions\r\n                // TODO Log?\r\n                continue;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "org.apache.commons.compress.utils.Sets",
    "methodName": "newHashSet",
    "signature": "java.util.HashSet newHashSet(java.lang.Object[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2",
      "B3 : If(r1 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Object[]\n  $r0 \u003d HashSet\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d lengthof r1\n  goto B3\n}",
      "B2 {\n  $i0 \u003d 0\n}",
      "B3 {\n  new HashSet($i0)\n  if (r1 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  Collections.addAll($r0, r1)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "org.apache.commons.compress.utils.SkipShieldingInputStream",
    "methodName": "skip",
    "signature": "long skip(long)",
    "visibility": "public",
    "body": "{\r\n    return n \u003c 0 ? 0 : read(SKIP_BUFFER, 0, (int) Math.min(n, SKIP_BUFFER_SIZE));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i6 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SkipShieldingInputStream\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 0L\n  $i6 \u003d (int) $b1\n  if ($i6 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $l5 \u003d 0L\n  goto B3\n}",
      "B2 {\n  $r1 \u003d SkipShieldingInputStream: byte[] SKIP_BUFFER\u003e\n  $l2 \u003d Math.min(l0, 8192L)\n  $i3 \u003d (int) $l2\n  $i4 \u003d r0.read($r1, 0, $i3)\n  $l5 \u003d (long) $i4\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SkipShieldingInputStream#read(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "SootCFGAnalysis",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 38,
    "edges": 49,
    "cc": 13,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B31",
      "B3 : If($z7 \u003d\u003d false) → B4 | else → B30",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B14",
      "B11 : If(i8 \u003c\u003d 0) → B12 | else → B13",
      "B14 : If(i6 \u003e i7) → B15 | else → B16",
      "B17 : If($z4 \u003d\u003d false) → B18 | else → B19",
      "B18 : If($z5 !\u003d 0) → B19 | else → B20",
      "B20 : If(i0 \u003d\u003d false) → B21 | else → B22",
      "B21 : If(i4 !\u003d 0) → B22 | else → B23",
      "B23 : If(i5 \u003e 0) → B24 | else → B25",
      "B25 : If($z6 !\u003d 0) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r2 \u003d Options.v()\n  $r1 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\commons-compress-master\\\\target\\\\classes\")\n  $r2.set_process_dir($r1)\n  $r3 \u003d Options.v()\n  $r3.set_whole_program(1)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r5 \u003d Options.v()\n  $r5.set_no_bodies_for_excluded(1)\n  $r6 \u003d Options.v()\n  $r6.set_allow_phantom_refs(1)\n  $r7 \u003d Options.v()\n  $r7.set_keep_line_number(1)\n  $r8 \u003d Options.v()\n  $r8.setPhaseOption(\"jb\", \"use-original-names:true\")\n  $r9 \u003d Scene.v()\n  $r9.loadNecessaryClasses()\n  $r10 \u003d HashSet\n  new HashSet()\n  $r11 \u003d CSVWriter\n  $r12 \u003d FileWriter\n  new FileWriter(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_com.csv\")\n  new CSVWriter($r12)\n  $r13 \u003d String)[9]\n  $r13[0] \u003d \"Class\"\n  $r13[1] \u003d \"Method\"\n  $r13[2] \u003d \"MethodSig\"\n  $r13[3] \u003d \"Nodes\"\n  $r13[4] \u003d \"Edges\"\n  $r13[5] \u003d \"McCabe_CC\"\n  $r13[6] \u003d \"StartLine\"\n  $r13[7] \u003d \"EndLine\"\n  $r13[8] \u003d \"LineCount\"\n  $r11.writeNext($r13)\n  $r14 \u003d ArrayList\n  $r15 \u003d Scene.v()\n  $r16 \u003d $r15.getApplicationClasses()\n  new ArrayList($r16)\n  r59 \u003d $r14.iterator()\n}",
      "B1 {\n  $z0 \u003d r59.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B31\n}",
      "B2 {\n  $r23 \u003d r59.next()\n  r24 \u003d SootClass) $r23\n  $r25 \u003d r24.getMethods()\n  r26 \u003d $r25.iterator()\n}",
      "B3 {\n  $z7 \u003d r26.hasNext()\n  if ($z7 \u003d\u003d false) goto B4 else B30\n}",
      "B4 {\n  $r27 \u003d r26.next()\n  r28 \u003d SootMethod) $r27\n  $z1 \u003d r28.isConcrete()\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r60 \u003d r28.retrieveActiveBody()\n  $r29 \u003d BriefBlockGraph\n  new BriefBlockGraph(r60)\n  i0 \u003d $r29.size()\n  i4 \u003d 0\n  r61 \u003d $r29.iterator()\n}",
      "B7 {\n  $z2 \u003d r61.hasNext()\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r41 \u003d r61.next()\n  r62 \u003d Block) $r41\n  $r42 \u003d $r29.getSuccsOf(r62)\n  $i3 \u003d $r42.size()\n  i4 \u003d i4 + $i3\n  goto B7\n}",
      "B9 {\n  $i1 \u003d i4 - i0\n  i5 \u003d $i1 + 2\n  i6 \u003d 2147483647\n  i7 \u003d -2147483648\n  $r30 \u003d r60.getUnits()\n  r63 \u003d $r30.iterator()\n}",
      "B10 {\n  $z3 \u003d r63.hasNext()\n  if ($z3 \u003d\u003d false) goto B11 else B14\n}",
      "B11 {\n  $r40 \u003d r63.next()\n  r64 \u003d Unit) $r40\n  i8 \u003d r64.getJavaSourceStartLineNumber()\n  if (i8 \u003c\u003d 0) goto B12 else B13\n}",
      "B12 {\n  i6 \u003d Math.min(i6, i8)\n  i7 \u003d Math.max(i7, i8)\n}",
      "B13 {\n  goto B10\n}",
      "B14 {\n  if (i6 \u003e i7) goto B15 else B16\n}",
      "B15 {\n  $i2 \u003d i7 - i6\n  $i9 \u003d $i2 + 1\n  goto B17\n}",
      "B16 {\n  $i9 \u003d 0\n}",
      "B17 {\n  $z4 \u003d SootCFGAnalysis.isTopLevelPublic(r24)\n  if ($z4 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $z5 \u003d SootCFGAnalysis.isRealMethod(r28)\n  if ($z5 !\u003d 0) goto B19 else B20\n}",
      "B19 {\n  goto B3\n}",
      "B20 {\n  if (i0 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  if (i4 !\u003d 0) goto B22 else B23\n}",
      "B22 {\n  goto B3\n}",
      "B23 {\n  if (i5 \u003e 0) goto B24 else B25\n}",
      "B24 {\n  goto B3\n}",
      "B25 {\n  r28.getSubSignature()\n  r65 \u003d r28.getSignature()\n  $z6 \u003d $r10.add(r65)\n  if ($z6 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B3\n}",
      "B27 {\n  $r31 \u003d String)[9]\n  $r32 \u003d r24.getName()\n  $r31[0] \u003d $r32\n  $r33 \u003d r28.getName()\n  $r31[1] \u003d $r33\n  $r31[2] \u003d r65\n  $r34 \u003d String.valueOf(i0)\n  $r31[3] \u003d $r34\n  $r35 \u003d String.valueOf(i4)\n  $r31[4] \u003d $r35\n  $r36 \u003d String.valueOf(i5)\n  $r31[5] \u003d $r36\n  $r37 \u003d String.valueOf(i6)\n  $r31[6] \u003d $r37\n  $r38 \u003d String.valueOf(i7)\n  $r31[7] \u003d $r38\n  $r39 \u003d String.valueOf($i9)\n  $r31[8] \u003d $r39\n  $r11.writeNext($r31)\n  goto B29\n}",
      "B28 {\n  $r52 :\u003d @caughtexception\n  $r54 \u003d PrintStream out\u003e\n  $r53 \u003d Object)[3]\n  $r55 \u003d r24.getName()\n  $r53[0] \u003d $r55\n  $r56 \u003d r28.getName()\n  $r53[1] \u003d $r56\n  $r57 \u003d $r52.getMessage()\n  $r53[2] \u003d $r57\n  $r54.printf(\"\\u26a0\\ufe0f \\uc624\\ub958 %s.%s: %s\\n\", $r53)\n}",
      "B29 {\n  goto B3\n}",
      "B30 {\n  goto B1\n}",
      "B31 {\n  $r18 \u003d PrintStream out\u003e\n  $r17 \u003d StringBuilder\n  new StringBuilder()\n  $r19 \u003d $r17.append(\"\\u2705 \\ubd84\\uc11d \\uc644\\ub8cc: \")\n  $r20 \u003d $r19.append(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_com.csv\")\n  $r21 \u003d $r20.append(\"\\uc5d0 \\uc800\\uc7a5\\ub428\")\n  $r22 \u003d $r21.toString()\n  $r18.println($r22)\n  $r11.close()\n  goto B35\n}",
      "B32 {\n  $r51 :\u003d @caughtexception\n  $r11.close()\n  goto B34\n}",
      "B33 {\n  $r50 :\u003d @caughtexception\n  $r51.addSuppressed($r50)\n}",
      "B34 {\n  throw $r51\n}",
      "B35 {\n  goto B37\n}",
      "B36 {\n  $r43 :\u003d @caughtexception\n  $r45 \u003d PrintStream err\u003e\n  $r44 \u003d StringBuilder\n  new StringBuilder()\n  $r47 \u003d $r44.append(\"\\u274c CSV \\uc800\\uc7a5 \\uc911 \\uc624\\ub958: \")\n  $r46 \u003d $r43.getMessage()\n  $r48 \u003d $r47.append($r46)\n  $r49 \u003d $r48.toString()\n  $r45.println($r49)\n}",
      "B37 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B31",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B30",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B10",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B3",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B3",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B3",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B3",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B3",
      "B30 --\u003e B1",
      "B31 --\u003e B35",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e B37",
      "B36 --\u003e B37",
      "B37 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  }
]