[
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "withReadPadding",
    "signature": "com.fasterxml.jackson.core.Base64Variant withReadPadding(com.fasterxml.jackson.core.Base64Variant$PaddingReadBehaviour)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  Base64Variant$PaddingReadBehaviour\n  $r2 \u003d Base64Variant$PaddingReadBehaviour _paddingReadBehaviour\u003e\n  if (r0 !\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r3 \u003d Base64Variant\n  new Base64Variant(r1, r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "withWritePadding",
    "signature": "com.fasterxml.jackson.core.Base64Variant withWritePadding(boolean)",
    "visibility": "public",
    "body": "{\r\n    return (writePadding \u003d\u003d _writePadding) ? this : new Base64Variant(this, _name, writePadding, _paddingChar, _maxLineLength);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 !\u003d $z1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  z0 :\u003d @parameter0: boolean\n  $z1 \u003d Base64Variant: boolean _writePadding\u003e\n  if (z0 !\u003d $z1) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d Base64Variant\n  $r1 \u003d String _name\u003e\n  $c1 \u003d Base64Variant: char _paddingChar\u003e\n  $i0 \u003d Base64Variant: int _maxLineLength\u003e\n  new Base64Variant(r0, $r1, z0, $c1, $i0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "requiresPaddingOnRead",
    "signature": "boolean requiresPaddingOnRead()",
    "visibility": "public",
    "body": "{\r\n    return _paddingReadBehaviour \u003d\u003d PaddingReadBehaviour.PADDING_REQUIRED;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  $r2 \u003d Base64Variant$PaddingReadBehaviour _paddingReadBehaviour\u003e\n  $r1 \u003d Base64Variant$PaddingReadBehaviour PADDING_REQUIRED\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "acceptsPaddingOnRead",
    "signature": "boolean acceptsPaddingOnRead()",
    "visibility": "public",
    "body": "{\r\n    return _paddingReadBehaviour !\u003d PaddingReadBehaviour.PADDING_FORBIDDEN;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  $r2 \u003d Base64Variant$PaddingReadBehaviour _paddingReadBehaviour\u003e\n  $r1 \u003d Base64Variant$PaddingReadBehaviour PADDING_FORBIDDEN\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "usesPaddingChar",
    "signature": "boolean usesPaddingChar(char)",
    "visibility": "public",
    "body": "{\r\n    return c \u003d\u003d _paddingChar;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  c0 :\u003d @parameter0: char\n  $c1 \u003d Base64Variant: char _paddingChar\u003e\n  $i2 \u003d (int) c0\n  $i3 \u003d (int) $c1\n  if ($i2 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "usesPaddingChar",
    "signature": "boolean usesPaddingChar(int)",
    "visibility": "public",
    "body": "{\r\n    return ch \u003d\u003d _paddingChar;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  i0 :\u003d @parameter0: int\n  $c1 \u003d Base64Variant: char _paddingChar\u003e\n  $i2 \u003d (int) $c1\n  if (i0 !\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "decodeBase64Char",
    "signature": "int decodeBase64Char(char)",
    "visibility": "public",
    "body": "{\r\n    int ch \u003d c;\r\n    return (ch \u003c\u003d 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003e 127) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  c0 :\u003d @parameter0: char\n  $i2 \u003d (int) c0\n  if ($i2 \u003e 127) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Base64Variant: int[] _asciiToBase64\u003e\n  $i3 \u003d (int) c0\n  $i1 \u003d $r1[$i3]\n  goto B3\n}",
      "B2 {\n  $i5 \u003d (int) -1\n  $i1 \u003d $i5\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "decodeBase64Char",
    "signature": "int decodeBase64Char(int)",
    "visibility": "public",
    "body": "{\r\n    return (ch \u003c\u003d 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e 127) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e 127) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Base64Variant: int[] _asciiToBase64\u003e\n  $i1 \u003d $r1[i0]\n  goto B3\n}",
      "B2 {\n  $i3 \u003d (int) -1\n  $i1 \u003d $i3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "decodeBase64Byte",
    "signature": "int decodeBase64Byte(byte)",
    "visibility": "public",
    "body": "{\r\n    int ch \u003d b;\r\n    // note: cast retains sign, so it\u0027s from -128 to +127\r\n    if (ch \u003c 0) {\r\n        return BASE64_VALUE_INVALID;\r\n    }\r\n    return _asciiToBase64[ch];\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  b0 :\u003d @parameter0: byte\n  $i2 \u003d (int) b0\n  if ($i2 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i4 \u003d (int) -1\n  return\n}",
      "B2 {\n  $r1 \u003d Base64Variant: int[] _asciiToBase64\u003e\n  $i5 \u003d (int) b0\n  $i1 \u003d $r1[$i5]\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "encodeBase64Partial",
    "signature": "int encodeBase64Partial(int,int,char[],int)",
    "visibility": "public",
    "body": "{\r\n    buffer[outPtr++] \u003d _base64ToAsciiC[(bits \u003e\u003e 18) \u0026 0x3F];\r\n    buffer[outPtr++] \u003d _base64ToAsciiC[(bits \u003e\u003e 12) \u0026 0x3F];\r\n    if (usesPadding()) {\r\n        buffer[outPtr++] \u003d (outputBytes \u003d\u003d 2) ? _base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F] : _paddingChar;\r\n        buffer[outPtr++] \u003d _paddingChar;\r\n    } else {\r\n        if (outputBytes \u003d\u003d 2) {\r\n            buffer[outPtr++] \u003d _base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F];\r\n        }\r\n    }\r\n    return outPtr;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B5",
      "B1 : If(i7 !\u003d 2) → B2 | else → B3",
      "B5 : If(i7 !\u003d 2) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  i0 :\u003d @parameter0: int\n  i7 :\u003d @parameter1: int\n  r0 :\u003d @parameter2: char[]\n  i16 :\u003d @parameter3: int\n  i17 \u003d i16 + 1\n  $r2 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i1 \u003d i0 \u003e\u003e 18\n  $i2 \u003d $i1 \u0026 63\n  $c3 \u003d $r2[$i2]\n  r0[i16] \u003d $c3\n  i18 \u003d i17 + 1\n  $r3 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i4 \u003d i0 \u003e\u003e 12\n  $i5 \u003d $i4 \u0026 63\n  $c6 \u003d $r3[$i5]\n  r0[i17] \u003d $c6\n  $z0 \u003d r1.usesPadding()\n  if ($z0 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  $i12 \u003d i18\n  i19 \u003d i18 + 1\n  if (i7 !\u003d 2) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i14 \u003d i0 \u003e\u003e 6\n  $i15 \u003d $i14 \u0026 63\n  $c20 \u003d $r5[$i15]\n  goto B4\n}",
      "B3 {\n  $c20 \u003d Base64Variant: char _paddingChar\u003e\n}",
      "B4 {\n  r0[$i12] \u003d $c20\n  i18 \u003d i19 + 1\n  $c13 \u003d Base64Variant: char _paddingChar\u003e\n  r0[i19] \u003d $c13\n  goto B7\n}",
      "B5 {\n  if (i7 !\u003d 2) goto B6 else B7\n}",
      "B6 {\n  $i8 \u003d i18\n  i18 \u003d i18 + 1\n  $r4 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i9 \u003d i0 \u003e\u003e 6\n  $i10 \u003d $i9 \u0026 63\n  $c11 \u003d $r4[$i10]\n  r0[$i8] \u003d $c11\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#usesPadding(...0)",
        "body": "{\r\n    return _writePadding;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "encodeBase64Partial",
    "signature": "void encodeBase64Partial(java.lang.StringBuilder,int,int)",
    "visibility": "public",
    "body": "{\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 18) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 12) \u0026 0x3F]);\r\n    if (usesPadding()) {\r\n        sb.append((outputBytes \u003d\u003d 2) ? _base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F] : _paddingChar);\r\n        sb.append(_paddingChar);\r\n    } else {\r\n        if (outputBytes \u003d\u003d 2) {\r\n            sb.append(_base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F]);\r\n        }\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B5",
      "B1 : If(i7 !\u003d 2) → B2 | else → B3",
      "B5 : If(i7 !\u003d 2) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  StringBuilder\n  i0 :\u003d @parameter1: int\n  i7 :\u003d @parameter2: int\n  $r2 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i1 \u003d i0 \u003e\u003e 18\n  $i2 \u003d $i1 \u0026 63\n  $c3 \u003d $r2[$i2]\n  r0.append($c3)\n  $r3 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i4 \u003d i0 \u003e\u003e 12\n  $i5 \u003d $i4 \u0026 63\n  $c6 \u003d $r3[$i5]\n  r0.append($c6)\n  $z0 \u003d r1.usesPadding()\n  if ($z0 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  if (i7 !\u003d 2) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i12 \u003d i0 \u003e\u003e 6\n  $i13 \u003d $i12 \u0026 63\n  $c14 \u003d $r5[$i13]\n  goto B4\n}",
      "B3 {\n  $c14 \u003d Base64Variant: char _paddingChar\u003e\n}",
      "B4 {\n  r0.append($c14)\n  $c11 \u003d Base64Variant: char _paddingChar\u003e\n  r0.append($c11)\n  goto B7\n}",
      "B5 {\n  if (i7 !\u003d 2) goto B6 else B7\n}",
      "B6 {\n  $r4 \u003d Base64Variant: char[] _base64ToAsciiC\u003e\n  $i8 \u003d i0 \u003e\u003e 6\n  $i9 \u003d $i8 \u0026 63\n  $c10 \u003d $r4[$i9]\n  r0.append($c10)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#usesPadding(...0)",
        "body": "{\r\n    return _writePadding;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "encodeBase64Partial",
    "signature": "int encodeBase64Partial(int,int,byte[],int)",
    "visibility": "public",
    "body": "{\r\n    buffer[outPtr++] \u003d _base64ToAsciiB[(bits \u003e\u003e 18) \u0026 0x3F];\r\n    buffer[outPtr++] \u003d _base64ToAsciiB[(bits \u003e\u003e 12) \u0026 0x3F];\r\n    if (usesPadding()) {\r\n        byte pb \u003d (byte) _paddingChar;\r\n        buffer[outPtr++] \u003d (outputBytes \u003d\u003d 2) ? _base64ToAsciiB[(bits \u003e\u003e 6) \u0026 0x3F] : pb;\r\n        buffer[outPtr++] \u003d pb;\r\n    } else {\r\n        if (outputBytes \u003d\u003d 2) {\r\n            buffer[outPtr++] \u003d _base64ToAsciiB[(bits \u003e\u003e 6) \u0026 0x3F];\r\n        }\r\n    }\r\n    return outPtr;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B5",
      "B1 : If(i7 !\u003d 2) → B2 | else → B3",
      "B5 : If(i7 !\u003d 2) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  i0 :\u003d @parameter0: int\n  i7 :\u003d @parameter1: int\n  r0 :\u003d @parameter2: byte[]\n  i17 :\u003d @parameter3: int\n  i18 \u003d i17 + 1\n  $r2 \u003d Base64Variant: byte[] _base64ToAsciiB\u003e\n  $i1 \u003d i0 \u003e\u003e 18\n  $i2 \u003d $i1 \u0026 63\n  $b3 \u003d $r2[$i2]\n  r0[i17] \u003d $b3\n  i19 \u003d i18 + 1\n  $r3 \u003d Base64Variant: byte[] _base64ToAsciiB\u003e\n  $i4 \u003d i0 \u003e\u003e 12\n  $i5 \u003d $i4 \u0026 63\n  $b6 \u003d $r3[$i5]\n  r0[i18] \u003d $b6\n  $z0 \u003d r1.usesPadding()\n  if ($z0 \u003d\u003d false) goto B1 else B5\n}",
      "B1 {\n  $c12 \u003d Base64Variant: char _paddingChar\u003e\n  b13 \u003d (byte) $c12\n  $i14 \u003d i19\n  i20 \u003d i19 + 1\n  if (i7 !\u003d 2) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d Base64Variant: byte[] _base64ToAsciiB\u003e\n  $i15 \u003d i0 \u003e\u003e 6\n  $i16 \u003d $i15 \u0026 63\n  $b21 \u003d $r5[$i16]\n  goto B4\n}",
      "B3 {\n  $b21 \u003d b13\n}",
      "B4 {\n  r0[$i14] \u003d $b21\n  i19 \u003d i20 + 1\n  r0[i20] \u003d b13\n  goto B7\n}",
      "B5 {\n  if (i7 !\u003d 2) goto B6 else B7\n}",
      "B6 {\n  $i8 \u003d i19\n  i19 \u003d i19 + 1\n  $r4 \u003d Base64Variant: byte[] _base64ToAsciiB\u003e\n  $i9 \u003d i0 \u003e\u003e 6\n  $i10 \u003d $i9 \u0026 63\n  $b11 \u003d $r4[$i10]\n  r0[$i8] \u003d $b11\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#usesPadding(...0)",
        "body": "{\r\n    return _writePadding;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "encode",
    "signature": "java.lang.String encode(byte[],boolean)",
    "visibility": "public",
    "body": "{\r\n    final int inputEnd \u003d input.length;\r\n    final StringBuilder sb \u003d new StringBuilder(inputEnd + (inputEnd \u003e\u003e 2) + (inputEnd \u003e\u003e 3));\r\n    if (addQuotes) {\r\n        sb.append(\u0027\"\u0027);\r\n    }\r\n    int chunksBeforeLF \u003d getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    int inputPtr \u003d 0;\r\n    // to get only full triplets\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        encodeBase64Chunk(sb, b24);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            // note: must quote in JSON value, so not really useful...\r\n            sb.append(\u0027\\\\\u0027);\r\n            sb.append(\u0027n\u0027);\r\n            chunksBeforeLF \u003d getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    // 0, 1 or 2\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        // yes, but do we have room for output?\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        encodeBase64Partial(sb, b24, inputLeft);\r\n    }\r\n    if (addQuotes) {\r\n        sb.append(\u0027\"\u0027);\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i19 \u003e $i17) → B4 | else → B7",
      "B4 : If(i18 \u003e 0) → B5 | else → B6",
      "B7 : If(i25 \u003c\u003d 0) → B8 | else → B11",
      "B8 : If(i25 !\u003d 2) → B9 | else → B10",
      "B11 : If(z0 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  r0 :\u003d @parameter0: byte[]\n  z0 :\u003d @parameter1: boolean\n  i0 \u003d lengthof r0\n  $r4 \u003d StringBuilder\n  $i1 \u003d i0 \u003e\u003e 2\n  $i3 \u003d i0 + $i1\n  $i2 \u003d i0 \u003e\u003e 3\n  $i4 \u003d $i3 + $i2\n  new StringBuilder($i4)\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4.append(34)\n}",
      "B2 {\n  $i5 \u003d r2.getMaxLineLength()\n  i18 \u003d $i5 \u003e\u003e 2\n  i19 \u003d 0\n  $i17 \u003d i0 - 3\n}",
      "B3 {\n  if (i19 \u003e $i17) goto B4 else B7\n}",
      "B4 {\n  i20 \u003d i19 + 1\n  $b10 \u003d r0[i19]\n  $i28 \u003d (int) $b10\n  i21 \u003d $i28 \u003c\u003c 8\n  i22 \u003d i20 + 1\n  $b11 \u003d r0[i20]\n  $s29 \u003d (short) $b11\n  $s12 \u003d $s29 \u0026 255\n  $i30 \u003d (int) $s12\n  i23 \u003d i21 | $i30\n  $i15 \u003d i23 \u003c\u003c 8\n  i19 \u003d i22 + 1\n  $b13 \u003d r0[i22]\n  $s31 \u003d (short) $b13\n  $s14 \u003d $s31 \u0026 255\n  $i32 \u003d (int) $s14\n  i24 \u003d $i15 | $i32\n  r2.encodeBase64Chunk($r4, i24)\n  $i34 \u003d (int) -1\n  i18 \u003d i18 + $i34\n  if (i18 \u003e 0) goto B5 else B6\n}",
      "B5 {\n  $r4.append(92)\n  $r4.append(110)\n  $i16 \u003d r2.getMaxLineLength()\n  i18 \u003d $i16 \u003e\u003e 2\n}",
      "B6 {\n  goto B3\n}",
      "B7 {\n  i25 \u003d i0 - i19\n  if (i25 \u003c\u003d 0) goto B8 else B11\n}",
      "B8 {\n  i26 \u003d i19 + 1\n  $b6 \u003d r0[i19]\n  $i35 \u003d (int) $b6\n  i27 \u003d $i35 \u003c\u003c 16\n  if (i25 !\u003d 2) goto B9 else B10\n}",
      "B9 {\n  $b7 \u003d r0[i26]\n  $s36 \u003d (short) $b7\n  $s8 \u003d $s36 \u0026 255\n  $i37 \u003d (int) $s8\n  $i9 \u003d $i37 \u003c\u003c 8\n  i27 \u003d i27 | $i9\n}",
      "B10 {\n  r2.encodeBase64Partial($r4, i27, i25)\n}",
      "B11 {\n  if (z0 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r4.append(34)\n}",
      "B13 {\n  $r3 \u003d $r4.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#encodeBase64Partial(...3)",
        "body": "{\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 18) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 12) \u0026 0x3F]);\r\n    if (usesPadding()) {\r\n        sb.append((outputBytes \u003d\u003d 2) ? _base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F] : _paddingChar);\r\n        sb.append(_paddingChar);\r\n    } else {\r\n        if (outputBytes \u003d\u003d 2) {\r\n            sb.append(_base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F]);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "Base64Variant#encodeBase64Chunk(...2)",
        "body": "{\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 18) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 12) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 6) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[b24 \u0026 0x3F]);\r\n}"
      },
      {
        "name": "Base64Variant#getMaxLineLength(...0)",
        "body": "{\r\n    return _maxLineLength;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "encode",
    "signature": "java.lang.String encode(byte[],boolean,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int inputEnd \u003d input.length;\r\n    final StringBuilder sb \u003d new StringBuilder(inputEnd + (inputEnd \u003e\u003e 2) + (inputEnd \u003e\u003e 3));\r\n    if (addQuotes) {\r\n        sb.append(\u0027\"\u0027);\r\n    }\r\n    int chunksBeforeLF \u003d getMaxLineLength() \u003e\u003e 2;\r\n    int inputPtr \u003d 0;\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        encodeBase64Chunk(sb, b24);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            sb.append(linefeed);\r\n            chunksBeforeLF \u003d getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        encodeBase64Partial(sb, b24, inputLeft);\r\n    }\r\n    if (addQuotes) {\r\n        sb.append(\u0027\"\u0027);\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i19 \u003e $i17) → B4 | else → B7",
      "B4 : If(i18 \u003e 0) → B5 | else → B6",
      "B7 : If(i25 \u003c\u003d 0) → B8 | else → B11",
      "B8 : If(i25 !\u003d 2) → B9 | else → B10",
      "B11 : If(z0 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  r0 :\u003d @parameter0: byte[]\n  z0 :\u003d @parameter1: boolean\n  String\n  i0 \u003d lengthof r0\n  $r5 \u003d StringBuilder\n  $i1 \u003d i0 \u003e\u003e 2\n  $i3 \u003d i0 + $i1\n  $i2 \u003d i0 \u003e\u003e 3\n  $i4 \u003d $i3 + $i2\n  new StringBuilder($i4)\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r5.append(34)\n}",
      "B2 {\n  $i5 \u003d r2.getMaxLineLength()\n  i18 \u003d $i5 \u003e\u003e 2\n  i19 \u003d 0\n  $i17 \u003d i0 - 3\n}",
      "B3 {\n  if (i19 \u003e $i17) goto B4 else B7\n}",
      "B4 {\n  i20 \u003d i19 + 1\n  $b10 \u003d r0[i19]\n  $i28 \u003d (int) $b10\n  i21 \u003d $i28 \u003c\u003c 8\n  i22 \u003d i20 + 1\n  $b11 \u003d r0[i20]\n  $s29 \u003d (short) $b11\n  $s12 \u003d $s29 \u0026 255\n  $i30 \u003d (int) $s12\n  i23 \u003d i21 | $i30\n  $i15 \u003d i23 \u003c\u003c 8\n  i19 \u003d i22 + 1\n  $b13 \u003d r0[i22]\n  $s31 \u003d (short) $b13\n  $s14 \u003d $s31 \u0026 255\n  $i32 \u003d (int) $s14\n  i24 \u003d $i15 | $i32\n  r2.encodeBase64Chunk($r5, i24)\n  $i34 \u003d (int) -1\n  i18 \u003d i18 + $i34\n  if (i18 \u003e 0) goto B5 else B6\n}",
      "B5 {\n  $r5.append(r4)\n  $i16 \u003d r2.getMaxLineLength()\n  i18 \u003d $i16 \u003e\u003e 2\n}",
      "B6 {\n  goto B3\n}",
      "B7 {\n  i25 \u003d i0 - i19\n  if (i25 \u003c\u003d 0) goto B8 else B11\n}",
      "B8 {\n  i26 \u003d i19 + 1\n  $b6 \u003d r0[i19]\n  $i35 \u003d (int) $b6\n  i27 \u003d $i35 \u003c\u003c 16\n  if (i25 !\u003d 2) goto B9 else B10\n}",
      "B9 {\n  $b7 \u003d r0[i26]\n  $s36 \u003d (short) $b7\n  $s8 \u003d $s36 \u0026 255\n  $i37 \u003d (int) $s8\n  $i9 \u003d $i37 \u003c\u003c 8\n  i27 \u003d i27 | $i9\n}",
      "B10 {\n  r2.encodeBase64Partial($r5, i27, i25)\n}",
      "B11 {\n  if (z0 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r5.append(34)\n}",
      "B13 {\n  $r3 \u003d $r5.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#encodeBase64Partial(...3)",
        "body": "{\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 18) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(bits \u003e\u003e 12) \u0026 0x3F]);\r\n    if (usesPadding()) {\r\n        sb.append((outputBytes \u003d\u003d 2) ? _base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F] : _paddingChar);\r\n        sb.append(_paddingChar);\r\n    } else {\r\n        if (outputBytes \u003d\u003d 2) {\r\n            sb.append(_base64ToAsciiC[(bits \u003e\u003e 6) \u0026 0x3F]);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "Base64Variant#encodeBase64Chunk(...2)",
        "body": "{\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 18) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 12) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[(b24 \u003e\u003e 6) \u0026 0x3F]);\r\n    sb.append(_base64ToAsciiC[b24 \u0026 0x3F]);\r\n}"
      },
      {
        "name": "Base64Variant#getMaxLineLength(...0)",
        "body": "{\r\n    return _maxLineLength;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "decode",
    "signature": "void decode(java.lang.String,com.fasterxml.jackson.core.util.ByteArrayBuilder)",
    "visibility": "public",
    "body": "{\r\n    int ptr \u003d 0;\r\n    int len \u003d str.length();\r\n    main_loop: while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        char ch;\r\n        do {\r\n            if (ptr \u003e\u003d len) {\r\n                break main_loop;\r\n            }\r\n            ch \u003d str.charAt(ptr++);\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            _reportInvalidBase64(ch, 0, null);\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        if (ptr \u003e\u003d len) {\r\n            _reportBase64EOF();\r\n        }\r\n        ch \u003d str.charAt(ptr++);\r\n        bits \u003d decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            _reportInvalidBase64(ch, 1, null);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        if (ptr \u003e\u003d len) {\r\n            // but as per [JACKSON-631] can be end-of-input, iff padding is not required\r\n            if (!requiresPaddingOnRead()) {\r\n                decodedData \u003e\u003e\u003d 4;\r\n                builder.append(decodedData);\r\n                break;\r\n            }\r\n            _reportBase64EOF();\r\n        }\r\n        ch \u003d str.charAt(ptr++);\r\n        bits \u003d decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                _reportInvalidBase64(ch, 2, null);\r\n            }\r\n            if (!acceptsPaddingOnRead()) {\r\n                _reportBase64UnexpectedPadding();\r\n            }\r\n            // Ok, must get padding\r\n            if (ptr \u003e\u003d len) {\r\n                _reportBase64EOF();\r\n            }\r\n            ch \u003d str.charAt(ptr++);\r\n            if (!usesPaddingChar(ch)) {\r\n                _reportInvalidBase64(ch, 3, \"expected padding character \u0027\" + getPaddingChar() + \"\u0027\");\r\n            }\r\n            // Got 12 bits, only need 8, need to shift\r\n            decodedData \u003e\u003e\u003d 4;\r\n            builder.append(decodedData);\r\n            continue;\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        if (ptr \u003e\u003d len) {\r\n            // but as per [JACKSON-631] can be end-of-input, iff padding on read is not required\r\n            if (!requiresPaddingOnRead()) {\r\n                decodedData \u003e\u003e\u003d 2;\r\n                builder.appendTwoBytes(decodedData);\r\n                break;\r\n            }\r\n            _reportBase64EOF();\r\n        }\r\n        ch \u003d str.charAt(ptr++);\r\n        bits \u003d decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                _reportInvalidBase64(ch, 3, null);\r\n            }\r\n            if (!acceptsPaddingOnRead()) {\r\n                _reportBase64UnexpectedPadding();\r\n            }\r\n            decodedData \u003e\u003e\u003d 2;\r\n            builder.appendTwoBytes(decodedData);\r\n        } else {\r\n            // otherwise, our triple is now complete\r\n            decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n            builder.appendThreeBytes(decodedData);\r\n        }\r\n    }\r\n}",
    "nodes": 37,
    "edges": 53,
    "cc": 18,
    "flowSummary": [
      "B1 : If(i16 \u003c i0) → B2 | else → B3",
      "B3 : If($i25 \u003c\u003d 32) → B4 | else → B1",
      "B4 : If(i18 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If(i16 \u003c i0) → B7 | else → B8",
      "B8 : If($i15 \u003e\u003d 0) → B9 | else → B10",
      "B10 : If(i19 \u003c i0) → B11 | else → B14",
      "B11 : If($z4 !\u003d 0) → B12 | else → B13",
      "B14 : If($i12 \u003e\u003d 0) → B15 | else → B24",
      "B15 : If($i12 \u003d\u003d $i27) → B16 | else → B17",
      "B17 : If($z2 !\u003d 0) → B18 | else → B19",
      "B19 : If(i21 \u003c i0) → B20 | else → B21",
      "B21 : If($z3 !\u003d 0) → B22 | else → B23",
      "B24 : If(i21 \u003c i0) → B25 | else → B28",
      "B25 : If($z1 !\u003d 0) → B26 | else → B27",
      "B28 : If($i7 \u003e\u003d 0) → B29 | else → B34",
      "B29 : If($i7 \u003d\u003d $i29) → B30 | else → B31",
      "B31 : If($z0 !\u003d 0) → B32 | else → B33"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  String\n  ByteArrayBuilder\n  i16 \u003d 0\n  i0 \u003d r0.length()\n}",
      "B1 {\n  if (i16 \u003c i0) goto B2 else B3\n}",
      "B2 {\n  goto B36\n}",
      "B3 {\n  $i1 \u003d i16\n  i16 \u003d i16 + 1\n  c17 \u003d r0.charAt($i1)\n  $i25 \u003d (int) c17\n  if ($i25 \u003c\u003d 32) goto B4 else B1\n}",
      "B4 {\n  i18 \u003d r1.decodeBase64Char(c17)\n  if (i18 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r1._reportInvalidBase64(c17, 0, null)\n}",
      "B6 {\n  if (i16 \u003c i0) goto B7 else B8\n}",
      "B7 {\n  r1._reportBase64EOF()\n}",
      "B8 {\n  i19 \u003d i16 + 1\n  $c14 \u003d r0.charAt(i16)\n  $i15 \u003d r1.decodeBase64Char($c14)\n  if ($i15 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  r1._reportInvalidBase64($c14, 1, null)\n}",
      "B10 {\n  $i2 \u003d i18 \u003c\u003c 6\n  $i13 \u003d $i2 | $i15\n  if (i19 \u003c i0) goto B11 else B14\n}",
      "B11 {\n  $z4 \u003d r1.requiresPaddingOnRead()\n  if ($z4 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  i20 \u003d $i13 \u003e\u003e 4\n  r2.append(i20)\n  goto B36\n}",
      "B13 {\n  r1._reportBase64EOF()\n}",
      "B14 {\n  i21 \u003d i19 + 1\n  $c11 \u003d r0.charAt(i19)\n  $i12 \u003d r1.decodeBase64Char($c11)\n  if ($i12 \u003e\u003d 0) goto B15 else B24\n}",
      "B15 {\n  $i27 \u003d (int) -2\n  if ($i12 \u003d\u003d $i27) goto B16 else B17\n}",
      "B16 {\n  r1._reportInvalidBase64($c11, 2, null)\n}",
      "B17 {\n  $z2 \u003d r1.acceptsPaddingOnRead()\n  if ($z2 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  r1._reportBase64UnexpectedPadding()\n}",
      "B19 {\n  if (i21 \u003c i0) goto B20 else B21\n}",
      "B20 {\n  r1._reportBase64EOF()\n}",
      "B21 {\n  i16 \u003d i21 + 1\n  $c10 \u003d r0.charAt(i21)\n  $z3 \u003d r1.usesPaddingChar($c10)\n  if ($z3 !\u003d 0) goto B22 else B23\n}",
      "B22 {\n  $c8 \u003d r1.getPaddingChar()\n  $r3 \u003d dynInvoke makeConcatWithConstants($c8)\n  r1._reportInvalidBase64($c10, 3, $r3)\n}",
      "B23 {\n  $i9 \u003d $i13 \u003e\u003e 4\n  r2.append($i9)\n  goto B1\n}",
      "B24 {\n  $i3 \u003d $i13 \u003c\u003c 6\n  i22 \u003d $i3 | $i12\n  if (i21 \u003c i0) goto B25 else B28\n}",
      "B25 {\n  $z1 \u003d r1.requiresPaddingOnRead()\n  if ($z1 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  i23 \u003d i22 \u003e\u003e 2\n  r2.appendTwoBytes(i23)\n  goto B36\n}",
      "B27 {\n  r1._reportBase64EOF()\n}",
      "B28 {\n  i16 \u003d i21 + 1\n  $c6 \u003d r0.charAt(i21)\n  $i7 \u003d r1.decodeBase64Char($c6)\n  if ($i7 \u003e\u003d 0) goto B29 else B34\n}",
      "B29 {\n  $i29 \u003d (int) -2\n  if ($i7 \u003d\u003d $i29) goto B30 else B31\n}",
      "B30 {\n  r1._reportInvalidBase64($c6, 3, null)\n}",
      "B31 {\n  $z0 \u003d r1.acceptsPaddingOnRead()\n  if ($z0 !\u003d 0) goto B32 else B33\n}",
      "B32 {\n  r1._reportBase64UnexpectedPadding()\n}",
      "B33 {\n  $i5 \u003d i22 \u003e\u003e 2\n  r2.appendTwoBytes($i5)\n  goto B35\n}",
      "B34 {\n  $i4 \u003d i22 \u003c\u003c 6\n  i24 \u003d $i4 | $i7\n  r2.appendThreeBytes(i24)\n}",
      "B35 {\n  goto B1\n}",
      "B36 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B36",
      "B3 --\u003e B4",
      "B3 --\u003e B1",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B36",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B24",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B1",
      "B24 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B36",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B34",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B31",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B35",
      "B34 --\u003e B35",
      "B35 --\u003e B1",
      "B36 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#decodeBase64Char(...1)",
        "body": "{\r\n    int ch \u003d c;\r\n    return (ch \u003c\u003d 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\r\n}"
      },
      {
        "name": "Base64Variant#_reportInvalidBase64(...3)",
        "body": "{\r\n    String base;\r\n    if (ch \u003c\u003d INT_SPACE) {\r\n        base \u003d \"Illegal white space character (code 0x\" + Integer.toHexString(ch) + \") as character #\" + (bindex + 1) + \" of 4-char base64 unit: can only used between units\";\r\n    } else if (usesPaddingChar(ch)) {\r\n        base \u003d \"Unexpected padding character (\u0027\" + getPaddingChar() + \"\u0027) as character #\" + (bindex + 1) + \" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\r\n    } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\r\n        // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\r\n        base \u003d \"Illegal character (code 0x\" + Integer.toHexString(ch) + \") in base64 content\";\r\n    } else {\r\n        base \u003d \"Illegal character \u0027\" + ch + \"\u0027 (code 0x\" + Integer.toHexString(ch) + \") in base64 content\";\r\n    }\r\n    if (msg !\u003d null) {\r\n        base \u003d base + \": \" + msg;\r\n    }\r\n    throw new IllegalArgumentException(base);\r\n}"
      },
      {
        "name": "Base64Variant#requiresPaddingOnRead(...0)",
        "body": "{\r\n    return _paddingReadBehaviour \u003d\u003d PaddingReadBehaviour.PADDING_REQUIRED;\r\n}"
      },
      {
        "name": "Base64Variant#_reportBase64EOF(...0)",
        "body": "{\r\n    throw new IllegalArgumentException(missingPaddingMessage());\r\n}"
      },
      {
        "name": "Base64Variant#_reportBase64UnexpectedPadding(...0)",
        "body": "{\r\n    throw new IllegalArgumentException(unexpectedPaddingMessage());\r\n}"
      },
      {
        "name": "Base64Variant#getPaddingChar(...0)",
        "body": "{\r\n    return _paddingChar;\r\n}"
      },
      {
        "name": "Base64Variant#acceptsPaddingOnRead(...0)",
        "body": "{\r\n    return _paddingReadBehaviour !\u003d PaddingReadBehaviour.PADDING_FORBIDDEN;\r\n}"
      },
      {
        "name": "Base64Variant#usesPaddingChar(...1)",
        "body": "{\r\n    return c \u003d\u003d _paddingChar;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variant",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // identity comparison should be fine\r\n    // 26-Oct-2020, tatu: ... not any more with 2.12\r\n    if (o \u003d\u003d this)\r\n        return true;\r\n    if (o \u003d\u003d null || o.getClass() !\u003d getClass())\r\n        return false;\r\n    Base64Variant other \u003d (Base64Variant) o;\r\n    return (other._paddingChar \u003d\u003d _paddingChar) \u0026\u0026 (other._maxLineLength \u003d\u003d _maxLineLength) \u0026\u0026 (other._writePadding \u003d\u003d _writePadding) \u0026\u0026 (other._paddingReadBehaviour \u003d\u003d _paddingReadBehaviour) \u0026\u0026 (_name.equals(other._name));\r\n}",
    "nodes": 13,
    "edges": 18,
    "cc": 7,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($i4 !\u003d $i5) → B6 | else → B11",
      "B6 : If($i3 !\u003d $i2) → B7 | else → B11",
      "B7 : If($z1 !\u003d $z0) → B8 | else → B11",
      "B8 : If($r6 !\u003d $r5) → B9 | else → B11",
      "B9 : If($z2 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  Base64Variant\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d Base64Variant) r0\n  $c1 \u003d Base64Variant: char _paddingChar\u003e\n  $c0 \u003d Base64Variant: char _paddingChar\u003e\n  $i4 \u003d (int) $c1\n  $i5 \u003d (int) $c0\n  if ($i4 !\u003d $i5) goto B6 else B11\n}",
      "B6 {\n  $i3 \u003d Base64Variant: int _maxLineLength\u003e\n  $i2 \u003d Base64Variant: int _maxLineLength\u003e\n  if ($i3 !\u003d $i2) goto B7 else B11\n}",
      "B7 {\n  $z1 \u003d Base64Variant: boolean _writePadding\u003e\n  $z0 \u003d Base64Variant: boolean _writePadding\u003e\n  if ($z1 !\u003d $z0) goto B8 else B11\n}",
      "B8 {\n  $r6 \u003d Base64Variant$PaddingReadBehaviour _paddingReadBehaviour\u003e\n  $r5 \u003d Base64Variant$PaddingReadBehaviour _paddingReadBehaviour\u003e\n  if ($r6 !\u003d $r5) goto B9 else B11\n}",
      "B9 {\n  $r8 \u003d String _name\u003e\n  $r7 \u003d String _name\u003e\n  $z2 \u003d $r8.equals($r7)\n  if ($z2 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $z3 \u003d 1\n  goto B12\n}",
      "B11 {\n  $z3 \u003d 0\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Base64Variant#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Base64Variants",
    "methodName": "valueOf",
    "signature": "com.fasterxml.jackson.core.Base64Variant valueOf(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (MIME._name.equals(name)) {\r\n        return MIME;\r\n    }\r\n    if (MIME_NO_LINEFEEDS._name.equals(name)) {\r\n        return MIME_NO_LINEFEEDS;\r\n    }\r\n    if (PEM._name.equals(name)) {\r\n        return PEM;\r\n    }\r\n    if (MODIFIED_FOR_URL._name.equals(name)) {\r\n        return MODIFIED_FOR_URL;\r\n    }\r\n    if (name \u003d\u003d null) {\r\n        name \u003d \"\u003cnull\u003e\";\r\n    } else {\r\n        name \u003d \"\u0027\" + name + \"\u0027\";\r\n    }\r\n    throw new IllegalArgumentException(\"No Base64Variant with name \" + name);\r\n}",
    "nodes": 12,
    "edges": 12,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z3 \u003d\u003d false) → B7 | else → B8",
      "B8 : If(r14 !\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  String\n  $r0 \u003d Base64Variant MIME\u003e\n  $r1 \u003d String _name\u003e\n  $z0 \u003d $r1.equals(r14)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d Base64Variant MIME\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d Base64Variant MIME_NO_LINEFEEDS\u003e\n  $r3 \u003d String _name\u003e\n  $z1 \u003d $r3.equals(r14)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r12 \u003d Base64Variant MIME_NO_LINEFEEDS\u003e\n  return\n}",
      "B4 {\n  $r4 \u003d Base64Variant PEM\u003e\n  $r5 \u003d String _name\u003e\n  $z2 \u003d $r5.equals(r14)\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r11 \u003d Base64Variant PEM\u003e\n  return\n}",
      "B6 {\n  $r6 \u003d Base64Variant MODIFIED_FOR_URL\u003e\n  $r7 \u003d String _name\u003e\n  $z3 \u003d $r7.equals(r14)\n  if ($z3 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d Base64Variant MODIFIED_FOR_URL\u003e\n  return\n}",
      "B8 {\n  if (r14 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  r15 \u003d \"\u003cnull\u003e\"\n  goto B11\n}",
      "B10 {\n  r15 \u003d dynInvoke makeConcatWithConstants(r14)\n}",
      "B11 {\n  $r8 \u003d IllegalArgumentException\n  $r9 \u003d dynInvoke makeConcatWithConstants(r15)\n  new IllegalArgumentException($r9)\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.ErrorReportConfiguration",
    "methodName": "overrideDefaultErrorReportConfiguration",
    "signature": "void overrideDefaultErrorReportConfiguration(com.fasterxml.jackson.core.ErrorReportConfiguration)",
    "visibility": "public",
    "body": "{\r\n    if (errorReportConfiguration \u003d\u003d null) {\r\n        DEFAULT \u003d new ErrorReportConfiguration(DEFAULT_MAX_ERROR_TOKEN_LENGTH, DEFAULT_MAX_RAW_CONTENT_LENGTH);\r\n    } else {\r\n        DEFAULT \u003d errorReportConfiguration;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ErrorReportConfiguration\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d ErrorReportConfiguration\n  new ErrorReportConfiguration(256, 500)\n  ErrorReportConfiguration DEFAULT\u003e \u003d $r1\n  goto B3\n}",
      "B2 {\n  ErrorReportConfiguration DEFAULT\u003e \u003d r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray()",
    "visibility": "public",
    "body": "{\r\n    // First things first: whole-sale skipping easy\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        // include the whole sub-tree?\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray();\r\n        return;\r\n    }\r\n    // Ok; regular checking state then\r\n    _itemFilter \u003d _filterContext.checkValue(_itemFilter);\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d _itemFilter.filterStartArray();\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray();\r\n    } else if (_itemFilter !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray();\r\n    } else {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If($r7 !\u003d null) → B5 | else → B6",
      "B6 : If($r9 \u003d\u003d $r8) → B7 | else → B8",
      "B8 : If($r11 !\u003d $r10) → B9 | else → B10",
      "B10 : If($r12 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r17 !\u003d $r16) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r34 \u003d TokenFilterContext _filterContext\u003e\n  $r35 \u003d $r34.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r35\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r31 \u003d TokenFilterContext _filterContext\u003e\n  $r30 \u003d TokenFilter _itemFilter\u003e\n  $r32 \u003d $r31.createChildArrayContext($r30, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r32\n  $r33 \u003d JsonGenerator delegate\u003e\n  $r33.writeStartArray()\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  $r6 \u003d $r5.checkValue($r4)\n  TokenFilter _itemFilter\u003e \u003d $r6\n  $r7 \u003d TokenFilter _itemFilter\u003e\n  if ($r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r28 \u003d TokenFilterContext _filterContext\u003e\n  $r29 \u003d $r28.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r29\n  return\n}",
      "B6 {\n  $r9 \u003d TokenFilter _itemFilter\u003e\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r9 \u003d\u003d $r8) goto B7 else B8\n}",
      "B7 {\n  $r26 \u003d TokenFilter _itemFilter\u003e\n  $r27 \u003d $r26.filterStartArray()\n  TokenFilter _itemFilter\u003e \u003d $r27\n}",
      "B8 {\n  $r11 \u003d TokenFilter _itemFilter\u003e\n  $r10 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r11 !\u003d $r10) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r23 \u003d TokenFilterContext _filterContext\u003e\n  $r22 \u003d TokenFilter _itemFilter\u003e\n  $r24 \u003d $r23.createChildArrayContext($r22, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r24\n  $r25 \u003d JsonGenerator delegate\u003e\n  $r25.writeStartArray()\n  goto B14\n}",
      "B10 {\n  $r12 \u003d TokenFilter _itemFilter\u003e\n  if ($r12 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r17 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r16 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r17 !\u003d $r16) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r19 \u003d TokenFilterContext _filterContext\u003e\n  $r18 \u003d TokenFilter _itemFilter\u003e\n  $r20 \u003d $r19.createChildArrayContext($r18, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r20\n  $r21 \u003d JsonGenerator delegate\u003e\n  $r21.writeStartArray()\n  goto B14\n}",
      "B13 {\n  $r14 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d TokenFilter _itemFilter\u003e\n  $r15 \u003d $r14.createChildArrayContext($r13, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r15\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(size);\r\n        return;\r\n    }\r\n    _itemFilter \u003d _filterContext.checkValue(_itemFilter);\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d _itemFilter.filterStartArray();\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(size);\r\n    } else if (_itemFilter !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(size);\r\n    } else {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If($r7 !\u003d null) → B5 | else → B6",
      "B6 : If($r9 \u003d\u003d $r8) → B7 | else → B8",
      "B8 : If($r11 !\u003d $r10) → B9 | else → B10",
      "B10 : If($r12 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r17 !\u003d $r16) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  i0 :\u003d @parameter0: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r34 \u003d TokenFilterContext _filterContext\u003e\n  $r35 \u003d $r34.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r35\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r31 \u003d TokenFilterContext _filterContext\u003e\n  $r30 \u003d TokenFilter _itemFilter\u003e\n  $r32 \u003d $r31.createChildArrayContext($r30, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r32\n  $r33 \u003d JsonGenerator delegate\u003e\n  $r33.writeStartArray(i0)\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  $r6 \u003d $r5.checkValue($r4)\n  TokenFilter _itemFilter\u003e \u003d $r6\n  $r7 \u003d TokenFilter _itemFilter\u003e\n  if ($r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r28 \u003d TokenFilterContext _filterContext\u003e\n  $r29 \u003d $r28.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r29\n  return\n}",
      "B6 {\n  $r9 \u003d TokenFilter _itemFilter\u003e\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r9 \u003d\u003d $r8) goto B7 else B8\n}",
      "B7 {\n  $r26 \u003d TokenFilter _itemFilter\u003e\n  $r27 \u003d $r26.filterStartArray()\n  TokenFilter _itemFilter\u003e \u003d $r27\n}",
      "B8 {\n  $r11 \u003d TokenFilter _itemFilter\u003e\n  $r10 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r11 !\u003d $r10) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r23 \u003d TokenFilterContext _filterContext\u003e\n  $r22 \u003d TokenFilter _itemFilter\u003e\n  $r24 \u003d $r23.createChildArrayContext($r22, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r24\n  $r25 \u003d JsonGenerator delegate\u003e\n  $r25.writeStartArray(i0)\n  goto B14\n}",
      "B10 {\n  $r12 \u003d TokenFilter _itemFilter\u003e\n  if ($r12 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r17 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r16 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r17 !\u003d $r16) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r19 \u003d TokenFilterContext _filterContext\u003e\n  $r18 \u003d TokenFilter _itemFilter\u003e\n  $r20 \u003d $r19.createChildArrayContext($r18, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r20\n  $r21 \u003d JsonGenerator delegate\u003e\n  $r21.writeStartArray(i0)\n  goto B14\n}",
      "B13 {\n  $r14 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d TokenFilter _itemFilter\u003e\n  $r15 \u003d $r14.createChildArrayContext($r13, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r15\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue);\r\n        return;\r\n    }\r\n    _itemFilter \u003d _filterContext.checkValue(_itemFilter);\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d _itemFilter.filterStartArray();\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue);\r\n    } else if (_itemFilter !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue);\r\n    } else {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If($r7 !\u003d null) → B5 | else → B6",
      "B6 : If($r9 \u003d\u003d $r8) → B7 | else → B8",
      "B8 : If($r11 !\u003d $r10) → B9 | else → B10",
      "B10 : If($r12 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r17 !\u003d $r16) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r35 \u003d TokenFilterContext _filterContext\u003e\n  $r36 \u003d $r35.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r36\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r32 \u003d TokenFilterContext _filterContext\u003e\n  $r31 \u003d TokenFilter _itemFilter\u003e\n  $r33 \u003d $r32.createChildArrayContext($r31, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r33\n  $r34 \u003d JsonGenerator delegate\u003e\n  $r34.writeStartArray(r21)\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  $r6 \u003d $r5.checkValue($r4)\n  TokenFilter _itemFilter\u003e \u003d $r6\n  $r7 \u003d TokenFilter _itemFilter\u003e\n  if ($r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r29 \u003d TokenFilterContext _filterContext\u003e\n  $r30 \u003d $r29.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r30\n  return\n}",
      "B6 {\n  $r9 \u003d TokenFilter _itemFilter\u003e\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r9 \u003d\u003d $r8) goto B7 else B8\n}",
      "B7 {\n  $r27 \u003d TokenFilter _itemFilter\u003e\n  $r28 \u003d $r27.filterStartArray()\n  TokenFilter _itemFilter\u003e \u003d $r28\n}",
      "B8 {\n  $r11 \u003d TokenFilter _itemFilter\u003e\n  $r10 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r11 !\u003d $r10) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r24 \u003d TokenFilterContext _filterContext\u003e\n  $r23 \u003d TokenFilter _itemFilter\u003e\n  $r25 \u003d $r24.createChildArrayContext($r23, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r25\n  $r26 \u003d JsonGenerator delegate\u003e\n  $r26.writeStartArray(r21)\n  goto B14\n}",
      "B10 {\n  $r12 \u003d TokenFilter _itemFilter\u003e\n  if ($r12 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r17 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r16 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r17 !\u003d $r16) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r19 \u003d TokenFilterContext _filterContext\u003e\n  $r18 \u003d TokenFilter _itemFilter\u003e\n  $r20 \u003d $r19.createChildArrayContext($r18, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r20\n  $r22 \u003d JsonGenerator delegate\u003e\n  $r22.writeStartArray(r21)\n  goto B14\n}",
      "B13 {\n  $r14 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d TokenFilter _itemFilter\u003e\n  $r15 \u003d $r14.createChildArrayContext($r13, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r15\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object,int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue, size);\r\n        return;\r\n    }\r\n    _itemFilter \u003d _filterContext.checkValue(_itemFilter);\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(null, false);\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d _itemFilter.filterStartArray();\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue, size);\r\n    } else if (_itemFilter !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, true);\r\n        delegate.writeStartArray(forValue, size);\r\n    } else {\r\n        _filterContext \u003d _filterContext.createChildArrayContext(_itemFilter, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If($r7 !\u003d null) → B5 | else → B6",
      "B6 : If($r9 \u003d\u003d $r8) → B7 | else → B8",
      "B8 : If($r11 !\u003d $r10) → B9 | else → B10",
      "B10 : If($r12 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r17 !\u003d $r16) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  i0 :\u003d @parameter1: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r35 \u003d TokenFilterContext _filterContext\u003e\n  $r36 \u003d $r35.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r36\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r32 \u003d TokenFilterContext _filterContext\u003e\n  $r31 \u003d TokenFilter _itemFilter\u003e\n  $r33 \u003d $r32.createChildArrayContext($r31, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r33\n  $r34 \u003d JsonGenerator delegate\u003e\n  $r34.writeStartArray(r21, i0)\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  $r6 \u003d $r5.checkValue($r4)\n  TokenFilter _itemFilter\u003e \u003d $r6\n  $r7 \u003d TokenFilter _itemFilter\u003e\n  if ($r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r29 \u003d TokenFilterContext _filterContext\u003e\n  $r30 \u003d $r29.createChildArrayContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r30\n  return\n}",
      "B6 {\n  $r9 \u003d TokenFilter _itemFilter\u003e\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r9 \u003d\u003d $r8) goto B7 else B8\n}",
      "B7 {\n  $r27 \u003d TokenFilter _itemFilter\u003e\n  $r28 \u003d $r27.filterStartArray()\n  TokenFilter _itemFilter\u003e \u003d $r28\n}",
      "B8 {\n  $r11 \u003d TokenFilter _itemFilter\u003e\n  $r10 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r11 !\u003d $r10) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r24 \u003d TokenFilterContext _filterContext\u003e\n  $r23 \u003d TokenFilter _itemFilter\u003e\n  $r25 \u003d $r24.createChildArrayContext($r23, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r25\n  $r26 \u003d JsonGenerator delegate\u003e\n  $r26.writeStartArray(r21, i0)\n  goto B14\n}",
      "B10 {\n  $r12 \u003d TokenFilter _itemFilter\u003e\n  if ($r12 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r17 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r16 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r17 !\u003d $r16) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r19 \u003d TokenFilterContext _filterContext\u003e\n  $r18 \u003d TokenFilter _itemFilter\u003e\n  $r20 \u003d $r19.createChildArrayContext($r18, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r20\n  $r22 \u003d JsonGenerator delegate\u003e\n  $r22.writeStartArray(r21, i0)\n  goto B14\n}",
      "B13 {\n  $r14 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d TokenFilter _itemFilter\u003e\n  $r15 \u003d $r14.createChildArrayContext($r13, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r15\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeEndArray",
    "signature": "void writeEndArray()",
    "visibility": "public",
    "body": "{\r\n    _filterContext \u003d _filterContext.closeArray(delegate);\r\n    if (_filterContext !\u003d null) {\r\n        _itemFilter \u003d _filterContext.getFilter();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r4 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  $r2 \u003d TokenFilterContext _filterContext\u003e\n  $r1 \u003d JsonGenerator delegate\u003e\n  $r3 \u003d $r2.closeArray($r1)\n  TokenFilterContext _filterContext\u003e \u003d $r3\n  $r4 \u003d TokenFilterContext _filterContext\u003e\n  if ($r4 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r6 \u003d $r5.getFilter()\n  TokenFilter _itemFilter\u003e \u003d $r6\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject()",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, true);\r\n        delegate.writeStartObject();\r\n        return;\r\n    }\r\n    TokenFilter f \u003d _filterContext.checkValue(_itemFilter);\r\n    if (f \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(null, false);\r\n        return;\r\n    }\r\n    if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n        f \u003d f.filterStartObject();\r\n    }\r\n    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, true);\r\n        delegate.writeStartObject();\r\n    } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, true);\r\n        delegate.writeStartObject();\r\n    } else {\r\n        // filter out\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If(r27 !\u003d null) → B5 | else → B6",
      "B6 : If(r27 \u003d\u003d $r6) → B7 | else → B8",
      "B8 : If(r27 !\u003d $r7) → B9 | else → B10",
      "B10 : If(r27 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r11 !\u003d $r10) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r25 \u003d TokenFilterContext _filterContext\u003e\n  $r24 \u003d TokenFilter _itemFilter\u003e\n  $r26 \u003d $r25.createChildObjectContext($r24, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r26\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r21 \u003d TokenFilterContext _filterContext\u003e\n  $r20 \u003d TokenFilter _itemFilter\u003e\n  $r22 \u003d $r21.createChildObjectContext($r20, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r22\n  $r23 \u003d JsonGenerator delegate\u003e\n  $r23.writeStartObject()\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r27 \u003d $r5.checkValue($r4)\n  if (r27 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r18 \u003d TokenFilterContext _filterContext\u003e\n  $r19 \u003d $r18.createChildObjectContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r19\n  return\n}",
      "B6 {\n  $r6 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r27 \u003d\u003d $r6) goto B7 else B8\n}",
      "B7 {\n  r27 \u003d r27.filterStartObject()\n}",
      "B8 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r27 !\u003d $r7) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r15 \u003d TokenFilterContext _filterContext\u003e\n  $r16 \u003d $r15.createChildObjectContext(r27, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r16\n  $r17 \u003d JsonGenerator delegate\u003e\n  $r17.writeStartObject()\n  goto B14\n}",
      "B10 {\n  if (r27 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r11 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r10 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r11 !\u003d $r10) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r12 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d $r12.createChildObjectContext(r27, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r13\n  $r14 \u003d JsonGenerator delegate\u003e\n  $r14.writeStartObject()\n  goto B14\n}",
      "B13 {\n  $r8 \u003d TokenFilterContext _filterContext\u003e\n  $r9 \u003d $r8.createChildObjectContext(r27, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r9\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, true);\r\n        delegate.writeStartObject(forValue);\r\n        return;\r\n    }\r\n    TokenFilter f \u003d _filterContext.checkValue(_itemFilter);\r\n    if (f \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(null, false);\r\n        return;\r\n    }\r\n    if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n        f \u003d f.filterStartObject();\r\n    }\r\n    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, true);\r\n        delegate.writeStartObject(forValue);\r\n    } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        _checkParentPath(false);\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, true);\r\n        delegate.writeStartObject(forValue);\r\n    } else {\r\n        // filter out\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, false);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If(r28 !\u003d null) → B5 | else → B6",
      "B6 : If(r28 \u003d\u003d $r6) → B7 | else → B8",
      "B8 : If(r28 !\u003d $r7) → B9 | else → B10",
      "B10 : If(r28 \u003d\u003d null) → B11 | else → B13",
      "B11 : If($r11 !\u003d $r10) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r26 \u003d TokenFilterContext _filterContext\u003e\n  $r25 \u003d TokenFilter _itemFilter\u003e\n  $r27 \u003d $r26.createChildObjectContext($r25, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r27\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r22 \u003d TokenFilterContext _filterContext\u003e\n  $r21 \u003d TokenFilter _itemFilter\u003e\n  $r23 \u003d $r22.createChildObjectContext($r21, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r23\n  $r24 \u003d JsonGenerator delegate\u003e\n  $r24.writeStartObject(r14)\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r28 \u003d $r5.checkValue($r4)\n  if (r28 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r19 \u003d TokenFilterContext _filterContext\u003e\n  $r20 \u003d $r19.createChildObjectContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r20\n  return\n}",
      "B6 {\n  $r6 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r28 \u003d\u003d $r6) goto B7 else B8\n}",
      "B7 {\n  r28 \u003d r28.filterStartObject()\n}",
      "B8 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r28 !\u003d $r7) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r16 \u003d TokenFilterContext _filterContext\u003e\n  $r17 \u003d $r16.createChildObjectContext(r28, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r17\n  $r18 \u003d JsonGenerator delegate\u003e\n  $r18.writeStartObject(r14)\n  goto B14\n}",
      "B10 {\n  if (r28 \u003d\u003d null) goto B11 else B13\n}",
      "B11 {\n  $r11 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r10 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r11 !\u003d $r10) goto B12 else B13\n}",
      "B12 {\n  r0._checkParentPath(0)\n  $r12 \u003d TokenFilterContext _filterContext\u003e\n  $r13 \u003d $r12.createChildObjectContext(r28, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r13\n  $r15 \u003d JsonGenerator delegate\u003e\n  $r15.writeStartObject(r14)\n  goto B14\n}",
      "B13 {\n  $r8 \u003d TokenFilterContext _filterContext\u003e\n  $r9 \u003d $r8.createChildObjectContext(r28, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r9\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...1)",
        "body": "{\r\n    if (isMatch) {\r\n        ++_matchCount;\r\n    }\r\n    // only need to construct path if parent wasn\u0027t written\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (isMatch \u0026\u0026 !_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      },
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(java.lang.Object,int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, false);\r\n        return;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(_itemFilter, true);\r\n        delegate.writeStartObject(forValue, size);\r\n        return;\r\n    }\r\n    TokenFilter f \u003d _filterContext.checkValue(_itemFilter);\r\n    if (f \u003d\u003d null) {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(null, false);\r\n        return;\r\n    }\r\n    if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n        f \u003d f.filterStartObject();\r\n    }\r\n    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkParentPath();\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, true);\r\n        delegate.writeStartObject(forValue, size);\r\n    } else {\r\n        _filterContext \u003d _filterContext.createChildObjectContext(f, false);\r\n    }\r\n}",
    "nodes": 12,
    "edges": 13,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d $r2) → B3 | else → B4",
      "B4 : If(r23 !\u003d null) → B5 | else → B6",
      "B6 : If(r23 \u003d\u003d $r6) → B7 | else → B8",
      "B8 : If(r23 !\u003d $r7) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  i0 :\u003d @parameter1: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r21 \u003d TokenFilterContext _filterContext\u003e\n  $r20 \u003d TokenFilter _itemFilter\u003e\n  $r22 \u003d $r21.createChildObjectContext($r20, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r22\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  $r17 \u003d TokenFilterContext _filterContext\u003e\n  $r16 \u003d TokenFilter _itemFilter\u003e\n  $r18 \u003d $r17.createChildObjectContext($r16, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r18\n  $r19 \u003d JsonGenerator delegate\u003e\n  $r19.writeStartObject(r12, i0)\n  return\n}",
      "B4 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r23 \u003d $r5.checkValue($r4)\n  if (r23 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r14 \u003d TokenFilterContext _filterContext\u003e\n  $r15 \u003d $r14.createChildObjectContext(null, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r15\n  return\n}",
      "B6 {\n  $r6 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r23 \u003d\u003d $r6) goto B7 else B8\n}",
      "B7 {\n  r23 \u003d r23.filterStartObject()\n}",
      "B8 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r23 !\u003d $r7) goto B9 else B10\n}",
      "B9 {\n  r0._checkParentPath()\n  $r10 \u003d TokenFilterContext _filterContext\u003e\n  $r11 \u003d $r10.createChildObjectContext(r23, 1)\n  TokenFilterContext _filterContext\u003e \u003d $r11\n  $r13 \u003d JsonGenerator delegate\u003e\n  $r13.writeStartObject(r12, i0)\n  goto B11\n}",
      "B10 {\n  $r8 \u003d TokenFilterContext _filterContext\u003e\n  $r9 \u003d $r8.createChildObjectContext(r23, 0)\n  TokenFilterContext _filterContext\u003e \u003d $r9\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject()",
    "visibility": "public",
    "body": "{\r\n    _filterContext \u003d _filterContext.closeObject(delegate);\r\n    if (_filterContext !\u003d null) {\r\n        _itemFilter \u003d _filterContext.getFilter();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r4 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  $r2 \u003d TokenFilterContext _filterContext\u003e\n  $r1 \u003d JsonGenerator delegate\u003e\n  $r3 \u003d $r2.closeObject($r1)\n  TokenFilterContext _filterContext\u003e \u003d $r3\n  $r4 \u003d TokenFilterContext _filterContext\u003e\n  if ($r4 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r6 \u003d $r5.getFilter()\n  TokenFilter _itemFilter\u003e \u003d $r6\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    TokenFilter state \u003d _filterContext.setFieldName(name);\r\n    if (state \u003d\u003d null) {\r\n        _itemFilter \u003d null;\r\n        return;\r\n    }\r\n    if (state \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d state;\r\n        delegate.writeFieldName(name);\r\n        return;\r\n    }\r\n    state \u003d state.includeProperty(name);\r\n    _itemFilter \u003d state;\r\n    if (state \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkPropertyParentPath();\r\n    }\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B2",
      "B2 : If(r6 !\u003d $r3) → B3 | else → B4",
      "B4 : If(r7 !\u003d $r4) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $r2 \u003d TokenFilterContext _filterContext\u003e\n  r6 \u003d $r2.setFieldName(r1)\n  if (r6 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  TokenFilter _itemFilter\u003e \u003d null\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 !\u003d $r3) goto B3 else B4\n}",
      "B3 {\n  TokenFilter _itemFilter\u003e \u003d r6\n  $r5 \u003d JsonGenerator delegate\u003e\n  $r5.writeFieldName(r1)\n  return\n}",
      "B4 {\n  r7 \u003d r6.includeProperty(r1)\n  TokenFilter _itemFilter\u003e \u003d r7\n  $r4 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 !\u003d $r4) goto B5 else B6\n}",
      "B5 {\n  r0._checkPropertyParentPath()\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkPropertyParentPath(...0)",
        "body": "{\r\n    ++_matchCount;\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (!_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    TokenFilter state \u003d _filterContext.setFieldName(name.getValue());\r\n    if (state \u003d\u003d null) {\r\n        _itemFilter \u003d null;\r\n        return;\r\n    }\r\n    if (state \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _itemFilter \u003d state;\r\n        delegate.writeFieldName(name);\r\n        return;\r\n    }\r\n    state \u003d state.includeProperty(name.getValue());\r\n    _itemFilter \u003d state;\r\n    if (state \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        _checkPropertyParentPath();\r\n    }\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r8 !\u003d null) → B1 | else → B2",
      "B2 : If(r8 !\u003d $r4) → B3 | else → B4",
      "B4 : If(r9 !\u003d $r6) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  SerializableString\n  $r2 \u003d TokenFilterContext _filterContext\u003e\n  $r3 \u003d r1.getValue()\n  r8 \u003d $r2.setFieldName($r3)\n  if (r8 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  TokenFilter _itemFilter\u003e \u003d null\n  return\n}",
      "B2 {\n  $r4 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r8 !\u003d $r4) goto B3 else B4\n}",
      "B3 {\n  TokenFilter _itemFilter\u003e \u003d r8\n  $r7 \u003d JsonGenerator delegate\u003e\n  $r7.writeFieldName(r1)\n  return\n}",
      "B4 {\n  $r5 \u003d r1.getValue()\n  r9 \u003d r8.includeProperty($r5)\n  TokenFilter _itemFilter\u003e \u003d r9\n  $r6 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r9 !\u003d $r6) goto B5 else B6\n}",
      "B5 {\n  r0._checkPropertyParentPath()\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkPropertyParentPath(...0)",
        "body": "{\r\n    ++_matchCount;\r\n    if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n        _filterContext.writePath(delegate);\r\n    } else if (_inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n        // path has already been written, except for maybe field name\r\n        _filterContext.ensureFieldNameWritten(delegate);\r\n    }\r\n    // also: if no multiple matches desired, short-cut checks\r\n    if (!_allowMultipleMatches) {\r\n        // Mark parents as \"skip\" so that further check calls are not made\r\n        _filterContext.skipParentChecks();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeString",
    "signature": "void writeString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeString(value)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeString(value);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeString(r4)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeString(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeString",
    "signature": "void writeString(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        String value \u003d new String(text, offset, len);\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeString(value)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeString(text, offset, len);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r8 !\u003d null) → B4 | else → B5",
      "B5 : If(r8 \u003d\u003d $r9) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r4 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d String\n  new String(r4, i0, i1)\n  $r7 \u003d TokenFilterContext _filterContext\u003e\n  $r6 \u003d TokenFilter _itemFilter\u003e\n  r8 \u003d $r7.checkValue($r6)\n  if (r8 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r9 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r8 \u003d\u003d $r9) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r8.includeString($r5)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r10 \u003d JsonGenerator delegate\u003e\n  $r10.writeString(r4, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeString",
    "signature": "void writeString(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeString(value.getValue())) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeString(value);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  SerializableString\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $r9 \u003d r4.getValue()\n  $z0 \u003d r7.includeString($r9)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r10 \u003d JsonGenerator delegate\u003e\n  $r10.writeString(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeString",
    "signature": "void writeString(java.io.Reader,int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            // [core#609]: do need to implement, but with 2.10.x TokenFilter no\r\n            // useful method to call so will be mostly unfiltered\r\n            if (!state.includeString(reader, len)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeString(reader, len);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Reader\n  i0 :\u003d @parameter1: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeString(r4, i0)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeString(r4, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRawUTF8String",
    "signature": "void writeRawUTF8String(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRawUTF8String(text, offset, length);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRawUTF8String(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeUTF8String",
    "signature": "void writeUTF8String(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // not exact match, but best we can do\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeUTF8String(text, offset, length);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeUTF8String(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRaw(text);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRaw(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRaw(text, offset, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRaw(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRaw",
    "signature": "void writeRaw(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRaw(text);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  SerializableString\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRaw(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRaw(text, offset, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRaw(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRaw(c);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  c0 :\u003d @parameter0: char\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d JsonGenerator delegate\u003e\n  $r1.writeRaw(c0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRawValue(text);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRawValue(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRawValue(text, offset, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRawValue(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkRawValueWrite()) {\r\n        delegate.writeRawValue(text, offset, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $z0 \u003d r0._checkRawValueWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.writeRawValue(r1, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkRawValueWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeRawValue()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeBinary",
    "signature": "void writeBinary(com.fasterxml.jackson.core.Base64Variant,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkBinaryWrite()) {\r\n        delegate.writeBinary(b64variant, data, offset, len);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Base64Variant\n  r2 :\u003d @parameter1: byte[]\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  $z0 \u003d r0._checkBinaryWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeBinary(r1, r2, i0, i1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkBinaryWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeBinary()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeBinary",
    "signature": "int writeBinary(com.fasterxml.jackson.core.Base64Variant,java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    if (_checkBinaryWrite()) {\r\n        return delegate.writeBinary(b64variant, data, dataLength);\r\n    }\r\n    return -1;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Base64Variant\n  InputStream\n  i0 :\u003d @parameter2: int\n  $z0 \u003d r0._checkBinaryWrite()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $i1 \u003d $r3.writeBinary(r1, r2, i0)\n  return\n}",
      "B2 {\n  $i3 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkBinaryWrite(...0)",
        "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n        return true;\r\n    }\r\n    if (_itemFilter.includeBinary()) {\r\n        // close enough?\r\n        _checkParentPath();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(short)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  s0 :\u003d @parameter0: short\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $i1 \u003d (int) s0\n  $z0 \u003d r6.includeNumber($i1)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNumber(s0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  i0 :\u003d @parameter0: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r6.includeNumber(i0)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNumber(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(long)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  l0 :\u003d @parameter0: long\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r6.includeNumber(l0)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNumber(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigInteger)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  BigInteger\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeNumber(r4)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeNumber(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(double)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  d0 :\u003d @parameter0: double\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r6.includeNumber(d0)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNumber(d0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(float)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  f0 :\u003d @parameter0: float\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r6.includeNumber(f0)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNumber(f0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigDecimal)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNumber(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  BigDecimal\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeNumber(r4)\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeNumber(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeRawValue()) {\r\n                // close enough?\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(encodedValue);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeRawValue()\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeNumber(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNumber",
    "signature": "void writeNumber(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeRawValue()) {\r\n                // close enough?\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNumber(encodedValueBuffer, offset, length);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r7 !\u003d null) → B4 | else → B5",
      "B5 : If(r7 \u003d\u003d $r8) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  r4 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r6 \u003d TokenFilterContext _filterContext\u003e\n  $r5 \u003d TokenFilter _itemFilter\u003e\n  r7 \u003d $r6.checkValue($r5)\n  if (r7 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r8 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r7 \u003d\u003d $r8) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r7.includeRawValue()\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r9 \u003d JsonGenerator delegate\u003e\n  $r9.writeNumber(r4, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeBoolean",
    "signature": "void writeBoolean(boolean)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeBoolean(v)) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeBoolean(v);\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z1 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  z0 :\u003d @parameter0: boolean\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z1 \u003d r6.includeBoolean(z0)\n  if ($z1 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeBoolean(z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeNull",
    "signature": "void writeNull()",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter \u003d\u003d null) {\r\n        return;\r\n    }\r\n    if (_itemFilter !\u003d TokenFilter.INCLUDE_ALL) {\r\n        TokenFilter state \u003d _filterContext.checkValue(_itemFilter);\r\n        if (state \u003d\u003d null) {\r\n            return;\r\n        }\r\n        if (state !\u003d TokenFilter.INCLUDE_ALL) {\r\n            if (!state.includeNull()) {\r\n                return;\r\n            }\r\n        }\r\n        _checkParentPath();\r\n    }\r\n    delegate.writeNull();\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d $r2) → B3 | else → B9",
      "B3 : If(r6 !\u003d null) → B4 | else → B5",
      "B5 : If(r6 \u003d\u003d $r7) → B6 | else → B8",
      "B6 : If($z0 !\u003d 0) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d TokenFilter _itemFilter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B3 else B9\n}",
      "B3 {\n  $r5 \u003d TokenFilterContext _filterContext\u003e\n  $r4 \u003d TokenFilter _itemFilter\u003e\n  r6 \u003d $r5.checkValue($r4)\n  if (r6 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r7 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r6 \u003d\u003d $r7) goto B6 else B8\n}",
      "B6 {\n  $z0 \u003d r6.includeNull()\n  if ($z0 !\u003d 0) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r0._checkParentPath()\n}",
      "B9 {\n  $r8 \u003d JsonGenerator delegate\u003e\n  $r8.writeNull()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringGeneratorDelegate#_checkParentPath(...0)",
        "body": "{\r\n    _checkParentPath(true);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeOmittedField",
    "signature": "void writeOmittedField(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // Hmmh. Not sure how this would work but...\r\n    if (_itemFilter !\u003d null) {\r\n        delegate.writeOmittedField(fieldName);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  String\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeOmittedField(r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeObjectId",
    "signature": "void writeObjectId(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter !\u003d null) {\r\n        delegate.writeObjectId(id);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeObjectId(r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeObjectRef",
    "signature": "void writeObjectRef(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter !\u003d null) {\r\n        delegate.writeObjectRef(id);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeObjectRef(r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate",
    "methodName": "writeTypeId",
    "signature": "void writeTypeId(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (_itemFilter !\u003d null) {\r\n        delegate.writeTypeId(id);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringGeneratorDelegate\n  Object\n  $r1 \u003d TokenFilter _itemFilter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeTypeId(r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "currentTokenId",
    "signature": "int currentTokenId()",
    "visibility": "public",
    "body": "{\r\n    final JsonToken t \u003d _currToken;\r\n    return (t \u003d\u003d null) ? JsonTokenId.ID_NO_TOKEN : t.id();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  r1 \u003d JsonToken _currToken\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d 0\n  goto B3\n}",
      "B2 {\n  $i0 \u003d r1.id()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "hasCurrentToken",
    "signature": "boolean hasCurrentToken()",
    "visibility": "public",
    "body": "{\r\n    return _currToken !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "hasTokenId",
    "signature": "boolean hasTokenId(int)",
    "visibility": "public",
    "body": "{\r\n    final JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d null) {\r\n        return (JsonTokenId.ID_NO_TOKEN \u003d\u003d id);\r\n    }\r\n    return t.id() \u003d\u003d id;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B5",
      "B1 : If(0 !\u003d i0) → B2 | else → B3",
      "B5 : If($i1 !\u003d i0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  i0 :\u003d @parameter0: int\n  r1 \u003d JsonToken _currToken\u003e\n  if (r1 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  if (0 !\u003d i0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i1 \u003d r1.id()\n  if ($i1 !\u003d i0) goto B6 else B7\n}",
      "B6 {\n  $z1 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z1 \u003d 0\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "hasToken",
    "signature": "boolean hasToken(com.fasterxml.jackson.core.JsonToken)",
    "visibility": "public",
    "body": "{\r\n    return (_currToken \u003d\u003d t);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  JsonToken\n  $r2 \u003d JsonToken _currToken\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "isExpectedStartArrayToken",
    "signature": "boolean isExpectedStartArrayToken()",
    "visibility": "public",
    "body": "{\r\n    return _currToken \u003d\u003d JsonToken.START_ARRAY;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken START_ARRAY\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "isExpectedStartObjectToken",
    "signature": "boolean isExpectedStartObjectToken()",
    "visibility": "public",
    "body": "{\r\n    return _currToken \u003d\u003d JsonToken.START_OBJECT;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken START_OBJECT\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getCurrentName",
    "signature": "java.lang.String getCurrentName()",
    "visibility": "public",
    "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r3 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If($r5 !\u003d $r4) → B2 | else → B6",
      "B2 : If($r7 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  r1 \u003d r0._filterContext()\n  $r3 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken START_OBJECT\u003e\n  if ($r3 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d JsonToken _currToken\u003e\n  $r4 \u003d JsonToken START_ARRAY\u003e\n  if ($r5 !\u003d $r4) goto B2 else B6\n}",
      "B2 {\n  $r7 \u003d r1.getParent()\n  if ($r7 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d null\n  goto B5\n}",
      "B4 {\n  $r8 \u003d $r7.getCurrentName()\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r6 \u003d r1.getCurrentName()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#_filterContext(...0)",
        "body": "{\r\n    if (_exposedContext !\u003d null) {\r\n        return _exposedContext;\r\n    }\r\n    return _headContext;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "currentName",
    "signature": "java.lang.String currentName()",
    "visibility": "public",
    "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r3 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If($r5 !\u003d $r4) → B2 | else → B6",
      "B2 : If($r7 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  r1 \u003d r0._filterContext()\n  $r3 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken START_OBJECT\u003e\n  if ($r3 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d JsonToken _currToken\u003e\n  $r4 \u003d JsonToken START_ARRAY\u003e\n  if ($r5 !\u003d $r4) goto B2 else B6\n}",
      "B2 {\n  $r7 \u003d r1.getParent()\n  if ($r7 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d null\n  goto B5\n}",
      "B4 {\n  $r8 \u003d $r7.getCurrentName()\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r6 \u003d r1.getCurrentName()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#_filterContext(...0)",
        "body": "{\r\n    if (_exposedContext !\u003d null) {\r\n        return _exposedContext;\r\n    }\r\n    return _headContext;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "clearCurrentToken",
    "signature": "void clearCurrentToken()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        _lastClearedToken \u003d _currToken;\r\n        _currToken \u003d null;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  JsonToken _lastClearedToken\u003e \u003d $r2\n  JsonToken _currToken\u003e \u003d null\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don\u0027t like all\r\n    //    conditionals; and it seems odd to return `null` but NOT considering input\r\n    //    as closed... would love a rewrite to simplify/clear up logic here.\r\n    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\r\n    // check for no buffered context _exposedContext - null\r\n    // If all the conditions matches then check for scalar / non-scalar property\r\n    if (!_allowMultipleMatches \u0026\u0026 (_currToken !\u003d null) \u0026\u0026 (_exposedContext \u003d\u003d null)) {\r\n        // if scalar, and scalar not present in obj/array and _inclusion \u003d\u003d ONLY_INCLUDE_ALL\r\n        // and INCLUDE_ALL matched once, return null\r\n        if (_currToken.isScalarValue() \u0026\u0026 !_headContext.isStartHandled() \u0026\u0026 _inclusion \u003d\u003d Inclusion.ONLY_INCLUDE_ALL \u0026\u0026 (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL)) {\r\n            return (_currToken \u003d null);\r\n        }\r\n    }\r\n    // Anything buffered?\r\n    TokenFilterContext ctxt \u003d _exposedContext;\r\n    if (ctxt !\u003d null) {\r\n        while (true) {\r\n            JsonToken t \u003d ctxt.nextTokenToRead();\r\n            if (t !\u003d null) {\r\n                _currToken \u003d t;\r\n                return t;\r\n            }\r\n            // all done with buffered stuff?\r\n            if (ctxt \u003d\u003d _headContext) {\r\n                _exposedContext \u003d null;\r\n                if (ctxt.inArray()) {\r\n                    t \u003d delegate.getCurrentToken();\r\n                    _currToken \u003d t;\r\n                    if (_currToken \u003d\u003d JsonToken.END_ARRAY) {\r\n                        _headContext \u003d _headContext.getParent();\r\n                        _itemFilter \u003d _headContext.getFilter();\r\n                    }\r\n                    return t;\r\n                }\r\n                // 19-Jul-2021, tatu: [core#700]: following was commented out?!\r\n                // Almost! Most likely still have the current token;\r\n                // with the sole exception of FIELD_NAME\r\n                t \u003d delegate.currentToken();\r\n                if (t \u003d\u003d JsonToken.END_OBJECT) {\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                }\r\n                if (t !\u003d JsonToken.FIELD_NAME) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n                break;\r\n            }\r\n            // If not, traverse down the context chain\r\n            ctxt \u003d _headContext.findChildOf(ctxt);\r\n            _exposedContext \u003d ctxt;\r\n            if (ctxt \u003d\u003d null) {\r\n                // should never occur\r\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\r\n            }\r\n        }\r\n    }\r\n    // If not, need to read more. If we got any:\r\n    JsonToken t \u003d delegate.nextToken();\r\n    if (t \u003d\u003d null) {\r\n        // no strict need to close, since we have no state here\r\n        _currToken \u003d t;\r\n        return t;\r\n    }\r\n    // otherwise... to include or not?\r\n    TokenFilter f;\r\n    switch(t.id()) {\r\n        case JsonTokenId.ID_NOT_AVAILABLE:\r\n            throw _constructError(\"`JsonToken.NOT_AVAILABLE` received: ensure all input is fed to the Parser before use\");\r\n        case ID_START_ARRAY:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartArray();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildArrayContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            break;\r\n        case ID_START_OBJECT:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartObject();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildObjectContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            // note: inclusion of surrounding Object handled separately via\r\n            // FIELD_NAME\r\n            break;\r\n        case ID_END_ARRAY:\r\n        case ID_END_OBJECT:\r\n            {\r\n                boolean returnEnd \u003d _headContext.isStartHandled();\r\n                f \u003d _headContext.getFilter();\r\n                if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                    if (t.id() \u003d\u003d JsonTokenId.ID_END_ARRAY) {\r\n                        f.filterFinishArray();\r\n                    } else {\r\n                        f.filterFinishObject();\r\n                    }\r\n                }\r\n                _headContext \u003d _headContext.getParent();\r\n                _itemFilter \u003d _headContext.getFilter();\r\n                if (returnEnd) {\r\n                    return (_currToken \u003d t);\r\n                }\r\n            }\r\n            break;\r\n        case ID_FIELD_NAME:\r\n            {\r\n                final String name \u003d delegate.currentName();\r\n                // note: this will also set \u0027needToHandleName\u0027\r\n                f \u003d _headContext.setFieldName(name);\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _itemFilter \u003d f;\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                f \u003d f.includeProperty(name);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                            return (_currToken \u003d t);\r\n                        }\r\n                    } else {\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                    }\r\n                }\r\n                if (_inclusion !\u003d Inclusion.ONLY_INCLUDE_ALL) {\r\n                    t \u003d _nextTokenWithBuffering(_headContext);\r\n                    if (t !\u003d null) {\r\n                        _currToken \u003d t;\r\n                        return t;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        default:\r\n            // scalar value\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f !\u003d null) {\r\n                f \u003d _headContext.checkValue(f);\r\n                if ((f \u003d\u003d TokenFilter.INCLUDE_ALL) || ((f !\u003d null) \u0026\u0026 f.includeValue(delegate))) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise not included (leaves must be explicitly included)\r\n            break;\r\n    }\r\n    // We get here if token was not yet found; offlined handling\r\n    return _nextToken2();\r\n}",
    "nodes": 90,
    "edges": 125,
    "cc": 37,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B8",
      "B1 : If($r80 \u003d\u003d null) → B2 | else → B8",
      "B2 : If($r81 !\u003d null) → B3 | else → B8",
      "B3 : If($z5 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($z6 !\u003d 0) → B5 | else → B8",
      "B5 : If($r85 !\u003d $r84) → B6 | else → B8",
      "B6 : If($r87 !\u003d $r86) → B7 | else → B8",
      "B8 : If($r88 \u003d\u003d null) → B9 | else → B23",
      "B9 : If($r63 \u003d\u003d null) → B10 | else → B11",
      "B11 : If(r89 !\u003d $r61) → B12 | else → B20",
      "B12 : If($z4 \u003d\u003d false) → B13 | else → B16",
      "B13 : If($r75 !\u003d $r74) → B14 | else → B15",
      "B16 : If(r91 !\u003d $r66) → B17 | else → B18",
      "B18 : If(r91 \u003d\u003d $r67) → B19 | else → B23",
      "B20 : If(r89 !\u003d null) → B21 | else → B22",
      "B23 : If($r68 !\u003d null) → B24 | else → B25",
      "B25 : If(switch-on $i0) → B26 | else → B81",
      "B27 : If(r92 !\u003d $r15) → B28 | else → B29",
      "B29 : If(r92 !\u003d null) → B30 | else → B31",
      "B31 : If(r93 !\u003d null) → B32 | else → B33",
      "B33 : If(r93 \u003d\u003d $r17) → B34 | else → B35",
      "B35 : If(r93 !\u003d $r18) → B36 | else → B37",
      "B37 : If(r93 \u003d\u003d null) → B38 | else → B40",
      "B38 : If($r25 !\u003d $r24) → B39 | else → B40",
      "B40 : If($r22 !\u003d $r21) → B41 | else → B89",
      "B41 : If(r94 \u003d\u003d null) → B42 | else → B89",
      "B43 : If(r95 !\u003d $r37) → B44 | else → B45",
      "B45 : If(r95 !\u003d null) → B46 | else → B47",
      "B47 : If(r96 !\u003d null) → B48 | else → B49",
      "B49 : If(r96 \u003d\u003d $r39) → B50 | else → B51",
      "B51 : If(r96 !\u003d $r40) → B52 | else → B53",
      "B53 : If(r96 \u003d\u003d null) → B54 | else → B56",
      "B54 : If($r47 !\u003d $r46) → B55 | else → B56",
      "B56 : If($r44 !\u003d $r43) → B57 | else → B89",
      "B57 : If(r97 \u003d\u003d null) → B58 | else → B89",
      "B59 : If(r98 \u003d\u003d null) → B60 | else → B64",
      "B60 : If(r98 \u003d\u003d $r36) → B61 | else → B64",
      "B61 : If($i1 !\u003d 4) → B62 | else → B63",
      "B64 : If(z7 \u003d\u003d false) → B65 | else → B66",
      "B67 : If(r104 !\u003d $r4) → B68 | else → B69",
      "B69 : If(r104 !\u003d null) → B70 | else → B71",
      "B71 : If(r105 !\u003d null) → B72 | else → B73",
      "B73 : If(r105 !\u003d $r5) → B74 | else → B78",
      "B74 : If($z1 \u003d\u003d false) → B75 | else → B77",
      "B75 : If($r10 !\u003d $r9) → B76 | else → B78",
      "B78 : If($r106 \u003d\u003d $r107) → B79 | else → B89",
      "B79 : If(r108 \u003d\u003d null) → B80 | else → B89",
      "B81 : If(r109 !\u003d $r57) → B82 | else → B83",
      "B83 : If(r109 \u003d\u003d null) → B84 | else → B89",
      "B84 : If(r110 \u003d\u003d $r59) → B85 | else → B87",
      "B85 : If(r110 \u003d\u003d null) → B86 | else → B89",
      "B86 : If($z3 \u003d\u003d false) → B87 | else → B89",
      "B87 : If($z2 \u003d\u003d false) → B88 | else → B89"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $z0 \u003d FilteringParserDelegate: boolean _allowMultipleMatches\u003e\n  if ($z0 !\u003d 0) goto B1 else B8\n}",
      "B1 {\n  $r80 \u003d JsonToken _currToken\u003e\n  if ($r80 \u003d\u003d null) goto B2 else B8\n}",
      "B2 {\n  $r81 \u003d TokenFilterContext _exposedContext\u003e\n  if ($r81 !\u003d null) goto B3 else B8\n}",
      "B3 {\n  $r82 \u003d JsonToken _currToken\u003e\n  $z5 \u003d $r82.isScalarValue()\n  if ($z5 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $r83 \u003d TokenFilterContext _headContext\u003e\n  $z6 \u003d $r83.isStartHandled()\n  if ($z6 !\u003d 0) goto B5 else B8\n}",
      "B5 {\n  $r85 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r84 \u003d TokenFilter$Inclusion ONLY_INCLUDE_ALL\u003e\n  if ($r85 !\u003d $r84) goto B6 else B8\n}",
      "B6 {\n  $r87 \u003d TokenFilter _itemFilter\u003e\n  $r86 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r87 !\u003d $r86) goto B7 else B8\n}",
      "B7 {\n  JsonToken _currToken\u003e \u003d null\n  return\n}",
      "B8 {\n  $r88 \u003d TokenFilterContext _exposedContext\u003e\n  r89 \u003d $r88\n  if ($r88 \u003d\u003d null) goto B9 else B23\n}",
      "B9 {\n  $r63 \u003d r89.nextTokenToRead()\n  if ($r63 \u003d\u003d null) goto B10 else B11\n}",
      "B10 {\n  JsonToken _currToken\u003e \u003d $r63\n  return\n}",
      "B11 {\n  $r61 \u003d TokenFilterContext _headContext\u003e\n  if (r89 !\u003d $r61) goto B12 else B20\n}",
      "B12 {\n  TokenFilterContext _exposedContext\u003e \u003d null\n  $z4 \u003d r89.inArray()\n  if ($z4 \u003d\u003d false) goto B13 else B16\n}",
      "B13 {\n  $r73 \u003d JsonParser delegate\u003e\n  r90 \u003d $r73.getCurrentToken()\n  JsonToken _currToken\u003e \u003d r90\n  $r75 \u003d JsonToken _currToken\u003e\n  $r74 \u003d JsonToken END_ARRAY\u003e\n  if ($r75 !\u003d $r74) goto B14 else B15\n}",
      "B14 {\n  $r76 \u003d TokenFilterContext _headContext\u003e\n  $r77 \u003d $r76.getParent()\n  TokenFilterContext _headContext\u003e \u003d $r77\n  $r78 \u003d TokenFilterContext _headContext\u003e\n  $r79 \u003d $r78.getFilter()\n  TokenFilter _itemFilter\u003e \u003d $r79\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $r65 \u003d JsonParser delegate\u003e\n  r91 \u003d $r65.currentToken()\n  $r66 \u003d JsonToken END_OBJECT\u003e\n  if (r91 !\u003d $r66) goto B17 else B18\n}",
      "B17 {\n  $r69 \u003d TokenFilterContext _headContext\u003e\n  $r70 \u003d $r69.getParent()\n  TokenFilterContext _headContext\u003e \u003d $r70\n  $r71 \u003d TokenFilterContext _headContext\u003e\n  $r72 \u003d $r71.getFilter()\n  TokenFilter _itemFilter\u003e \u003d $r72\n}",
      "B18 {\n  $r67 \u003d JsonToken FIELD_NAME\u003e\n  if (r91 \u003d\u003d $r67) goto B19 else B23\n}",
      "B19 {\n  JsonToken _currToken\u003e \u003d r91\n  return\n}",
      "B20 {\n  $r62 \u003d TokenFilterContext _headContext\u003e\n  r89 \u003d $r62.findChildOf(r89)\n  TokenFilterContext _exposedContext\u003e \u003d r89\n  if (r89 !\u003d null) goto B21 else B22\n}",
      "B21 {\n  $r64 \u003d r0._constructError(\"Unexpected problem: chain of filtered context broken\")\n  throw $r64\n}",
      "B22 {\n  goto B9\n}",
      "B23 {\n  $r1 \u003d JsonParser delegate\u003e\n  $r68 \u003d $r1.nextToken()\n  if ($r68 !\u003d null) goto B24 else B25\n}",
      "B24 {\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B25 {\n  $i0 \u003d $r68.id()\n  TokenFilter _itemFilter\u003e; }\n}",
      "B26 {\n  $r56 \u003d r0._constructError(\"`JsonToken.NOT_AVAILABLE` received: ensure all input is fed to the Parser before use\")\n  throw $r56\n}",
      "B27 {\n  r92 \u003d TokenFilter _itemFilter\u003e\n  $r15 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r92 !\u003d $r15) goto B28 else B29\n}",
      "B28 {\n  $r32 \u003d TokenFilterContext _headContext\u003e\n  $r33 \u003d $r32.createChildArrayContext(r92, 1)\n  TokenFilterContext _headContext\u003e \u003d $r33\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B29 {\n  if (r92 !\u003d null) goto B30 else B31\n}",
      "B30 {\n  $r31 \u003d JsonParser delegate\u003e\n  $r31.skipChildren()\n  goto B89\n}",
      "B31 {\n  $r16 \u003d TokenFilterContext _headContext\u003e\n  r93 \u003d $r16.checkValue(r92)\n  if (r93 !\u003d null) goto B32 else B33\n}",
      "B32 {\n  $r30 \u003d JsonParser delegate\u003e\n  $r30.skipChildren()\n  goto B89\n}",
      "B33 {\n  $r17 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r93 \u003d\u003d $r17) goto B34 else B35\n}",
      "B34 {\n  r93 \u003d r93.filterStartArray()\n}",
      "B35 {\n  TokenFilter _itemFilter\u003e \u003d r93\n  $r18 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r93 !\u003d $r18) goto B36 else B37\n}",
      "B36 {\n  $r28 \u003d TokenFilterContext _headContext\u003e\n  $r29 \u003d $r28.createChildArrayContext(r93, 1)\n  TokenFilterContext _headContext\u003e \u003d $r29\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B37 {\n  if (r93 \u003d\u003d null) goto B38 else B40\n}",
      "B38 {\n  $r25 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r24 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r25 !\u003d $r24) goto B39 else B40\n}",
      "B39 {\n  $r26 \u003d TokenFilterContext _headContext\u003e\n  $r27 \u003d $r26.createChildArrayContext(r93, 1)\n  TokenFilterContext _headContext\u003e \u003d $r27\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B40 {\n  $r19 \u003d TokenFilterContext _headContext\u003e\n  $r20 \u003d $r19.createChildArrayContext(r93, 0)\n  TokenFilterContext _headContext\u003e \u003d $r20\n  $r22 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r21 \u003d TokenFilter$Inclusion INCLUDE_ALL_AND_PATH\u003e\n  if ($r22 !\u003d $r21) goto B41 else B89\n}",
      "B41 {\n  $r23 \u003d TokenFilterContext _headContext\u003e\n  r94 \u003d r0._nextTokenWithBuffering($r23)\n  if (r94 \u003d\u003d null) goto B42 else B89\n}",
      "B42 {\n  JsonToken _currToken\u003e \u003d r94\n  return\n}",
      "B43 {\n  r95 \u003d TokenFilter _itemFilter\u003e\n  $r37 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r95 !\u003d $r37) goto B44 else B45\n}",
      "B44 {\n  $r54 \u003d TokenFilterContext _headContext\u003e\n  $r55 \u003d $r54.createChildObjectContext(r95, 1)\n  TokenFilterContext _headContext\u003e \u003d $r55\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B45 {\n  if (r95 !\u003d null) goto B46 else B47\n}",
      "B46 {\n  $r53 \u003d JsonParser delegate\u003e\n  $r53.skipChildren()\n  goto B89\n}",
      "B47 {\n  $r38 \u003d TokenFilterContext _headContext\u003e\n  r96 \u003d $r38.checkValue(r95)\n  if (r96 !\u003d null) goto B48 else B49\n}",
      "B48 {\n  $r52 \u003d JsonParser delegate\u003e\n  $r52.skipChildren()\n  goto B89\n}",
      "B49 {\n  $r39 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r96 \u003d\u003d $r39) goto B50 else B51\n}",
      "B50 {\n  r96 \u003d r96.filterStartObject()\n}",
      "B51 {\n  TokenFilter _itemFilter\u003e \u003d r96\n  $r40 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r96 !\u003d $r40) goto B52 else B53\n}",
      "B52 {\n  $r50 \u003d TokenFilterContext _headContext\u003e\n  $r51 \u003d $r50.createChildObjectContext(r96, 1)\n  TokenFilterContext _headContext\u003e \u003d $r51\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B53 {\n  if (r96 \u003d\u003d null) goto B54 else B56\n}",
      "B54 {\n  $r47 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r46 \u003d TokenFilter$Inclusion INCLUDE_NON_NULL\u003e\n  if ($r47 !\u003d $r46) goto B55 else B56\n}",
      "B55 {\n  $r48 \u003d TokenFilterContext _headContext\u003e\n  $r49 \u003d $r48.createChildObjectContext(r96, 1)\n  TokenFilterContext _headContext\u003e \u003d $r49\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B56 {\n  $r41 \u003d TokenFilterContext _headContext\u003e\n  $r42 \u003d $r41.createChildObjectContext(r96, 0)\n  TokenFilterContext _headContext\u003e \u003d $r42\n  $r44 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r43 \u003d TokenFilter$Inclusion INCLUDE_ALL_AND_PATH\u003e\n  if ($r44 !\u003d $r43) goto B57 else B89\n}",
      "B57 {\n  $r45 \u003d TokenFilterContext _headContext\u003e\n  r97 \u003d r0._nextTokenWithBuffering($r45)\n  if (r97 \u003d\u003d null) goto B58 else B89\n}",
      "B58 {\n  JsonToken _currToken\u003e \u003d r97\n  return\n}",
      "B59 {\n  $r34 \u003d TokenFilterContext _headContext\u003e\n  z7 \u003d $r34.isStartHandled()\n  $r35 \u003d TokenFilterContext _headContext\u003e\n  r98 \u003d $r35.getFilter()\n  if (r98 \u003d\u003d null) goto B60 else B64\n}",
      "B60 {\n  $r36 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r98 \u003d\u003d $r36) goto B61 else B64\n}",
      "B61 {\n  $i1 \u003d $r68.id()\n  if ($i1 !\u003d 4) goto B62 else B63\n}",
      "B62 {\n  r98.filterFinishArray()\n  goto B64\n}",
      "B63 {\n  r98.filterFinishObject()\n}",
      "B64 {\n  $r99 \u003d TokenFilterContext _headContext\u003e\n  $r100 \u003d $r99.getParent()\n  TokenFilterContext _headContext\u003e \u003d $r100\n  $r101 \u003d TokenFilterContext _headContext\u003e\n  $r102 \u003d $r101.getFilter()\n  TokenFilter _itemFilter\u003e \u003d $r102\n  if (z7 \u003d\u003d false) goto B65 else B66\n}",
      "B65 {\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B66 {\n  goto B89\n}",
      "B67 {\n  $r2 \u003d JsonParser delegate\u003e\n  r103 \u003d $r2.currentName()\n  $r3 \u003d TokenFilterContext _headContext\u003e\n  r104 \u003d $r3.setFieldName(r103)\n  $r4 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r104 !\u003d $r4) goto B68 else B69\n}",
      "B68 {\n  TokenFilter _itemFilter\u003e \u003d r104\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B69 {\n  if (r104 !\u003d null) goto B70 else B71\n}",
      "B70 {\n  $r13 \u003d JsonParser delegate\u003e\n  $r13.nextToken()\n  $r14 \u003d JsonParser delegate\u003e\n  $r14.skipChildren()\n  goto B89\n}",
      "B71 {\n  r105 \u003d r104.includeProperty(r103)\n  if (r105 !\u003d null) goto B72 else B73\n}",
      "B72 {\n  $r11 \u003d JsonParser delegate\u003e\n  $r11.nextToken()\n  $r12 \u003d JsonParser delegate\u003e\n  $r12.skipChildren()\n  goto B89\n}",
      "B73 {\n  TokenFilter _itemFilter\u003e \u003d r105\n  $r5 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r105 !\u003d $r5) goto B74 else B78\n}",
      "B74 {\n  $z1 \u003d r0._verifyAllowedMatches()\n  if ($z1 \u003d\u003d false) goto B75 else B77\n}",
      "B75 {\n  $r10 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r9 \u003d TokenFilter$Inclusion INCLUDE_ALL_AND_PATH\u003e\n  if ($r10 !\u003d $r9) goto B76 else B78\n}",
      "B76 {\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B77 {\n  $r7 \u003d JsonParser delegate\u003e\n  $r7.nextToken()\n  $r8 \u003d JsonParser delegate\u003e\n  $r8.skipChildren()\n}",
      "B78 {\n  $r106 \u003d TokenFilter$Inclusion _inclusion\u003e\n  $r107 \u003d TokenFilter$Inclusion ONLY_INCLUDE_ALL\u003e\n  if ($r106 \u003d\u003d $r107) goto B79 else B89\n}",
      "B79 {\n  $r6 \u003d TokenFilterContext _headContext\u003e\n  r108 \u003d r0._nextTokenWithBuffering($r6)\n  if (r108 \u003d\u003d null) goto B80 else B89\n}",
      "B80 {\n  JsonToken _currToken\u003e \u003d r108\n  return\n}",
      "B81 {\n  r109 \u003d TokenFilter _itemFilter\u003e\n  $r57 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r109 !\u003d $r57) goto B82 else B83\n}",
      "B82 {\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B83 {\n  if (r109 \u003d\u003d null) goto B84 else B89\n}",
      "B84 {\n  $r58 \u003d TokenFilterContext _headContext\u003e\n  r110 \u003d $r58.checkValue(r109)\n  $r59 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r110 \u003d\u003d $r59) goto B85 else B87\n}",
      "B85 {\n  if (r110 \u003d\u003d null) goto B86 else B89\n}",
      "B86 {\n  $r60 \u003d JsonParser delegate\u003e\n  $z3 \u003d r110.includeValue($r60)\n  if ($z3 \u003d\u003d false) goto B87 else B89\n}",
      "B87 {\n  $z2 \u003d r0._verifyAllowedMatches()\n  if ($z2 \u003d\u003d false) goto B88 else B89\n}",
      "B88 {\n  JsonToken _currToken\u003e \u003d $r68\n  return\n}",
      "B89 {\n  $r111 \u003d r0._nextToken2()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B23",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B20",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B23",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B9",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B81",
      "B25 --\u003e B43",
      "B25 --\u003e B59",
      "B25 --\u003e B27",
      "B25 --\u003e B67",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B89",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B89",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e B35",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e [EXIT]",
      "B37 --\u003e B38",
      "B37 --\u003e B40",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e [EXIT]",
      "B40 --\u003e B41",
      "B40 --\u003e B89",
      "B41 --\u003e B42",
      "B41 --\u003e B89",
      "B42 --\u003e [EXIT]",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e [EXIT]",
      "B45 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B89",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B89",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B51",
      "B51 --\u003e B52",
      "B51 --\u003e B53",
      "B52 --\u003e [EXIT]",
      "B53 --\u003e B54",
      "B53 --\u003e B56",
      "B54 --\u003e B55",
      "B54 --\u003e B56",
      "B55 --\u003e [EXIT]",
      "B56 --\u003e B57",
      "B56 --\u003e B89",
      "B57 --\u003e B58",
      "B57 --\u003e B89",
      "B58 --\u003e [EXIT]",
      "B59 --\u003e B60",
      "B59 --\u003e B64",
      "B60 --\u003e B61",
      "B60 --\u003e B64",
      "B61 --\u003e B62",
      "B61 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B65",
      "B64 --\u003e B66",
      "B65 --\u003e [EXIT]",
      "B66 --\u003e B89",
      "B67 --\u003e B68",
      "B67 --\u003e B69",
      "B68 --\u003e [EXIT]",
      "B69 --\u003e B70",
      "B69 --\u003e B71",
      "B70 --\u003e B89",
      "B71 --\u003e B72",
      "B71 --\u003e B73",
      "B72 --\u003e B89",
      "B73 --\u003e B74",
      "B73 --\u003e B78",
      "B74 --\u003e B75",
      "B74 --\u003e B77",
      "B75 --\u003e B76",
      "B75 --\u003e B78",
      "B76 --\u003e [EXIT]",
      "B77 --\u003e B78",
      "B78 --\u003e B79",
      "B78 --\u003e B89",
      "B79 --\u003e B80",
      "B79 --\u003e B89",
      "B80 --\u003e [EXIT]",
      "B81 --\u003e B82",
      "B81 --\u003e B83",
      "B82 --\u003e [EXIT]",
      "B83 --\u003e B84",
      "B83 --\u003e B89",
      "B84 --\u003e B85",
      "B84 --\u003e B87",
      "B85 --\u003e B86",
      "B85 --\u003e B89",
      "B86 --\u003e B87",
      "B86 --\u003e B89",
      "B87 --\u003e B88",
      "B87 --\u003e B89",
      "B88 --\u003e [EXIT]",
      "B89 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#_nextTokenWithBuffering(...1)",
        "body": "{\r\n    main_loop: while (true) {\r\n        JsonToken t \u003d delegate.nextToken();\r\n        if (t \u003d\u003d null) {\r\n            // is this even legal?\r\n            return t;\r\n        }\r\n        TokenFilter f;\r\n        // One simplification here: we know for a fact that the item filter is\r\n        // neither null nor \u0027include all\u0027, for most cases; the only exception\r\n        // being FIELD_NAME handling\r\n        switch(t.id()) {\r\n            case ID_START_ARRAY:\r\n                f \u003d _headContext.checkValue(_itemFilter);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                    f \u003d f.filterStartArray();\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return _nextBuffered(buffRoot);\r\n                } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                    // TODO don\u0027t count as match?\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return _nextBuffered(buffRoot);\r\n                }\r\n                _headContext \u003d _headContext.createChildArrayContext(f, false);\r\n                continue main_loop;\r\n            case ID_START_OBJECT:\r\n                f \u003d _itemFilter;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                    return t;\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    // does this occur?\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                // Otherwise still iffy, need to check\r\n                f \u003d _headContext.checkValue(f);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                    f \u003d f.filterStartObject();\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                    return _nextBuffered(buffRoot);\r\n                } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                    // TODO don\u0027t count as match?\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return _nextBuffered(buffRoot);\r\n                }\r\n                _headContext \u003d _headContext.createChildObjectContext(f, false);\r\n                continue main_loop;\r\n            case ID_END_ARRAY:\r\n                {\r\n                    // Unlike with other loops, here we know that content was NOT\r\n                    // included (won\u0027t get this far otherwise)\r\n                    f \u003d _headContext.getFilter();\r\n                    if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                        boolean includeEmpty \u003d f.includeEmptyArray(_headContext.hasCurrentIndex());\r\n                        f.filterFinishArray();\r\n                        if (includeEmpty) {\r\n                            return _nextBuffered(buffRoot);\r\n                        }\r\n                    }\r\n                    boolean gotEnd \u003d (_headContext \u003d\u003d buffRoot);\r\n                    boolean returnEnd \u003d gotEnd \u0026\u0026 _headContext.isStartHandled();\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                    if (returnEnd) {\r\n                        return t;\r\n                    }\r\n                    if (gotEnd) {\r\n                        return null;\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_END_OBJECT:\r\n                {\r\n                    // Unlike with other loops, here we know that content was NOT\r\n                    // included (won\u0027t get this far otherwise)\r\n                    f \u003d _headContext.getFilter();\r\n                    if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                        boolean includeEmpty \u003d f.includeEmptyObject(_headContext.hasCurrentName());\r\n                        f.filterFinishObject();\r\n                        if (includeEmpty) {\r\n                            _headContext._currentName \u003d _headContext._parent \u003d\u003d null ? null : _headContext._parent._currentName;\r\n                            _headContext._needToHandleName \u003d false;\r\n                            return _nextBuffered(buffRoot);\r\n                        }\r\n                    }\r\n                    boolean gotEnd \u003d (_headContext \u003d\u003d buffRoot);\r\n                    boolean returnEnd \u003d gotEnd \u0026\u0026 _headContext.isStartHandled();\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                    if (returnEnd) {\r\n                        return t;\r\n                    }\r\n                    if (gotEnd) {\r\n                        return null;\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_FIELD_NAME:\r\n                {\r\n                    final String name \u003d delegate.currentName();\r\n                    f \u003d _headContext.setFieldName(name);\r\n                    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                        _itemFilter \u003d f;\r\n                        return _nextBuffered(buffRoot);\r\n                    }\r\n                    if (f \u003d\u003d null) {\r\n                        // filter out the value\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                        continue main_loop;\r\n                    }\r\n                    f \u003d f.includeProperty(name);\r\n                    if (f \u003d\u003d null) {\r\n                        // filter out the value\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                        continue main_loop;\r\n                    }\r\n                    _itemFilter \u003d f;\r\n                    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                        if (_verifyAllowedMatches()) {\r\n                            return _nextBuffered(buffRoot);\r\n                        } else {\r\n                            // edge case: if no more matches allowed, reset filter\r\n                            // to initial state to prevent missing a token in next iteration\r\n                            _itemFilter \u003d _headContext.setFieldName(name);\r\n                        }\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            default:\r\n                // scalar value\r\n                f \u003d _itemFilter;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    return _nextBuffered(buffRoot);\r\n                }\r\n                if (f !\u003d null) {\r\n                    f \u003d _headContext.checkValue(f);\r\n                    if ((f \u003d\u003d TokenFilter.INCLUDE_ALL) || ((f !\u003d null) \u0026\u0026 f.includeValue(delegate))) {\r\n                        if (_verifyAllowedMatches()) {\r\n                            return _nextBuffered(buffRoot);\r\n                        }\r\n                    }\r\n                }\r\n                // Otherwise not included (leaves must be explicitly included)\r\n                continue main_loop;\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "FilteringParserDelegate#_verifyAllowedMatches(...0)",
        "body": "{\r\n    if (_matchCount \u003d\u003d 0 || _allowMultipleMatches) {\r\n        ++_matchCount;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "FilteringParserDelegate#_nextToken2(...0)",
        "body": "{\r\n    main_loop: while (true) {\r\n        JsonToken t \u003d delegate.nextToken();\r\n        if (t \u003d\u003d null) {\r\n            // is this even legal?\r\n            _currToken \u003d t;\r\n            return t;\r\n        }\r\n        TokenFilter f;\r\n        switch(t.id()) {\r\n            case ID_START_ARRAY:\r\n                f \u003d _itemFilter;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    // does this occur?\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                // Otherwise still iffy, need to check\r\n                f \u003d _headContext.checkValue(f);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                    f \u003d f.filterStartArray();\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                    _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                }\r\n                _headContext \u003d _headContext.createChildArrayContext(f, false);\r\n                // but if we didn\u0027t figure it out yet, need to buffer possible events\r\n                if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                    t \u003d _nextTokenWithBuffering(_headContext);\r\n                    if (t !\u003d null) {\r\n                        _currToken \u003d t;\r\n                        return t;\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_START_OBJECT:\r\n                f \u003d _itemFilter;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    // does this occur?\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                // Otherwise still iffy, need to check\r\n                f \u003d _headContext.checkValue(f);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.skipChildren();\r\n                    continue main_loop;\r\n                }\r\n                if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                    f \u003d f.filterStartObject();\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                    _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                    return (_currToken \u003d t);\r\n                }\r\n                _headContext \u003d _headContext.createChildObjectContext(f, false);\r\n                if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                    t \u003d _nextTokenWithBuffering(_headContext);\r\n                    if (t !\u003d null) {\r\n                        _currToken \u003d t;\r\n                        return t;\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_END_ARRAY:\r\n                {\r\n                    boolean returnEnd \u003d _headContext.isStartHandled();\r\n                    f \u003d _headContext.getFilter();\r\n                    if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                        boolean includeEmpty \u003d f.includeEmptyArray(_headContext.hasCurrentIndex());\r\n                        f.filterFinishArray();\r\n                        if (includeEmpty) {\r\n                            return _nextBuffered(_headContext);\r\n                        }\r\n                    }\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                    if (returnEnd) {\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_END_OBJECT:\r\n                {\r\n                    boolean returnEnd \u003d _headContext.isStartHandled();\r\n                    f \u003d _headContext.getFilter();\r\n                    if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                        boolean includeEmpty \u003d f.includeEmptyArray(_headContext.hasCurrentName());\r\n                        f.filterFinishObject();\r\n                        if (includeEmpty) {\r\n                            return _nextBuffered(_headContext);\r\n                        }\r\n                    }\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                    if (returnEnd) {\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            case ID_FIELD_NAME:\r\n                {\r\n                    final String name \u003d delegate.currentName();\r\n                    f \u003d _headContext.setFieldName(name);\r\n                    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                        _itemFilter \u003d f;\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                    if (f \u003d\u003d null) {\r\n                        // filter out the value\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                        continue main_loop;\r\n                    }\r\n                    f \u003d f.includeProperty(name);\r\n                    if (f \u003d\u003d null) {\r\n                        // filter out the value\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                        continue main_loop;\r\n                    }\r\n                    _itemFilter \u003d f;\r\n                    if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                        if (_verifyAllowedMatches()) {\r\n                            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                                return (_currToken \u003d t);\r\n                            }\r\n                        } else {\r\n                            delegate.nextToken();\r\n                            delegate.skipChildren();\r\n                        }\r\n                        continue main_loop;\r\n                    }\r\n                    if (_inclusion !\u003d Inclusion.ONLY_INCLUDE_ALL) {\r\n                        t \u003d _nextTokenWithBuffering(_headContext);\r\n                        if (t !\u003d null) {\r\n                            _currToken \u003d t;\r\n                            return t;\r\n                        }\r\n                    }\r\n                }\r\n                continue main_loop;\r\n            default:\r\n                // scalar value\r\n                f \u003d _itemFilter;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f !\u003d null) {\r\n                    f \u003d _headContext.checkValue(f);\r\n                    if ((f \u003d\u003d TokenFilter.INCLUDE_ALL) || ((f !\u003d null) \u0026\u0026 f.includeValue(delegate))) {\r\n                        if (_verifyAllowedMatches()) {\r\n                            return (_currToken \u003d t);\r\n                        }\r\n                    }\r\n                }\r\n                // Otherwise not included (leaves must be explicitly included)\r\n                break;\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "FilteringParserDelegate#_constructError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "nextValue",
    "signature": "com.fasterxml.jackson.core.JsonToken nextValue()",
    "visibility": "public",
    "body": "{\r\n    // Re-implemented same as ParserMinimalBase:\r\n    JsonToken t \u003d nextToken();\r\n    if (t \u003d\u003d JsonToken.FIELD_NAME) {\r\n        t \u003d nextToken();\r\n    }\r\n    return t;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  r2 \u003d r0.nextToken()\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if (r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r2 \u003d r0.nextToken()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#nextToken(...0)",
        "body": "{\r\n    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don\u0027t like all\r\n    //    conditionals; and it seems odd to return `null` but NOT considering input\r\n    //    as closed... would love a rewrite to simplify/clear up logic here.\r\n    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\r\n    // check for no buffered context _exposedContext - null\r\n    // If all the conditions matches then check for scalar / non-scalar property\r\n    if (!_allowMultipleMatches \u0026\u0026 (_currToken !\u003d null) \u0026\u0026 (_exposedContext \u003d\u003d null)) {\r\n        // if scalar, and scalar not present in obj/array and _inclusion \u003d\u003d ONLY_INCLUDE_ALL\r\n        // and INCLUDE_ALL matched once, return null\r\n        if (_currToken.isScalarValue() \u0026\u0026 !_headContext.isStartHandled() \u0026\u0026 _inclusion \u003d\u003d Inclusion.ONLY_INCLUDE_ALL \u0026\u0026 (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL)) {\r\n            return (_currToken \u003d null);\r\n        }\r\n    }\r\n    // Anything buffered?\r\n    TokenFilterContext ctxt \u003d _exposedContext;\r\n    if (ctxt !\u003d null) {\r\n        while (true) {\r\n            JsonToken t \u003d ctxt.nextTokenToRead();\r\n            if (t !\u003d null) {\r\n                _currToken \u003d t;\r\n                return t;\r\n            }\r\n            // all done with buffered stuff?\r\n            if (ctxt \u003d\u003d _headContext) {\r\n                _exposedContext \u003d null;\r\n                if (ctxt.inArray()) {\r\n                    t \u003d delegate.getCurrentToken();\r\n                    _currToken \u003d t;\r\n                    if (_currToken \u003d\u003d JsonToken.END_ARRAY) {\r\n                        _headContext \u003d _headContext.getParent();\r\n                        _itemFilter \u003d _headContext.getFilter();\r\n                    }\r\n                    return t;\r\n                }\r\n                // 19-Jul-2021, tatu: [core#700]: following was commented out?!\r\n                // Almost! Most likely still have the current token;\r\n                // with the sole exception of FIELD_NAME\r\n                t \u003d delegate.currentToken();\r\n                if (t \u003d\u003d JsonToken.END_OBJECT) {\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                }\r\n                if (t !\u003d JsonToken.FIELD_NAME) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n                break;\r\n            }\r\n            // If not, traverse down the context chain\r\n            ctxt \u003d _headContext.findChildOf(ctxt);\r\n            _exposedContext \u003d ctxt;\r\n            if (ctxt \u003d\u003d null) {\r\n                // should never occur\r\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\r\n            }\r\n        }\r\n    }\r\n    // If not, need to read more. If we got any:\r\n    JsonToken t \u003d delegate.nextToken();\r\n    if (t \u003d\u003d null) {\r\n        // no strict need to close, since we have no state here\r\n        _currToken \u003d t;\r\n        return t;\r\n    }\r\n    // otherwise... to include or not?\r\n    TokenFilter f;\r\n    switch(t.id()) {\r\n        case JsonTokenId.ID_NOT_AVAILABLE:\r\n            throw _constructError(\"`JsonToken.NOT_AVAILABLE` received: ensure all input is fed to the Parser before use\");\r\n        case ID_START_ARRAY:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartArray();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildArrayContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            break;\r\n        case ID_START_OBJECT:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartObject();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildObjectContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            // note: inclusion of surrounding Object handled separately via\r\n            // FIELD_NAME\r\n            break;\r\n        case ID_END_ARRAY:\r\n        case ID_END_OBJECT:\r\n            {\r\n                boolean returnEnd \u003d _headContext.isStartHandled();\r\n                f \u003d _headContext.getFilter();\r\n                if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                    if (t.id() \u003d\u003d JsonTokenId.ID_END_ARRAY) {\r\n                        f.filterFinishArray();\r\n                    } else {\r\n                        f.filterFinishObject();\r\n                    }\r\n                }\r\n                _headContext \u003d _headContext.getParent();\r\n                _itemFilter \u003d _headContext.getFilter();\r\n                if (returnEnd) {\r\n                    return (_currToken \u003d t);\r\n                }\r\n            }\r\n            break;\r\n        case ID_FIELD_NAME:\r\n            {\r\n                final String name \u003d delegate.currentName();\r\n                // note: this will also set \u0027needToHandleName\u0027\r\n                f \u003d _headContext.setFieldName(name);\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _itemFilter \u003d f;\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                f \u003d f.includeProperty(name);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                            return (_currToken \u003d t);\r\n                        }\r\n                    } else {\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                    }\r\n                }\r\n                if (_inclusion !\u003d Inclusion.ONLY_INCLUDE_ALL) {\r\n                    t \u003d _nextTokenWithBuffering(_headContext);\r\n                    if (t !\u003d null) {\r\n                        _currToken \u003d t;\r\n                        return t;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        default:\r\n            // scalar value\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f !\u003d null) {\r\n                f \u003d _headContext.checkValue(f);\r\n                if ((f \u003d\u003d TokenFilter.INCLUDE_ALL) || ((f !\u003d null) \u0026\u0026 f.includeValue(delegate))) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise not included (leaves must be explicitly included)\r\n            break;\r\n    }\r\n    // We get here if token was not yet found; offlined handling\r\n    return _nextToken2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "skipChildren",
    "signature": "com.fasterxml.jackson.core.JsonParser skipChildren()",
    "visibility": "public",
    "body": "{\r\n    if ((_currToken !\u003d JsonToken.START_OBJECT) \u0026\u0026 (_currToken !\u003d JsonToken.START_ARRAY)) {\r\n        return this;\r\n    }\r\n    int open \u003d 1;\r\n    // Since proper matching of start/end markers is handled\r\n    // by nextToken(), we\u0027ll just count nesting levels here\r\n    while (true) {\r\n        JsonToken t \u003d nextToken();\r\n        if (t \u003d\u003d null) {\r\n            // not ideal but for now, just return\r\n            return this;\r\n        }\r\n        if (t.isStructStart()) {\r\n            ++open;\r\n        } else if (t.isStructEnd()) {\r\n            if (--open \u003d\u003d 0) {\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B3",
      "B1 : If($r4 \u003d\u003d $r3) → B2 | else → B3",
      "B4 : If($r5 !\u003d null) → B5 | else → B6",
      "B6 : If($z0 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B11",
      "B9 : If(i0 !\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken START_OBJECT\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B3\n}",
      "B1 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken START_ARRAY\u003e\n  if ($r4 \u003d\u003d $r3) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  i0 \u003d 1\n}",
      "B4 {\n  $r5 \u003d r0.nextToken()\n  if ($r5 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $z0 \u003d $r5.isStructStart()\n  if ($z0 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  i0 \u003d i0 + 1\n  goto B11\n}",
      "B8 {\n  $z1 \u003d $r5.isStructEnd()\n  if ($z1 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  $i2 \u003d (int) -1\n  i0 \u003d i0 + $i2\n  if (i0 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  goto B4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B4"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#nextToken(...0)",
        "body": "{\r\n    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don\u0027t like all\r\n    //    conditionals; and it seems odd to return `null` but NOT considering input\r\n    //    as closed... would love a rewrite to simplify/clear up logic here.\r\n    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\r\n    // check for no buffered context _exposedContext - null\r\n    // If all the conditions matches then check for scalar / non-scalar property\r\n    if (!_allowMultipleMatches \u0026\u0026 (_currToken !\u003d null) \u0026\u0026 (_exposedContext \u003d\u003d null)) {\r\n        // if scalar, and scalar not present in obj/array and _inclusion \u003d\u003d ONLY_INCLUDE_ALL\r\n        // and INCLUDE_ALL matched once, return null\r\n        if (_currToken.isScalarValue() \u0026\u0026 !_headContext.isStartHandled() \u0026\u0026 _inclusion \u003d\u003d Inclusion.ONLY_INCLUDE_ALL \u0026\u0026 (_itemFilter \u003d\u003d TokenFilter.INCLUDE_ALL)) {\r\n            return (_currToken \u003d null);\r\n        }\r\n    }\r\n    // Anything buffered?\r\n    TokenFilterContext ctxt \u003d _exposedContext;\r\n    if (ctxt !\u003d null) {\r\n        while (true) {\r\n            JsonToken t \u003d ctxt.nextTokenToRead();\r\n            if (t !\u003d null) {\r\n                _currToken \u003d t;\r\n                return t;\r\n            }\r\n            // all done with buffered stuff?\r\n            if (ctxt \u003d\u003d _headContext) {\r\n                _exposedContext \u003d null;\r\n                if (ctxt.inArray()) {\r\n                    t \u003d delegate.getCurrentToken();\r\n                    _currToken \u003d t;\r\n                    if (_currToken \u003d\u003d JsonToken.END_ARRAY) {\r\n                        _headContext \u003d _headContext.getParent();\r\n                        _itemFilter \u003d _headContext.getFilter();\r\n                    }\r\n                    return t;\r\n                }\r\n                // 19-Jul-2021, tatu: [core#700]: following was commented out?!\r\n                // Almost! Most likely still have the current token;\r\n                // with the sole exception of FIELD_NAME\r\n                t \u003d delegate.currentToken();\r\n                if (t \u003d\u003d JsonToken.END_OBJECT) {\r\n                    _headContext \u003d _headContext.getParent();\r\n                    _itemFilter \u003d _headContext.getFilter();\r\n                }\r\n                if (t !\u003d JsonToken.FIELD_NAME) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n                break;\r\n            }\r\n            // If not, traverse down the context chain\r\n            ctxt \u003d _headContext.findChildOf(ctxt);\r\n            _exposedContext \u003d ctxt;\r\n            if (ctxt \u003d\u003d null) {\r\n                // should never occur\r\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\r\n            }\r\n        }\r\n    }\r\n    // If not, need to read more. If we got any:\r\n    JsonToken t \u003d delegate.nextToken();\r\n    if (t \u003d\u003d null) {\r\n        // no strict need to close, since we have no state here\r\n        _currToken \u003d t;\r\n        return t;\r\n    }\r\n    // otherwise... to include or not?\r\n    TokenFilter f;\r\n    switch(t.id()) {\r\n        case JsonTokenId.ID_NOT_AVAILABLE:\r\n            throw _constructError(\"`JsonToken.NOT_AVAILABLE` received: ensure all input is fed to the Parser before use\");\r\n        case ID_START_ARRAY:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartArray();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildArrayContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildArrayContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            break;\r\n        case ID_START_OBJECT:\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f \u003d\u003d null) {\r\n                // does this occur?\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            // Otherwise still iffy, need to check\r\n            f \u003d _headContext.checkValue(f);\r\n            if (f \u003d\u003d null) {\r\n                delegate.skipChildren();\r\n                break;\r\n            }\r\n            if (f !\u003d TokenFilter.INCLUDE_ALL) {\r\n                f \u003d f.filterStartObject();\r\n            }\r\n            _itemFilter \u003d f;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            } else if (f !\u003d null \u0026\u0026 _inclusion \u003d\u003d Inclusion.INCLUDE_NON_NULL) {\r\n                // TODO don\u0027t count as match?\r\n                _headContext \u003d _headContext.createChildObjectContext(f, true);\r\n                return (_currToken \u003d t);\r\n            }\r\n            _headContext \u003d _headContext.createChildObjectContext(f, false);\r\n            // Also: only need buffering if parent path to be included\r\n            if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                t \u003d _nextTokenWithBuffering(_headContext);\r\n                if (t !\u003d null) {\r\n                    _currToken \u003d t;\r\n                    return t;\r\n                }\r\n            }\r\n            // note: inclusion of surrounding Object handled separately via\r\n            // FIELD_NAME\r\n            break;\r\n        case ID_END_ARRAY:\r\n        case ID_END_OBJECT:\r\n            {\r\n                boolean returnEnd \u003d _headContext.isStartHandled();\r\n                f \u003d _headContext.getFilter();\r\n                if ((f !\u003d null) \u0026\u0026 (f !\u003d TokenFilter.INCLUDE_ALL)) {\r\n                    if (t.id() \u003d\u003d JsonTokenId.ID_END_ARRAY) {\r\n                        f.filterFinishArray();\r\n                    } else {\r\n                        f.filterFinishObject();\r\n                    }\r\n                }\r\n                _headContext \u003d _headContext.getParent();\r\n                _itemFilter \u003d _headContext.getFilter();\r\n                if (returnEnd) {\r\n                    return (_currToken \u003d t);\r\n                }\r\n            }\r\n            break;\r\n        case ID_FIELD_NAME:\r\n            {\r\n                final String name \u003d delegate.currentName();\r\n                // note: this will also set \u0027needToHandleName\u0027\r\n                f \u003d _headContext.setFieldName(name);\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    _itemFilter \u003d f;\r\n                    return (_currToken \u003d t);\r\n                }\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                f \u003d f.includeProperty(name);\r\n                if (f \u003d\u003d null) {\r\n                    delegate.nextToken();\r\n                    delegate.skipChildren();\r\n                    break;\r\n                }\r\n                _itemFilter \u003d f;\r\n                if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        if (_inclusion \u003d\u003d Inclusion.INCLUDE_ALL_AND_PATH) {\r\n                            return (_currToken \u003d t);\r\n                        }\r\n                    } else {\r\n                        delegate.nextToken();\r\n                        delegate.skipChildren();\r\n                    }\r\n                }\r\n                if (_inclusion !\u003d Inclusion.ONLY_INCLUDE_ALL) {\r\n                    t \u003d _nextTokenWithBuffering(_headContext);\r\n                    if (t !\u003d null) {\r\n                        _currToken \u003d t;\r\n                        return t;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        default:\r\n            // scalar value\r\n            f \u003d _itemFilter;\r\n            if (f \u003d\u003d TokenFilter.INCLUDE_ALL) {\r\n                return (_currToken \u003d t);\r\n            }\r\n            if (f !\u003d null) {\r\n                f \u003d _headContext.checkValue(f);\r\n                if ((f \u003d\u003d TokenFilter.INCLUDE_ALL) || ((f !\u003d null) \u0026\u0026 f.includeValue(delegate))) {\r\n                    if (_verifyAllowedMatches()) {\r\n                        return (_currToken \u003d t);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise not included (leaves must be explicitly included)\r\n            break;\r\n    }\r\n    // We get here if token was not yet found; offlined handling\r\n    return _nextToken2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getText",
    "signature": "java.lang.String getText()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return delegate.getText();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0.currentName()\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $r4 \u003d $r3.getText()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#currentName(...0)",
        "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "hasTextCharacters",
    "signature": "boolean hasTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return false;\r\n    }\r\n    return delegate.hasTextCharacters();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $z0 \u003d $r3.hasTextCharacters()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getTextCharacters",
    "signature": "char[] getTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    // Not optimal but is correct, unlike delegating (as underlying stream\r\n    // may point to something else due to buffering)\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName().toCharArray();\r\n    }\r\n    return delegate.getTextCharacters();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0.currentName()\n  $r6 \u003d $r5.toCharArray()\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $r4 \u003d $r3.getTextCharacters()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#currentName(...0)",
        "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getTextLength",
    "signature": "int getTextLength()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName().length();\r\n    }\r\n    return delegate.getTextLength();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r0.currentName()\n  $i1 \u003d $r4.length()\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $i0 \u003d $r3.getTextLength()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#currentName(...0)",
        "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getTextOffset",
    "signature": "int getTextOffset()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return 0;\r\n    }\r\n    return delegate.getTextOffset();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $i0 \u003d $r3.getTextOffset()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return delegate.getValueAsString();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r0.currentName()\n  return\n}",
      "B2 {\n  $r3 \u003d JsonParser delegate\u003e\n  $r4 \u003d $r3.getValueAsString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#currentName(...0)",
        "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return delegate.getValueAsString(defaultValue);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FilteringParserDelegate\n  String\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r0.currentName()\n  return\n}",
      "B2 {\n  $r4 \u003d JsonParser delegate\u003e\n  $r5 \u003d $r4.getValueAsString(r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "FilteringParserDelegate#currentName(...0)",
        "body": "{\r\n    JsonStreamContext ctxt \u003d _filterContext();\r\n    if (_currToken \u003d\u003d JsonToken.START_OBJECT || _currToken \u003d\u003d JsonToken.START_ARRAY) {\r\n        JsonStreamContext parent \u003d ctxt.getParent();\r\n        return (parent \u003d\u003d null) ? null : parent.getCurrentName();\r\n    }\r\n    return ctxt.getCurrentName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.JsonPointerBasedFilter",
    "methodName": "includeElement",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilter includeElement(int)",
    "visibility": "public",
    "body": "{\r\n    JsonPointer next;\r\n    if (_includeAllElements \u0026\u0026 !_pathToMatch.mayMatchElement()) {\r\n        next \u003d _pathToMatch.tail();\r\n    } else {\r\n        next \u003d _pathToMatch.matchElement(index);\r\n    }\r\n    if (next \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (next.matches()) {\r\n        return TokenFilter.INCLUDE_ALL;\r\n    }\r\n    return construct(next, _includeAllElements);\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z3 !\u003d 0) → B2 | else → B3",
      "B4 : If(r6 !\u003d null) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  JsonPointerBasedFilter\n  i0 :\u003d @parameter0: int\n  $z0 \u003d JsonPointerBasedFilter: boolean _includeAllElements\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r4 \u003d JsonPointer _pathToMatch\u003e\n  $z3 \u003d $r4.mayMatchElement()\n  if ($z3 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d JsonPointer _pathToMatch\u003e\n  r6 \u003d $r5.tail()\n  goto B4\n}",
      "B3 {\n  $r1 \u003d JsonPointer _pathToMatch\u003e\n  r6 \u003d $r1.matchElement(i0)\n}",
      "B4 {\n  if (r6 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $z1 \u003d r6.matches()\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r3 \u003d TokenFilter INCLUDE_ALL\u003e\n  return\n}",
      "B8 {\n  $z2 \u003d JsonPointerBasedFilter: boolean _includeAllElements\u003e\n  $r2 \u003d r0.construct(r6, $z2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointerBasedFilter#construct(...2)",
        "body": "{\r\n    return new JsonPointerBasedFilter(pathToMatch, includeAllElements);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.JsonPointerBasedFilter",
    "methodName": "includeProperty",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilter includeProperty(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    JsonPointer next \u003d _pathToMatch.matchProperty(name);\r\n    if (next \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (next.matches()) {\r\n        return TokenFilter.INCLUDE_ALL;\r\n    }\r\n    return construct(next, _includeAllElements);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonPointerBasedFilter\n  String\n  $r2 \u003d JsonPointer _pathToMatch\u003e\n  r3 \u003d $r2.matchProperty(r1)\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d r3.matches()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d TokenFilter INCLUDE_ALL\u003e\n  return\n}",
      "B4 {\n  $z1 \u003d JsonPointerBasedFilter: boolean _includeAllElements\u003e\n  $r4 \u003d r0.construct(r3, $z1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointerBasedFilter#construct(...2)",
        "body": "{\r\n    return new JsonPointerBasedFilter(pathToMatch, includeAllElements);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilter",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d INCLUDE_ALL) {\r\n        return \"TokenFilter.INCLUDE_ALL\";\r\n    }\r\n    return super.toString();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TokenFilter\n  $r1 \u003d TokenFilter INCLUDE_ALL\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "createChildArrayContext",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilterContext createChildArrayContext(com.fasterxml.jackson.core.filter.TokenFilter,boolean)",
    "visibility": "public",
    "body": "{\r\n    TokenFilterContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new TokenFilterContext(TYPE_ARRAY, this, filter, writeStart);\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_ARRAY, filter, writeStart);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  TokenFilter\n  z0 :\u003d @parameter1: boolean\n  r4 \u003d TokenFilterContext _child\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d TokenFilterContext\n  new TokenFilterContext(1, r0, r1, z0)\n  TokenFilterContext _child\u003e \u003d $r3\n  return\n}",
      "B2 {\n  $r2 \u003d r4.reset(1, r1, z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "createChildObjectContext",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilterContext createChildObjectContext(com.fasterxml.jackson.core.filter.TokenFilter,boolean)",
    "visibility": "public",
    "body": "{\r\n    TokenFilterContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new TokenFilterContext(TYPE_OBJECT, this, filter, writeStart);\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_OBJECT, filter, writeStart);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  TokenFilter\n  z0 :\u003d @parameter1: boolean\n  r4 \u003d TokenFilterContext _child\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d TokenFilterContext\n  new TokenFilterContext(2, r0, r1, z0)\n  TokenFilterContext _child\u003e \u003d $r3\n  return\n}",
      "B2 {\n  $r2 \u003d r4.reset(2, r1, z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "checkValue",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilter checkValue(com.fasterxml.jackson.core.filter.TokenFilter)",
    "visibility": "public",
    "body": "{\r\n    // First, checks for Object properties have been made earlier:\r\n    if (_type \u003d\u003d TYPE_OBJECT) {\r\n        return filter;\r\n    }\r\n    // We increase it first because at the beginning of array, value is -1\r\n    int ix \u003d ++_index;\r\n    if (_type \u003d\u003d TYPE_ARRAY) {\r\n        return filter.includeElement(ix);\r\n    }\r\n    return filter.includeRootValue(ix);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 !\u003d 2) → B1 | else → B2",
      "B2 : If($i3 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  TokenFilter\n  $i0 \u003d TokenFilterContext: int _type\u003e\n  if ($i0 !\u003d 2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i1 \u003d TokenFilterContext: int _index\u003e\n  $i2 \u003d $i1 + 1\n  TokenFilterContext: int _index\u003e \u003d $i2\n  $i3 \u003d TokenFilterContext: int _type\u003e\n  if ($i3 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r1.includeElement($i2)\n  return\n}",
      "B4 {\n  $r2 \u003d r1.includeRootValue($i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "ensureFieldNameWritten",
    "signature": "void ensureFieldNameWritten(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (_needToHandleName) {\r\n        _needToHandleName \u003d false;\r\n        gen.writeFieldName(_currentName);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  JsonGenerator\n  $z0 \u003d TokenFilterContext: boolean _needToHandleName\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  TokenFilterContext: boolean _needToHandleName\u003e \u003d 0\n  $r2 \u003d String _currentName\u003e\n  r1.writeFieldName($r2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "writePath",
    "signature": "void writePath(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if ((_filter \u003d\u003d null) || (_filter \u003d\u003d TokenFilter.INCLUDE_ALL)) {\r\n        return;\r\n    }\r\n    if (_parent !\u003d null) {\r\n        _parent._writePath(gen);\r\n    }\r\n    if (_startHandled) {\r\n        // even if Object started, need to start leaf-level name\r\n        if (_needToHandleName) {\r\n            gen.writeFieldName(_currentName);\r\n        }\r\n    } else {\r\n        _startHandled \u003d true;\r\n        if (_type \u003d\u003d TYPE_OBJECT) {\r\n            gen.writeStartObject();\r\n            // we know name must be written\r\n            gen.writeFieldName(_currentName);\r\n        } else if (_type \u003d\u003d TYPE_ARRAY) {\r\n            gen.writeStartArray();\r\n        }\r\n    }\r\n}",
    "nodes": 13,
    "edges": 18,
    "cc": 7,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($r3 !\u003d $r2) → B2 | else → B3",
      "B3 : If($r4 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B8",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B12",
      "B8 : If($i0 !\u003d 2) → B9 | else → B10",
      "B10 : If($i1 !\u003d 1) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  JsonGenerator\n  $r1 \u003d TokenFilter _filter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d TokenFilter _filter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 !\u003d $r2) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r4 \u003d TokenFilterContext _parent\u003e\n  if ($r4 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d TokenFilterContext _parent\u003e\n  $r8._writePath(r5)\n}",
      "B5 {\n  $z0 \u003d TokenFilterContext: boolean _startHandled\u003e\n  if ($z0 \u003d\u003d false) goto B6 else B8\n}",
      "B6 {\n  $z1 \u003d TokenFilterContext: boolean _needToHandleName\u003e\n  if ($z1 \u003d\u003d false) goto B7 else B12\n}",
      "B7 {\n  $r7 \u003d String _currentName\u003e\n  r5.writeFieldName($r7)\n  goto B12\n}",
      "B8 {\n  TokenFilterContext: boolean _startHandled\u003e \u003d 1\n  $i0 \u003d TokenFilterContext: int _type\u003e\n  if ($i0 !\u003d 2) goto B9 else B10\n}",
      "B9 {\n  r5.writeStartObject()\n  $r6 \u003d String _currentName\u003e\n  r5.writeFieldName($r6)\n  goto B12\n}",
      "B10 {\n  $i1 \u003d TokenFilterContext: int _type\u003e\n  if ($i1 !\u003d 1) goto B11 else B12\n}",
      "B11 {\n  r5.writeStartArray()\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B12",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "closeArray",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilterContext closeArray(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (_startHandled) {\r\n        gen.writeEndArray();\r\n    } else {\r\n        if ((_filter !\u003d null) \u0026\u0026 (_filter !\u003d TokenFilter.INCLUDE_ALL)) {\r\n            if (_filter.includeEmptyArray(hasCurrentIndex())) {\r\n                if (_parent !\u003d null) {\r\n                    _parent._writePath(gen);\r\n                }\r\n                gen.writeStartArray();\r\n                gen.writeEndArray();\r\n            }\r\n        }\r\n    }\r\n    if ((_filter !\u003d null) \u0026\u0026 (_filter !\u003d TokenFilter.INCLUDE_ALL)) {\r\n        _filter.filterFinishArray();\r\n    }\r\n    return _parent;\r\n}",
    "nodes": 12,
    "edges": 18,
    "cc": 8,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B8",
      "B3 : If($r6 \u003d\u003d $r5) → B4 | else → B8",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B8",
      "B5 : If($r8 \u003d\u003d null) → B6 | else → B7",
      "B8 : If($r11 \u003d\u003d null) → B9 | else → B11",
      "B9 : If($r3 \u003d\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  JsonGenerator\n  $z0 \u003d TokenFilterContext: boolean _startHandled\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r9.writeEndArray()\n  goto B8\n}",
      "B2 {\n  $r1 \u003d TokenFilter _filter\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B8\n}",
      "B3 {\n  $r6 \u003d TokenFilter _filter\u003e\n  $r5 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r6 \u003d\u003d $r5) goto B4 else B8\n}",
      "B4 {\n  $r7 \u003d TokenFilter _filter\u003e\n  $z1 \u003d r0.hasCurrentIndex()\n  $z2 \u003d $r7.includeEmptyArray($z1)\n  if ($z2 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $r8 \u003d TokenFilterContext _parent\u003e\n  if ($r8 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d TokenFilterContext _parent\u003e\n  $r10._writePath(r9)\n}",
      "B7 {\n  r9.writeStartArray()\n  r9.writeEndArray()\n}",
      "B8 {\n  $r11 \u003d TokenFilter _filter\u003e\n  if ($r11 \u003d\u003d null) goto B9 else B11\n}",
      "B9 {\n  $r3 \u003d TokenFilter _filter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r4 \u003d TokenFilter _filter\u003e\n  $r4.filterFinishArray()\n}",
      "B11 {\n  $r12 \u003d TokenFilterContext _parent\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TokenFilterContext#hasCurrentIndex(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "closeObject",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilterContext closeObject(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (_startHandled) {\r\n        gen.writeEndObject();\r\n    } else {\r\n        if ((_filter !\u003d null) \u0026\u0026 (_filter !\u003d TokenFilter.INCLUDE_ALL)) {\r\n            if (_filter.includeEmptyObject(hasCurrentName())) {\r\n                if (_parent !\u003d null) {\r\n                    _parent._writePath(gen);\r\n                }\r\n                gen.writeStartObject();\r\n                gen.writeEndObject();\r\n            }\r\n        }\r\n    }\r\n    if ((_filter !\u003d null) \u0026\u0026 (_filter !\u003d TokenFilter.INCLUDE_ALL)) {\r\n        _filter.filterFinishObject();\r\n    }\r\n    return _parent;\r\n}",
    "nodes": 12,
    "edges": 18,
    "cc": 8,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B8",
      "B3 : If($r6 \u003d\u003d $r5) → B4 | else → B8",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B8",
      "B5 : If($r8 \u003d\u003d null) → B6 | else → B7",
      "B8 : If($r11 \u003d\u003d null) → B9 | else → B11",
      "B9 : If($r3 \u003d\u003d $r2) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  JsonGenerator\n  $z0 \u003d TokenFilterContext: boolean _startHandled\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r9.writeEndObject()\n  goto B8\n}",
      "B2 {\n  $r1 \u003d TokenFilter _filter\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B8\n}",
      "B3 {\n  $r6 \u003d TokenFilter _filter\u003e\n  $r5 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r6 \u003d\u003d $r5) goto B4 else B8\n}",
      "B4 {\n  $r7 \u003d TokenFilter _filter\u003e\n  $z1 \u003d r0.hasCurrentName()\n  $z2 \u003d $r7.includeEmptyObject($z1)\n  if ($z2 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $r8 \u003d TokenFilterContext _parent\u003e\n  if ($r8 \u003d\u003d null) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d TokenFilterContext _parent\u003e\n  $r10._writePath(r9)\n}",
      "B7 {\n  r9.writeStartObject()\n  r9.writeEndObject()\n}",
      "B8 {\n  $r11 \u003d TokenFilter _filter\u003e\n  if ($r11 \u003d\u003d null) goto B9 else B11\n}",
      "B9 {\n  $r3 \u003d TokenFilter _filter\u003e\n  $r2 \u003d TokenFilter INCLUDE_ALL\u003e\n  if ($r3 \u003d\u003d $r2) goto B10 else B11\n}",
      "B10 {\n  $r4 \u003d TokenFilter _filter\u003e\n  $r4.filterFinishObject()\n}",
      "B11 {\n  $r12 \u003d TokenFilterContext _parent\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TokenFilterContext#hasCurrentName(...0)",
        "body": "{\r\n    return _currentName !\u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "skipParentChecks",
    "signature": "void skipParentChecks()",
    "visibility": "public",
    "body": "{\r\n    _filter \u003d null;\r\n    for (TokenFilterContext ctxt \u003d _parent; ctxt !\u003d null; ctxt \u003d ctxt._parent) {\r\n        ctxt._filter \u003d null;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(r1 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  TokenFilter _filter\u003e \u003d null\n  r1 \u003d TokenFilterContext _parent\u003e\n}",
      "B1 {\n  if (r1 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  TokenFilter _filter\u003e \u003d null\n  r1 \u003d TokenFilterContext _parent\u003e\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "hasCurrentName",
    "signature": "boolean hasCurrentName()",
    "visibility": "public",
    "body": "{\r\n    return _currentName !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  $r1 \u003d String _currentName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "nextTokenToRead",
    "signature": "com.fasterxml.jackson.core.JsonToken nextTokenToRead()",
    "visibility": "public",
    "body": "{\r\n    if (!_startHandled) {\r\n        _startHandled \u003d true;\r\n        if (_type \u003d\u003d TYPE_OBJECT) {\r\n            return JsonToken.START_OBJECT;\r\n        }\r\n        // Note: root should never be unhandled\r\n        return JsonToken.START_ARRAY;\r\n    }\r\n    // But otherwise at most might have FIELD_NAME\r\n    if (_needToHandleName \u0026\u0026 (_type \u003d\u003d TYPE_OBJECT)) {\r\n        _needToHandleName \u003d false;\r\n        return JsonToken.FIELD_NAME;\r\n    }\r\n    return null;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($i1 !\u003d 2) → B2 | else → B3",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B7",
      "B5 : If($i0 !\u003d 2) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  $z0 \u003d TokenFilterContext: boolean _startHandled\u003e\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  TokenFilterContext: boolean _startHandled\u003e \u003d 1\n  $i1 \u003d TokenFilterContext: int _type\u003e\n  if ($i1 !\u003d 2) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d JsonToken START_OBJECT\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d JsonToken START_ARRAY\u003e\n  return\n}",
      "B4 {\n  $z1 \u003d TokenFilterContext: boolean _needToHandleName\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  $i0 \u003d TokenFilterContext: int _type\u003e\n  if ($i0 !\u003d 2) goto B6 else B7\n}",
      "B6 {\n  TokenFilterContext: boolean _needToHandleName\u003e \u003d 0\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.filter.TokenFilterContext",
    "methodName": "findChildOf",
    "signature": "com.fasterxml.jackson.core.filter.TokenFilterContext findChildOf(com.fasterxml.jackson.core.filter.TokenFilterContext)",
    "visibility": "public",
    "body": "{\r\n    if (_parent \u003d\u003d parent) {\r\n        return this;\r\n    }\r\n    TokenFilterContext curr \u003d _parent;\r\n    while (curr !\u003d null) {\r\n        TokenFilterContext p \u003d curr._parent;\r\n        if (p \u003d\u003d parent) {\r\n            return curr;\r\n        }\r\n        curr \u003d p;\r\n    }\r\n    // should never occur but...\r\n    return null;\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2",
      "B3 : If(r4 \u003d\u003d null) → B4 | else → B7",
      "B4 : If(r3 !\u003d r1) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TokenFilterContext\n  TokenFilterContext\n  $r2 \u003d TokenFilterContext _parent\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d TokenFilterContext _parent\u003e\n}",
      "B3 {\n  if (r4 \u003d\u003d null) goto B4 else B7\n}",
      "B4 {\n  r3 \u003d TokenFilterContext _parent\u003e\n  if (r3 !\u003d r1) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r4 \u003d r3\n  goto B3\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatDetector",
    "methodName": "withOptimalMatch",
    "signature": "com.fasterxml.jackson.core.format.DataFormatDetector withOptimalMatch(com.fasterxml.jackson.core.format.MatchStrength)",
    "visibility": "public",
    "body": "{\r\n    if (optMatch \u003d\u003d _optimalMatch) {\r\n        return this;\r\n    }\r\n    return new DataFormatDetector(_detectors, optMatch, _minimalMatch, _maxInputLookahead);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatDetector\n  MatchStrength\n  $r2 \u003d MatchStrength _optimalMatch\u003e\n  if (r0 !\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DataFormatDetector\n  $r5 \u003d JsonFactory[] _detectors\u003e\n  $r4 \u003d MatchStrength _minimalMatch\u003e\n  $i0 \u003d DataFormatDetector: int _maxInputLookahead\u003e\n  new DataFormatDetector($r5, r0, $r4, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatDetector",
    "methodName": "withMinimalMatch",
    "signature": "com.fasterxml.jackson.core.format.DataFormatDetector withMinimalMatch(com.fasterxml.jackson.core.format.MatchStrength)",
    "visibility": "public",
    "body": "{\r\n    if (minMatch \u003d\u003d _minimalMatch) {\r\n        return this;\r\n    }\r\n    return new DataFormatDetector(_detectors, _optimalMatch, minMatch, _maxInputLookahead);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatDetector\n  MatchStrength\n  $r2 \u003d MatchStrength _minimalMatch\u003e\n  if (r0 !\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DataFormatDetector\n  $r5 \u003d JsonFactory[] _detectors\u003e\n  $r4 \u003d MatchStrength _optimalMatch\u003e\n  $i0 \u003d DataFormatDetector: int _maxInputLookahead\u003e\n  new DataFormatDetector($r5, $r4, r0, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatDetector",
    "methodName": "withMaxInputLookahead",
    "signature": "com.fasterxml.jackson.core.format.DataFormatDetector withMaxInputLookahead(int)",
    "visibility": "public",
    "body": "{\r\n    if (lookaheadBytes \u003d\u003d _maxInputLookahead) {\r\n        return this;\r\n    }\r\n    return new DataFormatDetector(_detectors, _optimalMatch, _minimalMatch, lookaheadBytes);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatDetector\n  i0 :\u003d @parameter0: int\n  $i1 \u003d DataFormatDetector: int _maxInputLookahead\u003e\n  if (i0 !\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d DataFormatDetector\n  $r4 \u003d JsonFactory[] _detectors\u003e\n  $r3 \u003d MatchStrength _optimalMatch\u003e\n  $r2 \u003d MatchStrength _minimalMatch\u003e\n  new DataFormatDetector($r4, $r3, $r2, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatDetector",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(\u0027[\u0027);\r\n    final int len \u003d _detectors.length;\r\n    if (len \u003e 0) {\r\n        sb.append(_detectors[0].getFormatName());\r\n        for (int i \u003d 1; i \u003c len; ++i) {\r\n            sb.append(\", \");\r\n            sb.append(_detectors[i].getFormatName());\r\n        }\r\n    }\r\n    sb.append(\u0027]\u0027);\r\n    return sb.toString();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d 0) → B1 | else → B4",
      "B2 : If(i1 \u003e\u003d i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DataFormatDetector\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $r0.append(91)\n  $r2 \u003d JsonFactory[] _detectors\u003e\n  i0 \u003d lengthof $r2\n  if (i0 \u003c\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $r4 \u003d JsonFactory[] _detectors\u003e\n  $r5 \u003d $r4[0]\n  $r6 \u003d $r5.getFormatName()\n  $r0.append($r6)\n  i1 \u003d 1\n}",
      "B2 {\n  if (i1 \u003e\u003d i0) goto B3 else B4\n}",
      "B3 {\n  $r0.append(\", \")\n  $r7 \u003d JsonFactory[] _detectors\u003e\n  $r8 \u003d $r7[i1]\n  $r9 \u003d $r8.getFormatName()\n  $r0.append($r9)\n  i1 \u003d i1 + 1\n  goto B2\n}",
      "B4 {\n  $r0.append(93)\n  $r3 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatMatcher",
    "methodName": "hasMatch",
    "signature": "boolean hasMatch()",
    "visibility": "public",
    "body": "{\r\n    return _match !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatMatcher\n  $r1 \u003d JsonFactory _match\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatMatcher",
    "methodName": "getMatchStrength",
    "signature": "com.fasterxml.jackson.core.format.MatchStrength getMatchStrength()",
    "visibility": "public",
    "body": "{\r\n    return (_matchStrength \u003d\u003d null) ? MatchStrength.INCONCLUSIVE : _matchStrength;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatMatcher\n  $r1 \u003d MatchStrength _matchStrength\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d MatchStrength INCONCLUSIVE\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d MatchStrength _matchStrength\u003e\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatMatcher",
    "methodName": "getMatchedFormatName",
    "signature": "java.lang.String getMatchedFormatName()",
    "visibility": "public",
    "body": "{\r\n    return hasMatch() ? getMatch().getFormatName() : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatMatcher\n  $z0 \u003d r0.hasMatch()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.getMatch()\n  $r2 \u003d $r1.getFormatName()\n  goto B3\n}",
      "B2 {\n  $r2 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DataFormatMatcher#getMatch(...0)",
        "body": "{\r\n    return _match;\r\n}"
      },
      {
        "name": "DataFormatMatcher#hasMatch(...0)",
        "body": "{\r\n    return _match !\u003d null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatMatcher",
    "methodName": "createParserWithMatch",
    "signature": "com.fasterxml.jackson.core.JsonParser createParserWithMatch()",
    "visibility": "public",
    "body": "{\r\n    if (_match \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (_originalStream \u003d\u003d null) {\r\n        return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength);\r\n    }\r\n    return _match.createParser(getDataStream());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DataFormatMatcher\n  $r1 \u003d JsonFactory _match\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d InputStream _originalStream\u003e\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d JsonFactory _match\u003e\n  $r6 \u003d DataFormatMatcher: byte[] _bufferedData\u003e\n  $i1 \u003d DataFormatMatcher: int _bufferedStart\u003e\n  $i0 \u003d DataFormatMatcher: int _bufferedLength\u003e\n  $r8 \u003d $r7.createParser($r6, $i1, $i0)\n  return\n}",
      "B4 {\n  $r3 \u003d JsonFactory _match\u003e\n  $r4 \u003d r0.getDataStream()\n  $r5 \u003d $r3.createParser($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DataFormatMatcher#getDataStream(...0)",
        "body": "{\r\n    if (_originalStream \u003d\u003d null) {\r\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\r\n    }\r\n    return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.format.DataFormatMatcher",
    "methodName": "getDataStream",
    "signature": "java.io.InputStream getDataStream()",
    "visibility": "public",
    "body": "{\r\n    if (_originalStream \u003d\u003d null) {\r\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\r\n    }\r\n    return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DataFormatMatcher\n  $r1 \u003d InputStream _originalStream\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d ByteArrayInputStream\n  $r6 \u003d DataFormatMatcher: byte[] _bufferedData\u003e\n  $i3 \u003d DataFormatMatcher: int _bufferedStart\u003e\n  $i2 \u003d DataFormatMatcher: int _bufferedLength\u003e\n  new ByteArrayInputStream($r6, $i3, $i2)\n  return\n}",
      "B2 {\n  $r2 \u003d MergedStream\n  $r4 \u003d InputStream _originalStream\u003e\n  $r3 \u003d DataFormatMatcher: byte[] _bufferedData\u003e\n  $i1 \u003d DataFormatMatcher: int _bufferedStart\u003e\n  $i0 \u003d DataFormatMatcher: int _bufferedLength\u003e\n  new MergedStream(null, $r4, $r3, $i1, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.BigIntegerParser",
    "methodName": "parseWithFastParser",
    "signature": "java.math.BigInteger parseWithFastParser(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        return JavaBigIntegerParser.parseBigInteger(valueStr);\r\n    } catch (NumberFormatException nfe) {\r\n        final String reportNum \u003d valueStr.length() \u003c\u003d MAX_CHARS_TO_REPORT ? valueStr : valueStr.substring(0, MAX_CHARS_TO_REPORT) + \" [truncated]\";\r\n        throw new NumberFormatException(\"Value \\\"\" + reportNum + \"\\\" can not be represented as `java.math.BigInteger`, reason: \" + nfe.getMessage());\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B1 : If($i0 \u003e 1000) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  String\n  $r1 \u003d JavaBigIntegerParser.parseBigInteger(r0)\n  return\n}",
      "B1 {\n  $r2 :\u003d @caughtexception\n  $i0 \u003d r0.length()\n  if ($i0 \u003e 1000) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d r0\n  goto B4\n}",
      "B3 {\n  $r3 \u003d r0.substring(0, 1000)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r3)\n}",
      "B4 {\n  $r4 \u003d NumberFormatException\n  $r5 \u003d $r2.getMessage()\n  $r6 \u003d dynInvoke makeConcatWithConstants($r7, $r5)\n  new NumberFormatException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e [EXIT]",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.BigIntegerParser",
    "methodName": "parseWithFastParser",
    "signature": "java.math.BigInteger parseWithFastParser(java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    try {\r\n        return JavaBigIntegerParser.parseBigInteger(valueStr, radix);\r\n    } catch (NumberFormatException nfe) {\r\n        final String reportNum \u003d valueStr.length() \u003c\u003d MAX_CHARS_TO_REPORT ? valueStr : valueStr.substring(0, MAX_CHARS_TO_REPORT) + \" [truncated]\";\r\n        throw new NumberFormatException(\"Value \\\"\" + reportNum + \"\\\" can not be represented as `java.math.BigInteger` with radix \" + radix + \", reason: \" + nfe.getMessage());\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B1 : If($i1 \u003e 1000) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  String\n  i0 :\u003d @parameter1: int\n  $r1 \u003d JavaBigIntegerParser.parseBigInteger(r0, i0)\n  return\n}",
      "B1 {\n  $r2 :\u003d @caughtexception\n  $i1 \u003d r0.length()\n  if ($i1 \u003e 1000) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d r0\n  goto B4\n}",
      "B3 {\n  $r3 \u003d r0.substring(0, 1000)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r3)\n}",
      "B4 {\n  $r4 \u003d NumberFormatException\n  $r5 \u003d $r2.getMessage()\n  $r6 \u003d dynInvoke makeConcatWithConstants($r7, i0, $r5)\n  new NumberFormatException($r6)\n  throw $r4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e [EXIT]",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.CharTypes",
    "methodName": "get7BitOutputEscapes",
    "signature": "int[] get7BitOutputEscapes(int)",
    "visibility": "public",
    "body": "{\r\n    if (quoteChar \u003d\u003d \u0027\"\u0027) {\r\n        return sOutputEscapes128;\r\n    }\r\n    return AltEscapes.instance.escapesFor(quoteChar);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 34) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  if (i0 !\u003d 34) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d CharTypes: int[] sOutputEscapes128\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d CharTypes$AltEscapes instance\u003e\n  $r1 \u003d $r0.escapesFor(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.CharTypes",
    "methodName": "get7BitOutputEscapes",
    "signature": "int[] get7BitOutputEscapes(int,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (quoteChar \u003d\u003d \u0027\"\u0027) {\r\n        if (escapeSlash) {\r\n            return sOutputEscapes128WithSlash;\r\n        }\r\n        return sOutputEscapes128;\r\n    }\r\n    return AltEscapes.instance.escapesFor(quoteChar, escapeSlash);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 !\u003d 34) → B1 | else → B4",
      "B1 : If(z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  z0 :\u003d @parameter1: boolean\n  if (i0 !\u003d 34) goto B1 else B4\n}",
      "B1 {\n  if (z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d CharTypes: int[] sOutputEscapes128WithSlash\u003e\n  return\n}",
      "B3 {\n  $r2 \u003d CharTypes: int[] sOutputEscapes128\u003e\n  return\n}",
      "B4 {\n  $r0 \u003d CharTypes$AltEscapes instance\u003e\n  $r1 \u003d $r0.escapesFor(i0, z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.CharTypes",
    "methodName": "appendQuoted",
    "signature": "void appendQuoted(java.lang.StringBuilder,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int[] escCodes \u003d sOutputEscapes128;\r\n    int escLen \u003d escCodes.length;\r\n    for (int i \u003d 0, len \u003d content.length(); i \u003c len; ++i) {\r\n        char c \u003d content.charAt(i);\r\n        if (c \u003e\u003d escLen || escCodes[c] \u003d\u003d 0) {\r\n            sb.append(c);\r\n            continue;\r\n        }\r\n        sb.append(\u0027\\\\\u0027);\r\n        int escCode \u003d escCodes[c];\r\n        if (escCode \u003c 0) {\r\n            // generic quoting (hex value)\r\n            // The only negative value sOutputEscapes128 returns\r\n            // is CharacterEscapes.ESCAPE_STANDARD, which mean\r\n            // appendQuotes should encode using the Unicode encoding;\r\n            // not sure if this is the right way to encode for\r\n            // CharacterEscapes.ESCAPE_CUSTOM or other (future)\r\n            // CharacterEscapes.ESCAPE_XXX values.\r\n            // We know that it has to fit in just 2 hex chars\r\n            sb.append(\u0027u\u0027);\r\n            sb.append(\u00270\u0027);\r\n            sb.append(\u00270\u0027);\r\n            // widening\r\n            int value \u003d c;\r\n            sb.append(HC[value \u003e\u003e 4]);\r\n            sb.append(HC[value \u0026 0xF]);\r\n        } else {\r\n            // \"named\", i.e. prepend with slash\r\n            sb.append((char) escCode);\r\n        }\r\n    }\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B1 : If(i10 \u003e\u003d i1) → B2 | else → B9",
      "B2 : If($i11 \u003e\u003d i0) → B3 | else → B4",
      "B3 : If($i3 !\u003d 0) → B4 | else → B5",
      "B5 : If(i4 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  StringBuilder\n  String\n  r0 \u003d CharTypes: int[] sOutputEscapes128\u003e\n  i0 \u003d lengthof r0\n  i10 \u003d 0\n  i1 \u003d r1.length()\n}",
      "B1 {\n  if (i10 \u003e\u003d i1) goto B2 else B9\n}",
      "B2 {\n  c2 \u003d r1.charAt(i10)\n  $i11 \u003d (int) c2\n  if ($i11 \u003e\u003d i0) goto B3 else B4\n}",
      "B3 {\n  $i12 \u003d (int) c2\n  $i3 \u003d r0[$i12]\n  if ($i3 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  r2.append(c2)\n  goto B8\n}",
      "B5 {\n  r2.append(92)\n  $i13 \u003d (int) c2\n  i4 \u003d r0[$i13]\n  if (i4 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r2.append(117)\n  r2.append(48)\n  r2.append(48)\n  $r3 \u003d CharTypes: char[] HC\u003e\n  $i14 \u003d (int) c2\n  $i6 \u003d $i14 \u003e\u003e 4\n  $c7 \u003d $r3[$i6]\n  r2.append($c7)\n  $r4 \u003d CharTypes: char[] HC\u003e\n  $c8 \u003d c2 \u0026 15\n  $i15 \u003d (int) $c8\n  $c9 \u003d $r4[$i15]\n  r2.append($c9)\n  goto B8\n}",
      "B7 {\n  $c5 \u003d (char) i4\n  r2.append($c5)\n}",
      "B8 {\n  i10 \u003d i10 + 1\n  goto B1\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B1",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.CharTypes",
    "methodName": "copyHexChars",
    "signature": "char[] copyHexChars(boolean)",
    "visibility": "public",
    "body": "{\r\n    return (uppercase) ? HC.clone() : HClower.clone();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d CharTypes: char[] HC\u003e\n  $r3 \u003d $r2.clone()\n  $r4 \u003d (char[]) $r3\n  goto B3\n}",
      "B2 {\n  $r0 \u003d CharTypes: char[] HClower\u003e\n  $r1 \u003d $r0.clone()\n  $r4 \u003d (char[]) $r1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.CharTypes",
    "methodName": "copyHexBytes",
    "signature": "byte[] copyHexBytes(boolean)",
    "visibility": "public",
    "body": "{\r\n    return (uppercase) ? HB.clone() : HBlower.clone();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  z0 :\u003d @parameter0: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d CharTypes: byte[] HB\u003e\n  $r3 \u003d $r2.clone()\n  $r4 \u003d (byte[]) $r3\n  goto B3\n}",
      "B2 {\n  $r0 \u003d CharTypes: byte[] HBlower\u003e\n  $r1 \u003d $r0.clone()\n  $r4 \u003d (byte[]) $r1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.ContentReference",
    "methodName": "rawReference",
    "signature": "com.fasterxml.jackson.core.io.ContentReference rawReference(boolean,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // Just to avoid russian-doll-nesting, let\u0027s:\r\n    if (rawContent instanceof ContentReference) {\r\n        return (ContentReference) rawContent;\r\n    }\r\n    return new ContentReference(isContentTextual, rawContent);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  z1 :\u003d @parameter0: boolean\n  Object\n  $z0 \u003d ContentReference\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ContentReference) r0\n  return\n}",
      "B2 {\n  $r1 \u003d ContentReference\n  new ContentReference(z1, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.ContentReference",
    "methodName": "appendSourceDescription",
    "signature": "java.lang.StringBuilder appendSourceDescription(java.lang.StringBuilder)",
    "visibility": "public",
    "body": "{\r\n    final Object srcRef \u003d getRawContent();\r\n    if (srcRef \u003d\u003d null) {\r\n        if (this \u003d\u003d REDACTED_CONTENT) {\r\n            // ugly but...\r\n            sb.append(\"REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled)\");\r\n        } else {\r\n            sb.append(\"UNKNOWN\");\r\n        }\r\n        return sb;\r\n    }\r\n    // First, figure out what name to use as source type\r\n    Class\u003c?\u003e srcType \u003d (srcRef instanceof Class\u003c?\u003e) ? ((Class\u003c?\u003e) srcRef) : srcRef.getClass();\r\n    String tn \u003d srcType.getName();\r\n    // standard JDK types without package\r\n    if (tn.startsWith(\"java.\")) {\r\n        tn \u003d srcType.getSimpleName();\r\n    } else if (srcRef instanceof byte[]) {\r\n        // then some other special cases\r\n        tn \u003d \"byte[]\";\r\n    } else if (srcRef instanceof char[]) {\r\n        tn \u003d \"char[]\";\r\n    }\r\n    sb.append(\u0027(\u0027).append(tn).append(\u0027)\u0027);\r\n    // and then, include (part of) contents for selected types\r\n    // (never for binary-format data)\r\n    if (hasTextualContent()) {\r\n        String unitStr \u003d \" chars\";\r\n        String trimmed;\r\n        // poor man\u0027s tuple...\r\n        final int maxLen \u003d maxRawContentLength();\r\n        int[] offsets \u003d new int[] { contentOffset(), contentLength() };\r\n        if (srcRef instanceof CharSequence) {\r\n            trimmed \u003d _truncate((CharSequence) srcRef, offsets, maxLen);\r\n        } else if (srcRef instanceof char[]) {\r\n            trimmed \u003d _truncate((char[]) srcRef, offsets, maxLen);\r\n        } else if (srcRef instanceof byte[]) {\r\n            trimmed \u003d _truncate((byte[]) srcRef, offsets, maxLen);\r\n            unitStr \u003d \" bytes\";\r\n        } else {\r\n            trimmed \u003d null;\r\n        }\r\n        if (trimmed !\u003d null) {\r\n            _append(sb, trimmed);\r\n            if (offsets[1] \u003e maxLen) {\r\n                sb.append(\"[truncated \").append(offsets[1] - maxLen).append(unitStr).append(\u0027]\u0027);\r\n            }\r\n        }\r\n    } else {\r\n        // What should we do with binary content? Indicate length, if possible\r\n        if (srcRef instanceof byte[]) {\r\n            int length \u003d contentLength();\r\n            // -1 is marker for \"till the end\" (should we consider offset then, too?)\r\n            if (length \u003c 0) {\r\n                length \u003d ((byte[]) srcRef).length;\r\n            }\r\n            sb.append(\u0027[\u0027).append(length).append(\" bytes]\");\r\n        }\r\n    }\r\n    return sb;\r\n}",
    "nodes": 31,
    "edges": 43,
    "cc": 14,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B5",
      "B1 : If(r0 !\u003d $r14) → B2 | else → B3",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B7",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($z3 \u003d\u003d false) → B13 | else → B14",
      "B14 : If($z8 \u003d\u003d false) → B15 | else → B26",
      "B15 : If($z5 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($z6 \u003d\u003d false) → B18 | else → B19",
      "B19 : If($z7 \u003d\u003d false) → B20 | else → B21",
      "B22 : If(r20 \u003d\u003d null) → B23 | else → B25",
      "B23 : If($i3 \u003c\u003d i0) → B24 | else → B25",
      "B26 : If($z4 \u003d\u003d false) → B27 | else → B30",
      "B27 : If(i6 \u003e\u003d 0) → B28 | else → B29"
    ],
    "blockList": [
      "B0 {\n  ContentReference\n  StringBuilder\n  r1 \u003d r0.getRawContent()\n  if (r1 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r14 \u003d ContentReference REDACTED_CONTENT\u003e\n  if (r0 !\u003d $r14) goto B2 else B3\n}",
      "B2 {\n  r2.append(\"REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled)\")\n  goto B4\n}",
      "B3 {\n  r2.append(\"UNKNOWN\")\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d Class\n  if ($z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r15 \u003d Class) r1\n  goto B8\n}",
      "B7 {\n  $r15 \u003d r1.getClass()\n}",
      "B8 {\n  $r13 \u003d $r15.getName()\n  r16 \u003d $r13\n  $z1 \u003d $r13.startsWith(\"java.\")\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r16 \u003d $r15.getSimpleName()\n  goto B14\n}",
      "B10 {\n  $z2 \u003d r1 instanceof byte[]\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  r16 \u003d \"byte[]\"\n  goto B14\n}",
      "B12 {\n  $z3 \u003d r1 instanceof char[]\n  if ($z3 \u003d\u003d false) goto B13 else B14\n}",
      "B13 {\n  r16 \u003d \"char[]\"\n}",
      "B14 {\n  $r17 \u003d r2.append(40)\n  $r18 \u003d $r17.append(r16)\n  $r18.append(41)\n  $z8 \u003d r0.hasTextualContent()\n  if ($z8 \u003d\u003d false) goto B15 else B26\n}",
      "B15 {\n  r19 \u003d \" chars\"\n  i0 \u003d r0.maxRawContentLength()\n  $r6 \u003d newarray (int)[2]\n  $i1 \u003d r0.contentOffset()\n  $r6[0] \u003d $i1\n  $i2 \u003d r0.contentLength()\n  $r6[1] \u003d $i2\n  $z5 \u003d CharSequence\n  if ($z5 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r12 \u003d CharSequence) r1\n  r20 \u003d r0._truncate($r12, $r6, i0)\n  goto B22\n}",
      "B17 {\n  $z6 \u003d r1 instanceof char[]\n  if ($z6 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r11 \u003d (char[]) r1\n  r20 \u003d r0._truncate($r11, $r6, i0)\n  goto B22\n}",
      "B19 {\n  $z7 \u003d r1 instanceof byte[]\n  if ($z7 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r10 \u003d (byte[]) r1\n  r20 \u003d r0._truncate($r10, $r6, i0)\n  r19 \u003d \" bytes\"\n  goto B22\n}",
      "B21 {\n  r20 \u003d null\n}",
      "B22 {\n  if (r20 \u003d\u003d null) goto B23 else B25\n}",
      "B23 {\n  r0._append(r2, r20)\n  $i3 \u003d $r6[1]\n  if ($i3 \u003c\u003d i0) goto B24 else B25\n}",
      "B24 {\n  $r7 \u003d r2.append(\"truncated \")\n  $i4 \u003d $r6[1]\n  $i5 \u003d $i4 - i0\n  $r8 \u003d $r7.append($i5)\n  $r9 \u003d $r8.append(r19)\n  $r9.append(93)\n}",
      "B25 {\n  goto B30\n}",
      "B26 {\n  $z4 \u003d r1 instanceof byte[]\n  if ($z4 \u003d\u003d false) goto B27 else B30\n}",
      "B27 {\n  i6 \u003d r0.contentLength()\n  if (i6 \u003e\u003d 0) goto B28 else B29\n}",
      "B28 {\n  $r5 \u003d (byte[]) r1\n  i6 \u003d lengthof $r5\n}",
      "B29 {\n  $r3 \u003d r2.append(91)\n  $r4 \u003d $r3.append(i6)\n  $r4.append(\" bytes\")\n}",
      "B30 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B14",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B26",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B22",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B25",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B30",
      "B26 --\u003e B27",
      "B26 --\u003e B30",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B30",
      "B30 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ContentReference#getRawContent(...0)",
        "body": "{\r\n    return _rawContent;\r\n}"
      },
      {
        "name": "ContentReference#hasTextualContent(...0)",
        "body": "{\r\n    return _isContentTextual;\r\n}"
      },
      {
        "name": "ContentReference#maxRawContentLength(...0)",
        "body": "{\r\n    return _maxRawContentLength;\r\n}"
      },
      {
        "name": "ContentReference#contentLength(...0)",
        "body": "{\r\n    return _length;\r\n}"
      },
      {
        "name": "ContentReference#contentOffset(...0)",
        "body": "{\r\n    return _offset;\r\n}"
      },
      {
        "name": "ContentReference#_truncate(...3)",
        "body": "{\r\n    _truncateOffsets(offsets, cs.length());\r\n    final int start \u003d offsets[0];\r\n    final int length \u003d Math.min(offsets[1], maxSnippetLen);\r\n    return cs.subSequence(start, start + length).toString();\r\n}"
      },
      {
        "name": "ContentReference#_append(...2)",
        "body": "{\r\n    sb.append(\u0027\"\u0027);\r\n    // [core#658]: make sure to escape non-printable\r\n    for (int i \u003d 0, end \u003d content.length(); i \u003c end; ++i) {\r\n        // 06-Apr-2021, tatu: Gee... there is no \"Character.isPrintable()\",\r\n        //   and from what I can see things get rather complicated trying\r\n        //   to figure out proper way. Hence, we\u0027ll do this\r\n        char ch \u003d content.charAt(i);\r\n        if (!Character.isISOControl(ch) || !_appendEscaped(sb, ch)) {\r\n            sb.append(ch);\r\n        }\r\n    }\r\n    sb.append(\u0027\"\u0027);\r\n    return content.length();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.ContentReference",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d this)\r\n        return true;\r\n    if (other \u003d\u003d null)\r\n        return false;\r\n    if (!(other instanceof ContentReference))\r\n        return false;\r\n    ContentReference otherSrc \u003d (ContentReference) other;\r\n    // 16-Jan-2022, tatu: First ensure offset/length the same\r\n    if ((_offset !\u003d otherSrc._offset) || (_length !\u003d otherSrc._length)) {\r\n        return false;\r\n    }\r\n    // 16-Jan-2022, tatu: As per [core#739] we\u0027ll want to consider some\r\n    //   but not all content cases with real equality: the concern here is\r\n    //   to avoid expensive comparisons and/or possible security issues\r\n    final Object otherRaw \u003d otherSrc._rawContent;\r\n    if (_rawContent \u003d\u003d null) {\r\n        return (otherRaw \u003d\u003d null);\r\n    } else if (otherRaw \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if ((_rawContent instanceof File) || (_rawContent instanceof URL) || (_rawContent instanceof URI)) {\r\n        return _rawContent.equals(otherRaw);\r\n    }\r\n    return _rawContent \u003d\u003d otherSrc._rawContent;\r\n}",
    "nodes": 24,
    "edges": 28,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B6 : If($i1 !\u003d $i0) → B7 | else → B8",
      "B7 : If($i3 \u003d\u003d $i2) → B8 | else → B9",
      "B9 : If($r4 !\u003d null) → B10 | else → B14",
      "B10 : If(r3 !\u003d null) → B11 | else → B12",
      "B14 : If(r3 !\u003d null) → B15 | else → B16",
      "B16 : If($z1 !\u003d 0) → B17 | else → B19",
      "B17 : If($z2 !\u003d 0) → B18 | else → B19",
      "B18 : If($z3 \u003d\u003d false) → B19 | else → B20",
      "B20 : If($r9 !\u003d $r8) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  ContentReference\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z0 \u003d ContentReference\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r2 \u003d ContentReference) r0\n  $i1 \u003d ContentReference: int _offset\u003e\n  $i0 \u003d ContentReference: int _offset\u003e\n  if ($i1 !\u003d $i0) goto B7 else B8\n}",
      "B7 {\n  $i3 \u003d ContentReference: int _length\u003e\n  $i2 \u003d ContentReference: int _length\u003e\n  if ($i3 \u003d\u003d $i2) goto B8 else B9\n}",
      "B8 {\n  return\n}",
      "B9 {\n  r3 \u003d Object _rawContent\u003e\n  $r4 \u003d Object _rawContent\u003e\n  if ($r4 !\u003d null) goto B10 else B14\n}",
      "B10 {\n  if (r3 !\u003d null) goto B11 else B12\n}",
      "B11 {\n  $z4 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z4 \u003d 0\n}",
      "B13 {\n  return\n}",
      "B14 {\n  if (r3 !\u003d null) goto B15 else B16\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $r5 \u003d Object _rawContent\u003e\n  $z1 \u003d File\n  if ($z1 !\u003d 0) goto B17 else B19\n}",
      "B17 {\n  $r6 \u003d Object _rawContent\u003e\n  $z2 \u003d URL\n  if ($z2 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  $r7 \u003d Object _rawContent\u003e\n  $z3 \u003d URI\n  if ($z3 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r10 \u003d Object _rawContent\u003e\n  $z5 \u003d $r10.equals(r3)\n  return\n}",
      "B20 {\n  $r9 \u003d Object _rawContent\u003e\n  $r8 \u003d Object _rawContent\u003e\n  if ($r9 !\u003d $r8) goto B21 else B22\n}",
      "B21 {\n  $z6 \u003d 1\n  goto B23\n}",
      "B22 {\n  $z6 \u003d 0\n}",
      "B23 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B19",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseReadIOBuffer",
    "signature": "void releaseReadIOBuffer(byte[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        // Let\u0027s do sanity checks to ensure once-and-only-once release,\r\n        // as well as avoiding trying to release buffers not owned\r\n        _verifyRelease(buf, _readIOBuffer);\r\n        _readIOBuffer \u003d null;\r\n        _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: byte[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: byte[] _readIOBuffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: byte[] _readIOBuffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseByteBuffer(0, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseWriteEncodingBuffer",
    "signature": "void releaseWriteEncodingBuffer(byte[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        // Let\u0027s do sanity checks to ensure once-and-only-once release,\r\n        // as well as avoiding trying to release buffers not owned\r\n        _verifyRelease(buf, _writeEncodingBuffer);\r\n        _writeEncodingBuffer \u003d null;\r\n        _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: byte[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: byte[] _writeEncodingBuffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: byte[] _writeEncodingBuffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseByteBuffer(1, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseBase64Buffer",
    "signature": "void releaseBase64Buffer(byte[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        // sanity checks, release once-and-only-once, must be one owned\r\n        _verifyRelease(buf, _base64Buffer);\r\n        _base64Buffer \u003d null;\r\n        _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: byte[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: byte[] _base64Buffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: byte[] _base64Buffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseByteBuffer(3, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseTokenBuffer",
    "signature": "void releaseTokenBuffer(char[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        _verifyRelease(buf, _tokenCBuffer);\r\n        _tokenCBuffer \u003d null;\r\n        _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: char[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: char[] _tokenCBuffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: char[] _tokenCBuffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseCharBuffer(0, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseConcatBuffer",
    "signature": "void releaseConcatBuffer(char[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        // 14-Jan-2014, tatu: Let\u0027s actually allow upgrade of the original buffer.\r\n        _verifyRelease(buf, _concatCBuffer);\r\n        _concatCBuffer \u003d null;\r\n        _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: char[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: char[] _concatCBuffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: char[] _concatCBuffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseCharBuffer(1, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "releaseNameCopyBuffer",
    "signature": "void releaseNameCopyBuffer(char[])",
    "visibility": "public",
    "body": "{\r\n    if (buf !\u003d null) {\r\n        // 14-Jan-2014, tatu: Let\u0027s actually allow upgrade of the original buffer.\r\n        _verifyRelease(buf, _nameCopyBuffer);\r\n        _nameCopyBuffer \u003d null;\r\n        _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, buf);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  r0 :\u003d @parameter0: char[]\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IOContext: char[] _nameCopyBuffer\u003e\n  r1._verifyRelease(r0, $r2)\n  IOContext: char[] _nameCopyBuffer\u003e \u003d null\n  $r3 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3.releaseCharBuffer(3, r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "IOContext#_verifyRelease(...2)",
        "body": "{\r\n    // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\r\n    if ((toRelease !\u003d src) \u0026\u0026 (toRelease.length \u003c src.length)) {\r\n        throw wrongBuf();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.IOContext",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!_closed) {\r\n        _closed \u003d true;\r\n        if (_releaseRecycler) {\r\n            _releaseRecycler \u003d false;\r\n            _bufferRecycler.releaseToPool();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  IOContext\n  $z0 \u003d IOContext: boolean _closed\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  IOContext: boolean _closed\u003e \u003d 1\n  $z1 \u003d IOContext: boolean _releaseRecycler\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  IOContext: boolean _releaseRecycler\u003e \u003d 0\n  $r1 \u003d BufferRecycler _bufferRecycler\u003e\n  $r1.releaseToPool()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "quoteAsString",
    "signature": "char[] quoteAsString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int inputLen \u003d input.length();\r\n    char[] outputBuffer \u003d new char[_initialCharBufSize(inputLen)];\r\n    final int[] escCodes \u003d CharTypes.get7BitOutputEscapes();\r\n    final int escCodeCount \u003d escCodes.length;\r\n    int inPtr \u003d 0;\r\n    TextBuffer textBuffer \u003d null;\r\n    int outPtr \u003d 0;\r\n    char[] qbuf \u003d null;\r\n    outer: while (inPtr \u003c inputLen) {\r\n        tight_loop: while (true) {\r\n            char c \u003d input.charAt(inPtr);\r\n            if (c \u003c escCodeCount \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break tight_loop;\r\n            }\r\n            if (outPtr \u003e\u003d outputBuffer.length) {\r\n                if (textBuffer \u003d\u003d null) {\r\n                    textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n                }\r\n                try {\r\n                    outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n                } catch (IOException e) {\r\n                    // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                    throw new IllegalStateException(e);\r\n                }\r\n                outPtr \u003d 0;\r\n            }\r\n            outputBuffer[outPtr++] \u003d c;\r\n            if (++inPtr \u003e\u003d inputLen) {\r\n                break outer;\r\n            }\r\n        }\r\n        // something to escape; 2 or 6-char variant?\r\n        if (qbuf \u003d\u003d null) {\r\n            qbuf \u003d _qbuf();\r\n        }\r\n        char d \u003d input.charAt(inPtr++);\r\n        int escCode \u003d escCodes[d];\r\n        int length \u003d (escCode \u003c 0) ? _appendNumeric(d, qbuf) : _appendNamed(escCode, qbuf);\r\n        if ((outPtr + length) \u003e outputBuffer.length) {\r\n            int first \u003d outputBuffer.length - outPtr;\r\n            if (first \u003e 0) {\r\n                System.arraycopy(qbuf, 0, outputBuffer, outPtr, first);\r\n            }\r\n            if (textBuffer \u003d\u003d null) {\r\n                textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n            }\r\n            try {\r\n                outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n            } catch (IOException e) {\r\n                // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                throw new IllegalStateException(e);\r\n            }\r\n            int second \u003d length - first;\r\n            System.arraycopy(qbuf, first, outputBuffer, 0, second);\r\n            outPtr \u003d second;\r\n        } else {\r\n            System.arraycopy(qbuf, 0, outputBuffer, outPtr, length);\r\n            outPtr +\u003d length;\r\n        }\r\n    }\r\n    if (textBuffer \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outPtr);\r\n    }\r\n    textBuffer.setCurrentLength(outPtr);\r\n    try {\r\n        return textBuffer.contentsAsArray();\r\n    } catch (IOException e) {\r\n        // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n        throw new IllegalStateException(e);\r\n    }\r\n}",
    "nodes": 33,
    "edges": 40,
    "cc": 9,
    "flowSummary": [
      "B1 : If(i15 \u003e\u003d i0) → B2 | else → B29",
      "B2 : If($i19 \u003e\u003d i2) → B3 | else → B5",
      "B3 : If($i6 \u003d\u003d false) → B4 | else → B5",
      "B5 : If(i16 \u003c $i3) → B6 | else → B11",
      "B6 : If(r13 !\u003d null) → B7 | else → B8",
      "B11 : If(i15 \u003c i0) → B12 | else → B13",
      "B14 : If(r14 !\u003d null) → B15 | else → B16",
      "B16 : If($i14 \u003e\u003d 0) → B17 | else → B18",
      "B19 : If($i10 \u003c\u003d $i9) → B20 | else → B27",
      "B20 : If(i12 \u003c\u003d 0) → B21 | else → B22",
      "B22 : If(r13 !\u003d null) → B23 | else → B24",
      "B29 : If(r13 !\u003d null) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  String\n  i0 \u003d r0.length()\n  $i1 \u003d JsonStringEncoder._initialCharBufSize(i0)\n  r12 \u003d newarray (char)[$i1]\n  r1 \u003d CharTypes.get7BitOutputEscapes()\n  i2 \u003d lengthof r1\n  i15 \u003d 0\n  r13 \u003d null\n  i16 \u003d 0\n  r14 \u003d null\n}",
      "B1 {\n  if (i15 \u003e\u003d i0) goto B2 else B29\n}",
      "B2 {\n  $c5 \u003d r0.charAt(i15)\n  $i19 \u003d (int) $c5\n  if ($i19 \u003e\u003d i2) goto B3 else B5\n}",
      "B3 {\n  $i20 \u003d (int) $c5\n  $i6 \u003d r1[$i20]\n  if ($i6 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  goto B14\n}",
      "B5 {\n  $i3 \u003d lengthof r12\n  if (i16 \u003c $i3) goto B6 else B11\n}",
      "B6 {\n  if (r13 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  r13 \u003d TextBuffer.fromInitial(r12)\n}",
      "B8 {\n  r12 \u003d r13.finishCurrentSegment()\n  goto B10\n}",
      "B9 {\n  $r10 :\u003d @caughtexception\n  $r15 \u003d IllegalStateException\n  new IllegalStateException($r10)\n  throw $r15\n}",
      "B10 {\n  i16 \u003d 0\n}",
      "B11 {\n  $i4 \u003d i16\n  i16 \u003d i16 + 1\n  r12[$i4] \u003d $c5\n  i15 \u003d i15 + 1\n  if (i15 \u003c i0) goto B12 else B13\n}",
      "B12 {\n  goto B29\n}",
      "B13 {\n  goto B2\n}",
      "B14 {\n  if (r14 !\u003d null) goto B15 else B16\n}",
      "B15 {\n  r14 \u003d r4._qbuf()\n}",
      "B16 {\n  $i7 \u003d i15\n  i15 \u003d i15 + 1\n  $c13 \u003d r0.charAt($i7)\n  $i21 \u003d (int) $c13\n  $i14 \u003d r1[$i21]\n  if ($i14 \u003e\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $i22 \u003d (int) $c13\n  $i17 \u003d r4._appendNumeric($i22, r14)\n  goto B19\n}",
      "B18 {\n  $i17 \u003d r4._appendNamed($i14, r14)\n}",
      "B19 {\n  i8 \u003d $i17\n  $i10 \u003d i16 + $i17\n  $i9 \u003d lengthof r12\n  if ($i10 \u003c\u003d $i9) goto B20 else B27\n}",
      "B20 {\n  $i11 \u003d lengthof r12\n  i12 \u003d $i11 - i16\n  if (i12 \u003c\u003d 0) goto B21 else B22\n}",
      "B21 {\n  System.arraycopy(r14, 0, r12, i16, i12)\n}",
      "B22 {\n  if (r13 !\u003d null) goto B23 else B24\n}",
      "B23 {\n  r13 \u003d TextBuffer.fromInitial(r12)\n}",
      "B24 {\n  $r5 \u003d r13.finishCurrentSegment()\n  r12 \u003d $r5\n  goto B26\n}",
      "B25 {\n  $r8 :\u003d @caughtexception\n  $r16 \u003d IllegalStateException\n  new IllegalStateException($r8)\n  throw $r16\n}",
      "B26 {\n  i18 \u003d i8 - i12\n  System.arraycopy(r14, i12, $r5, 0, i18)\n  i16 \u003d i18\n  goto B28\n}",
      "B27 {\n  System.arraycopy(r14, 0, r12, i16, $i17)\n  i16 \u003d i16 + $i17\n}",
      "B28 {\n  goto B1\n}",
      "B29 {\n  if (r13 !\u003d null) goto B30 else B31\n}",
      "B30 {\n  $r3 \u003d Arrays.copyOfRange(r12, 0, i16)\n  return\n}",
      "B31 {\n  r13.setCurrentLength(i16)\n  $r2 \u003d r13.contentsAsArray()\n  return\n}",
      "B32 {\n  $r6 :\u003d @caughtexception\n  $r17 \u003d IllegalStateException\n  new IllegalStateException($r6)\n  throw $r17\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B29",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B14",
      "B5 --\u003e B6",
      "B5 --\u003e B11",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B29",
      "B13 --\u003e B2",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B27",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B1",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e [EXIT]",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_appendNumeric(...2)",
        "body": "{\r\n    qbuf[1] \u003d \u0027u\u0027;\r\n    // We know it\u0027s a control char, so only the last 2 chars are non-0\r\n    qbuf[4] \u003d HC[value \u003e\u003e 4];\r\n    qbuf[5] \u003d HC[value \u0026 0xF];\r\n    return 6;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_appendNamed(...2)",
        "body": "{\r\n    qbuf[1] \u003d (char) esc;\r\n    return 2;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_qbuf(...0)",
        "body": "{\r\n    char[] qbuf \u003d new char[6];\r\n    qbuf[0] \u003d \u0027\\\\\u0027;\r\n    qbuf[2] \u003d \u00270\u0027;\r\n    qbuf[3] \u003d \u00270\u0027;\r\n    return qbuf;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_initialCharBufSize(...1)",
        "body": "{\r\n    // char-\u003echar won\u0027t expand but we need to give some room for escaping\r\n    // like 1/8 (12.5% expansion) but cap addition to something modest\r\n    final int estimated \u003d Math.max(MIN_CHAR_BUFFER_SIZE, strLen + Math.min(6 + (strLen \u003e\u003e 3), 1000));\r\n    return Math.min(estimated, MAX_CHAR_BUFFER_SIZE);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "quoteAsString",
    "signature": "char[] quoteAsString(java.lang.CharSequence)",
    "visibility": "public",
    "body": "{\r\n    // 15-Aug-2019, tatu: Optimize common case as JIT can\u0027t get rid of overhead otherwise\r\n    if (input instanceof String) {\r\n        return quoteAsString((String) input);\r\n    }\r\n    TextBuffer textBuffer \u003d null;\r\n    final int inputLen \u003d input.length();\r\n    char[] outputBuffer \u003d new char[_initialCharBufSize(inputLen)];\r\n    final int[] escCodes \u003d CharTypes.get7BitOutputEscapes();\r\n    final int escCodeCount \u003d escCodes.length;\r\n    int inPtr \u003d 0;\r\n    int outPtr \u003d 0;\r\n    char[] qbuf \u003d null;\r\n    outer: while (inPtr \u003c inputLen) {\r\n        tight_loop: while (true) {\r\n            char c \u003d input.charAt(inPtr);\r\n            if (c \u003c escCodeCount \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break tight_loop;\r\n            }\r\n            if (outPtr \u003e\u003d outputBuffer.length) {\r\n                if (textBuffer \u003d\u003d null) {\r\n                    textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n                }\r\n                try {\r\n                    outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n                } catch (IOException e) {\r\n                    // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                    throw new IllegalStateException(e);\r\n                }\r\n                outPtr \u003d 0;\r\n            }\r\n            outputBuffer[outPtr++] \u003d c;\r\n            if (++inPtr \u003e\u003d inputLen) {\r\n                break outer;\r\n            }\r\n        }\r\n        // something to escape; 2 or 6-char variant?\r\n        if (qbuf \u003d\u003d null) {\r\n            qbuf \u003d _qbuf();\r\n        }\r\n        char d \u003d input.charAt(inPtr++);\r\n        int escCode \u003d escCodes[d];\r\n        int length \u003d (escCode \u003c 0) ? _appendNumeric(d, qbuf) : _appendNamed(escCode, qbuf);\r\n        if ((outPtr + length) \u003e outputBuffer.length) {\r\n            int first \u003d outputBuffer.length - outPtr;\r\n            if (first \u003e 0) {\r\n                System.arraycopy(qbuf, 0, outputBuffer, outPtr, first);\r\n            }\r\n            if (textBuffer \u003d\u003d null) {\r\n                textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n            }\r\n            try {\r\n                outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n            } catch (IOException e) {\r\n                // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                throw new IllegalStateException(e);\r\n            }\r\n            int second \u003d length - first;\r\n            System.arraycopy(qbuf, first, outputBuffer, 0, second);\r\n            outPtr \u003d second;\r\n        } else {\r\n            System.arraycopy(qbuf, 0, outputBuffer, outPtr, length);\r\n            outPtr +\u003d length;\r\n        }\r\n    }\r\n    if (textBuffer \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outPtr);\r\n    }\r\n    textBuffer.setCurrentLength(outPtr);\r\n    try {\r\n        return textBuffer.contentsAsArray();\r\n    } catch (IOException e) {\r\n        // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n        throw new IllegalStateException(e);\r\n    }\r\n}",
    "nodes": 35,
    "edges": 42,
    "cc": 9,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i15 \u003e\u003d i0) → B4 | else → B31",
      "B4 : If($i19 \u003e\u003d i2) → B5 | else → B7",
      "B5 : If($i6 \u003d\u003d false) → B6 | else → B7",
      "B7 : If(i16 \u003c $i3) → B8 | else → B13",
      "B8 : If(r14 !\u003d null) → B9 | else → B10",
      "B13 : If(i15 \u003c i0) → B14 | else → B15",
      "B16 : If(r16 !\u003d null) → B17 | else → B18",
      "B18 : If($i14 \u003e\u003d 0) → B19 | else → B20",
      "B21 : If($i10 \u003c\u003d $i9) → B22 | else → B29",
      "B22 : If(i12 \u003c\u003d 0) → B23 | else → B24",
      "B24 : If(r14 !\u003d null) → B25 | else → B26",
      "B31 : If(r14 !\u003d null) → B32 | else → B33"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  CharSequence\n  $z0 \u003d String\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d String) r0\n  $r7 \u003d r4.quoteAsString($r6)\n  return\n}",
      "B2 {\n  r14 \u003d null\n  i0 \u003d r0.length()\n  $i1 \u003d JsonStringEncoder._initialCharBufSize(i0)\n  r15 \u003d newarray (char)[$i1]\n  r1 \u003d CharTypes.get7BitOutputEscapes()\n  i2 \u003d lengthof r1\n  i15 \u003d 0\n  i16 \u003d 0\n  r16 \u003d null\n}",
      "B3 {\n  if (i15 \u003e\u003d i0) goto B4 else B31\n}",
      "B4 {\n  $c5 \u003d r0.charAt(i15)\n  $i19 \u003d (int) $c5\n  if ($i19 \u003e\u003d i2) goto B5 else B7\n}",
      "B5 {\n  $i20 \u003d (int) $c5\n  $i6 \u003d r1[$i20]\n  if ($i6 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  goto B16\n}",
      "B7 {\n  $i3 \u003d lengthof r15\n  if (i16 \u003c $i3) goto B8 else B13\n}",
      "B8 {\n  if (r14 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  r14 \u003d TextBuffer.fromInitial(r15)\n}",
      "B10 {\n  r15 \u003d r14.finishCurrentSegment()\n  goto B12\n}",
      "B11 {\n  $r12 :\u003d @caughtexception\n  $r17 \u003d IllegalStateException\n  new IllegalStateException($r12)\n  throw $r17\n}",
      "B12 {\n  i16 \u003d 0\n}",
      "B13 {\n  $i4 \u003d i16\n  i16 \u003d i16 + 1\n  r15[$i4] \u003d $c5\n  i15 \u003d i15 + 1\n  if (i15 \u003c i0) goto B14 else B15\n}",
      "B14 {\n  goto B31\n}",
      "B15 {\n  goto B4\n}",
      "B16 {\n  if (r16 !\u003d null) goto B17 else B18\n}",
      "B17 {\n  r16 \u003d r4._qbuf()\n}",
      "B18 {\n  $i7 \u003d i15\n  i15 \u003d i15 + 1\n  $c13 \u003d r0.charAt($i7)\n  $i21 \u003d (int) $c13\n  $i14 \u003d r1[$i21]\n  if ($i14 \u003e\u003d 0) goto B19 else B20\n}",
      "B19 {\n  $i22 \u003d (int) $c13\n  $i17 \u003d r4._appendNumeric($i22, r16)\n  goto B21\n}",
      "B20 {\n  $i17 \u003d r4._appendNamed($i14, r16)\n}",
      "B21 {\n  i8 \u003d $i17\n  $i10 \u003d i16 + $i17\n  $i9 \u003d lengthof r15\n  if ($i10 \u003c\u003d $i9) goto B22 else B29\n}",
      "B22 {\n  $i11 \u003d lengthof r15\n  i12 \u003d $i11 - i16\n  if (i12 \u003c\u003d 0) goto B23 else B24\n}",
      "B23 {\n  System.arraycopy(r16, 0, r15, i16, i12)\n}",
      "B24 {\n  if (r14 !\u003d null) goto B25 else B26\n}",
      "B25 {\n  r14 \u003d TextBuffer.fromInitial(r15)\n}",
      "B26 {\n  $r5 \u003d r14.finishCurrentSegment()\n  r15 \u003d $r5\n  goto B28\n}",
      "B27 {\n  $r10 :\u003d @caughtexception\n  $r18 \u003d IllegalStateException\n  new IllegalStateException($r10)\n  throw $r18\n}",
      "B28 {\n  i18 \u003d i8 - i12\n  System.arraycopy(r16, i12, $r5, 0, i18)\n  i16 \u003d i18\n  goto B30\n}",
      "B29 {\n  System.arraycopy(r16, 0, r15, i16, $i17)\n  i16 \u003d i16 + $i17\n}",
      "B30 {\n  goto B3\n}",
      "B31 {\n  if (r14 !\u003d null) goto B32 else B33\n}",
      "B32 {\n  $r3 \u003d Arrays.copyOfRange(r15, 0, i16)\n  return\n}",
      "B33 {\n  r14.setCurrentLength(i16)\n  $r2 \u003d r14.contentsAsArray()\n  return\n}",
      "B34 {\n  $r8 :\u003d @caughtexception\n  $r19 \u003d IllegalStateException\n  new IllegalStateException($r8)\n  throw $r19\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B31",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B16",
      "B7 --\u003e B8",
      "B7 --\u003e B13",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B31",
      "B15 --\u003e B4",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B29",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B28",
      "B27 --\u003e [EXIT]",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B3",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e [EXIT]",
      "B33 --\u003e [EXIT]",
      "B34 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_appendNumeric(...2)",
        "body": "{\r\n    qbuf[1] \u003d \u0027u\u0027;\r\n    // We know it\u0027s a control char, so only the last 2 chars are non-0\r\n    qbuf[4] \u003d HC[value \u003e\u003e 4];\r\n    qbuf[5] \u003d HC[value \u0026 0xF];\r\n    return 6;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_appendNamed(...2)",
        "body": "{\r\n    qbuf[1] \u003d (char) esc;\r\n    return 2;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_qbuf(...0)",
        "body": "{\r\n    char[] qbuf \u003d new char[6];\r\n    qbuf[0] \u003d \u0027\\\\\u0027;\r\n    qbuf[2] \u003d \u00270\u0027;\r\n    qbuf[3] \u003d \u00270\u0027;\r\n    return qbuf;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_initialCharBufSize(...1)",
        "body": "{\r\n    // char-\u003echar won\u0027t expand but we need to give some room for escaping\r\n    // like 1/8 (12.5% expansion) but cap addition to something modest\r\n    final int estimated \u003d Math.max(MIN_CHAR_BUFFER_SIZE, strLen + Math.min(6 + (strLen \u003e\u003e 3), 1000));\r\n    return Math.min(estimated, MAX_CHAR_BUFFER_SIZE);\r\n}"
      },
      {
        "name": "JsonStringEncoder#quoteAsString(...1)",
        "body": "{\r\n    final int inputLen \u003d input.length();\r\n    char[] outputBuffer \u003d new char[_initialCharBufSize(inputLen)];\r\n    final int[] escCodes \u003d CharTypes.get7BitOutputEscapes();\r\n    final int escCodeCount \u003d escCodes.length;\r\n    int inPtr \u003d 0;\r\n    TextBuffer textBuffer \u003d null;\r\n    int outPtr \u003d 0;\r\n    char[] qbuf \u003d null;\r\n    outer: while (inPtr \u003c inputLen) {\r\n        tight_loop: while (true) {\r\n            char c \u003d input.charAt(inPtr);\r\n            if (c \u003c escCodeCount \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break tight_loop;\r\n            }\r\n            if (outPtr \u003e\u003d outputBuffer.length) {\r\n                if (textBuffer \u003d\u003d null) {\r\n                    textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n                }\r\n                try {\r\n                    outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n                } catch (IOException e) {\r\n                    // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                    throw new IllegalStateException(e);\r\n                }\r\n                outPtr \u003d 0;\r\n            }\r\n            outputBuffer[outPtr++] \u003d c;\r\n            if (++inPtr \u003e\u003d inputLen) {\r\n                break outer;\r\n            }\r\n        }\r\n        // something to escape; 2 or 6-char variant?\r\n        if (qbuf \u003d\u003d null) {\r\n            qbuf \u003d _qbuf();\r\n        }\r\n        char d \u003d input.charAt(inPtr++);\r\n        int escCode \u003d escCodes[d];\r\n        int length \u003d (escCode \u003c 0) ? _appendNumeric(d, qbuf) : _appendNamed(escCode, qbuf);\r\n        if ((outPtr + length) \u003e outputBuffer.length) {\r\n            int first \u003d outputBuffer.length - outPtr;\r\n            if (first \u003e 0) {\r\n                System.arraycopy(qbuf, 0, outputBuffer, outPtr, first);\r\n            }\r\n            if (textBuffer \u003d\u003d null) {\r\n                textBuffer \u003d TextBuffer.fromInitial(outputBuffer);\r\n            }\r\n            try {\r\n                outputBuffer \u003d textBuffer.finishCurrentSegment();\r\n            } catch (IOException e) {\r\n                // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n                throw new IllegalStateException(e);\r\n            }\r\n            int second \u003d length - first;\r\n            System.arraycopy(qbuf, first, outputBuffer, 0, second);\r\n            outPtr \u003d second;\r\n        } else {\r\n            System.arraycopy(qbuf, 0, outputBuffer, outPtr, length);\r\n            outPtr +\u003d length;\r\n        }\r\n    }\r\n    if (textBuffer \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outPtr);\r\n    }\r\n    textBuffer.setCurrentLength(outPtr);\r\n    try {\r\n        return textBuffer.contentsAsArray();\r\n    } catch (IOException e) {\r\n        // IOException won\u0027t happen here, can only occur when ReadConstrainedTextBuffer is used\r\n        throw new IllegalStateException(e);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "quoteAsString",
    "signature": "void quoteAsString(java.lang.CharSequence,java.lang.StringBuilder)",
    "visibility": "public",
    "body": "{\r\n    final int[] escCodes \u003d CharTypes.get7BitOutputEscapes();\r\n    final int escCodeCount \u003d escCodes.length;\r\n    int inPtr \u003d 0;\r\n    final int inputLen \u003d input.length();\r\n    char[] qbuf \u003d null;\r\n    outer: while (inPtr \u003c inputLen) {\r\n        tight_loop: while (true) {\r\n            char c \u003d input.charAt(inPtr);\r\n            if (c \u003c escCodeCount \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break tight_loop;\r\n            }\r\n            output.append(c);\r\n            if (++inPtr \u003e\u003d inputLen) {\r\n                break outer;\r\n            }\r\n        }\r\n        // something to escape; 2 or 6-char variant?\r\n        if (qbuf \u003d\u003d null) {\r\n            qbuf \u003d _qbuf();\r\n        }\r\n        char d \u003d input.charAt(inPtr++);\r\n        int escCode \u003d escCodes[d];\r\n        int length \u003d (escCode \u003c 0) ? _appendNumeric(d, qbuf) : _appendNamed(escCode, qbuf);\r\n        output.append(qbuf, 0, length);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 20,
    "cc": 7,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d i1) → B2 | else → B14",
      "B2 : If($i9 \u003e\u003d i0) → B3 | else → B5",
      "B3 : If($i3 \u003d\u003d false) → B4 | else → B5",
      "B5 : If(i7 \u003c i1) → B6 | else → B7",
      "B8 : If(r4 !\u003d null) → B9 | else → B10",
      "B10 : If($i6 \u003e\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  CharSequence\n  StringBuilder\n  r0 \u003d CharTypes.get7BitOutputEscapes()\n  i0 \u003d lengthof r0\n  i7 \u003d 0\n  i1 \u003d r1.length()\n  r4 \u003d null\n}",
      "B1 {\n  if (i7 \u003e\u003d i1) goto B2 else B14\n}",
      "B2 {\n  $c2 \u003d r1.charAt(i7)\n  $i9 \u003d (int) $c2\n  if ($i9 \u003e\u003d i0) goto B3 else B5\n}",
      "B3 {\n  $i10 \u003d (int) $c2\n  $i3 \u003d r0[$i10]\n  if ($i3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  goto B8\n}",
      "B5 {\n  r2.append($c2)\n  i7 \u003d i7 + 1\n  if (i7 \u003c i1) goto B6 else B7\n}",
      "B6 {\n  goto B14\n}",
      "B7 {\n  goto B2\n}",
      "B8 {\n  if (r4 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  r4 \u003d r3._qbuf()\n}",
      "B10 {\n  $i4 \u003d i7\n  i7 \u003d i7 + 1\n  $c5 \u003d r1.charAt($i4)\n  $i11 \u003d (int) $c5\n  $i6 \u003d r0[$i11]\n  if ($i6 \u003e\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $i12 \u003d (int) $c5\n  $i8 \u003d r3._appendNumeric($i12, r4)\n  goto B13\n}",
      "B12 {\n  $i8 \u003d r3._appendNamed($i6, r4)\n}",
      "B13 {\n  r2.append(r4, 0, $i8)\n  goto B1\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B14",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B14",
      "B7 --\u003e B2",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B1",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_appendNumeric(...2)",
        "body": "{\r\n    qbuf[1] \u003d \u0027u\u0027;\r\n    // We know it\u0027s a control char, so only the last 2 chars are non-0\r\n    qbuf[4] \u003d HC[value \u003e\u003e 4];\r\n    qbuf[5] \u003d HC[value \u0026 0xF];\r\n    return 6;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_appendNamed(...2)",
        "body": "{\r\n    qbuf[1] \u003d (char) esc;\r\n    return 2;\r\n}"
      },
      {
        "name": "JsonStringEncoder#_qbuf(...0)",
        "body": "{\r\n    char[] qbuf \u003d new char[6];\r\n    qbuf[0] \u003d \u0027\\\\\u0027;\r\n    qbuf[2] \u003d \u00270\u0027;\r\n    qbuf[3] \u003d \u00270\u0027;\r\n    return qbuf;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "quoteAsUTF8",
    "signature": "byte[] quoteAsUTF8(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    int inputPtr \u003d 0;\r\n    int inputEnd \u003d text.length();\r\n    int outputPtr \u003d 0;\r\n    byte[] outputBuffer \u003d new byte[_initialByteBufSize(inputEnd)];\r\n    ByteArrayBuilder bb \u003d null;\r\n    main: while (inputPtr \u003c inputEnd) {\r\n        final int[] escCodes \u003d CharTypes.get7BitOutputEscapes();\r\n        // ASCII and escapes\r\n        inner_loop: while (true) {\r\n            int ch \u003d text.charAt(inputPtr);\r\n            if (ch \u003e 0x7F || escCodes[ch] !\u003d 0) {\r\n                break inner_loop;\r\n            }\r\n            if (outputPtr \u003e\u003d outputBuffer.length) {\r\n                if (bb \u003d\u003d null) {\r\n                    bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n                }\r\n                outputBuffer \u003d bb.finishCurrentSegment();\r\n                outputPtr \u003d 0;\r\n            }\r\n            outputBuffer[outputPtr++] \u003d (byte) ch;\r\n            if (++inputPtr \u003e\u003d inputEnd) {\r\n                break main;\r\n            }\r\n        }\r\n        if (bb \u003d\u003d null) {\r\n            bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n        }\r\n        if (outputPtr \u003e\u003d outputBuffer.length) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputPtr \u003d 0;\r\n        }\r\n        // Ok, so what did we hit?\r\n        int ch \u003d text.charAt(inputPtr++);\r\n        if (ch \u003c\u003d 0x7F) {\r\n            // needs quoting\r\n            int escape \u003d escCodes[ch];\r\n            // ctrl-char, 6-byte escape...\r\n            outputPtr \u003d _appendByte(ch, escape, bb, outputPtr);\r\n            outputBuffer \u003d bb.getCurrentSegment();\r\n            continue main;\r\n        }\r\n        if (ch \u003c\u003d 0x7FF) {\r\n            // fine, just needs 2 byte output\r\n            outputBuffer[outputPtr++] \u003d (byte) (0xc0 | (ch \u003e\u003e 6));\r\n            ch \u003d (0x80 | (ch \u0026 0x3f));\r\n        } else {\r\n            // 3 or 4 bytes\r\n            // Surrogates?\r\n            if (ch \u003c SURR1_FIRST || ch \u003e SURR2_LAST) {\r\n                // nope\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xe0 | (ch \u003e\u003e 12));\r\n                if (outputPtr \u003e\u003d outputBuffer.length) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((ch \u003e\u003e 6) \u0026 0x3f));\r\n                ch \u003d (0x80 | (ch \u0026 0x3f));\r\n            } else {\r\n                // yes, surrogate pair\r\n                if (ch \u003e SURR1_LAST) {\r\n                    // must be from first range\r\n                    _illegal(ch);\r\n                }\r\n                // and if so, followed by another from next range\r\n                if (inputPtr \u003e\u003d inputEnd) {\r\n                    _illegal(ch);\r\n                }\r\n                ch \u003d _convert(ch, text.charAt(inputPtr++));\r\n                if (ch \u003e 0x10FFFF) {\r\n                    // illegal, as per RFC 4627\r\n                    _illegal(ch);\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xf0 | (ch \u003e\u003e 18));\r\n                if (outputPtr \u003e\u003d outputBuffer.length) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((ch \u003e\u003e 12) \u0026 0x3f));\r\n                if (outputPtr \u003e\u003d outputBuffer.length) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((ch \u003e\u003e 6) \u0026 0x3f));\r\n                ch \u003d (0x80 | (ch \u0026 0x3f));\r\n            }\r\n        }\r\n        if (outputPtr \u003e\u003d outputBuffer.length) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputPtr \u003d 0;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) ch;\r\n    }\r\n    if (bb \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outputPtr);\r\n    }\r\n    return bb.completeAndCoalesce(outputPtr);\r\n}",
    "nodes": 43,
    "edges": 61,
    "cc": 20,
    "flowSummary": [
      "B1 : If(i40 \u003e\u003d i0) → B2 | else → B40",
      "B3 : If($i50 \u003e 127) → B4 | else → B13",
      "B4 : If($i37 \u003d\u003d false) → B5 | else → B6",
      "B6 : If(i41 \u003c $i38) → B7 | else → B10",
      "B7 : If(r6 !\u003d null) → B8 | else → B9",
      "B10 : If(i40 \u003c i0) → B11 | else → B12",
      "B13 : If(r6 !\u003d null) → B14 | else → B15",
      "B15 : If(i41 \u003c $i2) → B16 | else → B17",
      "B17 : If($i52 \u003e 127) → B18 | else → B19",
      "B19 : If($i55 \u003e 2047) → B20 | else → B21",
      "B21 : If($i58 \u003c $i60) → B22 | else → B23",
      "B22 : If($i61 \u003c\u003d $i63) → B23 | else → B26",
      "B23 : If(i46 \u003c $i7) → B24 | else → B25",
      "B26 : If($i67 \u003c\u003d $i69) → B27 | else → B28",
      "B28 : If(i40 \u003c i0) → B29 | else → B30",
      "B30 : If($i30 \u003c\u003d 1114111) → B31 | else → B32",
      "B32 : If(i47 \u003c $i19) → B33 | else → B34",
      "B34 : If(i48 \u003c $i24) → B35 | else → B36",
      "B37 : If(i44 \u003c $i49) → B38 | else → B39",
      "B40 : If(r6 !\u003d null) → B41 | else → B42"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  String\n  i40 \u003d 0\n  i0 \u003d r0.length()\n  i41 \u003d 0\n  $i1 \u003d JsonStringEncoder._initialByteBufSize(i0)\n  r5 \u003d newarray (byte)[$i1]\n  r6 \u003d null\n}",
      "B1 {\n  if (i40 \u003e\u003d i0) goto B2 else B40\n}",
      "B2 {\n  r3 \u003d CharTypes.get7BitOutputEscapes()\n}",
      "B3 {\n  $c39 \u003d r0.charAt(i40)\n  $i50 \u003d (int) $c39\n  if ($i50 \u003e 127) goto B4 else B13\n}",
      "B4 {\n  $i51 \u003d (int) $c39\n  $i37 \u003d r3[$i51]\n  if ($i37 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  goto B13\n}",
      "B6 {\n  $i38 \u003d lengthof r5\n  if (i41 \u003c $i38) goto B7 else B10\n}",
      "B7 {\n  if (r6 !\u003d null) goto B8 else B9\n}",
      "B8 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i41)\n}",
      "B9 {\n  r5 \u003d r6.finishCurrentSegment()\n  i41 \u003d 0\n}",
      "B10 {\n  $i42 \u003d i41\n  i41 \u003d i41 + 1\n  $b43 \u003d (byte) $c39\n  r5[$i42] \u003d $b43\n  i40 \u003d i40 + 1\n  if (i40 \u003c i0) goto B11 else B12\n}",
      "B11 {\n  goto B40\n}",
      "B12 {\n  goto B3\n}",
      "B13 {\n  if (r6 !\u003d null) goto B14 else B15\n}",
      "B14 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i41)\n}",
      "B15 {\n  $i2 \u003d lengthof r5\n  if (i41 \u003c $i2) goto B16 else B17\n}",
      "B16 {\n  r5 \u003d r6.finishCurrentSegment()\n  i41 \u003d 0\n}",
      "B17 {\n  $i3 \u003d i40\n  i40 \u003d i40 + 1\n  $c36 \u003d r0.charAt($i3)\n  $i52 \u003d (int) $c36\n  if ($i52 \u003e 127) goto B18 else B19\n}",
      "B18 {\n  $i53 \u003d (int) $c36\n  i35 \u003d r3[$i53]\n  $i54 \u003d (int) $c36\n  i41 \u003d r4._appendByte($i54, i35, r6, i41)\n  r5 \u003d r6.getCurrentSegment()\n  goto B1\n}",
      "B19 {\n  $i55 \u003d (int) $c36\n  if ($i55 \u003e 2047) goto B20 else B21\n}",
      "B20 {\n  i44 \u003d i41 + 1\n  $i56 \u003d (int) $c36\n  $i31 \u003d $i56 \u003e\u003e 6\n  $i32 \u003d 192 | $i31\n  $b33 \u003d (byte) $i32\n  r5[i41] \u003d $b33\n  $c34 \u003d $c36 \u0026 63\n  $i57 \u003d (int) $c34\n  i45 \u003d 128 | $i57\n  goto B37\n}",
      "B21 {\n  $i58 \u003d (int) $c36\n  $i60 \u003d (int) 55296\n  if ($i58 \u003c $i60) goto B22 else B23\n}",
      "B22 {\n  $i61 \u003d (int) $c36\n  $i63 \u003d (int) 57343\n  if ($i61 \u003c\u003d $i63) goto B23 else B26\n}",
      "B23 {\n  i46 \u003d i41 + 1\n  $i64 \u003d (int) $c36\n  $i4 \u003d $i64 \u003e\u003e 12\n  $i5 \u003d 224 | $i4\n  $b6 \u003d (byte) $i5\n  r5[i41] \u003d $b6\n  $i7 \u003d lengthof r5\n  if (i46 \u003c $i7) goto B24 else B25\n}",
      "B24 {\n  r5 \u003d r6.finishCurrentSegment()\n  i46 \u003d 0\n}",
      "B25 {\n  i44 \u003d i46 + 1\n  $i65 \u003d (int) $c36\n  $i8 \u003d $i65 \u003e\u003e 6\n  $i9 \u003d $i8 \u0026 63\n  $i10 \u003d 128 | $i9\n  $b11 \u003d (byte) $i10\n  r5[i46] \u003d $b11\n  $c12 \u003d $c36 \u0026 63\n  $i66 \u003d (int) $c12\n  i45 \u003d 128 | $i66\n  goto B37\n}",
      "B26 {\n  $i67 \u003d (int) $c36\n  $i69 \u003d (int) 56319\n  if ($i67 \u003c\u003d $i69) goto B27 else B28\n}",
      "B27 {\n  $i70 \u003d (int) $c36\n  JsonStringEncoder._illegal($i70)\n}",
      "B28 {\n  if (i40 \u003c i0) goto B29 else B30\n}",
      "B29 {\n  $i71 \u003d (int) $c36\n  JsonStringEncoder._illegal($i71)\n}",
      "B30 {\n  $i14 \u003d i40\n  i40 \u003d i40 + 1\n  $c15 \u003d r0.charAt($i14)\n  $i72 \u003d (int) $c36\n  $i73 \u003d (int) $c15\n  $i30 \u003d JsonStringEncoder._convert($i72, $i73)\n  if ($i30 \u003c\u003d 1114111) goto B31 else B32\n}",
      "B31 {\n  JsonStringEncoder._illegal($i30)\n}",
      "B32 {\n  i47 \u003d i41 + 1\n  $i16 \u003d $i30 \u003e\u003e 18\n  $i17 \u003d 240 | $i16\n  $b18 \u003d (byte) $i17\n  r5[i41] \u003d $b18\n  $i19 \u003d lengthof r5\n  if (i47 \u003c $i19) goto B33 else B34\n}",
      "B33 {\n  r5 \u003d r6.finishCurrentSegment()\n  i47 \u003d 0\n}",
      "B34 {\n  i48 \u003d i47 + 1\n  $i20 \u003d $i30 \u003e\u003e 12\n  $i21 \u003d $i20 \u0026 63\n  $i22 \u003d 128 | $i21\n  $b23 \u003d (byte) $i22\n  r5[i47] \u003d $b23\n  $i24 \u003d lengthof r5\n  if (i48 \u003c $i24) goto B35 else B36\n}",
      "B35 {\n  r5 \u003d r6.finishCurrentSegment()\n  i48 \u003d 0\n}",
      "B36 {\n  i44 \u003d i48 + 1\n  $i25 \u003d $i30 \u003e\u003e 6\n  $i26 \u003d $i25 \u0026 63\n  $i27 \u003d 128 | $i26\n  $b28 \u003d (byte) $i27\n  r5[i48] \u003d $b28\n  $i29 \u003d $i30 \u0026 63\n  i45 \u003d 128 | $i29\n}",
      "B37 {\n  $i49 \u003d lengthof r5\n  if (i44 \u003c $i49) goto B38 else B39\n}",
      "B38 {\n  r5 \u003d r6.finishCurrentSegment()\n  i44 \u003d 0\n}",
      "B39 {\n  i41 \u003d i44 + 1\n  $b13 \u003d (byte) i45\n  r5[i44] \u003d $b13\n  goto B1\n}",
      "B40 {\n  if (r6 !\u003d null) goto B41 else B42\n}",
      "B41 {\n  $r2 \u003d Arrays.copyOfRange(r5, 0, i41)\n  return\n}",
      "B42 {\n  $r1 \u003d r6.completeAndCoalesce(i41)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B40",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B13",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B40",
      "B12 --\u003e B3",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B1",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B37",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B26",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B25",
      "B25 --\u003e B37",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e B35",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B39 --\u003e B1",
      "B40 --\u003e B41",
      "B40 --\u003e B42",
      "B41 --\u003e [EXIT]",
      "B42 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_illegal(...1)",
        "body": "{\r\n    throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(c));\r\n}"
      },
      {
        "name": "JsonStringEncoder#_initialByteBufSize(...1)",
        "body": "{\r\n    // char-\u003ebyte for UTF-8 can expand size by x3 itself, and escaping\r\n    // more... but let\u0027s use lower factor of 1.5\r\n    final int doubled \u003d Math.max(MIN_BYTE_BUFFER_SIZE, strLen + 6 + (strLen \u003e\u003e 1));\r\n    // but use upper bound for humongous cases (segmented)\r\n    return Math.min(doubled, MAX_BYTE_BUFFER_SIZE);\r\n}"
      },
      {
        "name": "JsonStringEncoder#_appendByte(...4)",
        "body": "{\r\n    bb.setCurrentSegmentLength(ptr);\r\n    bb.append(\u0027\\\\\u0027);\r\n    if (esc \u003c 0) {\r\n        // standard escape\r\n        bb.append(\u0027u\u0027);\r\n        if (ch \u003e 0xFF) {\r\n            int hi \u003d (ch \u003e\u003e 8);\r\n            bb.append(HB[hi \u003e\u003e 4]);\r\n            bb.append(HB[hi \u0026 0xF]);\r\n            ch \u0026\u003d 0xFF;\r\n        } else {\r\n            bb.append(\u00270\u0027);\r\n            bb.append(\u00270\u0027);\r\n        }\r\n        bb.append(HB[ch \u003e\u003e 4]);\r\n        bb.append(HB[ch \u0026 0xF]);\r\n    } else {\r\n        // 2-char simple escape\r\n        bb.append((byte) esc);\r\n    }\r\n    return bb.getCurrentSegmentLength();\r\n}"
      },
      {
        "name": "JsonStringEncoder#_convert(...2)",
        "body": "{\r\n    // Ok, then, is the second part valid?\r\n    if (p2 \u003c SURR2_FIRST || p2 \u003e SURR2_LAST) {\r\n        throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(p1) + \", second 0x\" + Integer.toHexString(p2) + \"; illegal combination\");\r\n    }\r\n    return (p1 \u003c\u003c 10) + p2 + UTF8Writer.SURROGATE_BASE;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "encodeAsUTF8",
    "signature": "byte[] encodeAsUTF8(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    int inputPtr \u003d 0;\r\n    int inputEnd \u003d text.length();\r\n    int outputPtr \u003d 0;\r\n    byte[] outputBuffer \u003d new byte[_initialByteBufSize(inputEnd)];\r\n    int outputEnd \u003d outputBuffer.length;\r\n    ByteArrayBuilder bb \u003d null;\r\n    main_loop: while (inputPtr \u003c inputEnd) {\r\n        int c \u003d text.charAt(inputPtr++);\r\n        // first tight loop for ascii\r\n        while (c \u003c\u003d 0x7F) {\r\n            if (outputPtr \u003e\u003d outputEnd) {\r\n                if (bb \u003d\u003d null) {\r\n                    bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n                }\r\n                outputBuffer \u003d bb.finishCurrentSegment();\r\n                outputEnd \u003d outputBuffer.length;\r\n                outputPtr \u003d 0;\r\n            }\r\n            outputBuffer[outputPtr++] \u003d (byte) c;\r\n            if (inputPtr \u003e\u003d inputEnd) {\r\n                break main_loop;\r\n            }\r\n            c \u003d text.charAt(inputPtr++);\r\n        }\r\n        // then multi-byte...\r\n        if (bb \u003d\u003d null) {\r\n            bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n        }\r\n        if (outputPtr \u003e\u003d outputEnd) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputEnd \u003d outputBuffer.length;\r\n            outputPtr \u003d 0;\r\n        }\r\n        if (c \u003c 0x800) {\r\n            // 2-byte\r\n            outputBuffer[outputPtr++] \u003d (byte) (0xc0 | (c \u003e\u003e 6));\r\n        } else {\r\n            // 3 or 4 bytes\r\n            // Surrogates?\r\n            if (c \u003c SURR1_FIRST || c \u003e SURR2_LAST) {\r\n                // nope\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xe0 | (c \u003e\u003e 12));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            } else {\r\n                // yes, surrogate pair\r\n                if (c \u003e SURR1_LAST) {\r\n                    // must be from first range\r\n                    _illegal(c);\r\n                }\r\n                // and if so, followed by another from next range\r\n                if (inputPtr \u003e\u003d inputEnd) {\r\n                    _illegal(c);\r\n                }\r\n                c \u003d _convert(c, text.charAt(inputPtr++));\r\n                if (c \u003e 0x10FFFF) {\r\n                    // illegal, as per RFC 4627\r\n                    _illegal(c);\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xf0 | (c \u003e\u003e 18));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 12) \u0026 0x3f));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            }\r\n        }\r\n        if (outputPtr \u003e\u003d outputEnd) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputEnd \u003d outputBuffer.length;\r\n            outputPtr \u003d 0;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n    }\r\n    if (bb \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outputPtr);\r\n    }\r\n    return bb.completeAndCoalesce(outputPtr);\r\n}",
    "nodes": 39,
    "edges": 55,
    "cc": 18,
    "flowSummary": [
      "B1 : If(i31 \u003e\u003d i0) → B2 | else → B36",
      "B3 : If(i34 \u003e 127) → B4 | else → B11",
      "B4 : If(i32 \u003c i33) → B5 | else → B8",
      "B5 : If(r6 !\u003d null) → B6 | else → B7",
      "B8 : If(i31 \u003c i0) → B9 | else → B10",
      "B11 : If(r6 !\u003d null) → B12 | else → B13",
      "B13 : If(i32 \u003c i33) → B14 | else → B15",
      "B15 : If(i34 \u003e\u003d 2048) → B16 | else → B17",
      "B17 : If(i34 \u003c $i46) → B18 | else → B19",
      "B18 : If(i34 \u003c\u003d $i48) → B19 | else → B22",
      "B19 : If(i38 \u003c i33) → B20 | else → B21",
      "B22 : If(i34 \u003c\u003d $i50) → B23 | else → B24",
      "B24 : If(i31 \u003c i0) → B25 | else → B26",
      "B26 : If($i26 \u003c\u003d 1114111) → B27 | else → B28",
      "B28 : If(i39 \u003c i33) → B29 | else → B30",
      "B30 : If(i40 \u003c i33) → B31 | else → B32",
      "B33 : If(i37 \u003c i33) → B34 | else → B35",
      "B36 : If(r6 !\u003d null) → B37 | else → B38"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  String\n  i31 \u003d 0\n  i0 \u003d r0.length()\n  i32 \u003d 0\n  $i1 \u003d JsonStringEncoder._initialByteBufSize(i0)\n  r5 \u003d newarray (byte)[$i1]\n  i33 \u003d lengthof r5\n  r6 \u003d null\n}",
      "B1 {\n  if (i31 \u003e\u003d i0) goto B2 else B36\n}",
      "B2 {\n  $i2 \u003d i31\n  i31 \u003d i31 + 1\n  $c41 \u003d r0.charAt($i2)\n  $i42 \u003d (int) $c41\n  i34 \u003d $i42\n}",
      "B3 {\n  if (i34 \u003e 127) goto B4 else B11\n}",
      "B4 {\n  if (i32 \u003c i33) goto B5 else B8\n}",
      "B5 {\n  if (r6 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i32)\n}",
      "B7 {\n  $r3 \u003d r6.finishCurrentSegment()\n  r5 \u003d $r3\n  i33 \u003d lengthof $r3\n  i32 \u003d 0\n}",
      "B8 {\n  $i35 \u003d i32\n  i32 \u003d i32 + 1\n  $b36 \u003d (byte) i34\n  r5[$i35] \u003d $b36\n  if (i31 \u003c i0) goto B9 else B10\n}",
      "B9 {\n  goto B36\n}",
      "B10 {\n  $i30 \u003d i31\n  i31 \u003d i31 + 1\n  $c43 \u003d r0.charAt($i30)\n  $i44 \u003d (int) $c43\n  i34 \u003d $i44\n  goto B3\n}",
      "B11 {\n  if (r6 !\u003d null) goto B12 else B13\n}",
      "B12 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i32)\n}",
      "B13 {\n  if (i32 \u003c i33) goto B14 else B15\n}",
      "B14 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i32 \u003d 0\n}",
      "B15 {\n  if (i34 \u003e\u003d 2048) goto B16 else B17\n}",
      "B16 {\n  i37 \u003d i32 + 1\n  $i27 \u003d i34 \u003e\u003e 6\n  $i28 \u003d 192 | $i27\n  $b29 \u003d (byte) $i28\n  r5[i32] \u003d $b29\n  goto B33\n}",
      "B17 {\n  $i46 \u003d (int) 55296\n  if (i34 \u003c $i46) goto B18 else B19\n}",
      "B18 {\n  $i48 \u003d (int) 57343\n  if (i34 \u003c\u003d $i48) goto B19 else B22\n}",
      "B19 {\n  i38 \u003d i32 + 1\n  $i3 \u003d i34 \u003e\u003e 12\n  $i4 \u003d 224 | $i3\n  $b5 \u003d (byte) $i4\n  r5[i32] \u003d $b5\n  if (i38 \u003c i33) goto B20 else B21\n}",
      "B20 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i38 \u003d 0\n}",
      "B21 {\n  i37 \u003d i38 + 1\n  $i6 \u003d i34 \u003e\u003e 6\n  $i7 \u003d $i6 \u0026 63\n  $i8 \u003d 128 | $i7\n  $b9 \u003d (byte) $i8\n  r5[i38] \u003d $b9\n  goto B33\n}",
      "B22 {\n  $i50 \u003d (int) 56319\n  if (i34 \u003c\u003d $i50) goto B23 else B24\n}",
      "B23 {\n  JsonStringEncoder._illegal(i34)\n}",
      "B24 {\n  if (i31 \u003c i0) goto B25 else B26\n}",
      "B25 {\n  JsonStringEncoder._illegal(i34)\n}",
      "B26 {\n  $i13 \u003d i31\n  i31 \u003d i31 + 1\n  $c14 \u003d r0.charAt($i13)\n  $i51 \u003d (int) $c14\n  $i26 \u003d JsonStringEncoder._convert(i34, $i51)\n  i34 \u003d $i26\n  if ($i26 \u003c\u003d 1114111) goto B27 else B28\n}",
      "B27 {\n  JsonStringEncoder._illegal($i26)\n}",
      "B28 {\n  i39 \u003d i32 + 1\n  $i15 \u003d $i26 \u003e\u003e 18\n  $i16 \u003d 240 | $i15\n  $b17 \u003d (byte) $i16\n  r5[i32] \u003d $b17\n  if (i39 \u003c i33) goto B29 else B30\n}",
      "B29 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i39 \u003d 0\n}",
      "B30 {\n  i40 \u003d i39 + 1\n  $i18 \u003d $i26 \u003e\u003e 12\n  $i19 \u003d $i18 \u0026 63\n  $i20 \u003d 128 | $i19\n  $b21 \u003d (byte) $i20\n  r5[i39] \u003d $b21\n  if (i40 \u003c i33) goto B31 else B32\n}",
      "B31 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i40 \u003d 0\n}",
      "B32 {\n  i37 \u003d i40 + 1\n  $i22 \u003d $i26 \u003e\u003e 6\n  $i23 \u003d $i22 \u0026 63\n  $i24 \u003d 128 | $i23\n  $b25 \u003d (byte) $i24\n  r5[i40] \u003d $b25\n}",
      "B33 {\n  if (i37 \u003c i33) goto B34 else B35\n}",
      "B34 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i37 \u003d 0\n}",
      "B35 {\n  i32 \u003d i37 + 1\n  $i10 \u003d i34 \u0026 63\n  $i11 \u003d 128 | $i10\n  $b12 \u003d (byte) $i11\n  r5[i37] \u003d $b12\n  goto B1\n}",
      "B36 {\n  if (r6 !\u003d null) goto B37 else B38\n}",
      "B37 {\n  $r2 \u003d Arrays.copyOfRange(r5, 0, i32)\n  return\n}",
      "B38 {\n  $r1 \u003d r6.completeAndCoalesce(i32)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B36",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B11",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B36",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B33",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B33",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e B35",
      "B35 --\u003e B1",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_illegal(...1)",
        "body": "{\r\n    throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(c));\r\n}"
      },
      {
        "name": "JsonStringEncoder#_initialByteBufSize(...1)",
        "body": "{\r\n    // char-\u003ebyte for UTF-8 can expand size by x3 itself, and escaping\r\n    // more... but let\u0027s use lower factor of 1.5\r\n    final int doubled \u003d Math.max(MIN_BYTE_BUFFER_SIZE, strLen + 6 + (strLen \u003e\u003e 1));\r\n    // but use upper bound for humongous cases (segmented)\r\n    return Math.min(doubled, MAX_BYTE_BUFFER_SIZE);\r\n}"
      },
      {
        "name": "JsonStringEncoder#_convert(...2)",
        "body": "{\r\n    // Ok, then, is the second part valid?\r\n    if (p2 \u003c SURR2_FIRST || p2 \u003e SURR2_LAST) {\r\n        throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(p1) + \", second 0x\" + Integer.toHexString(p2) + \"; illegal combination\");\r\n    }\r\n    return (p1 \u003c\u003c 10) + p2 + UTF8Writer.SURROGATE_BASE;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.JsonStringEncoder",
    "methodName": "encodeAsUTF8",
    "signature": "byte[] encodeAsUTF8(java.lang.CharSequence)",
    "visibility": "public",
    "body": "{\r\n    int inputPtr \u003d 0;\r\n    int inputEnd \u003d text.length();\r\n    int outputPtr \u003d 0;\r\n    byte[] outputBuffer \u003d new byte[_initialByteBufSize(inputEnd)];\r\n    int outputEnd \u003d outputBuffer.length;\r\n    ByteArrayBuilder bb \u003d null;\r\n    main_loop: while (inputPtr \u003c inputEnd) {\r\n        int c \u003d text.charAt(inputPtr++);\r\n        // first tight loop for ascii\r\n        while (c \u003c\u003d 0x7F) {\r\n            if (outputPtr \u003e\u003d outputEnd) {\r\n                if (bb \u003d\u003d null) {\r\n                    bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n                }\r\n                outputBuffer \u003d bb.finishCurrentSegment();\r\n                outputEnd \u003d outputBuffer.length;\r\n                outputPtr \u003d 0;\r\n            }\r\n            outputBuffer[outputPtr++] \u003d (byte) c;\r\n            if (inputPtr \u003e\u003d inputEnd) {\r\n                break main_loop;\r\n            }\r\n            c \u003d text.charAt(inputPtr++);\r\n        }\r\n        // then multi-byte...\r\n        if (bb \u003d\u003d null) {\r\n            bb \u003d ByteArrayBuilder.fromInitial(outputBuffer, outputPtr);\r\n        }\r\n        if (outputPtr \u003e\u003d outputEnd) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputEnd \u003d outputBuffer.length;\r\n            outputPtr \u003d 0;\r\n        }\r\n        if (c \u003c 0x800) {\r\n            // 2-byte\r\n            outputBuffer[outputPtr++] \u003d (byte) (0xc0 | (c \u003e\u003e 6));\r\n        } else {\r\n            // 3 or 4 bytes\r\n            // Surrogates?\r\n            if (c \u003c SURR1_FIRST || c \u003e SURR2_LAST) {\r\n                // nope\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xe0 | (c \u003e\u003e 12));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            } else {\r\n                // yes, surrogate pair\r\n                if (c \u003e SURR1_LAST) {\r\n                    // must be from first range\r\n                    _illegal(c);\r\n                }\r\n                // and if so, followed by another from next range\r\n                if (inputPtr \u003e\u003d inputEnd) {\r\n                    _illegal(c);\r\n                }\r\n                c \u003d _convert(c, text.charAt(inputPtr++));\r\n                if (c \u003e 0x10FFFF) {\r\n                    // illegal, as per RFC 4627\r\n                    _illegal(c);\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0xf0 | (c \u003e\u003e 18));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 12) \u0026 0x3f));\r\n                if (outputPtr \u003e\u003d outputEnd) {\r\n                    outputBuffer \u003d bb.finishCurrentSegment();\r\n                    outputEnd \u003d outputBuffer.length;\r\n                    outputPtr \u003d 0;\r\n                }\r\n                outputBuffer[outputPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            }\r\n        }\r\n        if (outputPtr \u003e\u003d outputEnd) {\r\n            outputBuffer \u003d bb.finishCurrentSegment();\r\n            outputEnd \u003d outputBuffer.length;\r\n            outputPtr \u003d 0;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n    }\r\n    if (bb \u003d\u003d null) {\r\n        return Arrays.copyOfRange(outputBuffer, 0, outputPtr);\r\n    }\r\n    return bb.completeAndCoalesce(outputPtr);\r\n}",
    "nodes": 39,
    "edges": 55,
    "cc": 18,
    "flowSummary": [
      "B1 : If(i31 \u003e\u003d i0) → B2 | else → B36",
      "B3 : If(i34 \u003e 127) → B4 | else → B11",
      "B4 : If(i32 \u003c i33) → B5 | else → B8",
      "B5 : If(r6 !\u003d null) → B6 | else → B7",
      "B8 : If(i31 \u003c i0) → B9 | else → B10",
      "B11 : If(r6 !\u003d null) → B12 | else → B13",
      "B13 : If(i32 \u003c i33) → B14 | else → B15",
      "B15 : If(i34 \u003e\u003d 2048) → B16 | else → B17",
      "B17 : If(i34 \u003c $i46) → B18 | else → B19",
      "B18 : If(i34 \u003c\u003d $i48) → B19 | else → B22",
      "B19 : If(i38 \u003c i33) → B20 | else → B21",
      "B22 : If(i34 \u003c\u003d $i50) → B23 | else → B24",
      "B24 : If(i31 \u003c i0) → B25 | else → B26",
      "B26 : If($i26 \u003c\u003d 1114111) → B27 | else → B28",
      "B28 : If(i39 \u003c i33) → B29 | else → B30",
      "B30 : If(i40 \u003c i33) → B31 | else → B32",
      "B33 : If(i37 \u003c i33) → B34 | else → B35",
      "B36 : If(r6 !\u003d null) → B37 | else → B38"
    ],
    "blockList": [
      "B0 {\n  JsonStringEncoder\n  CharSequence\n  i31 \u003d 0\n  i0 \u003d r0.length()\n  i32 \u003d 0\n  $i1 \u003d JsonStringEncoder._initialByteBufSize(i0)\n  r5 \u003d newarray (byte)[$i1]\n  i33 \u003d lengthof r5\n  r6 \u003d null\n}",
      "B1 {\n  if (i31 \u003e\u003d i0) goto B2 else B36\n}",
      "B2 {\n  $i2 \u003d i31\n  i31 \u003d i31 + 1\n  $c41 \u003d r0.charAt($i2)\n  $i42 \u003d (int) $c41\n  i34 \u003d $i42\n}",
      "B3 {\n  if (i34 \u003e 127) goto B4 else B11\n}",
      "B4 {\n  if (i32 \u003c i33) goto B5 else B8\n}",
      "B5 {\n  if (r6 !\u003d null) goto B6 else B7\n}",
      "B6 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i32)\n}",
      "B7 {\n  $r3 \u003d r6.finishCurrentSegment()\n  r5 \u003d $r3\n  i33 \u003d lengthof $r3\n  i32 \u003d 0\n}",
      "B8 {\n  $i35 \u003d i32\n  i32 \u003d i32 + 1\n  $b36 \u003d (byte) i34\n  r5[$i35] \u003d $b36\n  if (i31 \u003c i0) goto B9 else B10\n}",
      "B9 {\n  goto B36\n}",
      "B10 {\n  $i30 \u003d i31\n  i31 \u003d i31 + 1\n  $c43 \u003d r0.charAt($i30)\n  $i44 \u003d (int) $c43\n  i34 \u003d $i44\n  goto B3\n}",
      "B11 {\n  if (r6 !\u003d null) goto B12 else B13\n}",
      "B12 {\n  r6 \u003d ByteArrayBuilder.fromInitial(r5, i32)\n}",
      "B13 {\n  if (i32 \u003c i33) goto B14 else B15\n}",
      "B14 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i32 \u003d 0\n}",
      "B15 {\n  if (i34 \u003e\u003d 2048) goto B16 else B17\n}",
      "B16 {\n  i37 \u003d i32 + 1\n  $i27 \u003d i34 \u003e\u003e 6\n  $i28 \u003d 192 | $i27\n  $b29 \u003d (byte) $i28\n  r5[i32] \u003d $b29\n  goto B33\n}",
      "B17 {\n  $i46 \u003d (int) 55296\n  if (i34 \u003c $i46) goto B18 else B19\n}",
      "B18 {\n  $i48 \u003d (int) 57343\n  if (i34 \u003c\u003d $i48) goto B19 else B22\n}",
      "B19 {\n  i38 \u003d i32 + 1\n  $i3 \u003d i34 \u003e\u003e 12\n  $i4 \u003d 224 | $i3\n  $b5 \u003d (byte) $i4\n  r5[i32] \u003d $b5\n  if (i38 \u003c i33) goto B20 else B21\n}",
      "B20 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i38 \u003d 0\n}",
      "B21 {\n  i37 \u003d i38 + 1\n  $i6 \u003d i34 \u003e\u003e 6\n  $i7 \u003d $i6 \u0026 63\n  $i8 \u003d 128 | $i7\n  $b9 \u003d (byte) $i8\n  r5[i38] \u003d $b9\n  goto B33\n}",
      "B22 {\n  $i50 \u003d (int) 56319\n  if (i34 \u003c\u003d $i50) goto B23 else B24\n}",
      "B23 {\n  JsonStringEncoder._illegal(i34)\n}",
      "B24 {\n  if (i31 \u003c i0) goto B25 else B26\n}",
      "B25 {\n  JsonStringEncoder._illegal(i34)\n}",
      "B26 {\n  $i13 \u003d i31\n  i31 \u003d i31 + 1\n  $c14 \u003d r0.charAt($i13)\n  $i51 \u003d (int) $c14\n  $i26 \u003d JsonStringEncoder._convert(i34, $i51)\n  i34 \u003d $i26\n  if ($i26 \u003c\u003d 1114111) goto B27 else B28\n}",
      "B27 {\n  JsonStringEncoder._illegal($i26)\n}",
      "B28 {\n  i39 \u003d i32 + 1\n  $i15 \u003d $i26 \u003e\u003e 18\n  $i16 \u003d 240 | $i15\n  $b17 \u003d (byte) $i16\n  r5[i32] \u003d $b17\n  if (i39 \u003c i33) goto B29 else B30\n}",
      "B29 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i39 \u003d 0\n}",
      "B30 {\n  i40 \u003d i39 + 1\n  $i18 \u003d $i26 \u003e\u003e 12\n  $i19 \u003d $i18 \u0026 63\n  $i20 \u003d 128 | $i19\n  $b21 \u003d (byte) $i20\n  r5[i39] \u003d $b21\n  if (i40 \u003c i33) goto B31 else B32\n}",
      "B31 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i40 \u003d 0\n}",
      "B32 {\n  i37 \u003d i40 + 1\n  $i22 \u003d $i26 \u003e\u003e 6\n  $i23 \u003d $i22 \u0026 63\n  $i24 \u003d 128 | $i23\n  $b25 \u003d (byte) $i24\n  r5[i40] \u003d $b25\n}",
      "B33 {\n  if (i37 \u003c i33) goto B34 else B35\n}",
      "B34 {\n  r5 \u003d r6.finishCurrentSegment()\n  i33 \u003d lengthof r5\n  i37 \u003d 0\n}",
      "B35 {\n  i32 \u003d i37 + 1\n  $i10 \u003d i34 \u0026 63\n  $i11 \u003d 128 | $i10\n  $b12 \u003d (byte) $i11\n  r5[i37] \u003d $b12\n  goto B1\n}",
      "B36 {\n  if (r6 !\u003d null) goto B37 else B38\n}",
      "B37 {\n  $r2 \u003d Arrays.copyOfRange(r5, 0, i32)\n  return\n}",
      "B38 {\n  $r1 \u003d r6.completeAndCoalesce(i32)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B36",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B11",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B36",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B33",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B22",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B33",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e B35",
      "B35 --\u003e B1",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonStringEncoder#_illegal(...1)",
        "body": "{\r\n    throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(c));\r\n}"
      },
      {
        "name": "JsonStringEncoder#_initialByteBufSize(...1)",
        "body": "{\r\n    // char-\u003ebyte for UTF-8 can expand size by x3 itself, and escaping\r\n    // more... but let\u0027s use lower factor of 1.5\r\n    final int doubled \u003d Math.max(MIN_BYTE_BUFFER_SIZE, strLen + 6 + (strLen \u003e\u003e 1));\r\n    // but use upper bound for humongous cases (segmented)\r\n    return Math.min(doubled, MAX_BYTE_BUFFER_SIZE);\r\n}"
      },
      {
        "name": "JsonStringEncoder#_convert(...2)",
        "body": "{\r\n    // Ok, then, is the second part valid?\r\n    if (p2 \u003c SURR2_FIRST || p2 \u003e SURR2_LAST) {\r\n        throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(p1) + \", second 0x\" + Integer.toHexString(p2) + \"; illegal combination\");\r\n    }\r\n    return (p1 \u003c\u003c 10) + p2 + UTF8Writer.SURROGATE_BASE;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "available",
    "signature": "int available()",
    "visibility": "public",
    "body": "{\r\n    if (_b !\u003d null) {\r\n        return _end - _ptr;\r\n    }\r\n    return _in.available();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d MergedStream: int _end\u003e\n  $i1 \u003d MergedStream: int _ptr\u003e\n  $i3 \u003d $i2 - $i1\n  return\n}",
      "B2 {\n  $r2 \u003d InputStream _in\u003e\n  $i0 \u003d $r2.available()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "mark",
    "signature": "void mark(int)",
    "visibility": "public",
    "body": "{\r\n    if (_b \u003d\u003d null) {\r\n        _in.mark(readlimit);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  i0 :\u003d @parameter0: int\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d InputStream _in\u003e\n  $r2.mark(i0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "markSupported",
    "signature": "boolean markSupported()",
    "visibility": "public",
    "body": "{\r\n    // Only supports marks past the initial rewindable section...\r\n    return (_b \u003d\u003d null) \u0026\u0026 _in.markSupported();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d InputStream _in\u003e\n  $z0 \u003d $r2.markSupported()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    if (_b !\u003d null) {\r\n        int c \u003d _b[_ptr++] \u0026 0xFF;\r\n        if (_ptr \u003e\u003d _end) {\r\n            _free();\r\n        }\r\n        return c;\r\n    }\r\n    return _in.read();\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B1 : If($i6 \u003c $i5) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d MergedStream: byte[] _b\u003e\n  $i1 \u003d MergedStream: int _ptr\u003e\n  $i2 \u003d $i1 + 1\n  MergedStream: int _ptr\u003e \u003d $i2\n  $b3 \u003d $r3[$i1]\n  $s7 \u003d (short) $b3\n  s4 \u003d $s7 \u0026 255\n  $i6 \u003d MergedStream: int _ptr\u003e\n  $i5 \u003d MergedStream: int _end\u003e\n  if ($i6 \u003c $i5) goto B2 else B3\n}",
      "B2 {\n  r0._free()\n}",
      "B3 {\n  $i8 \u003d (int) s4\n  return\n}",
      "B4 {\n  $r2 \u003d InputStream _in\u003e\n  $i0 \u003d $r2.read()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MergedStream#_free(...0)",
        "body": "{\r\n    byte[] buf \u003d _b;\r\n    if (buf !\u003d null) {\r\n        _b \u003d null;\r\n        if (_ctxt !\u003d null) {\r\n            _ctxt.releaseReadIOBuffer(buf);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "read",
    "signature": "int read(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (_b !\u003d null) {\r\n        int avail \u003d _end - _ptr;\r\n        if (len \u003e avail) {\r\n            len \u003d avail;\r\n        }\r\n        System.arraycopy(_b, _ptr, b, off, len);\r\n        _ptr +\u003d len;\r\n        if (_ptr \u003e\u003d _end) {\r\n            _free();\r\n        }\r\n        return len;\r\n    }\r\n    return _in.read(b, off, len);\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B6",
      "B1 : If(i10 \u003c\u003d i4) → B2 | else → B3",
      "B3 : If($i9 \u003c $i8) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  r2 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i10 :\u003d @parameter2: int\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $i3 \u003d MergedStream: int _end\u003e\n  $i2 \u003d MergedStream: int _ptr\u003e\n  i4 \u003d $i3 - $i2\n  if (i10 \u003c\u003d i4) goto B2 else B3\n}",
      "B2 {\n  i10 \u003d i4\n}",
      "B3 {\n  $r4 \u003d MergedStream: byte[] _b\u003e\n  $i5 \u003d MergedStream: int _ptr\u003e\n  System.arraycopy($r4, $i5, r2, i0, i10)\n  $i6 \u003d MergedStream: int _ptr\u003e\n  $i7 \u003d $i6 + i10\n  MergedStream: int _ptr\u003e \u003d $i7\n  $i9 \u003d MergedStream: int _ptr\u003e\n  $i8 \u003d MergedStream: int _end\u003e\n  if ($i9 \u003c $i8) goto B4 else B5\n}",
      "B4 {\n  r0._free()\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r3 \u003d InputStream _in\u003e\n  $i1 \u003d $r3.read(r2, i0, i10)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MergedStream#_free(...0)",
        "body": "{\r\n    byte[] buf \u003d _b;\r\n    if (buf !\u003d null) {\r\n        _b \u003d null;\r\n        if (_ctxt !\u003d null) {\r\n            _ctxt.releaseReadIOBuffer(buf);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "reset",
    "signature": "void reset()",
    "visibility": "public",
    "body": "{\r\n    if (_b \u003d\u003d null) {\r\n        _in.reset();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d InputStream _in\u003e\n  $r2.reset()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.MergedStream",
    "methodName": "skip",
    "signature": "long skip(long)",
    "visibility": "public",
    "body": "{\r\n    long count \u003d 0L;\r\n    if (_b !\u003d null) {\r\n        int amount \u003d _end - _ptr;\r\n        if (amount \u003e n) {\r\n            // all in pushed back segment?\r\n            _ptr +\u003d (int) n;\r\n            return n;\r\n        }\r\n        _free();\r\n        count +\u003d amount;\r\n        n -\u003d amount;\r\n    }\r\n    if (n \u003e 0) {\r\n        count +\u003d _in.skip(n);\r\n    }\r\n    return count;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B1 : If($i14 \u003c\u003d 0) → B2 | else → B3",
      "B4 : If($i15 \u003c\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  MergedStream\n  l12 :\u003d @parameter0: long\n  l13 \u003d 0L\n  $r1 \u003d MergedStream: byte[] _b\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $i3 \u003d MergedStream: int _end\u003e\n  $i2 \u003d MergedStream: int _ptr\u003e\n  i4 \u003d $i3 - $i2\n  $l5 \u003d (long) i4\n  $b6 \u003d $l5 cmp l12\n  $i14 \u003d (int) $b6\n  if ($i14 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i10 \u003d MergedStream: int _ptr\u003e\n  $i9 \u003d (int) l12\n  $i11 \u003d $i10 + $i9\n  MergedStream: int _ptr\u003e \u003d $i11\n  return\n}",
      "B3 {\n  r0._free()\n  $l7 \u003d (long) i4\n  l13 \u003d 0L + $l7\n  $l8 \u003d (long) i4\n  l12 \u003d l12 - $l8\n}",
      "B4 {\n  $b0 \u003d l12 cmp 0L\n  $i15 \u003d (int) $b0\n  if ($i15 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r2 \u003d InputStream _in\u003e\n  $l1 \u003d $r2.skip(l12)\n  l13 \u003d l13 + $l1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MergedStream#_free(...0)",
        "body": "{\r\n    byte[] buf \u003d _b;\r\n    if (buf !\u003d null) {\r\n        _b \u003d null;\r\n        if (_ctxt !\u003d null) {\r\n            _ctxt.releaseReadIOBuffer(buf);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseInt",
    "signature": "int parseInt(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003e 0 \u0026\u0026 ch[off] \u003d\u003d \u0027+\u0027) {\r\n        off++;\r\n        len--;\r\n    }\r\n    int num \u003d ch[off + len - 1] - \u00270\u0027;\r\n    switch(len) {\r\n        case 9:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 100000000;\r\n        case 8:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 10000000;\r\n        case 7:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 1000000;\r\n        case 6:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 100000;\r\n        case 5:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 10000;\r\n        case 4:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 1000;\r\n        case 3:\r\n            num +\u003d (ch[off++] - \u00270\u0027) * 100;\r\n        case 2:\r\n            num +\u003d (ch[off] - \u00270\u0027) * 10;\r\n    }\r\n    return num;\r\n}",
    "nodes": 13,
    "edges": 22,
    "cc": 11,
    "flowSummary": [
      "B0 : If(i10 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($i39 !\u003d 43) → B2 | else → B3",
      "B3 : If(switch-on i10) → B11 | else → B10"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: char[]\n  i9 :\u003d @parameter1: int\n  i10 :\u003d @parameter2: int\n  if (i10 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $c8 \u003d r0[i9]\n  $i39 \u003d (int) $c8\n  if ($i39 !\u003d 43) goto B2 else B3\n}",
      "B2 {\n  i9 \u003d i9 + 1\n  $i41 \u003d (int) -1\n  i10 \u003d i10 + $i41\n}",
      "B3 {\n  $i11 \u003d i9 + i10\n  $i12 \u003d $i11 - 1\n  $c13 \u003d r0[$i12]\n  $i42 \u003d (int) $c13\n  $i14 \u003d $i42 - 48\n  i15 \u003d $i14\n  tableswitch(i10) {     case 2: goto $c36 \u003d r0[i9];     case 3: goto $i32 \u003d i9;     case 4: goto $i28 \u003d i9;     case 5: goto $i24 \u003d i9;     case 6: goto $i20 \u003d i9;     case 7: goto $i16 \u003d i9;     case 8: goto $i4 \u003d i9;     case 9: goto $i0 \u003d i9;     default: goto return i15; }\n}",
      "B4 {\n  $i0 \u003d i9\n  i9 \u003d i9 + 1\n  $c1 \u003d r0[$i0]\n  $i43 \u003d (int) $c1\n  $i2 \u003d $i43 - 48\n  $i3 \u003d $i2 * 100000000\n  i15 \u003d $i14 + $i3\n}",
      "B5 {\n  $i4 \u003d i9\n  i9 \u003d i9 + 1\n  $c5 \u003d r0[$i4]\n  $i44 \u003d (int) $c5\n  $i6 \u003d $i44 - 48\n  $i7 \u003d $i6 * 10000000\n  i15 \u003d i15 + $i7\n}",
      "B6 {\n  $i16 \u003d i9\n  i9 \u003d i9 + 1\n  $c17 \u003d r0[$i16]\n  $i45 \u003d (int) $c17\n  $i18 \u003d $i45 - 48\n  $i19 \u003d $i18 * 1000000\n  i15 \u003d i15 + $i19\n}",
      "B7 {\n  $i20 \u003d i9\n  i9 \u003d i9 + 1\n  $c21 \u003d r0[$i20]\n  $i46 \u003d (int) $c21\n  $i22 \u003d $i46 - 48\n  $i23 \u003d $i22 * 100000\n  i15 \u003d i15 + $i23\n}",
      "B8 {\n  $i24 \u003d i9\n  i9 \u003d i9 + 1\n  $c25 \u003d r0[$i24]\n  $i47 \u003d (int) $c25\n  $i26 \u003d $i47 - 48\n  $i27 \u003d $i26 * 10000\n  i15 \u003d i15 + $i27\n}",
      "B9 {\n  $i28 \u003d i9\n  i9 \u003d i9 + 1\n  $c29 \u003d r0[$i28]\n  $i48 \u003d (int) $c29\n  $i30 \u003d $i48 - 48\n  $i31 \u003d $i30 * 1000\n  i15 \u003d i15 + $i31\n}",
      "B10 {\n  $i32 \u003d i9\n  i9 \u003d i9 + 1\n  $c33 \u003d r0[$i32]\n  $i49 \u003d (int) $c33\n  $i34 \u003d $i49 - 48\n  $i35 \u003d $i34 * 100\n  i15 \u003d i15 + $i35\n}",
      "B11 {\n  $c36 \u003d r0[i9]\n  $i50 \u003d (int) $c36\n  $i37 \u003d $i50 - 48\n  $i38 \u003d $i37 * 10\n  i15 \u003d i15 + $i38\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B11",
      "B3 --\u003e B10",
      "B3 --\u003e B9",
      "B3 --\u003e B8",
      "B3 --\u003e B7",
      "B3 --\u003e B6",
      "B3 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B12",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseInt",
    "signature": "int parseInt(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    /* Ok: let\u0027s keep strategy simple: ignoring optional minus sign,\r\n         * we\u0027ll accept 1 - 9 digits and parse things efficiently;\r\n         * otherwise just defer to JDK parse functionality.\r\n         */\r\n    char c \u003d s.charAt(0);\r\n    int len \u003d s.length();\r\n    boolean neg \u003d (c \u003d\u003d \u0027-\u0027);\r\n    int offset \u003d 1;\r\n    // must have 1 - 9 digits after optional sign:\r\n    // negative?\r\n    if (neg) {\r\n        if (len \u003d\u003d 1 || len \u003e 10) {\r\n            return Integer.parseInt(s);\r\n        }\r\n        c \u003d s.charAt(offset++);\r\n    } else {\r\n        if (len \u003e 9) {\r\n            return Integer.parseInt(s);\r\n        }\r\n    }\r\n    if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n        return Integer.parseInt(s);\r\n    }\r\n    int num \u003d c - \u00270\u0027;\r\n    if (offset \u003c len) {\r\n        c \u003d s.charAt(offset++);\r\n        if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n            return Integer.parseInt(s);\r\n        }\r\n        num \u003d (num * 10) + (c - \u00270\u0027);\r\n        if (offset \u003c len) {\r\n            c \u003d s.charAt(offset++);\r\n            if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n                return Integer.parseInt(s);\r\n            }\r\n            num \u003d (num * 10) + (c - \u00270\u0027);\r\n            // Let\u0027s just loop if we have more than 3 digits:\r\n            if (offset \u003c len) {\r\n                do {\r\n                    c \u003d s.charAt(offset++);\r\n                    if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n                        return Integer.parseInt(s);\r\n                    }\r\n                    num \u003d (num * 10) + (c - \u00270\u0027);\r\n                } while (offset \u003c len);\r\n            }\r\n        }\r\n    }\r\n    return neg ? -num : num;\r\n}",
    "nodes": 30,
    "edges": 41,
    "cc": 13,
    "flowSummary": [
      "B0 : If($i26 !\u003d 45) → B1 | else → B2",
      "B3 : If($z3 \u003d\u003d false) → B4 | else → B8",
      "B4 : If(i0 \u003d\u003d 1) → B5 | else → B6",
      "B5 : If(i0 \u003c\u003d 10) → B6 | else → B7",
      "B8 : If(i0 \u003c\u003d 9) → B9 | else → B10",
      "B10 : If($i27 \u003e 57) → B11 | else → B12",
      "B11 : If($i28 \u003e\u003d 48) → B12 | else → B13",
      "B13 : If(b25 \u003e\u003d i0) → B14 | else → B26",
      "B14 : If($i30 \u003e 57) → B15 | else → B16",
      "B15 : If($i31 \u003e\u003d 48) → B16 | else → B17",
      "B17 : If(i18 \u003e\u003d i0) → B18 | else → B26",
      "B18 : If($i33 \u003e 57) → B19 | else → B20",
      "B19 : If($i34 \u003e\u003d 48) → B20 | else → B21",
      "B21 : If(i20 \u003e\u003d i0) → B22 | else → B26",
      "B22 : If($i36 \u003e 57) → B23 | else → B24",
      "B23 : If($i37 \u003e\u003d 48) → B24 | else → B25",
      "B25 : If(i20 \u003c i0) → B26 | else → B22",
      "B26 : If(z0 \u003d\u003d false) → B27 | else → B28"
    ],
    "blockList": [
      "B0 {\n  String\n  c15 \u003d r0.charAt(0)\n  i0 \u003d r0.length()\n  $i26 \u003d (int) c15\n  if ($i26 !\u003d 45) goto B1 else B2\n}",
      "B1 {\n  $z3 \u003d 1\n  $z2 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z3 \u003d 0\n  $z2 \u003d 0\n}",
      "B3 {\n  z0 \u003d $z2\n  b16 \u003d 1\n  b25 \u003d 1\n  b24 \u003d 1\n  b23 \u003d 1\n  if ($z3 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  if (i0 \u003d\u003d 1) goto B5 else B6\n}",
      "B5 {\n  if (i0 \u003c\u003d 10) goto B6 else B7\n}",
      "B6 {\n  $i14 \u003d Integer.parseInt(r0)\n  return\n}",
      "B7 {\n  b16 \u003d 2\n  b25 \u003d 2\n  b24 \u003d 2\n  b23 \u003d 2\n  c15 \u003d r0.charAt(1)\n  goto B10\n}",
      "B8 {\n  if (i0 \u003c\u003d 9) goto B9 else B10\n}",
      "B9 {\n  $i13 \u003d Integer.parseInt(r0)\n  return\n}",
      "B10 {\n  $i27 \u003d (int) c15\n  if ($i27 \u003e 57) goto B11 else B12\n}",
      "B11 {\n  $i28 \u003d (int) c15\n  if ($i28 \u003e\u003d 48) goto B12 else B13\n}",
      "B12 {\n  $i1 \u003d Integer.parseInt(r0)\n  return\n}",
      "B13 {\n  $i29 \u003d (int) c15\n  i17 \u003d $i29 - 48\n  if (b25 \u003e\u003d i0) goto B14 else B26\n}",
      "B14 {\n  i18 \u003d b23 + 1\n  c19 \u003d r0.charAt(b24)\n  $i30 \u003d (int) c19\n  if ($i30 \u003e 57) goto B15 else B16\n}",
      "B15 {\n  $i31 \u003d (int) c19\n  if ($i31 \u003e\u003d 48) goto B16 else B17\n}",
      "B16 {\n  $i2 \u003d Integer.parseInt(r0)\n  return\n}",
      "B17 {\n  $i4 \u003d i17 * 10\n  $i32 \u003d (int) c19\n  $i3 \u003d $i32 - 48\n  i17 \u003d $i4 + $i3\n  if (i18 \u003e\u003d i0) goto B18 else B26\n}",
      "B18 {\n  i20 \u003d i18 + 1\n  c21 \u003d r0.charAt(i18)\n  $i33 \u003d (int) c21\n  if ($i33 \u003e 57) goto B19 else B20\n}",
      "B19 {\n  $i34 \u003d (int) c21\n  if ($i34 \u003e\u003d 48) goto B20 else B21\n}",
      "B20 {\n  $i5 \u003d Integer.parseInt(r0)\n  return\n}",
      "B21 {\n  $i7 \u003d i17 * 10\n  $i35 \u003d (int) c21\n  $i6 \u003d $i35 - 48\n  i17 \u003d $i7 + $i6\n  if (i20 \u003e\u003d i0) goto B22 else B26\n}",
      "B22 {\n  $i8 \u003d i20\n  i20 \u003d i20 + 1\n  $c12 \u003d r0.charAt($i8)\n  $i36 \u003d (int) $c12\n  if ($i36 \u003e 57) goto B23 else B24\n}",
      "B23 {\n  $i37 \u003d (int) $c12\n  if ($i37 \u003e\u003d 48) goto B24 else B25\n}",
      "B24 {\n  $i9 \u003d Integer.parseInt(r0)\n  return\n}",
      "B25 {\n  $i11 \u003d i17 * 10\n  $i38 \u003d (int) $c12\n  $i10 \u003d $i38 - 48\n  i17 \u003d $i11 + $i10\n  if (i20 \u003c i0) goto B26 else B22\n}",
      "B26 {\n  if (z0 \u003d\u003d false) goto B27 else B28\n}",
      "B27 {\n  $i22 \u003d neg i17\n  goto B29\n}",
      "B28 {\n  $i22 \u003d i17\n}",
      "B29 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B26",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B26",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B22",
      "B21 --\u003e B26",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B22",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseLong19",
    "signature": "long parseLong19(char[],int,boolean)",
    "visibility": "public",
    "body": "{\r\n    // Note: caller must ensure length is 19\r\n    long num \u003d 0L;\r\n    for (int i \u003d 0; i \u003c 19; i++) {\r\n        char c \u003d ch[off + i];\r\n        num \u003d (num * 10) + (c - \u00270\u0027);\r\n    }\r\n    return negative ? -num : num;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i7 \u003e\u003d 19) → B2 | else → B3",
      "B3 : If(z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  z0 :\u003d @parameter2: boolean\n  l6 \u003d 0L\n  i7 \u003d 0\n}",
      "B1 {\n  if (i7 \u003e\u003d 19) goto B2 else B3\n}",
      "B2 {\n  $i1 \u003d i0 + i7\n  c2 \u003d r0[$i1]\n  $l5 \u003d l6 * 10L\n  $i9 \u003d (int) c2\n  $i3 \u003d $i9 - 48\n  $l4 \u003d (long) $i3\n  l6 \u003d $l5 + $l4\n  i7 \u003d i7 + 1\n  goto B1\n}",
      "B3 {\n  if (z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $l8 \u003d neg l6\n  goto B6\n}",
      "B5 {\n  $l8 \u003d l6\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseLong",
    "signature": "long parseLong(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // Ok, now; as the very first thing, let\u0027s just optimize case of \"fake longs\";\r\n    // that is, if we know they must be ints, call int parsing\r\n    int length \u003d s.length();\r\n    if (length \u003c\u003d 9) {\r\n        return parseInt(s);\r\n    }\r\n    // !!! TODO: implement efficient 2-int parsing...\r\n    return Long.parseLong(s);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e 9) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  i0 \u003d r0.length()\n  if (i0 \u003e 9) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d NumberInput.parseInt(r0)\n  $l3 \u003d (long) $i2\n  return\n}",
      "B2 {\n  $l1 \u003d Long.parseLong(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberInput#parseInt(...1)",
        "body": "{\r\n    /* Ok: let\u0027s keep strategy simple: ignoring optional minus sign,\r\n         * we\u0027ll accept 1 - 9 digits and parse things efficiently;\r\n         * otherwise just defer to JDK parse functionality.\r\n         */\r\n    char c \u003d s.charAt(0);\r\n    int len \u003d s.length();\r\n    boolean neg \u003d (c \u003d\u003d \u0027-\u0027);\r\n    int offset \u003d 1;\r\n    // must have 1 - 9 digits after optional sign:\r\n    // negative?\r\n    if (neg) {\r\n        if (len \u003d\u003d 1 || len \u003e 10) {\r\n            return Integer.parseInt(s);\r\n        }\r\n        c \u003d s.charAt(offset++);\r\n    } else {\r\n        if (len \u003e 9) {\r\n            return Integer.parseInt(s);\r\n        }\r\n    }\r\n    if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n        return Integer.parseInt(s);\r\n    }\r\n    int num \u003d c - \u00270\u0027;\r\n    if (offset \u003c len) {\r\n        c \u003d s.charAt(offset++);\r\n        if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n            return Integer.parseInt(s);\r\n        }\r\n        num \u003d (num * 10) + (c - \u00270\u0027);\r\n        if (offset \u003c len) {\r\n            c \u003d s.charAt(offset++);\r\n            if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n                return Integer.parseInt(s);\r\n            }\r\n            num \u003d (num * 10) + (c - \u00270\u0027);\r\n            // Let\u0027s just loop if we have more than 3 digits:\r\n            if (offset \u003c len) {\r\n                do {\r\n                    c \u003d s.charAt(offset++);\r\n                    if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n                        return Integer.parseInt(s);\r\n                    }\r\n                    num \u003d (num * 10) + (c - \u00270\u0027);\r\n                } while (offset \u003c len);\r\n            }\r\n        }\r\n    }\r\n    return neg ? -num : num;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "inLongRange",
    "signature": "boolean inLongRange(char[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    String cmpStr \u003d negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\r\n    int cmpLen \u003d cmpStr.length();\r\n    if (len \u003c cmpLen)\r\n        return true;\r\n    if (len \u003e cmpLen)\r\n        return false;\r\n    for (int i \u003d 0; i \u003c cmpLen; ++i) {\r\n        int diff \u003d ch[off + i] - cmpStr.charAt(i);\r\n        if (diff !\u003d 0) {\r\n            return (diff \u003c 0);\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 16,
    "edges": 18,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If(i0 \u003e\u003d $i6) → B4 | else → B5",
      "B5 : If(i0 \u003c\u003d $i6) → B6 | else → B7",
      "B8 : If(i7 \u003e\u003d $i6) → B9 | else → B15",
      "B9 : If(i5 \u003d\u003d false) → B10 | else → B14",
      "B10 : If(i5 \u003e\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: char[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  z0 :\u003d @parameter3: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d String MIN_LONG_STR_NO_SIGN\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d String MAX_LONG_STR\u003e\n}",
      "B3 {\n  r0 \u003d $r2\n  $i6 \u003d $r2.length()\n  if (i0 \u003e\u003d $i6) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  if (i0 \u003c\u003d $i6) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  i7 \u003d 0\n}",
      "B8 {\n  if (i7 \u003e\u003d $i6) goto B9 else B15\n}",
      "B9 {\n  $i2 \u003d i1 + i7\n  $c3 \u003d r1[$i2]\n  $c4 \u003d r0.charAt(i7)\n  $i8 \u003d (int) $c3\n  $i9 \u003d (int) $c4\n  i5 \u003d $i8 - $i9\n  if (i5 \u003d\u003d false) goto B10 else B14\n}",
      "B10 {\n  if (i5 \u003e\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $z1 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z1 \u003d 0\n}",
      "B13 {\n  return\n}",
      "B14 {\n  i7 \u003d i7 + 1\n  goto B8\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B15",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B8",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "inLongRange",
    "signature": "boolean inLongRange(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    String cmp \u003d negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\r\n    int cmpLen \u003d cmp.length();\r\n    int alen \u003d s.length();\r\n    if (alen \u003c cmpLen)\r\n        return true;\r\n    if (alen \u003e cmpLen)\r\n        return false;\r\n    // could perhaps just use String.compareTo()?\r\n    for (int i \u003d 0; i \u003c cmpLen; ++i) {\r\n        int diff \u003d s.charAt(i) - cmp.charAt(i);\r\n        if (diff !\u003d 0) {\r\n            return (diff \u003c 0);\r\n        }\r\n    }\r\n    return true;\r\n}",
    "nodes": 16,
    "edges": 18,
    "cc": 4,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($i4 \u003e\u003d $i3) → B4 | else → B5",
      "B5 : If($i4 \u003c\u003d $i3) → B6 | else → B7",
      "B8 : If(i5 \u003e\u003d $i3) → B9 | else → B15",
      "B9 : If(i2 \u003d\u003d false) → B10 | else → B14",
      "B10 : If(i2 \u003e\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  String\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d String MIN_LONG_STR_NO_SIGN\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d String MAX_LONG_STR\u003e\n}",
      "B3 {\n  r0 \u003d $r2\n  $i3 \u003d $r2.length()\n  $i4 \u003d r1.length()\n  if ($i4 \u003e\u003d $i3) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  if ($i4 \u003c\u003d $i3) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  i5 \u003d 0\n}",
      "B8 {\n  if (i5 \u003e\u003d $i3) goto B9 else B15\n}",
      "B9 {\n  $c1 \u003d r1.charAt(i5)\n  $c0 \u003d r0.charAt(i5)\n  $i6 \u003d (int) $c1\n  $i7 \u003d (int) $c0\n  i2 \u003d $i6 - $i7\n  if (i2 \u003d\u003d false) goto B10 else B14\n}",
      "B10 {\n  if (i2 \u003e\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $z1 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z1 \u003d 0\n}",
      "B13 {\n  return\n}",
      "B14 {\n  i5 \u003d i5 + 1\n  goto B8\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B15",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B8",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseAsInt",
    "signature": "int parseAsInt(java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    if (s \u003d\u003d null) {\r\n        return def;\r\n    }\r\n    s \u003d s.trim();\r\n    int len \u003d s.length();\r\n    if (len \u003d\u003d 0) {\r\n        return def;\r\n    }\r\n    // One more thing: use integer parsing for \u0027simple\u0027\r\n    int i \u003d 0;\r\n    // skip leading sign, if any\r\n    final char sign \u003d s.charAt(0);\r\n    if (sign \u003d\u003d \u0027+\u0027) {\r\n        // for plus, actually physically remove\r\n        s \u003d s.substring(1);\r\n        len \u003d s.length();\r\n    } else if (sign \u003d\u003d \u0027-\u0027) {\r\n        // minus, just skip for checks, must retain\r\n        i \u003d 1;\r\n    }\r\n    for (; i \u003c len; ++i) {\r\n        char c \u003d s.charAt(i);\r\n        // if other symbols, parse as Double, coerce\r\n        if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n            try {\r\n                //useFastParser\u003dtrue is used because there is a lot less risk that small changes in result will have an affect\r\n                //and performance benefit is useful\r\n                return (int) parseDouble(s, true);\r\n            } catch (NumberFormatException e) {\r\n                return def;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return Integer.parseInt(s);\r\n    } catch (NumberFormatException e) {\r\n    }\r\n    return def;\r\n}",
    "nodes": 16,
    "edges": 17,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(i4 !\u003d 0) → B3 | else → B4",
      "B4 : If($i7 !\u003d 43) → B5 | else → B6",
      "B6 : If($i8 !\u003d 45) → B7 | else → B8",
      "B8 : If(i5 \u003e\u003d i4) → B9 | else → B14",
      "B9 : If($i9 \u003e 57) → B10 | else → B11",
      "B10 : If($i10 \u003e\u003d 48) → B11 | else → B13"
    ],
    "blockList": [
      "B0 {\n  String\n  i3 :\u003d @parameter1: int\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r3 \u003d r2.trim()\n  i4 \u003d r3.length()\n  if (i4 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i5 \u003d 0\n  c0 \u003d r3.charAt(0)\n  $i7 \u003d (int) c0\n  if ($i7 !\u003d 43) goto B5 else B6\n}",
      "B5 {\n  r3 \u003d r3.substring(1)\n  i4 \u003d r3.length()\n  goto B8\n}",
      "B6 {\n  $i8 \u003d (int) c0\n  if ($i8 !\u003d 45) goto B7 else B8\n}",
      "B7 {\n  i5 \u003d 1\n}",
      "B8 {\n  if (i5 \u003e\u003d i4) goto B9 else B14\n}",
      "B9 {\n  c6 \u003d r3.charAt(i5)\n  $i9 \u003d (int) c6\n  if ($i9 \u003e 57) goto B10 else B11\n}",
      "B10 {\n  $i10 \u003d (int) c6\n  if ($i10 \u003e\u003d 48) goto B11 else B13\n}",
      "B11 {\n  $d0 \u003d NumberInput.parseDouble(r3, 1)\n  $i2 \u003d (int) $d0\n  return\n}",
      "B12 {\n  $r1 :\u003d @caughtexception\n  return\n}",
      "B13 {\n  i5 \u003d i5 + 1\n  goto B8\n}",
      "B14 {\n  $i1 \u003d Integer.parseInt(r3)\n  return\n}",
      "B15 {\n  $r0 :\u003d @caughtexception\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B8",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberInput#parseDouble(...2)",
        "body": "{\r\n    return useFastParser ? JavaDoubleParser.parseDouble(s) : Double.parseDouble(s);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseAsLong",
    "signature": "long parseAsLong(java.lang.String,long)",
    "visibility": "public",
    "body": "{\r\n    if (s \u003d\u003d null) {\r\n        return def;\r\n    }\r\n    s \u003d s.trim();\r\n    int len \u003d s.length();\r\n    if (len \u003d\u003d 0) {\r\n        return def;\r\n    }\r\n    // One more thing: use long parsing for \u0027simple\u0027\r\n    int i \u003d 0;\r\n    // skip leading sign, if any\r\n    final char sign \u003d s.charAt(0);\r\n    if (sign \u003d\u003d \u0027+\u0027) {\r\n        // for plus, actually physically remove\r\n        s \u003d s.substring(1);\r\n        len \u003d s.length();\r\n    } else if (sign \u003d\u003d \u0027-\u0027) {\r\n        // minus, just skip for checks, must retain\r\n        i \u003d 1;\r\n    }\r\n    for (; i \u003c len; ++i) {\r\n        char c \u003d s.charAt(i);\r\n        // if other symbols, parse as Double, coerce\r\n        if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027) {\r\n            try {\r\n                //useFastParser\u003dtrue is used because there is a lot less risk that small changes in result will have an affect\r\n                //and performance benefit is useful\r\n                return (long) parseDouble(s, true);\r\n            } catch (NumberFormatException e) {\r\n                return def;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return Long.parseLong(s);\r\n    } catch (NumberFormatException e) {\r\n    }\r\n    return def;\r\n}",
    "nodes": 16,
    "edges": 17,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2",
      "B2 : If(i4 !\u003d 0) → B3 | else → B4",
      "B4 : If($i7 !\u003d 43) → B5 | else → B6",
      "B6 : If($i8 !\u003d 45) → B7 | else → B8",
      "B8 : If(i5 \u003e\u003d i4) → B9 | else → B14",
      "B9 : If($i9 \u003e 57) → B10 | else → B11",
      "B10 : If($i10 \u003e\u003d 48) → B11 | else → B13"
    ],
    "blockList": [
      "B0 {\n  String\n  l3 :\u003d @parameter1: long\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r3 \u003d r2.trim()\n  i4 \u003d r3.length()\n  if (i4 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  i5 \u003d 0\n  c0 \u003d r3.charAt(0)\n  $i7 \u003d (int) c0\n  if ($i7 !\u003d 43) goto B5 else B6\n}",
      "B5 {\n  r3 \u003d r3.substring(1)\n  i4 \u003d r3.length()\n  goto B8\n}",
      "B6 {\n  $i8 \u003d (int) c0\n  if ($i8 !\u003d 45) goto B7 else B8\n}",
      "B7 {\n  i5 \u003d 1\n}",
      "B8 {\n  if (i5 \u003e\u003d i4) goto B9 else B14\n}",
      "B9 {\n  c6 \u003d r3.charAt(i5)\n  $i9 \u003d (int) c6\n  if ($i9 \u003e 57) goto B10 else B11\n}",
      "B10 {\n  $i10 \u003d (int) c6\n  if ($i10 \u003e\u003d 48) goto B11 else B13\n}",
      "B11 {\n  $d0 \u003d NumberInput.parseDouble(r3, 1)\n  $l2 \u003d (long) $d0\n  return\n}",
      "B12 {\n  $r1 :\u003d @caughtexception\n  return\n}",
      "B13 {\n  i5 \u003d i5 + 1\n  goto B8\n}",
      "B14 {\n  $l1 \u003d Long.parseLong(r3)\n  return\n}",
      "B15 {\n  $r0 :\u003d @caughtexception\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B8",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberInput#parseDouble(...2)",
        "body": "{\r\n    return useFastParser ? JavaDoubleParser.parseDouble(s) : Double.parseDouble(s);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseDouble",
    "signature": "double parseDouble(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    return useFastParser ? JavaDoubleParser.parseDouble(s) : Double.parseDouble(s);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $d0 \u003d JavaDoubleParser.parseDouble(r0)\n  goto B3\n}",
      "B2 {\n  $d0 \u003d Double.parseDouble(r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseDouble",
    "signature": "double parseDouble(char[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    return useFastParser ? JavaDoubleParser.parseDouble(array, offset, len) : Double.parseDouble(new String(array, offset, len));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  z0 :\u003d @parameter3: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $d0 \u003d JavaDoubleParser.parseDouble(r1, i0, i1)\n  goto B3\n}",
      "B2 {\n  $r0 \u003d String\n  new String(r1, i0, i1)\n  $d0 \u003d Double.parseDouble($r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseFloat",
    "signature": "float parseFloat(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return JavaFloatParser.parseFloat(s);\r\n    }\r\n    return Float.parseFloat(s);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $f1 \u003d JavaFloatParser.parseFloat(r0)\n  return\n}",
      "B2 {\n  $f0 \u003d Float.parseFloat(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseFloat",
    "signature": "float parseFloat(char[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    return useFastParser ? JavaFloatParser.parseFloat(array, offset, len) : Float.parseFloat(new String(array, offset, len));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  z0 :\u003d @parameter3: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $f0 \u003d JavaFloatParser.parseFloat(r1, i0, i1)\n  goto B3\n}",
      "B2 {\n  $r0 \u003d String\n  new String(r1, i0, i1)\n  $f0 \u003d Float.parseFloat($r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseBigDecimal",
    "signature": "java.math.BigDecimal parseBigDecimal(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return BigDecimalParser.parseWithFastParser(s);\r\n    }\r\n    return BigDecimalParser.parse(s);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d BigDecimalParser.parseWithFastParser(r0)\n  return\n}",
      "B2 {\n  $r1 \u003d BigDecimalParser.parse(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseBigDecimal",
    "signature": "java.math.BigDecimal parseBigDecimal(char[],int,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return BigDecimalParser.parseWithFastParser(ch, off, len);\r\n    }\r\n    return BigDecimalParser.parse(ch, off, len);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  z0 :\u003d @parameter3: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d BigDecimalParser.parseWithFastParser(r0, i0, i1)\n  return\n}",
      "B2 {\n  $r1 \u003d BigDecimalParser.parse(r0, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseBigDecimal",
    "signature": "java.math.BigDecimal parseBigDecimal(char[],boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return BigDecimalParser.parseWithFastParser(ch, 0, ch.length);\r\n    }\r\n    return BigDecimalParser.parse(ch);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  r0 :\u003d @parameter0: char[]\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d lengthof r0\n  $r2 \u003d BigDecimalParser.parseWithFastParser(r0, 0, $i0)\n  return\n}",
      "B2 {\n  $r1 \u003d BigDecimalParser.parse(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseBigInteger",
    "signature": "java.math.BigInteger parseBigInteger(java.lang.String,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return BigIntegerParser.parseWithFastParser(s);\r\n    }\r\n    return new BigInteger(s);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d BigIntegerParser.parseWithFastParser(r1)\n  return\n}",
      "B2 {\n  $r0 \u003d BigInteger\n  new BigInteger(r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "parseBigIntegerWithRadix",
    "signature": "java.math.BigInteger parseBigIntegerWithRadix(java.lang.String,int,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (useFastParser) {\r\n        return BigIntegerParser.parseWithFastParser(s, radix);\r\n    }\r\n    return new BigInteger(s, radix);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  String\n  i0 :\u003d @parameter1: int\n  z0 :\u003d @parameter2: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d BigIntegerParser.parseWithFastParser(r1, i0)\n  return\n}",
      "B2 {\n  $r0 \u003d BigInteger\n  new BigInteger(r1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberInput",
    "methodName": "looksLikeValidNumber",
    "signature": "boolean looksLikeValidNumber(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // While PATTERN_FLOAT handles most cases we can optimize some simple ones:\r\n    if (s \u003d\u003d null || s.isEmpty()) {\r\n        return false;\r\n    }\r\n    if (s.length() \u003d\u003d 1) {\r\n        char c \u003d s.charAt(0);\r\n        return (c \u003c\u003d \u00279\u0027) \u0026\u0026 (c \u003e\u003d \u00270\u0027);\r\n    }\r\n    return PATTERN_FLOAT.matcher(s).matches() || PATTERN_FLOAT_TRAILING_DOT.matcher(s).matches();\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($i0 !\u003d 1) → B4 | else → B9",
      "B4 : If($i2 \u003e 57) → B5 | else → B7",
      "B5 : If($i3 \u003c 48) → B6 | else → B7",
      "B9 : If($z1 !\u003d 0) → B10 | else → B11",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d r0.isEmpty()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $i0 \u003d r0.length()\n  if ($i0 !\u003d 1) goto B4 else B9\n}",
      "B4 {\n  c1 \u003d r0.charAt(0)\n  $i2 \u003d (int) c1\n  if ($i2 \u003e 57) goto B5 else B7\n}",
      "B5 {\n  $i3 \u003d (int) c1\n  if ($i3 \u003c 48) goto B6 else B7\n}",
      "B6 {\n  $z3 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z3 \u003d 0\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $r1 \u003d Pattern PATTERN_FLOAT\u003e\n  $r2 \u003d $r1.matcher(r0)\n  $z1 \u003d $r2.matches()\n  if ($z1 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $r3 \u003d Pattern PATTERN_FLOAT_TRAILING_DOT\u003e\n  $r4 \u003d $r3.matcher(r0)\n  $z2 \u003d $r4.matches()\n  if ($z2 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $z4 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z4 \u003d 0\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "outputInt",
    "signature": "int outputInt(int,char[],int)",
    "visibility": "public",
    "body": "{\r\n    if (v \u003c 0) {\r\n        if (v \u003d\u003d Integer.MIN_VALUE) {\r\n            // Special case: no matching positive value within range;\r\n            // let\u0027s then \"upgrade\" to long and output as such.\r\n            return _outputSmallestI(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    }\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            if (v \u003c 10) {\r\n                b[off] \u003d (char) (\u00270\u0027 + v);\r\n                return off + 1;\r\n            }\r\n            return _leading3(v, b, off);\r\n        }\r\n        int thousands \u003d divBy1000(v);\r\n        // \u003d\u003d value % 1000\r\n        v -\u003d (thousands * 1000);\r\n        off \u003d _leading3(thousands, b, off);\r\n        off \u003d _full3(v, b, off);\r\n        return off;\r\n    }\r\n    // ok, all 3 triplets included\r\n    /* Let\u0027s first hand possible billions separately before\r\n         * handling 3 triplets. This is possible since we know we\r\n         * can have at most \u00272\u0027 as billion count.\r\n         */\r\n    if (v \u003e\u003d BILLION) {\r\n        v -\u003d BILLION;\r\n        if (v \u003e\u003d BILLION) {\r\n            v -\u003d BILLION;\r\n            b[off++] \u003d \u00272\u0027;\r\n        } else {\r\n            b[off++] \u003d \u00271\u0027;\r\n        }\r\n        return _outputFullBillion(v, b, off);\r\n    }\r\n    int newValue \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (newValue * 1000));\r\n    v \u003d newValue;\r\n    newValue \u003d divBy1000(newValue);\r\n    int thousands \u003d (v - (newValue * 1000));\r\n    off \u003d _leading3(newValue, b, off);\r\n    off \u003d _full3(thousands, b, off);\r\n    return _full3(ones, b, off);\r\n}",
    "nodes": 16,
    "edges": 17,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i18 \u003e\u003d 0) → B1 | else → B4",
      "B1 : If(i18 !\u003d -2147483648) → B2 | else → B3",
      "B4 : If(i18 \u003e\u003d $i0) → B5 | else → B10",
      "B5 : If(i18 \u003e\u003d 1000) → B6 | else → B9",
      "B6 : If(i18 \u003e\u003d 10) → B7 | else → B8",
      "B10 : If(i18 \u003c $i1) → B11 | else → B15",
      "B11 : If(i24 \u003c $i8) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  i18 :\u003d @parameter0: int\n  r0 :\u003d @parameter1: char[]\n  i19 :\u003d @parameter2: int\n  if (i18 \u003e\u003d 0) goto B1 else B4\n}",
      "B1 {\n  if (i18 !\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  $i17 \u003d NumberOutput._outputSmallestI(r0, i19)\n  return\n}",
      "B3 {\n  $i16 \u003d i19\n  i19 \u003d i19 + 1\n  r0[$i16] \u003d 45\n  i18 \u003d neg i18\n}",
      "B4 {\n  $i0 \u003d NumberOutput: int MILLION\u003e\n  if (i18 \u003e\u003d $i0) goto B5 else B10\n}",
      "B5 {\n  if (i18 \u003e\u003d 1000) goto B6 else B9\n}",
      "B6 {\n  if (i18 \u003e\u003d 10) goto B7 else B8\n}",
      "B7 {\n  $i13 \u003d 48 + i18\n  $c14 \u003d (char) $i13\n  r0[i19] \u003d $c14\n  $i15 \u003d i19 + 1\n  return\n}",
      "B8 {\n  $i12 \u003d NumberOutput._leading3(i18, r0, i19)\n  return\n}",
      "B9 {\n  i20 \u003d NumberOutput.divBy1000(i18)\n  $i11 \u003d i20 * 1000\n  i21 \u003d i18 - $i11\n  i22 \u003d NumberOutput._leading3(i20, r0, i19)\n  i23 \u003d NumberOutput._full3(i21, r0, i22)\n  return\n}",
      "B10 {\n  $i1 \u003d NumberOutput: int BILLION\u003e\n  if (i18 \u003c $i1) goto B11 else B15\n}",
      "B11 {\n  $i7 \u003d NumberOutput: int BILLION\u003e\n  i24 \u003d i18 - $i7\n  $i8 \u003d NumberOutput: int BILLION\u003e\n  if (i24 \u003c $i8) goto B12 else B13\n}",
      "B12 {\n  $i10 \u003d NumberOutput: int BILLION\u003e\n  i24 \u003d i24 - $i10\n  i25 \u003d i19 + 1\n  r0[i19] \u003d 50\n  goto B14\n}",
      "B13 {\n  i25 \u003d i19 + 1\n  r0[i19] \u003d 49\n}",
      "B14 {\n  $i9 \u003d NumberOutput._outputFullBillion(i24, r0, i25)\n  return\n}",
      "B15 {\n  i26 \u003d NumberOutput.divBy1000(i18)\n  $i2 \u003d i26 * 1000\n  i3 \u003d i18 - $i2\n  i27 \u003d NumberOutput.divBy1000(i26)\n  $i4 \u003d i27 * 1000\n  i5 \u003d i26 - $i4\n  i28 \u003d NumberOutput._leading3(i27, r0, i19)\n  i29 \u003d NumberOutput._full3(i5, r0, i28)\n  $i6 \u003d NumberOutput._full3(i3, r0, i29)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B10",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B15",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberOutput#divBy1000(...1)",
        "body": "{\r\n    return (int) (number * 274_877_907L \u003e\u003e\u003e 38);\r\n}"
      },
      {
        "name": "NumberOutput#_outputSmallestI(...2)",
        "body": "{\r\n    int len \u003d SMALLEST_INT.length();\r\n    SMALLEST_INT.getChars(0, len, b, off);\r\n    return (off + len);\r\n}"
      },
      {
        "name": "NumberOutput#_leading3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    if (t \u003e 9) {\r\n        if (t \u003e 99) {\r\n            b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n        }\r\n        b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    }\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_outputFullBillion(...3)",
        "body": "{\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    int enc \u003d TRIPLET_TO_CHARS[millions];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    thousands -\u003d (millions * 1000);\r\n    enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_full3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "outputInt",
    "signature": "int outputInt(int,byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (v \u003c 0) {\r\n        if (v \u003d\u003d Integer.MIN_VALUE) {\r\n            return _outputSmallestI(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    }\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            if (v \u003c 10) {\r\n                b[off++] \u003d (byte) (\u00270\u0027 + v);\r\n            } else {\r\n                off \u003d _leading3(v, b, off);\r\n            }\r\n        } else {\r\n            int thousands \u003d divBy1000(v);\r\n            // \u003d\u003d value % 1000\r\n            v -\u003d (thousands * 1000);\r\n            off \u003d _leading3(thousands, b, off);\r\n            off \u003d _full3(v, b, off);\r\n        }\r\n        return off;\r\n    }\r\n    if (v \u003e\u003d BILLION) {\r\n        v -\u003d BILLION;\r\n        if (v \u003e\u003d BILLION) {\r\n            v -\u003d BILLION;\r\n            b[off++] \u003d \u00272\u0027;\r\n        } else {\r\n            b[off++] \u003d \u00271\u0027;\r\n        }\r\n        return _outputFullBillion(v, b, off);\r\n    }\r\n    int newValue \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (newValue * 1000));\r\n    v \u003d newValue;\r\n    newValue \u003d divBy1000(newValue);\r\n    int thousands \u003d (v - (newValue * 1000));\r\n    off \u003d _leading3(newValue, b, off);\r\n    off \u003d _full3(thousands, b, off);\r\n    return _full3(ones, b, off);\r\n}",
    "nodes": 17,
    "edges": 20,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i16 \u003e\u003d 0) → B1 | else → B4",
      "B1 : If(i16 !\u003d -2147483648) → B2 | else → B3",
      "B4 : If(i16 \u003e\u003d $i0) → B5 | else → B11",
      "B5 : If(i16 \u003e\u003d 1000) → B6 | else → B9",
      "B6 : If(i16 \u003e\u003d 10) → B7 | else → B8",
      "B11 : If(i16 \u003c $i1) → B12 | else → B16",
      "B12 : If(i22 \u003c $i8) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  i16 :\u003d @parameter0: int\n  r0 :\u003d @parameter1: byte[]\n  i17 :\u003d @parameter2: int\n  if (i16 \u003e\u003d 0) goto B1 else B4\n}",
      "B1 {\n  if (i16 !\u003d -2147483648) goto B2 else B3\n}",
      "B2 {\n  $i15 \u003d NumberOutput._outputSmallestI(r0, i17)\n  return\n}",
      "B3 {\n  $i14 \u003d i17\n  i17 \u003d i17 + 1\n  r0[$i14] \u003d 45\n  i16 \u003d neg i16\n}",
      "B4 {\n  $i0 \u003d NumberOutput: int MILLION\u003e\n  if (i16 \u003e\u003d $i0) goto B5 else B11\n}",
      "B5 {\n  if (i16 \u003e\u003d 1000) goto B6 else B9\n}",
      "B6 {\n  if (i16 \u003e\u003d 10) goto B7 else B8\n}",
      "B7 {\n  i18 \u003d i17 + 1\n  $i12 \u003d 48 + i16\n  $b13 \u003d (byte) $i12\n  r0[i17] \u003d $b13\n  goto B10\n}",
      "B8 {\n  i18 \u003d NumberOutput._leading3(i16, r0, i17)\n  goto B10\n}",
      "B9 {\n  i19 \u003d NumberOutput.divBy1000(i16)\n  $i11 \u003d i19 * 1000\n  i20 \u003d i16 - $i11\n  i21 \u003d NumberOutput._leading3(i19, r0, i17)\n  i18 \u003d NumberOutput._full3(i20, r0, i21)\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $i1 \u003d NumberOutput: int BILLION\u003e\n  if (i16 \u003c $i1) goto B12 else B16\n}",
      "B12 {\n  $i7 \u003d NumberOutput: int BILLION\u003e\n  i22 \u003d i16 - $i7\n  $i8 \u003d NumberOutput: int BILLION\u003e\n  if (i22 \u003c $i8) goto B13 else B14\n}",
      "B13 {\n  $i10 \u003d NumberOutput: int BILLION\u003e\n  i22 \u003d i22 - $i10\n  i23 \u003d i17 + 1\n  r0[i17] \u003d 50\n  goto B15\n}",
      "B14 {\n  i23 \u003d i17 + 1\n  r0[i17] \u003d 49\n}",
      "B15 {\n  $i9 \u003d NumberOutput._outputFullBillion(i22, r0, i23)\n  return\n}",
      "B16 {\n  i24 \u003d NumberOutput.divBy1000(i16)\n  $i2 \u003d i24 * 1000\n  i3 \u003d i16 - $i2\n  i25 \u003d NumberOutput.divBy1000(i24)\n  $i4 \u003d i25 * 1000\n  i5 \u003d i24 - $i4\n  i26 \u003d NumberOutput._leading3(i25, r0, i17)\n  i27 \u003d NumberOutput._full3(i5, r0, i26)\n  $i6 \u003d NumberOutput._full3(i3, r0, i27)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B11",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberOutput#divBy1000(...1)",
        "body": "{\r\n    return (int) (number * 274_877_907L \u003e\u003e\u003e 38);\r\n}"
      },
      {
        "name": "NumberOutput#_outputSmallestI(...2)",
        "body": "{\r\n    int len \u003d SMALLEST_INT.length();\r\n    SMALLEST_INT.getChars(0, len, b, off);\r\n    return (off + len);\r\n}"
      },
      {
        "name": "NumberOutput#_leading3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    if (t \u003e 9) {\r\n        if (t \u003e 99) {\r\n            b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n        }\r\n        b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    }\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_outputFullBillion(...3)",
        "body": "{\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    int enc \u003d TRIPLET_TO_CHARS[millions];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    thousands -\u003d (millions * 1000);\r\n    enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_full3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "outputLong",
    "signature": "int outputLong(long,char[],int)",
    "visibility": "public",
    "body": "{\r\n    // First: does it actually fit in an int?\r\n    if (v \u003c 0L) {\r\n        if (v \u003e MIN_INT_AS_LONG) {\r\n            return outputInt((int) v, b, off);\r\n        }\r\n        if (v \u003d\u003d Long.MIN_VALUE) {\r\n            return _outputSmallestL(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    } else {\r\n        if (v \u003c\u003d MAX_INT_AS_LONG) {\r\n            return outputInt((int) v, b, off);\r\n        }\r\n    }\r\n    // Ok, let\u0027s separate last 9 digits (3 x full sets of 3)\r\n    long upper \u003d v / BILLION_L;\r\n    v -\u003d (upper * BILLION_L);\r\n    // two integers?\r\n    if (upper \u003c BILLION_L) {\r\n        off \u003d _outputUptoBillion((int) upper, b, off);\r\n    } else {\r\n        // no, two ints and bits; hi may be about 16 or so\r\n        long hi \u003d upper / BILLION_L;\r\n        upper -\u003d (hi * BILLION_L);\r\n        off \u003d _leading3((int) hi, b, off);\r\n        off \u003d _outputFullBillion((int) upper, b, off);\r\n    }\r\n    return _outputFullBillion((int) v, b, off);\r\n}",
    "nodes": 12,
    "edges": 13,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i33 \u003e\u003d 0) → B1 | else → B6",
      "B1 : If($i34 \u003c\u003d 0) → B2 | else → B3",
      "B3 : If($b21 !\u003d 0) → B4 | else → B5",
      "B6 : If($i35 \u003e 0) → B7 | else → B8",
      "B8 : If($i36 \u003e\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  l28 :\u003d @parameter0: long\n  r0 :\u003d @parameter1: char[]\n  i29 :\u003d @parameter2: int\n  $b0 \u003d l28 cmp 0L\n  $i33 \u003d (int) $b0\n  if ($i33 \u003e\u003d 0) goto B1 else B6\n}",
      "B1 {\n  $l19 \u003d NumberOutput: long MIN_INT_AS_LONG\u003e\n  $b20 \u003d l28 cmp $l19\n  $i34 \u003d (int) $b20\n  if ($i34 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i26 \u003d (int) l28\n  $i27 \u003d NumberOutput.outputInt($i26, r0, i29)\n  return\n}",
      "B3 {\n  $b21 \u003d l28 cmp -9223372036854775808L\n  if ($b21 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i25 \u003d NumberOutput._outputSmallestL(r0, i29)\n  return\n}",
      "B5 {\n  $i22 \u003d i29\n  i29 \u003d i29 + 1\n  r0[$i22] \u003d 45\n  l28 \u003d neg l28\n  goto B8\n}",
      "B6 {\n  $l1 \u003d NumberOutput: long MAX_INT_AS_LONG\u003e\n  $b2 \u003d l28 cmp $l1\n  $i35 \u003d (int) $b2\n  if ($i35 \u003e 0) goto B7 else B8\n}",
      "B7 {\n  $i17 \u003d (int) l28\n  $i18 \u003d NumberOutput.outputInt($i17, r0, i29)\n  return\n}",
      "B8 {\n  $l3 \u003d NumberOutput: long BILLION_L\u003e\n  $l23 \u003d l28 / $l3\n  $l4 \u003d NumberOutput: long BILLION_L\u003e\n  $l5 \u003d $l23 * $l4\n  $l24 \u003d l28 - $l5\n  $l6 \u003d NumberOutput: long BILLION_L\u003e\n  $b7 \u003d $l23 cmp $l6\n  $i36 \u003d (int) $b7\n  if ($i36 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $i16 \u003d (int) $l23\n  i30 \u003d NumberOutput._outputUptoBillion($i16, r0, i29)\n  goto B11\n}",
      "B10 {\n  $l8 \u003d NumberOutput: long BILLION_L\u003e\n  l9 \u003d $l23 / $l8\n  $l10 \u003d NumberOutput: long BILLION_L\u003e\n  $l11 \u003d l9 * $l10\n  l31 \u003d $l23 - $l11\n  $i12 \u003d (int) l9\n  i32 \u003d NumberOutput._leading3($i12, r0, i29)\n  $i13 \u003d (int) l31\n  i30 \u003d NumberOutput._outputFullBillion($i13, r0, i32)\n}",
      "B11 {\n  $i14 \u003d (int) $l24\n  $i15 \u003d NumberOutput._outputFullBillion($i14, r0, i30)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberOutput#_outputUptoBillion(...3)",
        "body": "{\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            return _leading3(v, b, off);\r\n        }\r\n        int thousands \u003d divBy1000(v);\r\n        // \u003d\u003d value % 1000\r\n        int ones \u003d v - (thousands * 1000);\r\n        return _outputUptoMillion(b, off, thousands, ones);\r\n    }\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    thousands -\u003d (millions * 1000);\r\n    off \u003d _leading3(millions, b, off);\r\n    int enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_leading3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    if (t \u003e 9) {\r\n        if (t \u003e 99) {\r\n            b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n        }\r\n        b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    }\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#outputInt(...3)",
        "body": "{\r\n    if (v \u003c 0) {\r\n        if (v \u003d\u003d Integer.MIN_VALUE) {\r\n            // Special case: no matching positive value within range;\r\n            // let\u0027s then \"upgrade\" to long and output as such.\r\n            return _outputSmallestI(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    }\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            if (v \u003c 10) {\r\n                b[off] \u003d (char) (\u00270\u0027 + v);\r\n                return off + 1;\r\n            }\r\n            return _leading3(v, b, off);\r\n        }\r\n        int thousands \u003d divBy1000(v);\r\n        // \u003d\u003d value % 1000\r\n        v -\u003d (thousands * 1000);\r\n        off \u003d _leading3(thousands, b, off);\r\n        off \u003d _full3(v, b, off);\r\n        return off;\r\n    }\r\n    // ok, all 3 triplets included\r\n    /* Let\u0027s first hand possible billions separately before\r\n         * handling 3 triplets. This is possible since we know we\r\n         * can have at most \u00272\u0027 as billion count.\r\n         */\r\n    if (v \u003e\u003d BILLION) {\r\n        v -\u003d BILLION;\r\n        if (v \u003e\u003d BILLION) {\r\n            v -\u003d BILLION;\r\n            b[off++] \u003d \u00272\u0027;\r\n        } else {\r\n            b[off++] \u003d \u00271\u0027;\r\n        }\r\n        return _outputFullBillion(v, b, off);\r\n    }\r\n    int newValue \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (newValue * 1000));\r\n    v \u003d newValue;\r\n    newValue \u003d divBy1000(newValue);\r\n    int thousands \u003d (v - (newValue * 1000));\r\n    off \u003d _leading3(newValue, b, off);\r\n    off \u003d _full3(thousands, b, off);\r\n    return _full3(ones, b, off);\r\n}"
      },
      {
        "name": "NumberOutput#_outputSmallestL(...2)",
        "body": "{\r\n    int len \u003d SMALLEST_LONG.length();\r\n    SMALLEST_LONG.getChars(0, len, b, off);\r\n    return (off + len);\r\n}"
      },
      {
        "name": "NumberOutput#_outputFullBillion(...3)",
        "body": "{\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    int enc \u003d TRIPLET_TO_CHARS[millions];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    thousands -\u003d (millions * 1000);\r\n    enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "outputLong",
    "signature": "int outputLong(long,byte[],int)",
    "visibility": "public",
    "body": "{\r\n    if (v \u003c 0L) {\r\n        if (v \u003e MIN_INT_AS_LONG) {\r\n            return outputInt((int) v, b, off);\r\n        }\r\n        if (v \u003d\u003d Long.MIN_VALUE) {\r\n            return _outputSmallestL(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    } else {\r\n        if (v \u003c\u003d MAX_INT_AS_LONG) {\r\n            return outputInt((int) v, b, off);\r\n        }\r\n    }\r\n    // Ok, let\u0027s separate last 9 digits (3 x full sets of 3)\r\n    long upper \u003d v / BILLION_L;\r\n    v -\u003d (upper * BILLION_L);\r\n    // two integers?\r\n    if (upper \u003c BILLION_L) {\r\n        off \u003d _outputUptoBillion((int) upper, b, off);\r\n    } else {\r\n        // no, two ints and bits; hi may be about 16 or so\r\n        long hi \u003d upper / BILLION_L;\r\n        upper -\u003d (hi * BILLION_L);\r\n        off \u003d _leading3((int) hi, b, off);\r\n        off \u003d _outputFullBillion((int) upper, b, off);\r\n    }\r\n    return _outputFullBillion((int) v, b, off);\r\n}",
    "nodes": 12,
    "edges": 13,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i33 \u003e\u003d 0) → B1 | else → B6",
      "B1 : If($i34 \u003c\u003d 0) → B2 | else → B3",
      "B3 : If($b21 !\u003d 0) → B4 | else → B5",
      "B6 : If($i35 \u003e 0) → B7 | else → B8",
      "B8 : If($i36 \u003e\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  l28 :\u003d @parameter0: long\n  r0 :\u003d @parameter1: byte[]\n  i29 :\u003d @parameter2: int\n  $b0 \u003d l28 cmp 0L\n  $i33 \u003d (int) $b0\n  if ($i33 \u003e\u003d 0) goto B1 else B6\n}",
      "B1 {\n  $l19 \u003d NumberOutput: long MIN_INT_AS_LONG\u003e\n  $b20 \u003d l28 cmp $l19\n  $i34 \u003d (int) $b20\n  if ($i34 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i26 \u003d (int) l28\n  $i27 \u003d NumberOutput.outputInt($i26, r0, i29)\n  return\n}",
      "B3 {\n  $b21 \u003d l28 cmp -9223372036854775808L\n  if ($b21 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i25 \u003d NumberOutput._outputSmallestL(r0, i29)\n  return\n}",
      "B5 {\n  $i22 \u003d i29\n  i29 \u003d i29 + 1\n  r0[$i22] \u003d 45\n  l28 \u003d neg l28\n  goto B8\n}",
      "B6 {\n  $l1 \u003d NumberOutput: long MAX_INT_AS_LONG\u003e\n  $b2 \u003d l28 cmp $l1\n  $i35 \u003d (int) $b2\n  if ($i35 \u003e 0) goto B7 else B8\n}",
      "B7 {\n  $i17 \u003d (int) l28\n  $i18 \u003d NumberOutput.outputInt($i17, r0, i29)\n  return\n}",
      "B8 {\n  $l3 \u003d NumberOutput: long BILLION_L\u003e\n  $l23 \u003d l28 / $l3\n  $l4 \u003d NumberOutput: long BILLION_L\u003e\n  $l5 \u003d $l23 * $l4\n  $l24 \u003d l28 - $l5\n  $l6 \u003d NumberOutput: long BILLION_L\u003e\n  $b7 \u003d $l23 cmp $l6\n  $i36 \u003d (int) $b7\n  if ($i36 \u003e\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $i16 \u003d (int) $l23\n  i30 \u003d NumberOutput._outputUptoBillion($i16, r0, i29)\n  goto B11\n}",
      "B10 {\n  $l8 \u003d NumberOutput: long BILLION_L\u003e\n  l9 \u003d $l23 / $l8\n  $l10 \u003d NumberOutput: long BILLION_L\u003e\n  $l11 \u003d l9 * $l10\n  l31 \u003d $l23 - $l11\n  $i12 \u003d (int) l9\n  i32 \u003d NumberOutput._leading3($i12, r0, i29)\n  $i13 \u003d (int) l31\n  i30 \u003d NumberOutput._outputFullBillion($i13, r0, i32)\n}",
      "B11 {\n  $i14 \u003d (int) $l24\n  $i15 \u003d NumberOutput._outputFullBillion($i14, r0, i30)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberOutput#_outputUptoBillion(...3)",
        "body": "{\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            return _leading3(v, b, off);\r\n        }\r\n        int thousands \u003d divBy1000(v);\r\n        // \u003d\u003d value % 1000\r\n        int ones \u003d v - (thousands * 1000);\r\n        return _outputUptoMillion(b, off, thousands, ones);\r\n    }\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    thousands -\u003d (millions * 1000);\r\n    off \u003d _leading3(millions, b, off);\r\n    int enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#_leading3(...3)",
        "body": "{\r\n    int enc \u003d TRIPLET_TO_CHARS[t];\r\n    if (t \u003e 9) {\r\n        if (t \u003e 99) {\r\n            b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n        }\r\n        b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    }\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      },
      {
        "name": "NumberOutput#outputInt(...3)",
        "body": "{\r\n    if (v \u003c 0) {\r\n        if (v \u003d\u003d Integer.MIN_VALUE) {\r\n            // Special case: no matching positive value within range;\r\n            // let\u0027s then \"upgrade\" to long and output as such.\r\n            return _outputSmallestI(b, off);\r\n        }\r\n        b[off++] \u003d \u0027-\u0027;\r\n        v \u003d -v;\r\n    }\r\n    if (v \u003c MILLION) {\r\n        // at most 2 triplets...\r\n        if (v \u003c 1000) {\r\n            if (v \u003c 10) {\r\n                b[off] \u003d (char) (\u00270\u0027 + v);\r\n                return off + 1;\r\n            }\r\n            return _leading3(v, b, off);\r\n        }\r\n        int thousands \u003d divBy1000(v);\r\n        // \u003d\u003d value % 1000\r\n        v -\u003d (thousands * 1000);\r\n        off \u003d _leading3(thousands, b, off);\r\n        off \u003d _full3(v, b, off);\r\n        return off;\r\n    }\r\n    // ok, all 3 triplets included\r\n    /* Let\u0027s first hand possible billions separately before\r\n         * handling 3 triplets. This is possible since we know we\r\n         * can have at most \u00272\u0027 as billion count.\r\n         */\r\n    if (v \u003e\u003d BILLION) {\r\n        v -\u003d BILLION;\r\n        if (v \u003e\u003d BILLION) {\r\n            v -\u003d BILLION;\r\n            b[off++] \u003d \u00272\u0027;\r\n        } else {\r\n            b[off++] \u003d \u00271\u0027;\r\n        }\r\n        return _outputFullBillion(v, b, off);\r\n    }\r\n    int newValue \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (newValue * 1000));\r\n    v \u003d newValue;\r\n    newValue \u003d divBy1000(newValue);\r\n    int thousands \u003d (v - (newValue * 1000));\r\n    off \u003d _leading3(newValue, b, off);\r\n    off \u003d _full3(thousands, b, off);\r\n    return _full3(ones, b, off);\r\n}"
      },
      {
        "name": "NumberOutput#_outputSmallestL(...2)",
        "body": "{\r\n    int len \u003d SMALLEST_LONG.length();\r\n    SMALLEST_LONG.getChars(0, len, b, off);\r\n    return (off + len);\r\n}"
      },
      {
        "name": "NumberOutput#_outputFullBillion(...3)",
        "body": "{\r\n    int thousands \u003d divBy1000(v);\r\n    // \u003d\u003d value % 1000\r\n    int ones \u003d (v - (thousands * 1000));\r\n    int millions \u003d divBy1000(thousands);\r\n    int enc \u003d TRIPLET_TO_CHARS[millions];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    thousands -\u003d (millions * 1000);\r\n    enc \u003d TRIPLET_TO_CHARS[thousands];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    enc \u003d TRIPLET_TO_CHARS[ones];\r\n    b[off++] \u003d (char) (enc \u003e\u003e 16);\r\n    b[off++] \u003d (char) ((enc \u003e\u003e 8) \u0026 0x7F);\r\n    b[off++] \u003d (char) (enc \u0026 0x7F);\r\n    return off;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "toString",
    "signature": "java.lang.String toString(int)",
    "visibility": "public",
    "body": "{\r\n    // Lookup table for small values\r\n    if (v \u003c sSmallIntStrs.length) {\r\n        if (v \u003e\u003d 0) {\r\n            return sSmallIntStrs[v];\r\n        }\r\n        int v2 \u003d -v - 1;\r\n        if (v2 \u003c sSmallIntStrs2.length) {\r\n            return sSmallIntStrs2[v2];\r\n        }\r\n    }\r\n    return Integer.toString(v);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d $i1) → B1 | else → B5",
      "B1 : If(i0 \u003c 0) → B2 | else → B3",
      "B3 : If(i3 \u003e\u003d $i4) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  i0 :\u003d @parameter0: int\n  $r0 \u003d String[] sSmallIntStrs\u003e\n  $i1 \u003d lengthof $r0\n  if (i0 \u003e\u003d $i1) goto B1 else B5\n}",
      "B1 {\n  if (i0 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d String[] sSmallIntStrs\u003e\n  $r6 \u003d $r5[i0]\n  return\n}",
      "B3 {\n  $i2 \u003d neg i0\n  i3 \u003d $i2 - 1\n  $r2 \u003d String[] sSmallIntStrs2\u003e\n  $i4 \u003d lengthof $r2\n  if (i3 \u003e\u003d $i4) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d String[] sSmallIntStrs2\u003e\n  $r4 \u003d $r3[i3]\n  return\n}",
      "B5 {\n  $r1 \u003d Integer.toString(i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "toString",
    "signature": "java.lang.String toString(long)",
    "visibility": "public",
    "body": "{\r\n    if (v \u003c\u003d Integer.MAX_VALUE \u0026\u0026 v \u003e\u003d Integer.MIN_VALUE) {\r\n        return toString((int) v);\r\n    }\r\n    return Long.toString(v);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 \u003e 0) → B1 | else → B3",
      "B1 : If($i5 \u003c 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  l0 :\u003d @parameter0: long\n  $b1 \u003d l0 cmp 2147483647L\n  $i4 \u003d (int) $b1\n  if ($i4 \u003e 0) goto B1 else B3\n}",
      "B1 {\n  $b2 \u003d l0 cmp -2147483648L\n  $i5 \u003d (int) $b2\n  if ($i5 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $i3 \u003d (int) l0\n  $r1 \u003d NumberOutput.toString($i3)\n  return\n}",
      "B3 {\n  $r0 \u003d Long.toString(l0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberOutput#toString(...1)",
        "body": "{\r\n    // Lookup table for small values\r\n    if (v \u003c sSmallIntStrs.length) {\r\n        if (v \u003e\u003d 0) {\r\n            return sSmallIntStrs[v];\r\n        }\r\n        int v2 \u003d -v - 1;\r\n        if (v2 \u003c sSmallIntStrs2.length) {\r\n            return sSmallIntStrs2[v2];\r\n        }\r\n    }\r\n    return Integer.toString(v);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "toString",
    "signature": "java.lang.String toString(double,boolean)",
    "visibility": "public",
    "body": "{\r\n    return useFastWriter ? DoubleToDecimal.toString(v) : Double.toString(v);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  d0 :\u003d @parameter0: double\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d DoubleToDecimal.toString(d0)\n  goto B3\n}",
      "B2 {\n  $r0 \u003d Double.toString(d0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "toString",
    "signature": "java.lang.String toString(float,boolean)",
    "visibility": "public",
    "body": "{\r\n    return useFastWriter ? FloatToDecimal.toString(v) : Float.toString(v);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  f0 :\u003d @parameter0: float\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r0 \u003d FloatToDecimal.toString(f0)\n  goto B3\n}",
      "B2 {\n  $r0 \u003d Float.toString(f0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "notFinite",
    "signature": "boolean notFinite(double)",
    "visibility": "public",
    "body": "{\r\n    return !Double.isFinite(value);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  d0 :\u003d @parameter0: double\n  $z0 \u003d Double.isFinite(d0)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.NumberOutput",
    "methodName": "notFinite",
    "signature": "boolean notFinite(float)",
    "visibility": "public",
    "body": "{\r\n    return !Float.isFinite(value);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  f0 :\u003d @parameter0: float\n  $z0 \u003d Float.isFinite(f0)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "asQuotedChars",
    "signature": "char[] asQuotedChars()",
    "visibility": "public",
    "body": "{\r\n    char[] result \u003d _quotedChars;\r\n    if (result \u003d\u003d null) {\r\n        _quotedChars \u003d result \u003d JSON_ENCODER.quoteAsString(_value);\r\n    }\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r4 \u003d SerializedString: char[] _quotedChars\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r1 \u003d String _value\u003e\n  $r3 \u003d $r2.quoteAsString($r1)\n  r4 \u003d $r3\n  SerializedString: char[] _quotedChars\u003e \u003d $r3\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "asQuotedUTF8",
    "signature": "byte[] asQuotedUTF8()",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _quotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _quotedUTF8Ref \u003d result \u003d JSON_ENCODER.quoteAsUTF8(_value);\r\n    }\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r4 \u003d SerializedString: byte[] _quotedUTF8Ref\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r1 \u003d String _value\u003e\n  $r3 \u003d $r2.quoteAsUTF8($r1)\n  r4 \u003d $r3\n  SerializedString: byte[] _quotedUTF8Ref\u003e \u003d $r3\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "asUnquotedUTF8",
    "signature": "byte[] asUnquotedUTF8()",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _unquotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _unquotedUTF8Ref \u003d result \u003d JSON_ENCODER.encodeAsUTF8(_value);\r\n    }\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r4 \u003d SerializedString: byte[] _unquotedUTF8Ref\u003e\n  if (r4 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r1 \u003d String _value\u003e\n  $r3 \u003d $r2.encodeAsUTF8($r1)\n  r4 \u003d $r3\n  SerializedString: byte[] _unquotedUTF8Ref\u003e \u003d $r3\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "appendQuoted",
    "signature": "int appendQuoted(char[],int)",
    "visibility": "public",
    "body": "{\r\n    char[] result \u003d _quotedChars;\r\n    if (result \u003d\u003d null) {\r\n        _quotedChars \u003d result \u003d JSON_ENCODER.quoteAsString(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    if ((offset + length) \u003e buffer.length) {\r\n        return -1;\r\n    }\r\n    System.arraycopy(result, 0, buffer, offset, length);\r\n    return length;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c\u003d $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  r5 \u003d SerializedString: char[] _quotedChars\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.quoteAsString($r2)\n  r5 \u003d $r4\n  SerializedString: char[] _quotedChars\u003e \u003d $r4\n}",
      "B2 {\n  $i3 \u003d lengthof r5\n  $i2 \u003d i0 + $i3\n  $i1 \u003d lengthof r1\n  if ($i2 \u003c\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d (int) -1\n  return\n}",
      "B4 {\n  System.arraycopy(r5, 0, r1, i0, $i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "appendQuotedUTF8",
    "signature": "int appendQuotedUTF8(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _quotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _quotedUTF8Ref \u003d result \u003d JSON_ENCODER.quoteAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    if ((offset + length) \u003e buffer.length) {\r\n        return -1;\r\n    }\r\n    System.arraycopy(result, 0, buffer, offset, length);\r\n    return length;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c\u003d $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  r5 \u003d SerializedString: byte[] _quotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.quoteAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _quotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i3 \u003d lengthof r5\n  $i2 \u003d i0 + $i3\n  $i1 \u003d lengthof r1\n  if ($i2 \u003c\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d (int) -1\n  return\n}",
      "B4 {\n  System.arraycopy(r5, 0, r1, i0, $i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "appendUnquoted",
    "signature": "int appendUnquoted(char[],int)",
    "visibility": "public",
    "body": "{\r\n    String str \u003d _value;\r\n    final int length \u003d str.length();\r\n    if ((offset + length) \u003e buffer.length) {\r\n        return -1;\r\n    }\r\n    str.getChars(0, length, buffer, offset);\r\n    return length;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i3 \u003c\u003d $i2) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r2 :\u003d @parameter0: char[]\n  i1 :\u003d @parameter1: int\n  r1 \u003d String _value\u003e\n  i0 \u003d r1.length()\n  $i3 \u003d i1 + i0\n  $i2 \u003d lengthof r2\n  if ($i3 \u003c\u003d $i2) goto B1 else B2\n}",
      "B1 {\n  $i5 \u003d (int) -1\n  return\n}",
      "B2 {\n  r1.getChars(0, i0, r2, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "appendUnquotedUTF8",
    "signature": "int appendUnquotedUTF8(byte[],int)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _unquotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _unquotedUTF8Ref \u003d result \u003d JSON_ENCODER.encodeAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    if ((offset + length) \u003e buffer.length) {\r\n        return -1;\r\n    }\r\n    System.arraycopy(result, 0, buffer, offset, length);\r\n    return length;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c\u003d $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  r5 \u003d SerializedString: byte[] _unquotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.encodeAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _unquotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i3 \u003d lengthof r5\n  $i2 \u003d i0 + $i3\n  $i1 \u003d lengthof r1\n  if ($i2 \u003c\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d (int) -1\n  return\n}",
      "B4 {\n  System.arraycopy(r5, 0, r1, i0, $i3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "writeQuotedUTF8",
    "signature": "int writeQuotedUTF8(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _quotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _quotedUTF8Ref \u003d result \u003d JSON_ENCODER.quoteAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    out.write(result, 0, length);\r\n    return length;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  OutputStream\n  r5 \u003d SerializedString: byte[] _quotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.quoteAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _quotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i0 \u003d lengthof r5\n  r1.write(r5, 0, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "writeUnquotedUTF8",
    "signature": "int writeUnquotedUTF8(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _unquotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _unquotedUTF8Ref \u003d result \u003d JSON_ENCODER.encodeAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    out.write(result, 0, length);\r\n    return length;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  OutputStream\n  r5 \u003d SerializedString: byte[] _unquotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.encodeAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _unquotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i0 \u003d lengthof r5\n  r1.write(r5, 0, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "putQuotedUTF8",
    "signature": "int putQuotedUTF8(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _quotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _quotedUTF8Ref \u003d result \u003d JSON_ENCODER.quoteAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    if (length \u003e buffer.remaining()) {\r\n        return -1;\r\n    }\r\n    buffer.put(result, 0, length);\r\n    return length;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($i1 \u003c\u003d $i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  ByteBuffer\n  r5 \u003d SerializedString: byte[] _quotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.quoteAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _quotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i1 \u003d lengthof r5\n  $i0 \u003d r1.remaining()\n  if ($i1 \u003c\u003d $i0) goto B3 else B4\n}",
      "B3 {\n  $i3 \u003d (int) -1\n  return\n}",
      "B4 {\n  r1.put(r5, 0, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "putUnquotedUTF8",
    "signature": "int putUnquotedUTF8(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    byte[] result \u003d _unquotedUTF8Ref;\r\n    if (result \u003d\u003d null) {\r\n        _unquotedUTF8Ref \u003d result \u003d JSON_ENCODER.encodeAsUTF8(_value);\r\n    }\r\n    final int length \u003d result.length;\r\n    if (length \u003e buffer.remaining()) {\r\n        return -1;\r\n    }\r\n    buffer.put(result, 0, length);\r\n    return length;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($i1 \u003c\u003d $i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  ByteBuffer\n  r5 \u003d SerializedString: byte[] _unquotedUTF8Ref\u003e\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonStringEncoder JSON_ENCODER\u003e\n  $r2 \u003d String _value\u003e\n  $r4 \u003d $r3.encodeAsUTF8($r2)\n  r5 \u003d $r4\n  SerializedString: byte[] _unquotedUTF8Ref\u003e \u003d $r4\n}",
      "B2 {\n  $i1 \u003d lengthof r5\n  $i0 \u003d r1.remaining()\n  if ($i1 \u003c\u003d $i0) goto B3 else B4\n}",
      "B3 {\n  $i3 \u003d (int) -1\n  return\n}",
      "B4 {\n  r1.put(r5, 0, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.SerializedString",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o \u003d\u003d this)\r\n        return true;\r\n    if (o \u003d\u003d null || o.getClass() !\u003d getClass())\r\n        return false;\r\n    SerializedString other \u003d (SerializedString) o;\r\n    return _value.equals(other._value);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  SerializedString\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d SerializedString) r0\n  $r6 \u003d String _value\u003e\n  $r5 \u003d String _value\u003e\n  $z0 \u003d $r6.equals($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SerializedString#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF32Reader",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    InputStream in \u003d _in;\r\n    if (in !\u003d null) {\r\n        _in \u003d null;\r\n        freeBuffers();\r\n        in.close();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF32Reader\n  r1 \u003d InputStream _in\u003e\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  InputStream _in\u003e \u003d null\n  r0.freeBuffers()\n  r1.close()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF32Reader#freeBuffers(...0)",
        "body": "{\r\n    byte[] buf \u003d _buffer;\r\n    if (buf !\u003d null) {\r\n        _buffer \u003d null;\r\n        if (_context !\u003d null) {\r\n            // tests pass null\r\n            _context.releaseReadIOBuffer(buf);\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF32Reader",
    "methodName": "read",
    "signature": "int read()",
    "visibility": "public",
    "body": "{\r\n    if (_tmpBuf \u003d\u003d null) {\r\n        _tmpBuf \u003d new char[1];\r\n    }\r\n    if (read(_tmpBuf, 0, 1) \u003c 1) {\r\n        return -1;\r\n    }\r\n    return _tmpBuf[0];\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($i0 \u003e\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF32Reader\n  $r1 \u003d UTF32Reader: char[] _tmpBuf\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d newarray (char)[1]\n  UTF32Reader: char[] _tmpBuf\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d UTF32Reader: char[] _tmpBuf\u003e\n  $i0 \u003d r0.read($r2, 0, 1)\n  if ($i0 \u003e\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $i3 \u003d (int) -1\n  return\n}",
      "B4 {\n  $r3 \u003d UTF32Reader: char[] _tmpBuf\u003e\n  $c1 \u003d $r3[0]\n  $i4 \u003d (int) $c1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF32Reader#read(...3)",
        "body": "{\r\n    // Already EOF?\r\n    if (_buffer \u003d\u003d null) {\r\n        return -1;\r\n    }\r\n    if (len \u003c 1) {\r\n        return len;\r\n    }\r\n    // Let\u0027s then ensure there\u0027s enough room...\r\n    if (start \u003c 0 || (start + len) \u003e cbuf.length) {\r\n        reportBounds(cbuf, start, len);\r\n    }\r\n    int outPtr \u003d start;\r\n    final int outEnd \u003d len + start;\r\n    // Ok, first; do we have a surrogate from last round?\r\n    if (_surrogate !\u003d NC) {\r\n        cbuf[outPtr++] \u003d _surrogate;\r\n        _surrogate \u003d NC;\r\n        // No need to load more, already got one char\r\n    } else {\r\n        // Note: we\u0027ll try to avoid blocking as much as possible. As a\r\n        // result, we only need to get 4 bytes for a full char.\r\n        int left \u003d (_length - _ptr);\r\n        if (left \u003c 4) {\r\n            if (!loadMore(left)) {\r\n                // (legal) EOF?\r\n                // Ok if (but only if!) was at boundary\r\n                if (left \u003d\u003d 0) {\r\n                    return -1;\r\n                }\r\n                reportUnexpectedEOF(_length - _ptr, 4);\r\n            }\r\n        }\r\n    }\r\n    // 02-Jun-2017, tatu: Must ensure we don\u0027t try to read past buffer end:\r\n    final int lastValidInputStart \u003d (_length - 4);\r\n    main_loop: while ((outPtr \u003c outEnd) \u0026\u0026 (_ptr \u003c\u003d lastValidInputStart)) {\r\n        int ptr \u003d _ptr;\r\n        int hi, lo;\r\n        if (_bigEndian) {\r\n            hi \u003d (_buffer[ptr] \u003c\u003c 8) | (_buffer[ptr + 1] \u0026 0xFF);\r\n            lo \u003d ((_buffer[ptr + 2] \u0026 0xFF) \u003c\u003c 8) | (_buffer[ptr + 3] \u0026 0xFF);\r\n        } else {\r\n            lo \u003d (_buffer[ptr] \u0026 0xFF) | ((_buffer[ptr + 1] \u0026 0xFF) \u003c\u003c 8);\r\n            hi \u003d (_buffer[ptr + 2] \u0026 0xFF) | (_buffer[ptr + 3] \u003c\u003c 8);\r\n        }\r\n        _ptr +\u003d 4;\r\n        // Does it need to be split to surrogates?\r\n        // (also, we can and need to verify illegal chars)\r\n        if (hi !\u003d 0) {\r\n            // need to split into surrogates?\r\n            // since it may be sign extended\r\n            hi \u0026\u003d 0xFFFF;\r\n            // ch -\u003d 0x10000; to normalize starting with 0x0\r\n            int ch \u003d ((hi - 1) \u003c\u003c 16) | lo;\r\n            if (hi \u003e 0x10) {\r\n                // last valid is 0x10FFFF\r\n                reportInvalid(ch, outPtr - start, String.format(\" (above 0x%08x)\", LAST_VALID_UNICODE_CHAR));\r\n            }\r\n            cbuf[outPtr++] \u003d (char) (0xD800 + (ch \u003e\u003e 10));\r\n            // hmmh. can this ever be 0? (not legal, at least?)\r\n            lo \u003d (0xDC00 | (ch \u0026 0x03FF));\r\n            // Room for second part?\r\n            if (outPtr \u003e\u003d outEnd) {\r\n                // nope\r\n                _surrogate \u003d (char) ch;\r\n                break main_loop;\r\n            }\r\n        }\r\n        cbuf[outPtr++] \u003d (char) lo;\r\n    }\r\n    int actualLen \u003d (outPtr - start);\r\n    _charCount +\u003d actualLen;\r\n    return actualLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF32Reader",
    "methodName": "read",
    "signature": "int read(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // Already EOF?\r\n    if (_buffer \u003d\u003d null) {\r\n        return -1;\r\n    }\r\n    if (len \u003c 1) {\r\n        return len;\r\n    }\r\n    // Let\u0027s then ensure there\u0027s enough room...\r\n    if (start \u003c 0 || (start + len) \u003e cbuf.length) {\r\n        reportBounds(cbuf, start, len);\r\n    }\r\n    int outPtr \u003d start;\r\n    final int outEnd \u003d len + start;\r\n    // Ok, first; do we have a surrogate from last round?\r\n    if (_surrogate !\u003d NC) {\r\n        cbuf[outPtr++] \u003d _surrogate;\r\n        _surrogate \u003d NC;\r\n        // No need to load more, already got one char\r\n    } else {\r\n        // Note: we\u0027ll try to avoid blocking as much as possible. As a\r\n        // result, we only need to get 4 bytes for a full char.\r\n        int left \u003d (_length - _ptr);\r\n        if (left \u003c 4) {\r\n            if (!loadMore(left)) {\r\n                // (legal) EOF?\r\n                // Ok if (but only if!) was at boundary\r\n                if (left \u003d\u003d 0) {\r\n                    return -1;\r\n                }\r\n                reportUnexpectedEOF(_length - _ptr, 4);\r\n            }\r\n        }\r\n    }\r\n    // 02-Jun-2017, tatu: Must ensure we don\u0027t try to read past buffer end:\r\n    final int lastValidInputStart \u003d (_length - 4);\r\n    main_loop: while ((outPtr \u003c outEnd) \u0026\u0026 (_ptr \u003c\u003d lastValidInputStart)) {\r\n        int ptr \u003d _ptr;\r\n        int hi, lo;\r\n        if (_bigEndian) {\r\n            hi \u003d (_buffer[ptr] \u003c\u003c 8) | (_buffer[ptr + 1] \u0026 0xFF);\r\n            lo \u003d ((_buffer[ptr + 2] \u0026 0xFF) \u003c\u003c 8) | (_buffer[ptr + 3] \u0026 0xFF);\r\n        } else {\r\n            lo \u003d (_buffer[ptr] \u0026 0xFF) | ((_buffer[ptr + 1] \u0026 0xFF) \u003c\u003c 8);\r\n            hi \u003d (_buffer[ptr + 2] \u0026 0xFF) | (_buffer[ptr + 3] \u003c\u003c 8);\r\n        }\r\n        _ptr +\u003d 4;\r\n        // Does it need to be split to surrogates?\r\n        // (also, we can and need to verify illegal chars)\r\n        if (hi !\u003d 0) {\r\n            // need to split into surrogates?\r\n            // since it may be sign extended\r\n            hi \u0026\u003d 0xFFFF;\r\n            // ch -\u003d 0x10000; to normalize starting with 0x0\r\n            int ch \u003d ((hi - 1) \u003c\u003c 16) | lo;\r\n            if (hi \u003e 0x10) {\r\n                // last valid is 0x10FFFF\r\n                reportInvalid(ch, outPtr - start, String.format(\" (above 0x%08x)\", LAST_VALID_UNICODE_CHAR));\r\n            }\r\n            cbuf[outPtr++] \u003d (char) (0xD800 + (ch \u003e\u003e 10));\r\n            // hmmh. can this ever be 0? (not legal, at least?)\r\n            lo \u003d (0xDC00 | (ch \u0026 0x03FF));\r\n            // Room for second part?\r\n            if (outPtr \u003e\u003d outEnd) {\r\n                // nope\r\n                _surrogate \u003d (char) ch;\r\n                break main_loop;\r\n            }\r\n        }\r\n        cbuf[outPtr++] \u003d (char) lo;\r\n    }\r\n    int actualLen \u003d (outPtr - start);\r\n    _charCount +\u003d actualLen;\r\n    return actualLen;\r\n}",
    "nodes": 27,
    "edges": 37,
    "cc": 12,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003e\u003d 1) → B3 | else → B4",
      "B4 : If(i1 \u003c 0) → B5 | else → B6",
      "B5 : If($i48 \u003c\u003d $i47) → B6 | else → B7",
      "B7 : If($c51 \u003d\u003d false) → B8 | else → B9",
      "B9 : If(i52 \u003e\u003d 4) → B10 | else → B14",
      "B10 : If($z1 !\u003d 0) → B11 | else → B14",
      "B11 : If(i52 !\u003d 0) → B12 | else → B13",
      "B15 : If(i49 \u003e\u003d $i50) → B16 | else → B26",
      "B16 : If($i4 \u003e $i54) → B17 | else → B26",
      "B17 : If($z0 \u003d\u003d false) → B18 | else → B19",
      "B20 : If(i56 \u003d\u003d false) → B21 | else → B25",
      "B21 : If(i58 \u003c\u003d 16) → B22 | else → B23",
      "B23 : If(i49 \u003c $i50) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  UTF32Reader\n  r2 :\u003d @parameter0: char[]\n  i1 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  $r1 \u003d UTF32Reader: byte[] _buffer\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i63 \u003d (int) -1\n  return\n}",
      "B2 {\n  if (i0 \u003e\u003d 1) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  if (i1 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  $i48 \u003d i1 + i0\n  $i47 \u003d lengthof r2\n  if ($i48 \u003c\u003d $i47) goto B6 else B7\n}",
      "B6 {\n  r0.reportBounds(r2, i1, i0)\n}",
      "B7 {\n  i49 \u003d i1\n  $i50 \u003d i0 + i1\n  $c51 \u003d UTF32Reader: char _surrogate\u003e\n  if ($c51 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  i49 \u003d i1 + 1\n  $c46 \u003d UTF32Reader: char _surrogate\u003e\n  r2[i1] \u003d $c46\n  UTF32Reader: char _surrogate\u003e \u003d 0\n  goto B14\n}",
      "B9 {\n  $i3 \u003d UTF32Reader: int _length\u003e\n  $i2 \u003d UTF32Reader: int _ptr\u003e\n  i52 \u003d $i3 - $i2\n  if (i52 \u003e\u003d 4) goto B10 else B14\n}",
      "B10 {\n  $z1 \u003d r0.loadMore(i52)\n  if ($z1 !\u003d 0) goto B11 else B14\n}",
      "B11 {\n  if (i52 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $i65 \u003d (int) -1\n  return\n}",
      "B13 {\n  $i44 \u003d UTF32Reader: int _length\u003e\n  $i43 \u003d UTF32Reader: int _ptr\u003e\n  $i45 \u003d $i44 - $i43\n  r0.reportUnexpectedEOF($i45, 4)\n}",
      "B14 {\n  $i53 \u003d UTF32Reader: int _length\u003e\n  $i54 \u003d $i53 - 4\n}",
      "B15 {\n  if (i49 \u003e\u003d $i50) goto B16 else B26\n}",
      "B16 {\n  $i4 \u003d UTF32Reader: int _ptr\u003e\n  if ($i4 \u003e $i54) goto B17 else B26\n}",
      "B17 {\n  i55 \u003d UTF32Reader: int _ptr\u003e\n  $z0 \u003d UTF32Reader: boolean _bigEndian\u003e\n  if ($z0 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $r10 \u003d UTF32Reader: byte[] _buffer\u003e\n  $b31 \u003d $r10[i55]\n  $i66 \u003d (int) $b31\n  $i35 \u003d $i66 \u003c\u003c 8\n  $r11 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i32 \u003d i55 + 1\n  $b33 \u003d $r11[$i32]\n  $s67 \u003d (short) $b33\n  $s34 \u003d $s67 \u0026 255\n  $i68 \u003d (int) $s34\n  i56 \u003d $i35 | $i68\n  $r12 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i36 \u003d i55 + 2\n  $b37 \u003d $r12[$i36]\n  $s69 \u003d (short) $b37\n  $s38 \u003d $s69 \u0026 255\n  $i70 \u003d (int) $s38\n  $i42 \u003d $i70 \u003c\u003c 8\n  $r13 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i39 \u003d i55 + 3\n  $b40 \u003d $r13[$i39]\n  $s71 \u003d (short) $b40\n  $s41 \u003d $s71 \u0026 255\n  $i72 \u003d (int) $s41\n  i57 \u003d $i42 | $i72\n  goto B20\n}",
      "B19 {\n  $r3 \u003d UTF32Reader: byte[] _buffer\u003e\n  $b5 \u003d $r3[i55]\n  $s73 \u003d (short) $b5\n  $s10 \u003d $s73 \u0026 255\n  $r4 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i6 \u003d i55 + 1\n  $b7 \u003d $r4[$i6]\n  $s74 \u003d (short) $b7\n  $s8 \u003d $s74 \u0026 255\n  $i75 \u003d (int) $s8\n  $i9 \u003d $i75 \u003c\u003c 8\n  $i76 \u003d (int) $s10\n  i57 \u003d $i76 | $i9\n  $r5 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i11 \u003d i55 + 2\n  $b12 \u003d $r5[$i11]\n  $s77 \u003d (short) $b12\n  $s16 \u003d $s77 \u0026 255\n  $r6 \u003d UTF32Reader: byte[] _buffer\u003e\n  $i13 \u003d i55 + 3\n  $b14 \u003d $r6[$i13]\n  $i78 \u003d (int) $b14\n  $i15 \u003d $i78 \u003c\u003c 8\n  $i79 \u003d (int) $s16\n  i56 \u003d $i79 | $i15\n}",
      "B20 {\n  $i17 \u003d UTF32Reader: int _ptr\u003e\n  $i18 \u003d $i17 + 4\n  UTF32Reader: int _ptr\u003e \u003d $i18\n  if (i56 \u003d\u003d false) goto B21 else B25\n}",
      "B21 {\n  $i81 \u003d (int) 65535\n  i58 \u003d i56 \u0026 $i81\n  $i21 \u003d i58 - 1\n  $i22 \u003d $i21 \u003c\u003c 16\n  i23 \u003d $i22 | i57\n  if (i58 \u003c\u003d 16) goto B22 else B23\n}",
      "B22 {\n  $i30 \u003d i49 - i1\n  $r7 \u003d Object)[1]\n  $r8 \u003d Integer.valueOf(1114111)\n  $r7[0] \u003d $r8\n  $r9 \u003d String.format(\" (above 0x%08x)\", $r7)\n  r0.reportInvalid(i23, $i30, $r9)\n}",
      "B23 {\n  $i24 \u003d i49\n  i49 \u003d i49 + 1\n  $i25 \u003d i23 \u003e\u003e 10\n  $i83 \u003d (int) 55296\n  $i26 \u003d $i83 + $i25\n  $c27 \u003d (char) $i26\n  r2[$i24] \u003d $c27\n  $i28 \u003d i23 \u0026 1023\n  $i85 \u003d (int) 56320\n  i57 \u003d $i85 | $i28\n  if (i49 \u003c $i50) goto B24 else B25\n}",
      "B24 {\n  $c29 \u003d (char) i23\n  UTF32Reader: char _surrogate\u003e \u003d $c29\n  goto B26\n}",
      "B25 {\n  $i19 \u003d i49\n  i49 \u003d i49 + 1\n  $c20 \u003d (char) i57\n  r2[$i19] \u003d $c20\n  goto B15\n}",
      "B26 {\n  $i59 \u003d i49 - i1\n  $i60 \u003d UTF32Reader: int _charCount\u003e\n  $i61 \u003d $i60 + $i59\n  UTF32Reader: int _charCount\u003e \u003d $i61\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B26",
      "B16 --\u003e B17",
      "B16 --\u003e B26",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B15",
      "B26 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF32Reader#loadMore(...1)",
        "body": "{\r\n    // 06-Apr-2021, tatu: If no InputStream (either due to closure or\r\n    //    input being passed direcly in buffer) let\u0027s NOT bother\r\n    //    trying to read (can\u0027t).\r\n    //    Similarly, without read buffer cannot really read...\r\n    if ((_in \u003d\u003d null) || (_buffer \u003d\u003d null)) {\r\n        return false;\r\n    }\r\n    _byteCount +\u003d (_length - available);\r\n    // Bytes that need to be moved to the beginning of buffer?\r\n    if (available \u003e 0) {\r\n        if (_ptr \u003e 0) {\r\n            System.arraycopy(_buffer, _ptr, _buffer, 0, available);\r\n            _ptr \u003d 0;\r\n        }\r\n        _length \u003d available;\r\n    } else {\r\n        // Ok; here we can actually reasonably expect an EOF,\r\n        // so let\u0027s do a separate read right away:\r\n        _ptr \u003d 0;\r\n        int count \u003d _in.read(_buffer);\r\n        if (count \u003c 1) {\r\n            _length \u003d 0;\r\n            if (count \u003c 0) {\r\n                // -1\r\n                if (_managedBuffers) {\r\n                    // to help GC?\r\n                    freeBuffers();\r\n                }\r\n                return false;\r\n            }\r\n            // 0 count is no good; let\u0027s err out\r\n            reportStrangeStream();\r\n        }\r\n        _length \u003d count;\r\n    }\r\n    // Need at least 4 bytes; if we don\u0027t get that many, it\u0027s an error.\r\n    while (_length \u003c 4) {\r\n        int count \u003d _in.read(_buffer, _length, _buffer.length - _length);\r\n        if (count \u003c 1) {\r\n            if (count \u003c 0) {\r\n                // -1, EOF... no good!\r\n                if (_managedBuffers) {\r\n                    // to help GC?\r\n                    freeBuffers();\r\n                }\r\n                reportUnexpectedEOF(_length, 4);\r\n            }\r\n            // 0 count is no good; let\u0027s err out\r\n            reportStrangeStream();\r\n        }\r\n        _length +\u003d count;\r\n    }\r\n    return true;\r\n}"
      },
      {
        "name": "UTF32Reader#reportInvalid(...3)",
        "body": "{\r\n    int bytePos \u003d _byteCount + _ptr - 1, charPos \u003d _charCount + offset;\r\n    throw new CharConversionException(\"Invalid UTF-32 character 0x\" + Integer.toHexString(value) + msg + \" at char #\" + charPos + \", byte #\" + bytePos + \")\");\r\n}"
      },
      {
        "name": "UTF32Reader#reportBounds(...3)",
        "body": "{\r\n    throw new ArrayIndexOutOfBoundsException(String.format(\"read(buf,%d,%d), cbuf[%d]\", start, len, cbuf.length));\r\n}"
      },
      {
        "name": "UTF32Reader#reportUnexpectedEOF(...2)",
        "body": "{\r\n    int bytePos \u003d _byteCount + gotBytes, charPos \u003d _charCount;\r\n    throw new CharConversionException(\"Unexpected EOF in the middle of a 4-byte UTF-32 char: got \" + gotBytes + \", needed \" + needed + \", at char #\" + charPos + \", byte #\" + bytePos + \")\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF8Writer",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (_out !\u003d null) {\r\n        if (_outPtr \u003e 0) {\r\n            _out.write(_outBuffer, 0, _outPtr);\r\n            _outPtr \u003d 0;\r\n        }\r\n        OutputStream out \u003d _out;\r\n        _out \u003d null;\r\n        byte[] buf \u003d _outBuffer;\r\n        if (buf !\u003d null) {\r\n            _outBuffer \u003d null;\r\n            _context.releaseWriteEncodingBuffer(buf);\r\n        }\r\n        out.close();\r\n        // Let\u0027s \u0027flush\u0027 orphan surrogate, no matter what; but only\r\n        // after cleanly closing everything else.\r\n        int code \u003d _surrogate;\r\n        _surrogate \u003d 0;\r\n        if (code \u003e 0) {\r\n            illegalSurrogate(code);\r\n        }\r\n    }\r\n    _context.close();\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If($i0 \u003c\u003d 0) → B2 | else → B3",
      "B3 : If($r6 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($i1 \u003c\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8Writer\n  $r1 \u003d OutputStream _out\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $i0 \u003d UTF8Writer: int _outPtr\u003e\n  if ($i0 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d OutputStream _out\u003e\n  $r3 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i2 \u003d UTF8Writer: int _outPtr\u003e\n  $r4.write($r3, 0, $i2)\n  UTF8Writer: int _outPtr\u003e \u003d 0\n}",
      "B3 {\n  $r5 \u003d OutputStream _out\u003e\n  OutputStream _out\u003e \u003d null\n  $r6 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  if ($r6 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  UTF8Writer: byte[] _outBuffer\u003e \u003d null\n  $r2 \u003d IOContext _context\u003e\n  $r2.releaseWriteEncodingBuffer($r6)\n}",
      "B5 {\n  $r5.close()\n  $i1 \u003d UTF8Writer: int _surrogate\u003e\n  UTF8Writer: int _surrogate\u003e \u003d 0\n  if ($i1 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  UTF8Writer.illegalSurrogate($i1)\n}",
      "B7 {\n  $r7 \u003d IOContext _context\u003e\n  $r7.close()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8Writer#illegalSurrogate(...1)",
        "body": "{\r\n    throw new IOException(illegalSurrogateDesc(code));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF8Writer",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    if (_out !\u003d null) {\r\n        if (_outPtr \u003e 0) {\r\n            _out.write(_outBuffer, 0, _outPtr);\r\n            _outPtr \u003d 0;\r\n        }\r\n        _out.flush();\r\n    }\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B1 : If($i0 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8Writer\n  $r1 \u003d OutputStream _out\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $i0 \u003d UTF8Writer: int _outPtr\u003e\n  if ($i0 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d OutputStream _out\u003e\n  $r3 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i1 \u003d UTF8Writer: int _outPtr\u003e\n  $r4.write($r3, 0, $i1)\n  UTF8Writer: int _outPtr\u003e \u003d 0\n}",
      "B3 {\n  $r2 \u003d OutputStream _out\u003e\n  $r2.flush()\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF8Writer",
    "methodName": "write",
    "signature": "void write(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003c 2) {\r\n        if (len \u003d\u003d 1) {\r\n            write(cbuf[off]);\r\n        }\r\n        return;\r\n    }\r\n    // First: do we have a leftover surrogate to deal with?\r\n    if (_surrogate \u003e 0) {\r\n        char second \u003d cbuf[off++];\r\n        --len;\r\n        write(convertSurrogate(second));\r\n        // will have at least one more char\r\n    }\r\n    int outPtr \u003d _outPtr;\r\n    byte[] outBuf \u003d _outBuffer;\r\n    // has 4 \u0027spare\u0027 bytes\r\n    int outBufLast \u003d _outBufferEnd;\r\n    // All right; can just loop it nice and easy now:\r\n    // len will now be the end of input buffer\r\n    len +\u003d off;\r\n    output_loop: for (; off \u003c len; ) {\r\n        /* First, let\u0027s ensure we can output at least 4 bytes\r\n             * (longest UTF-8 encoded codepoint):\r\n             */\r\n        if (outPtr \u003e\u003d outBufLast) {\r\n            _out.write(outBuf, 0, outPtr);\r\n            outPtr \u003d 0;\r\n        }\r\n        int c \u003d cbuf[off++];\r\n        // And then see if we have an Ascii char:\r\n        if (c \u003c 0x80) {\r\n            // If so, can do a tight inner loop:\r\n            outBuf[outPtr++] \u003d (byte) c;\r\n            // Let\u0027s calc how many ascii chars we can copy at most:\r\n            int maxInCount \u003d (len - off);\r\n            int maxOutCount \u003d (outBufLast - outPtr);\r\n            if (maxInCount \u003e maxOutCount) {\r\n                maxInCount \u003d maxOutCount;\r\n            }\r\n            maxInCount +\u003d off;\r\n            ascii_loop: while (true) {\r\n                if (off \u003e\u003d maxInCount) {\r\n                    // done with max. ascii seq\r\n                    continue output_loop;\r\n                }\r\n                c \u003d cbuf[off++];\r\n                if (c \u003e\u003d 0x80) {\r\n                    break ascii_loop;\r\n                }\r\n                outBuf[outPtr++] \u003d (byte) c;\r\n            }\r\n        }\r\n        // Nope, multi-byte:\r\n        if (c \u003c 0x800) {\r\n            // 2-byte\r\n            outBuf[outPtr++] \u003d (byte) (0xc0 | (c \u003e\u003e 6));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        } else {\r\n            // 3 or 4 bytes\r\n            // Surrogates?\r\n            if (c \u003c SURR1_FIRST || c \u003e SURR2_LAST) {\r\n                outBuf[outPtr++] \u003d (byte) (0xe0 | (c \u003e\u003e 12));\r\n                outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n                outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n                continue;\r\n            }\r\n            // Yup, a surrogate:\r\n            if (c \u003e SURR1_LAST) {\r\n                // must be from first range\r\n                _outPtr \u003d outPtr;\r\n                illegalSurrogate(c);\r\n            }\r\n            _surrogate \u003d c;\r\n            // and if so, followed by another from next range\r\n            if (off \u003e\u003d len) {\r\n                // unless we hit the end?\r\n                break;\r\n            }\r\n            c \u003d convertSurrogate(cbuf[off++]);\r\n            if (c \u003e 0x10FFFF) {\r\n                // illegal in JSON as well as in XML\r\n                _outPtr \u003d outPtr;\r\n                illegalSurrogate(c);\r\n            }\r\n            outBuf[outPtr++] \u003d (byte) (0xf0 | (c \u003e\u003e 18));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 12) \u0026 0x3f));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        }\r\n    }\r\n    _outPtr \u003d outPtr;\r\n}",
    "nodes": 33,
    "edges": 46,
    "cc": 15,
    "flowSummary": [
      "B0 : If(i48 \u003e\u003d 2) → B1 | else → B4",
      "B1 : If(i48 !\u003d 1) → B2 | else → B3",
      "B4 : If($i0 \u003c\u003d 0) → B5 | else → B6",
      "B7 : If(i47 \u003e\u003d $i45) → B8 | else → B32",
      "B8 : If(i50 \u003c $i44) → B9 | else → B10",
      "B10 : If($i64 \u003e\u003d 128) → B11 | else → B19",
      "B11 : If(i52 \u003c\u003d i36) → B12 | else → B13",
      "B14 : If(i47 \u003c $i40) → B15 | else → B16",
      "B16 : If($i65 \u003c 128) → B17 | else → B18",
      "B19 : If($i66 \u003e\u003d 2048) → B20 | else → B21",
      "B21 : If($i68 \u003c $i70) → B22 | else → B23",
      "B22 : If($i71 \u003c\u003d $i73) → B23 | else → B24",
      "B24 : If($i76 \u003c\u003d $i78) → B25 | else → B26",
      "B26 : If(i47 \u003c $i45) → B27 | else → B28",
      "B28 : If(i56 \u003c\u003d 1114111) → B29 | else → B30"
    ],
    "blockList": [
      "B0 {\n  UTF8Writer\n  r1 :\u003d @parameter0: char[]\n  i47 :\u003d @parameter1: int\n  i48 :\u003d @parameter2: int\n  if (i48 \u003e\u003d 2) goto B1 else B4\n}",
      "B1 {\n  if (i48 !\u003d 1) goto B2 else B3\n}",
      "B2 {\n  $c46 \u003d r1[i47]\n  $i60 \u003d (int) $c46\n  r0.write($i60)\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $i0 \u003d UTF8Writer: int _surrogate\u003e\n  if ($i0 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i42 \u003d i47\n  i47 \u003d i47 + 1\n  c49 \u003d r1[$i42]\n  $i62 \u003d (int) -1\n  i48 \u003d i48 + $i62\n  $i63 \u003d (int) c49\n  $i43 \u003d r0.convertSurrogate($i63)\n  r0.write($i43)\n}",
      "B6 {\n  i50 \u003d UTF8Writer: int _outPtr\u003e\n  $r3 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i44 \u003d UTF8Writer: int _outBufferEnd\u003e\n  $i45 \u003d i48 + i47\n}",
      "B7 {\n  if (i47 \u003e\u003d $i45) goto B8 else B32\n}",
      "B8 {\n  if (i50 \u003c $i44) goto B9 else B10\n}",
      "B9 {\n  $r2 \u003d OutputStream _out\u003e\n  $r2.write($r3, 0, i50)\n  i50 \u003d 0\n}",
      "B10 {\n  $i1 \u003d i47\n  i47 \u003d i47 + 1\n  $c41 \u003d r1[$i1]\n  c51 \u003d $c41\n  $i64 \u003d (int) $c41\n  if ($i64 \u003e\u003d 128) goto B11 else B19\n}",
      "B11 {\n  $i34 \u003d i50\n  i50 \u003d i50 + 1\n  $b35 \u003d (byte) $c41\n  $r3[$i34] \u003d $b35\n  i52 \u003d $i45 - i47\n  i36 \u003d $i44 - i50\n  if (i52 \u003c\u003d i36) goto B12 else B13\n}",
      "B12 {\n  i52 \u003d i36\n}",
      "B13 {\n  $i40 \u003d i52 + i47\n}",
      "B14 {\n  if (i47 \u003c $i40) goto B15 else B16\n}",
      "B15 {\n  goto B7\n}",
      "B16 {\n  $i37 \u003d i47\n  i47 \u003d i47 + 1\n  c51 \u003d r1[$i37]\n  $i65 \u003d (int) c51\n  if ($i65 \u003c 128) goto B17 else B18\n}",
      "B17 {\n  goto B19\n}",
      "B18 {\n  $i38 \u003d i50\n  i50 \u003d i50 + 1\n  $b39 \u003d (byte) c51\n  $r3[$i38] \u003d $b39\n  goto B14\n}",
      "B19 {\n  $i66 \u003d (int) c51\n  if ($i66 \u003e\u003d 2048) goto B20 else B21\n}",
      "B20 {\n  i53 \u003d i50 + 1\n  $i67 \u003d (int) c51\n  $i28 \u003d $i67 \u003e\u003e 6\n  $i29 \u003d 192 | $i28\n  $b30 \u003d (byte) $i29\n  $r3[i50] \u003d $b30\n  i50 \u003d i53 + 1\n  $c31 \u003d c51 \u0026 63\n  $s32 \u003d 128 | $c31\n  $b33 \u003d (byte) $s32\n  $r3[i53] \u003d $b33\n  goto B31\n}",
      "B21 {\n  $i68 \u003d (int) c51\n  $i70 \u003d (int) 55296\n  if ($i68 \u003c $i70) goto B22 else B23\n}",
      "B22 {\n  $i71 \u003d (int) c51\n  $i73 \u003d (int) 57343\n  if ($i71 \u003c\u003d $i73) goto B23 else B24\n}",
      "B23 {\n  i54 \u003d i50 + 1\n  $i74 \u003d (int) c51\n  $i2 \u003d $i74 \u003e\u003e 12\n  $i3 \u003d 224 | $i2\n  $b4 \u003d (byte) $i3\n  $r3[i50] \u003d $b4\n  i55 \u003d i54 + 1\n  $i75 \u003d (int) c51\n  $i5 \u003d $i75 \u003e\u003e 6\n  $i6 \u003d $i5 \u0026 63\n  $i7 \u003d 128 | $i6\n  $b8 \u003d (byte) $i7\n  $r3[i54] \u003d $b8\n  i50 \u003d i55 + 1\n  $c9 \u003d c51 \u0026 63\n  $s10 \u003d 128 | $c9\n  $b11 \u003d (byte) $s10\n  $r3[i55] \u003d $b11\n  goto B7\n}",
      "B24 {\n  $i76 \u003d (int) c51\n  $i78 \u003d (int) 56319\n  if ($i76 \u003c\u003d $i78) goto B25 else B26\n}",
      "B25 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  $i79 \u003d (int) c51\n  UTF8Writer.illegalSurrogate($i79)\n}",
      "B26 {\n  $i80 \u003d (int) c51\n  UTF8Writer: int _surrogate\u003e \u003d $i80\n  if (i47 \u003c $i45) goto B27 else B28\n}",
      "B27 {\n  goto B32\n}",
      "B28 {\n  $i12 \u003d i47\n  i47 \u003d i47 + 1\n  $c13 \u003d r1[$i12]\n  $i81 \u003d (int) $c13\n  i56 \u003d r0.convertSurrogate($i81)\n  if (i56 \u003c\u003d 1114111) goto B29 else B30\n}",
      "B29 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  UTF8Writer.illegalSurrogate(i56)\n}",
      "B30 {\n  i57 \u003d i50 + 1\n  $i14 \u003d i56 \u003e\u003e 18\n  $i15 \u003d 240 | $i14\n  $b16 \u003d (byte) $i15\n  $r3[i50] \u003d $b16\n  i58 \u003d i57 + 1\n  $i17 \u003d i56 \u003e\u003e 12\n  $i18 \u003d $i17 \u0026 63\n  $i19 \u003d 128 | $i18\n  $b20 \u003d (byte) $i19\n  $r3[i57] \u003d $b20\n  i59 \u003d i58 + 1\n  $i21 \u003d i56 \u003e\u003e 6\n  $i22 \u003d $i21 \u0026 63\n  $i23 \u003d 128 | $i22\n  $b24 \u003d (byte) $i23\n  $r3[i58] \u003d $b24\n  i50 \u003d i59 + 1\n  $i25 \u003d i56 \u0026 63\n  $i26 \u003d 128 | $i25\n  $b27 \u003d (byte) $i26\n  $r3[i59] \u003d $b27\n}",
      "B31 {\n  goto B7\n}",
      "B32 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B32",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B19",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B7",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B14",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B31",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B7",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B32",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B31 --\u003e B7",
      "B32 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8Writer#write(...1)",
        "body": "{\r\n    write(cbuf, 0, cbuf.length);\r\n}"
      },
      {
        "name": "UTF8Writer#convertSurrogate(...1)",
        "body": "{\r\n    int firstPart \u003d _surrogate;\r\n    _surrogate \u003d 0;\r\n    // Ok, then, is the second part valid?\r\n    if (secondPart \u003c SURR2_FIRST || secondPart \u003e SURR2_LAST) {\r\n        throw new IOException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(firstPart) + \", second 0x\" + Integer.toHexString(secondPart) + \"; illegal combination\");\r\n    }\r\n    return (firstPart \u003c\u003c 10) + secondPart + UTF8Writer.SURROGATE_BASE;\r\n}"
      },
      {
        "name": "UTF8Writer#illegalSurrogate(...1)",
        "body": "{\r\n    throw new IOException(illegalSurrogateDesc(code));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF8Writer",
    "methodName": "write",
    "signature": "void write(int)",
    "visibility": "public",
    "body": "{\r\n    // First; do we have a left over surrogate?\r\n    if (_surrogate \u003e 0) {\r\n        c \u003d convertSurrogate(c);\r\n        // If not, do we start with a surrogate?\r\n    } else if (c \u003e\u003d SURR1_FIRST \u0026\u0026 c \u003c\u003d SURR2_LAST) {\r\n        // Illegal to get second part without first:\r\n        if (c \u003e SURR1_LAST) {\r\n            illegalSurrogate(c);\r\n        }\r\n        // First part just needs to be held for now\r\n        _surrogate \u003d c;\r\n        return;\r\n    }\r\n    if (_outPtr \u003e\u003d _outBufferEnd) {\r\n        // let\u0027s require enough room, first\r\n        _out.write(_outBuffer, 0, _outPtr);\r\n        _outPtr \u003d 0;\r\n    }\r\n    if (c \u003c 0x80) {\r\n        // ascii\r\n        _outBuffer[_outPtr++] \u003d (byte) c;\r\n    } else {\r\n        int ptr \u003d _outPtr;\r\n        if (c \u003c 0x800) {\r\n            // 2-byte\r\n            _outBuffer[ptr++] \u003d (byte) (0xc0 | (c \u003e\u003e 6));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        } else if (c \u003c\u003d 0xFFFF) {\r\n            // 3 bytes\r\n            _outBuffer[ptr++] \u003d (byte) (0xe0 | (c \u003e\u003e 12));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        } else {\r\n            // 4 bytes\r\n            if (c \u003e 0x10FFFF) {\r\n                // illegal\r\n                illegalSurrogate(c);\r\n            }\r\n            _outBuffer[ptr++] \u003d (byte) (0xf0 | (c \u003e\u003e 18));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | ((c \u003e\u003e 12) \u0026 0x3f));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            _outBuffer[ptr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        }\r\n        _outPtr \u003d ptr;\r\n    }\r\n}",
    "nodes": 20,
    "edges": 27,
    "cc": 9,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2",
      "B2 : If(i35 \u003c $i47) → B3 | else → B7",
      "B3 : If(i35 \u003e $i49) → B4 | else → B7",
      "B4 : If(i35 \u003c\u003d $i51) → B5 | else → B6",
      "B7 : If($i36 \u003c $i37) → B8 | else → B9",
      "B9 : If(i35 \u003e\u003d 128) → B10 | else → B11",
      "B11 : If(i35 \u003e\u003d 2048) → B12 | else → B13",
      "B13 : If(i35 \u003e $i53) → B14 | else → B15",
      "B15 : If(i35 \u003c\u003d 1114111) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  UTF8Writer\n  i35 :\u003d @parameter0: int\n  $i0 \u003d UTF8Writer: int _surrogate\u003e\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i35 \u003d r0.convertSurrogate(i35)\n  goto B7\n}",
      "B2 {\n  $i47 \u003d (int) 55296\n  if (i35 \u003c $i47) goto B3 else B7\n}",
      "B3 {\n  $i49 \u003d (int) 57343\n  if (i35 \u003e $i49) goto B4 else B7\n}",
      "B4 {\n  $i51 \u003d (int) 56319\n  if (i35 \u003c\u003d $i51) goto B5 else B6\n}",
      "B5 {\n  UTF8Writer.illegalSurrogate(i35)\n}",
      "B6 {\n  UTF8Writer: int _surrogate\u003e \u003d i35\n  return\n}",
      "B7 {\n  $i36 \u003d UTF8Writer: int _outPtr\u003e\n  $i37 \u003d UTF8Writer: int _outBufferEnd\u003e\n  if ($i36 \u003c $i37) goto B8 else B9\n}",
      "B8 {\n  $r12 \u003d OutputStream _out\u003e\n  $r11 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i34 \u003d UTF8Writer: int _outPtr\u003e\n  $r12.write($r11, 0, $i34)\n  UTF8Writer: int _outPtr\u003e \u003d 0\n}",
      "B9 {\n  if (i35 \u003e\u003d 128) goto B10 else B11\n}",
      "B10 {\n  $r10 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i31 \u003d UTF8Writer: int _outPtr\u003e\n  $i32 \u003d $i31 + 1\n  UTF8Writer: int _outPtr\u003e \u003d $i32\n  $b33 \u003d (byte) i35\n  $r10[$i31] \u003d $b33\n  goto B19\n}",
      "B11 {\n  i38 \u003d UTF8Writer: int _outPtr\u003e\n  if (i35 \u003e\u003d 2048) goto B12 else B13\n}",
      "B12 {\n  $r8 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i39 \u003d i38 + 1\n  $i25 \u003d i35 \u003e\u003e 6\n  $i26 \u003d 192 | $i25\n  $b27 \u003d (byte) $i26\n  $r8[i38] \u003d $b27\n  $r9 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i40 \u003d i39 + 1\n  $i28 \u003d i35 \u0026 63\n  $i29 \u003d 128 | $i28\n  $b30 \u003d (byte) $i29\n  $r9[i39] \u003d $b30\n  goto B18\n}",
      "B13 {\n  $i53 \u003d (int) 65535\n  if (i35 \u003e $i53) goto B14 else B15\n}",
      "B14 {\n  $r5 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i41 \u003d i38 + 1\n  $i15 \u003d i35 \u003e\u003e 12\n  $i16 \u003d 224 | $i15\n  $b17 \u003d (byte) $i16\n  $r5[i38] \u003d $b17\n  $r6 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i42 \u003d i41 + 1\n  $i18 \u003d i35 \u003e\u003e 6\n  $i19 \u003d $i18 \u0026 63\n  $i20 \u003d 128 | $i19\n  $b21 \u003d (byte) $i20\n  $r6[i41] \u003d $b21\n  $r7 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i40 \u003d i42 + 1\n  $i22 \u003d i35 \u0026 63\n  $i23 \u003d 128 | $i22\n  $b24 \u003d (byte) $i23\n  $r7[i42] \u003d $b24\n  goto B18\n}",
      "B15 {\n  if (i35 \u003c\u003d 1114111) goto B16 else B17\n}",
      "B16 {\n  UTF8Writer.illegalSurrogate(i35)\n}",
      "B17 {\n  $r1 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i43 \u003d i38 + 1\n  $i1 \u003d i35 \u003e\u003e 18\n  $i2 \u003d 240 | $i1\n  $b3 \u003d (byte) $i2\n  $r1[i38] \u003d $b3\n  $r2 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i44 \u003d i43 + 1\n  $i4 \u003d i35 \u003e\u003e 12\n  $i5 \u003d $i4 \u0026 63\n  $i6 \u003d 128 | $i5\n  $b7 \u003d (byte) $i6\n  $r2[i43] \u003d $b7\n  $r3 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i45 \u003d i44 + 1\n  $i8 \u003d i35 \u003e\u003e 6\n  $i9 \u003d $i8 \u0026 63\n  $i10 \u003d 128 | $i9\n  $b11 \u003d (byte) $i10\n  $r3[i44] \u003d $b11\n  $r4 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  i40 \u003d i45 + 1\n  $i12 \u003d i35 \u0026 63\n  $i13 \u003d 128 | $i12\n  $b14 \u003d (byte) $i13\n  $r4[i45] \u003d $b14\n}",
      "B18 {\n  UTF8Writer: int _outPtr\u003e \u003d i40\n}",
      "B19 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B19",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B18",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8Writer#convertSurrogate(...1)",
        "body": "{\r\n    int firstPart \u003d _surrogate;\r\n    _surrogate \u003d 0;\r\n    // Ok, then, is the second part valid?\r\n    if (secondPart \u003c SURR2_FIRST || secondPart \u003e SURR2_LAST) {\r\n        throw new IOException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(firstPart) + \", second 0x\" + Integer.toHexString(secondPart) + \"; illegal combination\");\r\n    }\r\n    return (firstPart \u003c\u003c 10) + secondPart + UTF8Writer.SURROGATE_BASE;\r\n}"
      },
      {
        "name": "UTF8Writer#illegalSurrogate(...1)",
        "body": "{\r\n    throw new IOException(illegalSurrogateDesc(code));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.io.UTF8Writer",
    "methodName": "write",
    "signature": "void write(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003c 2) {\r\n        if (len \u003d\u003d 1) {\r\n            write(str.charAt(off));\r\n        }\r\n        return;\r\n    }\r\n    // First: do we have a leftover surrogate to deal with?\r\n    if (_surrogate \u003e 0) {\r\n        char second \u003d str.charAt(off++);\r\n        --len;\r\n        write(convertSurrogate(second));\r\n        // will have at least one more char (case of 1 char was checked earlier on)\r\n    }\r\n    int outPtr \u003d _outPtr;\r\n    byte[] outBuf \u003d _outBuffer;\r\n    // has 4 \u0027spare\u0027 bytes\r\n    int outBufLast \u003d _outBufferEnd;\r\n    // All right; can just loop it nice and easy now:\r\n    // len will now be the end of input buffer\r\n    len +\u003d off;\r\n    output_loop: for (; off \u003c len; ) {\r\n        /* First, let\u0027s ensure we can output at least 4 bytes\r\n             * (longest UTF-8 encoded codepoint):\r\n             */\r\n        if (outPtr \u003e\u003d outBufLast) {\r\n            _out.write(outBuf, 0, outPtr);\r\n            outPtr \u003d 0;\r\n        }\r\n        int c \u003d str.charAt(off++);\r\n        // And then see if we have an Ascii char:\r\n        if (c \u003c 0x80) {\r\n            // If so, can do a tight inner loop:\r\n            outBuf[outPtr++] \u003d (byte) c;\r\n            // Let\u0027s calc how many ascii chars we can copy at most:\r\n            int maxInCount \u003d (len - off);\r\n            int maxOutCount \u003d (outBufLast - outPtr);\r\n            if (maxInCount \u003e maxOutCount) {\r\n                maxInCount \u003d maxOutCount;\r\n            }\r\n            maxInCount +\u003d off;\r\n            ascii_loop: while (true) {\r\n                if (off \u003e\u003d maxInCount) {\r\n                    // done with max. ascii seq\r\n                    continue output_loop;\r\n                }\r\n                c \u003d str.charAt(off++);\r\n                if (c \u003e\u003d 0x80) {\r\n                    break ascii_loop;\r\n                }\r\n                outBuf[outPtr++] \u003d (byte) c;\r\n            }\r\n        }\r\n        // Nope, multi-byte:\r\n        if (c \u003c 0x800) {\r\n            // 2-byte\r\n            outBuf[outPtr++] \u003d (byte) (0xc0 | (c \u003e\u003e 6));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        } else {\r\n            // 3 or 4 bytes\r\n            // Surrogates?\r\n            if (c \u003c SURR1_FIRST || c \u003e SURR2_LAST) {\r\n                outBuf[outPtr++] \u003d (byte) (0xe0 | (c \u003e\u003e 12));\r\n                outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n                outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n                continue;\r\n            }\r\n            // Yup, a surrogate:\r\n            if (c \u003e SURR1_LAST) {\r\n                // must be from first range\r\n                _outPtr \u003d outPtr;\r\n                illegalSurrogate(c);\r\n            }\r\n            _surrogate \u003d c;\r\n            // and if so, followed by another from next range\r\n            if (off \u003e\u003d len) {\r\n                // unless we hit the end?\r\n                break;\r\n            }\r\n            c \u003d convertSurrogate(str.charAt(off++));\r\n            if (c \u003e 0x10FFFF) {\r\n                // illegal, as per RFC 4627\r\n                _outPtr \u003d outPtr;\r\n                illegalSurrogate(c);\r\n            }\r\n            outBuf[outPtr++] \u003d (byte) (0xf0 | (c \u003e\u003e 18));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 12) \u0026 0x3f));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3f));\r\n            outBuf[outPtr++] \u003d (byte) (0x80 | (c \u0026 0x3f));\r\n        }\r\n    }\r\n    _outPtr \u003d outPtr;\r\n}",
    "nodes": 33,
    "edges": 46,
    "cc": 15,
    "flowSummary": [
      "B0 : If(i48 \u003e\u003d 2) → B1 | else → B4",
      "B1 : If(i48 !\u003d 1) → B2 | else → B3",
      "B4 : If($i0 \u003c\u003d 0) → B5 | else → B6",
      "B7 : If(i47 \u003e\u003d $i45) → B8 | else → B32",
      "B8 : If(i50 \u003c $i44) → B9 | else → B10",
      "B10 : If($i64 \u003e\u003d 128) → B11 | else → B19",
      "B11 : If(i52 \u003c\u003d i36) → B12 | else → B13",
      "B14 : If(i47 \u003c $i40) → B15 | else → B16",
      "B16 : If($i65 \u003c 128) → B17 | else → B18",
      "B19 : If($i66 \u003e\u003d 2048) → B20 | else → B21",
      "B21 : If($i68 \u003c $i70) → B22 | else → B23",
      "B22 : If($i71 \u003c\u003d $i73) → B23 | else → B24",
      "B24 : If($i76 \u003c\u003d $i78) → B25 | else → B26",
      "B26 : If(i47 \u003c $i45) → B27 | else → B28",
      "B28 : If(i56 \u003c\u003d 1114111) → B29 | else → B30"
    ],
    "blockList": [
      "B0 {\n  UTF8Writer\n  String\n  i47 :\u003d @parameter1: int\n  i48 :\u003d @parameter2: int\n  if (i48 \u003e\u003d 2) goto B1 else B4\n}",
      "B1 {\n  if (i48 !\u003d 1) goto B2 else B3\n}",
      "B2 {\n  $c46 \u003d r1.charAt(i47)\n  $i60 \u003d (int) $c46\n  r0.write($i60)\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $i0 \u003d UTF8Writer: int _surrogate\u003e\n  if ($i0 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i42 \u003d i47\n  i47 \u003d i47 + 1\n  c49 \u003d r1.charAt($i42)\n  $i62 \u003d (int) -1\n  i48 \u003d i48 + $i62\n  $i63 \u003d (int) c49\n  $i43 \u003d r0.convertSurrogate($i63)\n  r0.write($i43)\n}",
      "B6 {\n  i50 \u003d UTF8Writer: int _outPtr\u003e\n  $r3 \u003d UTF8Writer: byte[] _outBuffer\u003e\n  $i44 \u003d UTF8Writer: int _outBufferEnd\u003e\n  $i45 \u003d i48 + i47\n}",
      "B7 {\n  if (i47 \u003e\u003d $i45) goto B8 else B32\n}",
      "B8 {\n  if (i50 \u003c $i44) goto B9 else B10\n}",
      "B9 {\n  $r2 \u003d OutputStream _out\u003e\n  $r2.write($r3, 0, i50)\n  i50 \u003d 0\n}",
      "B10 {\n  $i1 \u003d i47\n  i47 \u003d i47 + 1\n  $c41 \u003d r1.charAt($i1)\n  c51 \u003d $c41\n  $i64 \u003d (int) $c41\n  if ($i64 \u003e\u003d 128) goto B11 else B19\n}",
      "B11 {\n  $i34 \u003d i50\n  i50 \u003d i50 + 1\n  $b35 \u003d (byte) $c41\n  $r3[$i34] \u003d $b35\n  i52 \u003d $i45 - i47\n  i36 \u003d $i44 - i50\n  if (i52 \u003c\u003d i36) goto B12 else B13\n}",
      "B12 {\n  i52 \u003d i36\n}",
      "B13 {\n  $i40 \u003d i52 + i47\n}",
      "B14 {\n  if (i47 \u003c $i40) goto B15 else B16\n}",
      "B15 {\n  goto B7\n}",
      "B16 {\n  $i37 \u003d i47\n  i47 \u003d i47 + 1\n  c51 \u003d r1.charAt($i37)\n  $i65 \u003d (int) c51\n  if ($i65 \u003c 128) goto B17 else B18\n}",
      "B17 {\n  goto B19\n}",
      "B18 {\n  $i38 \u003d i50\n  i50 \u003d i50 + 1\n  $b39 \u003d (byte) c51\n  $r3[$i38] \u003d $b39\n  goto B14\n}",
      "B19 {\n  $i66 \u003d (int) c51\n  if ($i66 \u003e\u003d 2048) goto B20 else B21\n}",
      "B20 {\n  i53 \u003d i50 + 1\n  $i67 \u003d (int) c51\n  $i28 \u003d $i67 \u003e\u003e 6\n  $i29 \u003d 192 | $i28\n  $b30 \u003d (byte) $i29\n  $r3[i50] \u003d $b30\n  i50 \u003d i53 + 1\n  $c31 \u003d c51 \u0026 63\n  $s32 \u003d 128 | $c31\n  $b33 \u003d (byte) $s32\n  $r3[i53] \u003d $b33\n  goto B31\n}",
      "B21 {\n  $i68 \u003d (int) c51\n  $i70 \u003d (int) 55296\n  if ($i68 \u003c $i70) goto B22 else B23\n}",
      "B22 {\n  $i71 \u003d (int) c51\n  $i73 \u003d (int) 57343\n  if ($i71 \u003c\u003d $i73) goto B23 else B24\n}",
      "B23 {\n  i54 \u003d i50 + 1\n  $i74 \u003d (int) c51\n  $i2 \u003d $i74 \u003e\u003e 12\n  $i3 \u003d 224 | $i2\n  $b4 \u003d (byte) $i3\n  $r3[i50] \u003d $b4\n  i55 \u003d i54 + 1\n  $i75 \u003d (int) c51\n  $i5 \u003d $i75 \u003e\u003e 6\n  $i6 \u003d $i5 \u0026 63\n  $i7 \u003d 128 | $i6\n  $b8 \u003d (byte) $i7\n  $r3[i54] \u003d $b8\n  i50 \u003d i55 + 1\n  $c9 \u003d c51 \u0026 63\n  $s10 \u003d 128 | $c9\n  $b11 \u003d (byte) $s10\n  $r3[i55] \u003d $b11\n  goto B7\n}",
      "B24 {\n  $i76 \u003d (int) c51\n  $i78 \u003d (int) 56319\n  if ($i76 \u003c\u003d $i78) goto B25 else B26\n}",
      "B25 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  $i79 \u003d (int) c51\n  UTF8Writer.illegalSurrogate($i79)\n}",
      "B26 {\n  $i80 \u003d (int) c51\n  UTF8Writer: int _surrogate\u003e \u003d $i80\n  if (i47 \u003c $i45) goto B27 else B28\n}",
      "B27 {\n  goto B32\n}",
      "B28 {\n  $i12 \u003d i47\n  i47 \u003d i47 + 1\n  $c13 \u003d r1.charAt($i12)\n  $i81 \u003d (int) $c13\n  i56 \u003d r0.convertSurrogate($i81)\n  if (i56 \u003c\u003d 1114111) goto B29 else B30\n}",
      "B29 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  UTF8Writer.illegalSurrogate(i56)\n}",
      "B30 {\n  i57 \u003d i50 + 1\n  $i14 \u003d i56 \u003e\u003e 18\n  $i15 \u003d 240 | $i14\n  $b16 \u003d (byte) $i15\n  $r3[i50] \u003d $b16\n  i58 \u003d i57 + 1\n  $i17 \u003d i56 \u003e\u003e 12\n  $i18 \u003d $i17 \u0026 63\n  $i19 \u003d 128 | $i18\n  $b20 \u003d (byte) $i19\n  $r3[i57] \u003d $b20\n  i59 \u003d i58 + 1\n  $i21 \u003d i56 \u003e\u003e 6\n  $i22 \u003d $i21 \u0026 63\n  $i23 \u003d 128 | $i22\n  $b24 \u003d (byte) $i23\n  $r3[i58] \u003d $b24\n  i50 \u003d i59 + 1\n  $i25 \u003d i56 \u0026 63\n  $i26 \u003d 128 | $i25\n  $b27 \u003d (byte) $i26\n  $r3[i59] \u003d $b27\n}",
      "B31 {\n  goto B7\n}",
      "B32 {\n  UTF8Writer: int _outPtr\u003e \u003d i50\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B32",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B19",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B7",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B14",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B31",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B7",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B32",
      "B28 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B31",
      "B31 --\u003e B7",
      "B32 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8Writer#write(...1)",
        "body": "{\r\n    write(cbuf, 0, cbuf.length);\r\n}"
      },
      {
        "name": "UTF8Writer#convertSurrogate(...1)",
        "body": "{\r\n    int firstPart \u003d _surrogate;\r\n    _surrogate \u003d 0;\r\n    // Ok, then, is the second part valid?\r\n    if (secondPart \u003c SURR2_FIRST || secondPart \u003e SURR2_LAST) {\r\n        throw new IOException(\"Broken surrogate pair: first char 0x\" + Integer.toHexString(firstPart) + \", second 0x\" + Integer.toHexString(secondPart) + \"; illegal combination\");\r\n    }\r\n    return (firstPart \u003c\u003c 10) + secondPart + UTF8Writer.SURROGATE_BASE;\r\n}"
      },
      {
        "name": "UTF8Writer#illegalSurrogate(...1)",
        "body": "{\r\n    throw new IOException(illegalSurrogateDesc(code));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.async.NonBlockingByteBufferJsonParser",
    "methodName": "feedInput",
    "signature": "void feedInput(java.nio.ByteBuffer)",
    "visibility": "public",
    "body": "{\r\n    // Must not have remaining input\r\n    if (_inputPtr \u003c _inputEnd) {\r\n        _reportError(\"Still have %d undecoded bytes, should not call \u0027feedInput\u0027\", _inputEnd - _inputPtr);\r\n    }\r\n    final int start \u003d byteBuffer.position();\r\n    final int end \u003d byteBuffer.limit();\r\n    if (end \u003c start) {\r\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\r\n    }\r\n    // and shouldn\u0027t have been marked as end-of-input\r\n    if (_endOfInput) {\r\n        _reportError(\"Already closed, can not feed more input\");\r\n    }\r\n    // Time to update pointers first\r\n    _currInputProcessed +\u003d _origBufferLen;\r\n    // 06-Sep-2023, tatu: [core#1046] Enforce max doc length limit\r\n    _streamReadConstraints.validateDocumentLength(_currInputProcessed);\r\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\r\n    _currInputRowStart \u003d start - (_inputEnd - _currInputRowStart);\r\n    // And then update buffer settings\r\n    _currBufferStart \u003d start;\r\n    _inputBuffer \u003d byteBuffer;\r\n    _inputPtr \u003d start;\r\n    _inputEnd \u003d end;\r\n    _origBufferLen \u003d end - start;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 \u003e\u003d $i0) → B1 | else → B2",
      "B2 : If($i16 \u003e\u003d $i15) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  NonBlockingByteBufferJsonParser\n  ByteBuffer\n  $i1 \u003d NonBlockingByteBufferJsonParser: int _inputPtr\u003e\n  $i0 \u003d NonBlockingByteBufferJsonParser: int _inputEnd\u003e\n  if ($i1 \u003e\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  $i13 \u003d NonBlockingByteBufferJsonParser: int _inputEnd\u003e\n  $i12 \u003d NonBlockingByteBufferJsonParser: int _inputPtr\u003e\n  $i14 \u003d $i13 - $i12\n  $r5 \u003d Integer.valueOf($i14)\n  r0._reportError(\"Still have %d undecoded bytes, should not call \\\u0027feedInput\\\u0027\", $r5)\n}",
      "B2 {\n  $i15 \u003d r1.position()\n  $i16 \u003d r1.limit()\n  if ($i16 \u003e\u003d $i15) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d Integer.valueOf($i16)\n  $r3 \u003d Integer.valueOf($i15)\n  r0._reportError(\"Input end (%d) may not be before start (%d)\", $r4, $r3)\n}",
      "B4 {\n  $z0 \u003d NonBlockingByteBufferJsonParser: boolean _endOfInput\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r0._reportError(\"Already closed, can not feed more input\")\n}",
      "B6 {\n  $l4 \u003d NonBlockingByteBufferJsonParser: long _currInputProcessed\u003e\n  $i2 \u003d NonBlockingByteBufferJsonParser: int _origBufferLen\u003e\n  $l3 \u003d (long) $i2\n  $l5 \u003d $l4 + $l3\n  NonBlockingByteBufferJsonParser: long _currInputProcessed\u003e \u003d $l5\n  $r2 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  $l6 \u003d NonBlockingByteBufferJsonParser: long _currInputProcessed\u003e\n  $r2.validateDocumentLength($l6)\n  $i8 \u003d NonBlockingByteBufferJsonParser: int _inputEnd\u003e\n  $i7 \u003d NonBlockingByteBufferJsonParser: int _currInputRowStart\u003e\n  $i9 \u003d $i8 - $i7\n  $i10 \u003d $i15 - $i9\n  NonBlockingByteBufferJsonParser: int _currInputRowStart\u003e \u003d $i10\n  NonBlockingByteBufferJsonParser: int _currBufferStart\u003e \u003d $i15\n  ByteBuffer _inputBuffer\u003e \u003d r1\n  NonBlockingByteBufferJsonParser: int _inputPtr\u003e \u003d $i15\n  NonBlockingByteBufferJsonParser: int _inputEnd\u003e \u003d $i16\n  $i11 \u003d $i16 - $i15\n  NonBlockingByteBufferJsonParser: int _origBufferLen\u003e \u003d $i11\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NonBlockingByteBufferJsonParser#_reportError(...2)",
        "body": "(source not found)"
      },
      {
        "name": "NonBlockingByteBufferJsonParser#_reportError(...3)",
        "body": "(source not found)"
      },
      {
        "name": "NonBlockingByteBufferJsonParser#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.async.NonBlockingByteBufferJsonParser",
    "methodName": "releaseBuffered",
    "signature": "int releaseBuffered(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    final int avail \u003d _inputEnd - _inputPtr;\r\n    if (avail \u003e 0) {\r\n        final WritableByteChannel channel \u003d Channels.newChannel(out);\r\n        channel.write(_inputBuffer);\r\n    }\r\n    return avail;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NonBlockingByteBufferJsonParser\n  OutputStream\n  $i1 \u003d NonBlockingByteBufferJsonParser: int _inputEnd\u003e\n  $i0 \u003d NonBlockingByteBufferJsonParser: int _inputPtr\u003e\n  i2 \u003d $i1 - $i0\n  if (i2 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r2 \u003d Channels.newChannel(r1)\n  $r3 \u003d ByteBuffer _inputBuffer\u003e\n  r2.write($r3)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.async.NonBlockingJsonParser",
    "methodName": "feedInput",
    "signature": "void feedInput(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // Must not have remaining input\r\n    if (_inputPtr \u003c _inputEnd) {\r\n        _reportError(\"Still have %d undecoded bytes, should not call \u0027feedInput\u0027\", _inputEnd - _inputPtr);\r\n    }\r\n    if (end \u003c start) {\r\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\r\n    }\r\n    // and shouldn\u0027t have been marked as end-of-input\r\n    if (_endOfInput) {\r\n        _reportError(\"Already closed, can not feed more input\");\r\n    }\r\n    // Time to update pointers first\r\n    _currInputProcessed +\u003d _origBufferLen;\r\n    // 06-Sep-2023, tatu: [core#1046] Enforce max doc length limit\r\n    _streamReadConstraints.validateDocumentLength(_currInputProcessed);\r\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\r\n    _currInputRowStart \u003d start - (_inputEnd - _currInputRowStart);\r\n    // And then update buffer settings\r\n    _currBufferStart \u003d start;\r\n    _inputBuffer \u003d buf;\r\n    _inputPtr \u003d start;\r\n    _inputEnd \u003d end;\r\n    _origBufferLen \u003d end - start;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 \u003e\u003d $i0) → B1 | else → B2",
      "B2 : If(i2 \u003e\u003d i3) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  NonBlockingJsonParser\n  r2 :\u003d @parameter0: byte[]\n  i3 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  $i1 \u003d NonBlockingJsonParser: int _inputPtr\u003e\n  $i0 \u003d NonBlockingJsonParser: int _inputEnd\u003e\n  if ($i1 \u003e\u003d $i0) goto B1 else B2\n}",
      "B1 {\n  $i15 \u003d NonBlockingJsonParser: int _inputEnd\u003e\n  $i14 \u003d NonBlockingJsonParser: int _inputPtr\u003e\n  $i16 \u003d $i15 - $i14\n  $r5 \u003d Integer.valueOf($i16)\n  r0._reportError(\"Still have %d undecoded bytes, should not call \\\u0027feedInput\\\u0027\", $r5)\n}",
      "B2 {\n  if (i2 \u003e\u003d i3) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d Integer.valueOf(i2)\n  $r3 \u003d Integer.valueOf(i3)\n  r0._reportError(\"Input end (%d) may not be before start (%d)\", $r4, $r3)\n}",
      "B4 {\n  $z0 \u003d NonBlockingJsonParser: boolean _endOfInput\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r0._reportError(\"Already closed, can not feed more input\")\n}",
      "B6 {\n  $l6 \u003d NonBlockingJsonParser: long _currInputProcessed\u003e\n  $i4 \u003d NonBlockingJsonParser: int _origBufferLen\u003e\n  $l5 \u003d (long) $i4\n  $l7 \u003d $l6 + $l5\n  NonBlockingJsonParser: long _currInputProcessed\u003e \u003d $l7\n  $r1 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  $l8 \u003d NonBlockingJsonParser: long _currInputProcessed\u003e\n  $r1.validateDocumentLength($l8)\n  $i10 \u003d NonBlockingJsonParser: int _inputEnd\u003e\n  $i9 \u003d NonBlockingJsonParser: int _currInputRowStart\u003e\n  $i11 \u003d $i10 - $i9\n  $i12 \u003d i3 - $i11\n  NonBlockingJsonParser: int _currInputRowStart\u003e \u003d $i12\n  NonBlockingJsonParser: int _currBufferStart\u003e \u003d i3\n  NonBlockingJsonParser: byte[] _inputBuffer\u003e \u003d r2\n  NonBlockingJsonParser: int _inputPtr\u003e \u003d i3\n  NonBlockingJsonParser: int _inputEnd\u003e \u003d i2\n  $i13 \u003d i2 - i3\n  NonBlockingJsonParser: int _origBufferLen\u003e \u003d $i13\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NonBlockingJsonParser#_reportError(...2)",
        "body": "(source not found)"
      },
      {
        "name": "NonBlockingJsonParser#_reportError(...3)",
        "body": "(source not found)"
      },
      {
        "name": "NonBlockingJsonParser#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.async.NonBlockingJsonParser",
    "methodName": "releaseBuffered",
    "signature": "int releaseBuffered(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    final int avail \u003d _inputEnd - _inputPtr;\r\n    if (avail \u003e 0) {\r\n        out.write(_inputBuffer, _inputPtr, avail);\r\n    }\r\n    return avail;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NonBlockingJsonParser\n  OutputStream\n  $i1 \u003d NonBlockingJsonParser: int _inputEnd\u003e\n  $i0 \u003d NonBlockingJsonParser: int _inputPtr\u003e\n  i2 \u003d $i1 - $i0\n  if (i2 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d NonBlockingJsonParser: byte[] _inputBuffer\u003e\n  $i3 \u003d NonBlockingJsonParser: int _inputPtr\u003e\n  r1.write($r2, $i3, i2)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper",
    "methodName": "detectEncoding",
    "signature": "com.fasterxml.jackson.core.JsonEncoding detectEncoding()",
    "visibility": "public",
    "body": "{\r\n    boolean foundEncoding \u003d false;\r\n    // First things first: BOM handling\r\n    /* Note: we can require 4 bytes to be read, since no\r\n         * combination of BOM + valid JSON content can have\r\n         * shorter length (shortest valid JSON content is single\r\n         * digit char, but BOMs are chosen such that combination\r\n         * is always at least 4 chars long)\r\n         */\r\n    if (ensureLoaded(4)) {\r\n        int quad \u003d (_inputBuffer[_inputPtr] \u003c\u003c 24) | ((_inputBuffer[_inputPtr + 1] \u0026 0xFF) \u003c\u003c 16) | ((_inputBuffer[_inputPtr + 2] \u0026 0xFF) \u003c\u003c 8) | (_inputBuffer[_inputPtr + 3] \u0026 0xFF);\r\n        if (handleBOM(quad)) {\r\n            foundEncoding \u003d true;\r\n        } else {\r\n            /* If no BOM, need to auto-detect based on first char;\r\n                 * this works since it must be 7-bit ascii (wrt. unicode\r\n                 * compatible encodings, only ones JSON can be transferred\r\n                 * over)\r\n                 */\r\n            // UTF-32?\r\n            if (checkUTF32(quad)) {\r\n                foundEncoding \u003d true;\r\n            } else if (checkUTF16(quad \u003e\u003e\u003e 16)) {\r\n                foundEncoding \u003d true;\r\n            }\r\n        }\r\n    } else if (ensureLoaded(2)) {\r\n        int i16 \u003d ((_inputBuffer[_inputPtr] \u0026 0xFF) \u003c\u003c 8) | (_inputBuffer[_inputPtr + 1] \u0026 0xFF);\r\n        if (checkUTF16(i16)) {\r\n            foundEncoding \u003d true;\r\n        }\r\n    }\r\n    JsonEncoding enc;\r\n    /* Not found yet? As per specs, this means it must be UTF-8. */\r\n    if (!foundEncoding) {\r\n        enc \u003d JsonEncoding.UTF8;\r\n    } else {\r\n        switch(_bytesPerChar) {\r\n            case 1:\r\n                enc \u003d JsonEncoding.UTF8;\r\n                break;\r\n            case 2:\r\n                enc \u003d _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\r\n                break;\r\n            case 4:\r\n                enc \u003d _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\r\n                break;\r\n            default:\r\n                return VersionUtil.throwInternalReturnAny();\r\n        }\r\n    }\r\n    _context.setEncoding(enc);\r\n    return enc;\r\n}",
    "nodes": 25,
    "edges": 35,
    "cc": 12,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B8",
      "B1 : If($z5 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($z6 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z7 \u003d\u003d false) → B6 | else → B7",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B11",
      "B9 : If($z4 \u003d\u003d false) → B10 | else → B11",
      "B11 : If(z8 !\u003d 0) → B12 | else → B13",
      "B13 : If(switch-on $i0) → B14 | else → B15",
      "B15 : If($z3 \u003d\u003d false) → B16 | else → B17",
      "B19 : If($z2 \u003d\u003d false) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  ByteSourceJsonBootstrapper\n  z8 \u003d 0\n  $z0 \u003d r0.ensureLoaded(4)\n  if ($z0 \u003d\u003d false) goto B1 else B8\n}",
      "B1 {\n  $r5 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i9 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $b10 \u003d $r5[$i9]\n  $i31 \u003d (int) $b10\n  $i16 \u003d $i31 \u003c\u003c 24\n  $r6 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i11 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i12 \u003d $i11 + 1\n  $b13 \u003d $r6[$i12]\n  $s32 \u003d (short) $b13\n  $s14 \u003d $s32 \u0026 255\n  $i33 \u003d (int) $s14\n  $i15 \u003d $i33 \u003c\u003c 16\n  $i22 \u003d $i16 | $i15\n  $r7 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i17 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i18 \u003d $i17 + 2\n  $b19 \u003d $r7[$i18]\n  $s34 \u003d (short) $b19\n  $s20 \u003d $s34 \u0026 255\n  $i35 \u003d (int) $s20\n  $i21 \u003d $i35 \u003c\u003c 8\n  $i27 \u003d $i22 | $i21\n  $r8 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i23 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i24 \u003d $i23 + 3\n  $b25 \u003d $r8[$i24]\n  $s36 \u003d (short) $b25\n  $s26 \u003d $s36 \u0026 255\n  $i37 \u003d (int) $s26\n  i29 \u003d $i27 | $i37\n  $z5 \u003d r0.handleBOM(i29)\n  if ($z5 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  z8 \u003d 1\n  goto B7\n}",
      "B3 {\n  $z6 \u003d r0.checkUTF32(i29)\n  if ($z6 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  z8 \u003d 1\n  goto B7\n}",
      "B5 {\n  $i28 \u003d i29 \u003e\u003e\u003e 16\n  $z7 \u003d r0.checkUTF16($i28)\n  if ($z7 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  z8 \u003d 1\n}",
      "B7 {\n  goto B11\n}",
      "B8 {\n  $z1 \u003d r0.ensureLoaded(2)\n  if ($z1 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  $r3 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i1 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $b2 \u003d $r3[$i1]\n  $s38 \u003d (short) $b2\n  $s3 \u003d $s38 \u0026 255\n  $i39 \u003d (int) $s3\n  $i8 \u003d $i39 \u003c\u003c 8\n  $r4 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i4 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i5 \u003d $i4 + 1\n  $b6 \u003d $r4[$i5]\n  $s40 \u003d (short) $b6\n  $s7 \u003d $s40 \u0026 255\n  $i41 \u003d (int) $s7\n  i30 \u003d $i8 | $i41\n  $z4 \u003d r0.checkUTF16(i30)\n  if ($z4 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  z8 \u003d 1\n}",
      "B11 {\n  if (z8 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  r9 \u003d JsonEncoding UTF8\u003e\n  goto B24\n}",
      "B13 {\n  $i0 \u003d ByteSourceJsonBootstrapper: int _bytesPerChar\u003e\n  Object throwInternalReturnAny()\u003e(); }\n}",
      "B14 {\n  r9 \u003d JsonEncoding UTF8\u003e\n  goto B24\n}",
      "B15 {\n  $z3 \u003d ByteSourceJsonBootstrapper: boolean _bigEndian\u003e\n  if ($z3 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  $r10 \u003d JsonEncoding UTF16_BE\u003e\n  goto B18\n}",
      "B17 {\n  $r10 \u003d JsonEncoding UTF16_LE\u003e\n}",
      "B18 {\n  r9 \u003d $r10\n  goto B24\n}",
      "B19 {\n  $z2 \u003d ByteSourceJsonBootstrapper: boolean _bigEndian\u003e\n  if ($z2 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r11 \u003d JsonEncoding UTF32_BE\u003e\n  goto B22\n}",
      "B21 {\n  $r11 \u003d JsonEncoding UTF32_LE\u003e\n}",
      "B22 {\n  r9 \u003d $r11\n  goto B24\n}",
      "B23 {\n  $r1 \u003d VersionUtil.throwInternalReturnAny()\n  $r2 \u003d JsonEncoding) $r1\n  return\n}",
      "B24 {\n  $r12 \u003d IOContext _context\u003e\n  $r12.setEncoding(r9)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B24",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B13 --\u003e B23",
      "B13 --\u003e B19",
      "B14 --\u003e B24",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e B24",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B24",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteSourceJsonBootstrapper#ensureLoaded(...1)",
        "body": "{\r\n    // Let\u0027s assume here buffer has enough room -- this will always\r\n    // be true for the limited used this method gets\r\n    int gotten \u003d (_inputEnd - _inputPtr);\r\n    while (gotten \u003c minimum) {\r\n        int count;\r\n        if (_in \u003d\u003d null) {\r\n            // block source\r\n            count \u003d -1;\r\n        } else {\r\n            count \u003d _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\r\n        }\r\n        if (count \u003c 1) {\r\n            return false;\r\n        }\r\n        _inputEnd +\u003d count;\r\n        gotten +\u003d count;\r\n    }\r\n    return true;\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#handleBOM(...1)",
        "body": "{\r\n    /* Handling of (usually) optional BOM (required for\r\n         * multi-byte formats); first 32-bit charsets:\r\n         */\r\n    switch(quad) {\r\n        case 0x0000FEFF:\r\n            _bigEndian \u003d true;\r\n            _inputPtr +\u003d 4;\r\n            _bytesPerChar \u003d 4;\r\n            return true;\r\n        case // UCS-4, LE?\r\n        0xFFFE0000:\r\n            _inputPtr +\u003d 4;\r\n            _bytesPerChar \u003d 4;\r\n            _bigEndian \u003d false;\r\n            return true;\r\n        case // UCS-4, in-order...\r\n        0x0000FFFE:\r\n            // throws exception\r\n            reportWeirdUCS4(\"2143\");\r\n            // never gets here\r\n            break;\r\n        case // UCS-4, in-order...\r\n        0xFEFF0000:\r\n            // throws exception\r\n            reportWeirdUCS4(\"3412\");\r\n            // never gets here\r\n            break;\r\n        default:\r\n    }\r\n    // Ok, if not, how about 16-bit encoding BOMs?\r\n    int msw \u003d quad \u003e\u003e\u003e 16;\r\n    if (msw \u003d\u003d 0xFEFF) {\r\n        // UTF-16, BE\r\n        _inputPtr +\u003d 2;\r\n        _bytesPerChar \u003d 2;\r\n        _bigEndian \u003d true;\r\n        return true;\r\n    }\r\n    if (msw \u003d\u003d 0xFFFE) {\r\n        // UTF-16, LE\r\n        _inputPtr +\u003d 2;\r\n        _bytesPerChar \u003d 2;\r\n        _bigEndian \u003d false;\r\n        return true;\r\n    }\r\n    // And if not, then UTF-8 BOM?\r\n    if ((quad \u003e\u003e\u003e 8) \u003d\u003d 0xEFBBBF) {\r\n        // UTF-8\r\n        _inputPtr +\u003d 3;\r\n        _bytesPerChar \u003d 1;\r\n        // doesn\u0027t really matter\r\n        _bigEndian \u003d true;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#checkUTF32(...1)",
        "body": "{\r\n    /* Handling of (usually) optional BOM (required for\r\n         * multi-byte formats); first 32-bit charsets:\r\n         */\r\n    if ((quad \u003e\u003e 8) \u003d\u003d 0) {\r\n        // 0x000000?? -\u003e UTF32-BE\r\n        _bigEndian \u003d true;\r\n    } else if ((quad \u0026 0x00FFFFFF) \u003d\u003d 0) {\r\n        // 0x??000000 -\u003e UTF32-LE\r\n        _bigEndian \u003d false;\r\n    } else if ((quad \u0026 ~0x00FF0000) \u003d\u003d 0) {\r\n        // 0x00??0000 -\u003e UTF32-in-order\r\n        reportWeirdUCS4(\"3412\");\r\n    } else if ((quad \u0026 ~0x0000FF00) \u003d\u003d 0) {\r\n        // 0x0000??00 -\u003e UTF32-in-order\r\n        reportWeirdUCS4(\"2143\");\r\n    } else {\r\n        // Cannot be valid UTF-32 encoded JSON...\r\n        return false;\r\n    }\r\n    // Not BOM (just regular content), nothing to skip past:\r\n    //_inputPtr +\u003d 4;\r\n    _bytesPerChar \u003d 4;\r\n    return true;\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#checkUTF16(...1)",
        "body": "{\r\n    if ((i16 \u0026 0xFF00) \u003d\u003d 0) {\r\n        // UTF-16BE\r\n        _bigEndian \u003d true;\r\n    } else if ((i16 \u0026 0x00FF) \u003d\u003d 0) {\r\n        // UTF-16LE\r\n        _bigEndian \u003d false;\r\n    } else {\r\n        // nope, not  UTF-16\r\n        return false;\r\n    }\r\n    // Not BOM (just regular content), nothing to skip past:\r\n    //_inputPtr +\u003d 2;\r\n    _bytesPerChar \u003d 2;\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper",
    "methodName": "skipUTF8BOM",
    "signature": "int skipUTF8BOM(java.io.DataInput)",
    "visibility": "public",
    "body": "{\r\n    int b \u003d input.readUnsignedByte();\r\n    if (b !\u003d 0xEF) {\r\n        return b;\r\n    }\r\n    // since this is not legal byte in JSON otherwise, except\r\n    // that we do get BOM; if not, report error\r\n    b \u003d input.readUnsignedByte();\r\n    if (b !\u003d 0xBB) {\r\n        throw new IOException(\"Unexpected byte 0x\" + Integer.toHexString(b) + \" following 0xEF; should get 0xBB as part of UTF-8 BOM\");\r\n    }\r\n    b \u003d input.readUnsignedByte();\r\n    if (b !\u003d 0xBF) {\r\n        throw new IOException(\"Unexpected byte 0x\" + Integer.toHexString(b) + \" following 0xEF 0xBB; should get 0xBF as part of UTF-8 BOM\");\r\n    }\r\n    return input.readUnsignedByte();\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003d\u003d 239) → B1 | else → B2",
      "B2 : If(i2 \u003d\u003d 187) → B3 | else → B4",
      "B4 : If(i3 \u003d\u003d 191) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DataInput\n  i1 \u003d r0.readUnsignedByte()\n  if (i1 \u003d\u003d 239) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i2 \u003d r0.readUnsignedByte()\n  if (i2 \u003d\u003d 187) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d IOException\n  $r5 \u003d Integer.toHexString(i2)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IOException($r6)\n  throw $r4\n}",
      "B4 {\n  i3 \u003d r0.readUnsignedByte()\n  if (i3 \u003d\u003d 191) goto B5 else B6\n}",
      "B5 {\n  $r1 \u003d IOException\n  $r2 \u003d Integer.toHexString(i3)\n  $r3 \u003d dynInvoke makeConcatWithConstants($r2)\n  new IOException($r3)\n  throw $r1\n}",
      "B6 {\n  $i0 \u003d r0.readUnsignedByte()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper",
    "methodName": "constructReader",
    "signature": "java.io.Reader constructReader()",
    "visibility": "public",
    "body": "{\r\n    JsonEncoding enc \u003d _context.getEncoding();\r\n    switch(enc.bits()) {\r\n        // only in non-common case where we don\u0027t want to do direct mapping\r\n        case 8:\r\n        case 16:\r\n            {\r\n                // First: do we have a Stream? If not, need to create one:\r\n                InputStream in \u003d _in;\r\n                if (in \u003d\u003d null) {\r\n                    int length \u003d _inputEnd - _inputPtr;\r\n                    if (length \u003c\u003d STRING_READER_BYTE_ARRAY_LENGTH_LIMIT) {\r\n                        // [jackson-core#1081] Avoid overhead of heap ByteBuffer allocated by InputStreamReader\r\n                        // when processing small inputs up to 8KiB.\r\n                        return new StringReader(new String(_inputBuffer, _inputPtr, length, enc.getJavaName()));\r\n                    }\r\n                    in \u003d new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd);\r\n                } else {\r\n                    // Also, if we have any read but unused input (usually true),\r\n                    // need to merge that input in:\r\n                    if (_inputPtr \u003c _inputEnd) {\r\n                        in \u003d new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd);\r\n                    }\r\n                }\r\n                return new InputStreamReader(in, enc.getJavaName());\r\n            }\r\n        case 32:\r\n            return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian());\r\n    }\r\n    return VersionUtil.throwInternalReturnAny();\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If(switch-on $i0) → B1 | else → B8",
      "B1 : If(r20 !\u003d null) → B2 | else → B5",
      "B2 : If(i9 \u003e 8192) → B3 | else → B4",
      "B5 : If($i4 \u003e\u003d $i3) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  ByteSourceJsonBootstrapper\n  $r1 \u003d IOContext _context\u003e\n  r2 \u003d $r1.getEncoding()\n  $i0 \u003d r2.bits()\n  Object throwInternalReturnAny()\u003e(); }\n}",
      "B1 {\n  r20 \u003d InputStream _in\u003e\n  if (r20 !\u003d null) goto B2 else B5\n}",
      "B2 {\n  $i8 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  $i7 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  i9 \u003d $i8 - $i7\n  if (i9 \u003e 8192) goto B3 else B4\n}",
      "B3 {\n  $r14 \u003d StringReader\n  $r15 \u003d String\n  $r16 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i12 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $r17 \u003d r2.getJavaName()\n  new String($r16, $i12, i9, $r17)\n  new StringReader($r15)\n  return\n}",
      "B4 {\n  $r12 \u003d ByteArrayInputStream\n  $r13 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i11 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i10 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  new ByteArrayInputStream($r13, $i11, $i10)\n  r20 \u003d $r12\n  goto B7\n}",
      "B5 {\n  $i4 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i3 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  if ($i4 \u003e\u003d $i3) goto B6 else B7\n}",
      "B6 {\n  $r9 \u003d MergedStream\n  $r11 \u003d IOContext _context\u003e\n  $r10 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i6 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i5 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  new MergedStream($r11, r20, $r10, $i6, $i5)\n  r20 \u003d $r9\n}",
      "B7 {\n  $r21 \u003d InputStreamReader\n  $r22 \u003d r2.getJavaName()\n  new InputStreamReader(r20, $r22)\n  return\n}",
      "B8 {\n  $r3 \u003d UTF32Reader\n  $r5 \u003d IOContext _context\u003e\n  $r6 \u003d InputStream _in\u003e\n  $r7 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i1 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i2 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  $r4 \u003d IOContext _context\u003e\n  $r8 \u003d $r4.getEncoding()\n  $z0 \u003d $r8.isBigEndian()\n  new UTF32Reader($r5, $r6, $r7, $i1, $i2, $z0)\n  return\n}",
      "B9 {\n  $r18 \u003d VersionUtil.throwInternalReturnAny()\n  $r19 \u003d Reader) $r18\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B0 --\u003e B9",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper",
    "methodName": "constructParser",
    "signature": "com.fasterxml.jackson.core.JsonParser constructParser(int,com.fasterxml.jackson.core.ObjectCodec,com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer,com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer,int)",
    "visibility": "public",
    "body": "{\r\n    int prevInputPtr \u003d _inputPtr;\r\n    JsonEncoding enc \u003d JsonFactory.Feature.CHARSET_DETECTION.enabledIn(factoryFeatures) ? detectEncoding() : JsonEncoding.UTF8;\r\n    int bytesProcessed \u003d _inputPtr - prevInputPtr;\r\n    if (enc \u003d\u003d JsonEncoding.UTF8) {\r\n        // and without canonicalization, byte-based approach is not performant; just use std UTF-8 reader\r\n        // (which is ok for larger input; not so hot for smaller; but this is not a common case)\r\n        if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\r\n            ByteQuadsCanonicalizer can \u003d rootByteSymbols.makeChild(factoryFeatures);\r\n            return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, bytesProcessed, _bufferRecyclable);\r\n        }\r\n    }\r\n    return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec, rootCharSymbols.makeChild());\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($r16 !\u003d $r2) → B4 | else → B6",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ByteSourceJsonBootstrapper\n  i3 :\u003d @parameter0: int\n  ObjectCodec\n  ByteQuadsCanonicalizer\n  CharsToNameCanonicalizer\n  i1 :\u003d @parameter4: int\n  i0 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $r1 \u003d JsonFactory$Feature CHARSET_DETECTION\u003e\n  $z0 \u003d $r1.enabledIn(i1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r16 \u003d r0.detectEncoding()\n  goto B3\n}",
      "B2 {\n  $r16 \u003d JsonEncoding UTF8\u003e\n}",
      "B3 {\n  $i2 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i6 \u003d $i2 - i0\n  $r2 \u003d JsonEncoding UTF8\u003e\n  if ($r16 !\u003d $r2) goto B4 else B6\n}",
      "B4 {\n  $r9 \u003d JsonFactory$Feature CANONICALIZE_FIELD_NAMES\u003e\n  $z1 \u003d $r9.enabledIn(i1)\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r11 \u003d r10.makeChild(i1)\n  $r12 \u003d UTF8StreamJsonParser\n  $r15 \u003d IOContext _context\u003e\n  $r14 \u003d InputStream _in\u003e\n  $r13 \u003d ByteSourceJsonBootstrapper: byte[] _inputBuffer\u003e\n  $i5 \u003d ByteSourceJsonBootstrapper: int _inputPtr\u003e\n  $i4 \u003d ByteSourceJsonBootstrapper: int _inputEnd\u003e\n  $z2 \u003d ByteSourceJsonBootstrapper: boolean _bufferRecyclable\u003e\n  new UTF8StreamJsonParser($r15, i3, $r14, r5, r11, $r13, $i5, $i4, $i6, $z2)\n  return\n}",
      "B6 {\n  $r3 \u003d ReaderBasedJsonParser\n  $r4 \u003d IOContext _context\u003e\n  $r8 \u003d r0.constructReader()\n  $r7 \u003d r6.makeChild()\n  new ReaderBasedJsonParser($r4, i3, $r8, r5, $r7)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteSourceJsonBootstrapper#detectEncoding(...0)",
        "body": "{\r\n    boolean foundEncoding \u003d false;\r\n    // First things first: BOM handling\r\n    /* Note: we can require 4 bytes to be read, since no\r\n         * combination of BOM + valid JSON content can have\r\n         * shorter length (shortest valid JSON content is single\r\n         * digit char, but BOMs are chosen such that combination\r\n         * is always at least 4 chars long)\r\n         */\r\n    if (ensureLoaded(4)) {\r\n        int quad \u003d (_inputBuffer[_inputPtr] \u003c\u003c 24) | ((_inputBuffer[_inputPtr + 1] \u0026 0xFF) \u003c\u003c 16) | ((_inputBuffer[_inputPtr + 2] \u0026 0xFF) \u003c\u003c 8) | (_inputBuffer[_inputPtr + 3] \u0026 0xFF);\r\n        if (handleBOM(quad)) {\r\n            foundEncoding \u003d true;\r\n        } else {\r\n            /* If no BOM, need to auto-detect based on first char;\r\n                 * this works since it must be 7-bit ascii (wrt. unicode\r\n                 * compatible encodings, only ones JSON can be transferred\r\n                 * over)\r\n                 */\r\n            // UTF-32?\r\n            if (checkUTF32(quad)) {\r\n                foundEncoding \u003d true;\r\n            } else if (checkUTF16(quad \u003e\u003e\u003e 16)) {\r\n                foundEncoding \u003d true;\r\n            }\r\n        }\r\n    } else if (ensureLoaded(2)) {\r\n        int i16 \u003d ((_inputBuffer[_inputPtr] \u0026 0xFF) \u003c\u003c 8) | (_inputBuffer[_inputPtr + 1] \u0026 0xFF);\r\n        if (checkUTF16(i16)) {\r\n            foundEncoding \u003d true;\r\n        }\r\n    }\r\n    JsonEncoding enc;\r\n    /* Not found yet? As per specs, this means it must be UTF-8. */\r\n    if (!foundEncoding) {\r\n        enc \u003d JsonEncoding.UTF8;\r\n    } else {\r\n        switch(_bytesPerChar) {\r\n            case 1:\r\n                enc \u003d JsonEncoding.UTF8;\r\n                break;\r\n            case 2:\r\n                enc \u003d _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\r\n                break;\r\n            case 4:\r\n                enc \u003d _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\r\n                break;\r\n            default:\r\n                return VersionUtil.throwInternalReturnAny();\r\n        }\r\n    }\r\n    _context.setEncoding(enc);\r\n    return enc;\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#constructReader(...0)",
        "body": "{\r\n    JsonEncoding enc \u003d _context.getEncoding();\r\n    switch(enc.bits()) {\r\n        // only in non-common case where we don\u0027t want to do direct mapping\r\n        case 8:\r\n        case 16:\r\n            {\r\n                // First: do we have a Stream? If not, need to create one:\r\n                InputStream in \u003d _in;\r\n                if (in \u003d\u003d null) {\r\n                    int length \u003d _inputEnd - _inputPtr;\r\n                    if (length \u003c\u003d STRING_READER_BYTE_ARRAY_LENGTH_LIMIT) {\r\n                        // [jackson-core#1081] Avoid overhead of heap ByteBuffer allocated by InputStreamReader\r\n                        // when processing small inputs up to 8KiB.\r\n                        return new StringReader(new String(_inputBuffer, _inputPtr, length, enc.getJavaName()));\r\n                    }\r\n                    in \u003d new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd);\r\n                } else {\r\n                    // Also, if we have any read but unused input (usually true),\r\n                    // need to merge that input in:\r\n                    if (_inputPtr \u003c _inputEnd) {\r\n                        in \u003d new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd);\r\n                    }\r\n                }\r\n                return new InputStreamReader(in, enc.getJavaName());\r\n            }\r\n        case 32:\r\n            return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd, _context.getEncoding().isBigEndian());\r\n    }\r\n    return VersionUtil.throwInternalReturnAny();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper",
    "methodName": "hasJSONFormat",
    "signature": "com.fasterxml.jackson.core.format.MatchStrength hasJSONFormat(com.fasterxml.jackson.core.format.InputAccessor)",
    "visibility": "public",
    "body": "{\r\n    // Ideally we should see \"[\" or \"{\"; but if not, we\u0027ll accept double-quote (String)\r\n    // in future could also consider accepting non-standard matches?\r\n    if (!acc.hasMoreBytes()) {\r\n        return MatchStrength.INCONCLUSIVE;\r\n    }\r\n    byte b \u003d acc.nextByte();\r\n    // Very first thing, a UTF-8 BOM?\r\n    if (b \u003d\u003d UTF8_BOM_1) {\r\n        // yes, looks like UTF-8 BOM\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d UTF8_BOM_2) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d UTF8_BOM_3) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        b \u003d acc.nextByte();\r\n    }\r\n    // Then possible leading space\r\n    int ch \u003d skipSpace(acc, b);\r\n    if (ch \u003c 0) {\r\n        return MatchStrength.INCONCLUSIVE;\r\n    }\r\n    // First, let\u0027s see if it looks like a structured type:\r\n    if (ch \u003d\u003d \u0027{\u0027) {\r\n        // JSON object?\r\n        // Ideally we need to find either double-quote or closing bracket\r\n        ch \u003d skipSpace(acc);\r\n        if (ch \u003c 0) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (ch \u003d\u003d \u0027\"\u0027 || ch \u003d\u003d \u0027}\u0027) {\r\n            return MatchStrength.SOLID_MATCH;\r\n        }\r\n        // ... should we allow non-standard? Let\u0027s not yet... can add if need be\r\n        return MatchStrength.NO_MATCH;\r\n    }\r\n    MatchStrength strength;\r\n    if (ch \u003d\u003d \u0027[\u0027) {\r\n        ch \u003d skipSpace(acc);\r\n        if (ch \u003c 0) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        // closing brackets is easy; but for now, let\u0027s also accept opening...\r\n        if (ch \u003d\u003d \u0027]\u0027 || ch \u003d\u003d \u0027[\u0027) {\r\n            return MatchStrength.SOLID_MATCH;\r\n        }\r\n        return MatchStrength.SOLID_MATCH;\r\n    } else {\r\n        // plain old value is not very convincing...\r\n        strength \u003d MatchStrength.WEAK_MATCH;\r\n    }\r\n    if (ch \u003d\u003d \u0027\"\u0027) {\r\n        // string value\r\n        return strength;\r\n    }\r\n    if (ch \u003c\u003d \u00279\u0027 \u0026\u0026 ch \u003e\u003d \u00270\u0027) {\r\n        // number\r\n        return strength;\r\n    }\r\n    if (ch \u003d\u003d \u0027-\u0027) {\r\n        // negative number\r\n        ch \u003d skipSpace(acc);\r\n        if (ch \u003c 0) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        return (ch \u003c\u003d \u00279\u0027 \u0026\u0026 ch \u003e\u003d \u00270\u0027) ? strength : MatchStrength.NO_MATCH;\r\n    }\r\n    // or one of literals\r\n    if (ch \u003d\u003d \u0027n\u0027) {\r\n        // null\r\n        return tryMatch(acc, \"ull\", strength);\r\n    }\r\n    if (ch \u003d\u003d \u0027t\u0027) {\r\n        // true\r\n        return tryMatch(acc, \"rue\", strength);\r\n    }\r\n    if (ch \u003d\u003d \u0027f\u0027) {\r\n        // false\r\n        return tryMatch(acc, \"alse\", strength);\r\n    }\r\n    return MatchStrength.NO_MATCH;\r\n}",
    "nodes": 50,
    "edges": 55,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($i7 !\u003d $i9) → B3 | else → B14",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B5 : If($i10 \u003d\u003d $i12) → B6 | else → B7",
      "B7 : If($z2 !\u003d 0) → B8 | else → B9",
      "B9 : If($i13 \u003d\u003d $i15) → B10 | else → B11",
      "B11 : If($z3 !\u003d 0) → B12 | else → B13",
      "B14 : If($i2 \u003e\u003d 0) → B15 | else → B16",
      "B16 : If($i2 !\u003d 123) → B17 | else → B23",
      "B17 : If(i4 \u003e\u003d 0) → B18 | else → B19",
      "B19 : If(i4 \u003d\u003d 34) → B20 | else → B21",
      "B20 : If(i4 !\u003d 125) → B21 | else → B22",
      "B23 : If($i2 !\u003d 91) → B24 | else → B30",
      "B24 : If(i5 \u003e\u003d 0) → B25 | else → B26",
      "B26 : If(i5 \u003d\u003d 93) → B27 | else → B28",
      "B27 : If(i5 !\u003d 91) → B28 | else → B29",
      "B30 : If($i2 !\u003d 34) → B31 | else → B32",
      "B32 : If($i2 \u003e 57) → B33 | else → B35",
      "B33 : If($i2 \u003c 48) → B34 | else → B35",
      "B35 : If($i2 !\u003d 45) → B36 | else → B43",
      "B36 : If(i6 \u003e\u003d 0) → B37 | else → B38",
      "B38 : If(i6 \u003e 57) → B39 | else → B41",
      "B39 : If(i6 \u003c 48) → B40 | else → B41",
      "B43 : If($i2 !\u003d 110) → B44 | else → B45",
      "B45 : If($i2 !\u003d 116) → B46 | else → B47",
      "B47 : If($i2 !\u003d 102) → B48 | else → B49"
    ],
    "blockList": [
      "B0 {\n  InputAccessor\n  $z0 \u003d r0.hasMoreBytes()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r19 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B2 {\n  b3 \u003d r0.nextByte()\n  $i7 \u003d (int) b3\n  $i9 \u003d (int) -17\n  if ($i7 !\u003d $i9) goto B3 else B14\n}",
      "B3 {\n  $z1 \u003d r0.hasMoreBytes()\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r18 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B5 {\n  $b0 \u003d r0.nextByte()\n  $i10 \u003d (int) $b0\n  $i12 \u003d (int) -69\n  if ($i10 \u003d\u003d $i12) goto B6 else B7\n}",
      "B6 {\n  $r17 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B7 {\n  $z2 \u003d r0.hasMoreBytes()\n  if ($z2 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $r16 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B9 {\n  $b1 \u003d r0.nextByte()\n  $i13 \u003d (int) $b1\n  $i15 \u003d (int) -65\n  if ($i13 \u003d\u003d $i15) goto B10 else B11\n}",
      "B10 {\n  $r15 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B11 {\n  $z3 \u003d r0.hasMoreBytes()\n  if ($z3 !\u003d 0) goto B12 else B13\n}",
      "B12 {\n  $r14 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B13 {\n  b3 \u003d r0.nextByte()\n}",
      "B14 {\n  $i2 \u003d ByteSourceJsonBootstrapper.skipSpace(r0, b3)\n  if ($i2 \u003e\u003d 0) goto B15 else B16\n}",
      "B15 {\n  $r13 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B16 {\n  if ($i2 !\u003d 123) goto B17 else B23\n}",
      "B17 {\n  i4 \u003d ByteSourceJsonBootstrapper.skipSpace(r0)\n  if (i4 \u003e\u003d 0) goto B18 else B19\n}",
      "B18 {\n  $r12 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B19 {\n  if (i4 \u003d\u003d 34) goto B20 else B21\n}",
      "B20 {\n  if (i4 !\u003d 125) goto B21 else B22\n}",
      "B21 {\n  $r10 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B22 {\n  $r11 \u003d MatchStrength NO_MATCH\u003e\n  return\n}",
      "B23 {\n  if ($i2 !\u003d 91) goto B24 else B30\n}",
      "B24 {\n  i5 \u003d ByteSourceJsonBootstrapper.skipSpace(r0)\n  if (i5 \u003e\u003d 0) goto B25 else B26\n}",
      "B25 {\n  $r9 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B26 {\n  if (i5 \u003d\u003d 93) goto B27 else B28\n}",
      "B27 {\n  if (i5 !\u003d 91) goto B28 else B29\n}",
      "B28 {\n  $r7 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B29 {\n  $r8 \u003d MatchStrength SOLID_MATCH\u003e\n  return\n}",
      "B30 {\n  r1 \u003d MatchStrength WEAK_MATCH\u003e\n  if ($i2 !\u003d 34) goto B31 else B32\n}",
      "B31 {\n  return\n}",
      "B32 {\n  if ($i2 \u003e 57) goto B33 else B35\n}",
      "B33 {\n  if ($i2 \u003c 48) goto B34 else B35\n}",
      "B34 {\n  return\n}",
      "B35 {\n  if ($i2 !\u003d 45) goto B36 else B43\n}",
      "B36 {\n  i6 \u003d ByteSourceJsonBootstrapper.skipSpace(r0)\n  if (i6 \u003e\u003d 0) goto B37 else B38\n}",
      "B37 {\n  $r6 \u003d MatchStrength INCONCLUSIVE\u003e\n  return\n}",
      "B38 {\n  if (i6 \u003e 57) goto B39 else B41\n}",
      "B39 {\n  if (i6 \u003c 48) goto B40 else B41\n}",
      "B40 {\n  $r20 \u003d r1\n  goto B42\n}",
      "B41 {\n  $r20 \u003d MatchStrength NO_MATCH\u003e\n}",
      "B42 {\n  return\n}",
      "B43 {\n  if ($i2 !\u003d 110) goto B44 else B45\n}",
      "B44 {\n  $r5 \u003d ByteSourceJsonBootstrapper.tryMatch(r0, \"ull\", r1)\n  return\n}",
      "B45 {\n  if ($i2 !\u003d 116) goto B46 else B47\n}",
      "B46 {\n  $r4 \u003d ByteSourceJsonBootstrapper.tryMatch(r0, \"rue\", r1)\n  return\n}",
      "B47 {\n  if ($i2 !\u003d 102) goto B48 else B49\n}",
      "B48 {\n  $r3 \u003d ByteSourceJsonBootstrapper.tryMatch(r0, \"alse\", r1)\n  return\n}",
      "B49 {\n  $r2 \u003d MatchStrength NO_MATCH\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B14",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B23",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B30",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e [EXIT]",
      "B26 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e [EXIT]",
      "B29 --\u003e [EXIT]",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e [EXIT]",
      "B32 --\u003e B33",
      "B32 --\u003e B35",
      "B33 --\u003e B34",
      "B33 --\u003e B35",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e B36",
      "B35 --\u003e B43",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e B39",
      "B38 --\u003e B41",
      "B39 --\u003e B40",
      "B39 --\u003e B41",
      "B40 --\u003e B42",
      "B41 --\u003e B42",
      "B42 --\u003e [EXIT]",
      "B43 --\u003e B44",
      "B43 --\u003e B45",
      "B44 --\u003e [EXIT]",
      "B45 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e [EXIT]",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e [EXIT]",
      "B49 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteSourceJsonBootstrapper#tryMatch(...3)",
        "body": "{\r\n    for (int i \u003d 0, len \u003d matchStr.length(); i \u003c len; ++i) {\r\n        if (!acc.hasMoreBytes()) {\r\n            return MatchStrength.INCONCLUSIVE;\r\n        }\r\n        if (acc.nextByte() !\u003d matchStr.charAt(i)) {\r\n            return MatchStrength.NO_MATCH;\r\n        }\r\n    }\r\n    return fullMatchStrength;\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#skipSpace(...2)",
        "body": "{\r\n    while (true) {\r\n        int ch \u003d b \u0026 0xFF;\r\n        if (!(ch \u003d\u003d \u0027 \u0027 || ch \u003d\u003d \u0027\\r\u0027 || ch \u003d\u003d \u0027\\n\u0027 || ch \u003d\u003d \u0027\\t\u0027)) {\r\n            return ch;\r\n        }\r\n        if (!acc.hasMoreBytes()) {\r\n            return -1;\r\n        }\r\n        b \u003d acc.nextByte();\r\n    }\r\n}"
      },
      {
        "name": "ByteSourceJsonBootstrapper#skipSpace(...1)",
        "body": "{\r\n    if (!acc.hasMoreBytes()) {\r\n        return -1;\r\n    }\r\n    return skipSpace(acc, acc.nextByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.DupDetector",
    "methodName": "findLocation",
    "signature": "com.fasterxml.jackson.core.JsonLocation findLocation()",
    "visibility": "public",
    "body": "{\r\n    // ugly but:\r\n    if (_source instanceof JsonParser) {\r\n        return ((JsonParser) _source).currentLocation();\r\n    }\r\n    // do generators have a way to provide Location? Apparently not...\r\n    return null;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DupDetector\n  $r1 \u003d Object _source\u003e\n  $z0 \u003d JsonParser\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Object _source\u003e\n  $r3 \u003d JsonParser) $r2\n  $r4 \u003d $r3.currentLocation()\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.DupDetector",
    "methodName": "isDup",
    "signature": "boolean isDup(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_firstName \u003d\u003d null) {\r\n        _firstName \u003d name;\r\n        return false;\r\n    }\r\n    if (name.equals(_firstName)) {\r\n        return true;\r\n    }\r\n    if (_secondName \u003d\u003d null) {\r\n        _secondName \u003d name;\r\n        return false;\r\n    }\r\n    if (name.equals(_secondName)) {\r\n        return true;\r\n    }\r\n    if (_seen \u003d\u003d null) {\r\n        // 16 is default, seems reasonable\r\n        _seen \u003d new HashSet\u003c\u003e(16);\r\n        _seen.add(_firstName);\r\n        _seen.add(_secondName);\r\n    }\r\n    return !_seen.add(name);\r\n}",
    "nodes": 14,
    "edges": 15,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($r4 !\u003d null) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($r6 !\u003d null) → B9 | else → B10",
      "B10 : If($z2 !\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  DupDetector\n  String\n  $r1 \u003d String _firstName\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  String _firstName\u003e \u003d r2\n  return\n}",
      "B2 {\n  $r3 \u003d String _firstName\u003e\n  $z0 \u003d r2.equals($r3)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r4 \u003d String _secondName\u003e\n  if ($r4 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  String _secondName\u003e \u003d r2\n  return\n}",
      "B6 {\n  $r5 \u003d String _secondName\u003e\n  $z1 \u003d r2.equals($r5)\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r6 \u003d HashSet _seen\u003e\n  if ($r6 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r8 \u003d HashSet\n  new HashSet(16)\n  HashSet _seen\u003e \u003d $r8\n  $r10 \u003d HashSet _seen\u003e\n  $r9 \u003d String _firstName\u003e\n  $r10.add($r9)\n  $r12 \u003d HashSet _seen\u003e\n  $r11 \u003d String _secondName\u003e\n  $r12.add($r11)\n}",
      "B10 {\n  $r7 \u003d HashSet _seen\u003e\n  $z2 \u003d $r7.add(r2)\n  if ($z2 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $z3 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z3 \u003d 0\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "reset",
    "signature": "void reset(int,int,int)",
    "visibility": "public",
    "body": "{\r\n    _type \u003d type;\r\n    _index \u003d -1;\r\n    _lineNr \u003d lineNr;\r\n    _columnNr \u003d colNr;\r\n    _currentName \u003d null;\r\n    _currentValue \u003d null;\r\n    if (_dups !\u003d null) {\r\n        _dups.reset();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  JsonReadContext: int _type\u003e \u003d i0\n  $i4 \u003d (int) -1\n  JsonReadContext: int _index\u003e \u003d $i4\n  JsonReadContext: int _lineNr\u003e \u003d i1\n  JsonReadContext: int _columnNr\u003e \u003d i2\n  String _currentName\u003e \u003d null\n  Object _currentValue\u003e \u003d null\n  $r1 \u003d DupDetector _dups\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d DupDetector _dups\u003e\n  $r2.reset()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "createChildArrayContext",
    "signature": "com.fasterxml.jackson.core.json.JsonReadContext createChildArrayContext(int,int)",
    "visibility": "public",
    "body": "{\r\n    JsonReadContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonReadContext(this, _nestingDepth + 1, (_dups \u003d\u003d null) ? null : _dups.child(), TYPE_ARRAY, lineNr, colNr);\r\n    } else {\r\n        ctxt.reset(TYPE_ARRAY, lineNr, colNr);\r\n    }\r\n    return ctxt;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B5",
      "B1 : If($r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  r4 \u003d JsonReadContext _child\u003e\n  if (r4 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r1 \u003d JsonReadContext\n  $i2 \u003d JsonReadContext: int _nestingDepth\u003e\n  $i3 \u003d $i2 + 1\n  $r2 \u003d DupDetector _dups\u003e\n  if ($r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d null\n  goto B4\n}",
      "B3 {\n  $r3 \u003d DupDetector _dups\u003e\n  $r5 \u003d $r3.child()\n}",
      "B4 {\n  new JsonReadContext(r0, $i3, $r5, 1, i0, i1)\n  r4 \u003d $r1\n  JsonReadContext _child\u003e \u003d $r1\n  goto B6\n}",
      "B5 {\n  r4.reset(1, i0, i1)\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "createChildObjectContext",
    "signature": "com.fasterxml.jackson.core.json.JsonReadContext createChildObjectContext(int,int)",
    "visibility": "public",
    "body": "{\r\n    JsonReadContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonReadContext(this, _nestingDepth + 1, (_dups \u003d\u003d null) ? null : _dups.child(), TYPE_OBJECT, lineNr, colNr);\r\n        return ctxt;\r\n    }\r\n    ctxt.reset(TYPE_OBJECT, lineNr, colNr);\r\n    return ctxt;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r4 !\u003d null) → B1 | else → B5",
      "B1 : If($r2 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  r4 \u003d JsonReadContext _child\u003e\n  if (r4 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r1 \u003d JsonReadContext\n  $i2 \u003d JsonReadContext: int _nestingDepth\u003e\n  $i3 \u003d $i2 + 1\n  $r2 \u003d DupDetector _dups\u003e\n  if ($r2 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d null\n  goto B4\n}",
      "B3 {\n  $r3 \u003d DupDetector _dups\u003e\n  $r5 \u003d $r3.child()\n}",
      "B4 {\n  new JsonReadContext(r0, $i3, $r5, 2, i0, i1)\n  JsonReadContext _child\u003e \u003d $r1\n  return\n}",
      "B5 {\n  r4.reset(2, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "hasCurrentName",
    "signature": "boolean hasCurrentName()",
    "visibility": "public",
    "body": "{\r\n    return _currentName !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  $r1 \u003d String _currentName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "expectComma",
    "signature": "boolean expectComma()",
    "visibility": "public",
    "body": "{\r\n    /* Assumption here is that we will be getting a value (at least\r\n         * before calling this method again), and\r\n         * so will auto-increment index to avoid having to do another call\r\n         */\r\n    // starts from -1\r\n    int ix \u003d ++_index;\r\n    return (_type !\u003d TYPE_ROOT \u0026\u0026 ix \u003e 0);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($i1 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  $i0 \u003d JsonReadContext: int _index\u003e\n  $i1 \u003d $i0 + 1\n  JsonReadContext: int _index\u003e \u003d $i1\n  $i2 \u003d JsonReadContext: int _type\u003e\n  if ($i2 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  if ($i1 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadContext",
    "methodName": "setCurrentName",
    "signature": "void setCurrentName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _currentName \u003d name;\r\n    if (_dups !\u003d null) {\r\n        _checkDup(_dups, name);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonReadContext\n  String\n  String _currentName\u003e \u003d r1\n  $r2 \u003d DupDetector _dups\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DupDetector _dups\u003e\n  r0._checkDup($r3, r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReadContext#_checkDup(...2)",
        "body": "{\r\n    if (dd.isDup(name)) {\r\n        Object src \u003d dd.getSource();\r\n        throw new JsonParseException(((src instanceof JsonParser) ? ((JsonParser) src) : null), \"Duplicate field \u0027\" + name + \"\u0027\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadFeature",
    "methodName": "collectDefaults",
    "signature": "int collectDefaults()",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  i2 \u003d 0\n  r0 \u003d JsonReadFeature.values()\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r1 \u003d r0[i3]\n  $z0 \u003d r1.enabledByDefault()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i1 \u003d r1.getMask()\n  i2 \u003d i2 | $i1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonReadFeature",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonReadFeature\n  i0 :\u003d @parameter0: int\n  $i1 \u003d JsonReadFeature: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "reset",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext reset(int)",
    "visibility": "public",
    "body": "{\r\n    _type \u003d type;\r\n    _index \u003d -1;\r\n    _currentName \u003d null;\r\n    _gotName \u003d false;\r\n    _currentValue \u003d null;\r\n    if (_dups !\u003d null) {\r\n        _dups.reset();\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  i0 :\u003d @parameter0: int\n  JsonWriteContext: int _type\u003e \u003d i0\n  $i2 \u003d (int) -1\n  JsonWriteContext: int _index\u003e \u003d $i2\n  String _currentName\u003e \u003d null\n  JsonWriteContext: boolean _gotName\u003e \u003d 0\n  Object _currentValue\u003e \u003d null\n  $r1 \u003d DupDetector _dups\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d DupDetector _dups\u003e\n  $r2.reset()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "reset",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext reset(int,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _type \u003d type;\r\n    _index \u003d -1;\r\n    _currentName \u003d null;\r\n    _gotName \u003d false;\r\n    _currentValue \u003d currValue;\r\n    if (_dups !\u003d null) {\r\n        _dups.reset();\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  i0 :\u003d @parameter0: int\n  Object\n  JsonWriteContext: int _type\u003e \u003d i0\n  $i2 \u003d (int) -1\n  JsonWriteContext: int _index\u003e \u003d $i2\n  String _currentName\u003e \u003d null\n  JsonWriteContext: boolean _gotName\u003e \u003d 0\n  Object _currentValue\u003e \u003d r1\n  $r2 \u003d DupDetector _dups\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d DupDetector _dups\u003e\n  $r3.reset()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "createChildArrayContext",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext createChildArrayContext()",
    "visibility": "public",
    "body": "{\r\n    JsonWriteContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonWriteContext(TYPE_ARRAY, this, (_dups \u003d\u003d null) ? null : _dups.child());\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_ARRAY);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B5",
      "B1 : If($r3 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  r5 \u003d JsonWriteContext _child\u003e\n  if (r5 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d JsonWriteContext\n  $r3 \u003d DupDetector _dups\u003e\n  if ($r3 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d null\n  goto B4\n}",
      "B3 {\n  $r4 \u003d DupDetector _dups\u003e\n  $r6 \u003d $r4.child()\n}",
      "B4 {\n  new JsonWriteContext(1, r0, $r6)\n  JsonWriteContext _child\u003e \u003d $r2\n  return\n}",
      "B5 {\n  $r1 \u003d r5.reset(1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "createChildArrayContext",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext createChildArrayContext(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    JsonWriteContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonWriteContext(TYPE_ARRAY, this, (_dups \u003d\u003d null) ? null : _dups.child(), currValue);\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_ARRAY, currValue);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B5",
      "B1 : If($r4 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  Object\n  r6 \u003d JsonWriteContext _child\u003e\n  if (r6 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r3 \u003d JsonWriteContext\n  $r4 \u003d DupDetector _dups\u003e\n  if ($r4 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d null\n  goto B4\n}",
      "B3 {\n  $r5 \u003d DupDetector _dups\u003e\n  $r7 \u003d $r5.child()\n}",
      "B4 {\n  new JsonWriteContext(1, r0, $r7, r1)\n  JsonWriteContext _child\u003e \u003d $r3\n  return\n}",
      "B5 {\n  $r2 \u003d r6.reset(1, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "createChildObjectContext",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext createChildObjectContext()",
    "visibility": "public",
    "body": "{\r\n    JsonWriteContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonWriteContext(TYPE_OBJECT, this, (_dups \u003d\u003d null) ? null : _dups.child());\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_OBJECT);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B5",
      "B1 : If($r3 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  r5 \u003d JsonWriteContext _child\u003e\n  if (r5 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r2 \u003d JsonWriteContext\n  $r3 \u003d DupDetector _dups\u003e\n  if ($r3 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r6 \u003d null\n  goto B4\n}",
      "B3 {\n  $r4 \u003d DupDetector _dups\u003e\n  $r6 \u003d $r4.child()\n}",
      "B4 {\n  new JsonWriteContext(2, r0, $r6)\n  JsonWriteContext _child\u003e \u003d $r2\n  return\n}",
      "B5 {\n  $r1 \u003d r5.reset(2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "createChildObjectContext",
    "signature": "com.fasterxml.jackson.core.json.JsonWriteContext createChildObjectContext(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    JsonWriteContext ctxt \u003d _child;\r\n    if (ctxt \u003d\u003d null) {\r\n        _child \u003d ctxt \u003d new JsonWriteContext(TYPE_OBJECT, this, (_dups \u003d\u003d null) ? null : _dups.child(), currValue);\r\n        return ctxt;\r\n    }\r\n    return ctxt.reset(TYPE_OBJECT, currValue);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r6 !\u003d null) → B1 | else → B5",
      "B1 : If($r4 !\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  Object\n  r6 \u003d JsonWriteContext _child\u003e\n  if (r6 !\u003d null) goto B1 else B5\n}",
      "B1 {\n  $r3 \u003d JsonWriteContext\n  $r4 \u003d DupDetector _dups\u003e\n  if ($r4 !\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d null\n  goto B4\n}",
      "B3 {\n  $r5 \u003d DupDetector _dups\u003e\n  $r7 \u003d $r5.child()\n}",
      "B4 {\n  new JsonWriteContext(2, r0, $r7, r1)\n  JsonWriteContext _child\u003e \u003d $r3\n  return\n}",
      "B5 {\n  $r2 \u003d r6.reset(2, r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "hasCurrentName",
    "signature": "boolean hasCurrentName()",
    "visibility": "public",
    "body": "{\r\n    return _currentName !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  $r1 \u003d String _currentName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "writeFieldName",
    "signature": "int writeFieldName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if ((_type !\u003d TYPE_OBJECT) || _gotName) {\r\n        return STATUS_EXPECT_VALUE;\r\n    }\r\n    _gotName \u003d true;\r\n    _currentName \u003d name;\r\n    if (_dups !\u003d null) {\r\n        _checkDup(_dups, name);\r\n    }\r\n    return (_index \u003c 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 !\u003d 2) → B1 | else → B2",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5",
      "B5 : If($i1 \u003e\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  String\n  $i0 \u003d JsonWriteContext: int _type\u003e\n  if ($i0 !\u003d 2) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d JsonWriteContext: boolean _gotName\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  JsonWriteContext: boolean _gotName\u003e \u003d 1\n  String _currentName\u003e \u003d r1\n  $r2 \u003d DupDetector _dups\u003e\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d DupDetector _dups\u003e\n  r0._checkDup($r3, r1)\n}",
      "B5 {\n  $i1 \u003d JsonWriteContext: int _index\u003e\n  if ($i1 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $b2 \u003d 0\n  goto B8\n}",
      "B7 {\n  $b2 \u003d 1\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriteContext#_checkDup(...2)",
        "body": "{\r\n    if (dd.isDup(name)) {\r\n        Object src \u003d dd.getSource();\r\n        throw new JsonGenerationException(\"Duplicate field \u0027\" + name + \"\u0027\", ((src instanceof JsonGenerator) ? ((JsonGenerator) src) : null));\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteContext",
    "methodName": "writeValue",
    "signature": "int writeValue()",
    "visibility": "public",
    "body": "{\r\n    // Most likely, object:\r\n    if (_type \u003d\u003d TYPE_OBJECT) {\r\n        if (!_gotName) {\r\n            return STATUS_EXPECT_NAME;\r\n        }\r\n        _gotName \u003d false;\r\n        ++_index;\r\n        return STATUS_OK_AFTER_COLON;\r\n    }\r\n    // Ok, array?\r\n    if (_type \u003d\u003d TYPE_ARRAY) {\r\n        int ix \u003d _index;\r\n        ++_index;\r\n        return (ix \u003c 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\r\n    }\r\n    // Nope, root context\r\n    // No commas within root context, but need space\r\n    ++_index;\r\n    return (_index \u003d\u003d 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\r\n}",
    "nodes": 13,
    "edges": 14,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 !\u003d 2) → B1 | else → B4",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3",
      "B4 : If($i1 !\u003d 1) → B5 | else → B9",
      "B5 : If(i5 \u003e\u003d 0) → B6 | else → B7",
      "B9 : If($i4 !\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  JsonWriteContext\n  $i0 \u003d JsonWriteContext: int _type\u003e\n  if ($i0 !\u003d 2) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d JsonWriteContext: boolean _gotName\u003e\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  JsonWriteContext: boolean _gotName\u003e \u003d 0\n  $i8 \u003d JsonWriteContext: int _index\u003e\n  $i9 \u003d $i8 + 1\n  JsonWriteContext: int _index\u003e \u003d $i9\n  return\n}",
      "B4 {\n  $i1 \u003d JsonWriteContext: int _type\u003e\n  if ($i1 !\u003d 1) goto B5 else B9\n}",
      "B5 {\n  i5 \u003d JsonWriteContext: int _index\u003e\n  $i6 \u003d JsonWriteContext: int _index\u003e\n  $i7 \u003d $i6 + 1\n  JsonWriteContext: int _index\u003e \u003d $i7\n  if (i5 \u003e\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $b10 \u003d 0\n  goto B8\n}",
      "B7 {\n  $b10 \u003d 1\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $i2 \u003d JsonWriteContext: int _index\u003e\n  $i3 \u003d $i2 + 1\n  JsonWriteContext: int _index\u003e \u003d $i3\n  $i4 \u003d JsonWriteContext: int _index\u003e\n  if ($i4 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $b11 \u003d 0\n  goto B12\n}",
      "B11 {\n  $b11 \u003d 3\n}",
      "B12 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteFeature",
    "methodName": "collectDefaults",
    "signature": "int collectDefaults()",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  i2 \u003d 0\n  r0 \u003d JsonWriteFeature.values()\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r1 \u003d r0[i3]\n  $z0 \u003d r1.enabledByDefault()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i1 \u003d r1.getMask()\n  i2 \u003d i2 | $i1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.JsonWriteFeature",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriteFeature\n  i0 :\u003d @parameter0: int\n  $i1 \u003d JsonWriteFeature: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "releaseBuffered",
    "signature": "int releaseBuffered(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    int count \u003d _inputEnd - _inputPtr;\r\n    if (count \u003c 1) {\r\n        return 0;\r\n    }\r\n    // let\u0027s just advance ptr to end\r\n    int origPtr \u003d _inputPtr;\r\n    _inputPtr +\u003d count;\r\n    w.write(_inputBuffer, origPtr, count);\r\n    return count;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i2 \u003e\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  Writer\n  $i1 \u003d ReaderBasedJsonParser: int _inputEnd\u003e\n  $i0 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n  i2 \u003d $i1 - $i0\n  if (i2 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i3 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n  $i4 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n  $i5 \u003d $i4 + i2\n  ReaderBasedJsonParser: int _inputPtr\u003e \u003d $i5\n  $r2 \u003d ReaderBasedJsonParser: char[] _inputBuffer\u003e\n  r1.write($r2, i3, i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getText",
    "signature": "java.lang.String getText()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $r6 \u003d $r5.contentsAsString()\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken _currToken\u003e\n  $r4 \u003d r0._getText2($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_getText2(...1)",
        "body": "{\r\n    if (t \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(t.id()) {\r\n        case ID_FIELD_NAME:\r\n            return _parsingContext.getCurrentName();\r\n        case ID_STRING:\r\n        // fall through\r\n        case ID_NUMBER_INT:\r\n        case ID_NUMBER_FLOAT:\r\n            return _textBuffer.contentsAsString();\r\n        default:\r\n            return t.asString();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getText",
    "signature": "int getText(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsToWriter(writer);\r\n    }\r\n    if (t \u003d\u003d JsonToken.FIELD_NAME) {\r\n        String n \u003d _parsingContext.getCurrentName();\r\n        writer.write(n);\r\n        return n.length();\r\n    }\r\n    if (t !\u003d null) {\r\n        if (t.isNumeric()) {\r\n            return _textBuffer.contentsToWriter(writer);\r\n        }\r\n        char[] ch \u003d t.asCharArray();\r\n        writer.write(ch);\r\n        return ch.length;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d $r2) → B1 | else → B4",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(r1 !\u003d $r3) → B5 | else → B6",
      "B6 : If(r1 \u003d\u003d null) → B7 | else → B10",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  Writer\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_STRING\u003e\n  if (r1 !\u003d $r2) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r7.contentsToWriter(r4)\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if (r1 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d JsonReadContext _parsingContext\u003e\n  r8 \u003d $r6.getCurrentName()\n  r4.write(r8)\n  $i2 \u003d r8.length()\n  return\n}",
      "B6 {\n  if (r1 \u003d\u003d null) goto B7 else B10\n}",
      "B7 {\n  $z0 \u003d r1.isNumeric()\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r5.contentsToWriter(r4)\n  return\n}",
      "B9 {\n  r9 \u003d r1.asCharArray()\n  r4.write(r9)\n  $i0 \u003d lengthof r9\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(null);\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $r8 \u003d $r7.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r5 \u003d r0.getValueAsString(null)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#currentName(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(defValue);\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  String\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r8 \u003d TextBuffer _textBuffer\u003e\n  $r9 \u003d $r8.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r6 \u003d r0.getValueAsString(r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#currentName(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getTextCharacters",
    "signature": "char[] getTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                if (!_nameCopied) {\r\n                    String name \u003d _parsingContext.getCurrentName();\r\n                    int nameLen \u003d name.length();\r\n                    if (_nameCopyBuffer \u003d\u003d null) {\r\n                        _nameCopyBuffer \u003d _ioContext.allocNameCopyBuffer(nameLen);\r\n                    } else if (_nameCopyBuffer.length \u003c nameLen) {\r\n                        _nameCopyBuffer \u003d new char[nameLen];\r\n                    }\r\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\r\n                    _nameCopied \u003d true;\r\n                }\r\n                return _nameCopyBuffer;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextBuffer();\r\n            default:\r\n                return _currToken.asCharArray();\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B13",
      "B1 : If(switch-on $i0) → B2 | else → B9",
      "B2 : If($z1 !\u003d 0) → B3 | else → B8",
      "B3 : If($r5 !\u003d null) → B4 | else → B5",
      "B5 : If($i2 \u003e\u003d i1) → B6 | else → B7",
      "B9 : If($z0 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B13\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  JsonToken _currToken\u003e; }\n}",
      "B2 {\n  $z1 \u003d ReaderBasedJsonParser: boolean _nameCopied\u003e\n  if ($z1 !\u003d 0) goto B3 else B8\n}",
      "B3 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  r4 \u003d $r3.getCurrentName()\n  i1 \u003d r4.length()\n  $r5 \u003d ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e\n  if ($r5 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d IOContext _ioContext\u003e\n  $r9 \u003d $r8.allocNameCopyBuffer(i1)\n  ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e \u003d $r9\n  goto B7\n}",
      "B5 {\n  $r6 \u003d ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e\n  $i2 \u003d lengthof $r6\n  if ($i2 \u003e\u003d i1) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d newarray (char)[i1]\n  ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e \u003d $r7\n}",
      "B7 {\n  $r12 \u003d ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e\n  r4.getChars(0, i1, $r12, 0)\n  ReaderBasedJsonParser: boolean _nameCopied\u003e \u003d 1\n}",
      "B8 {\n  $r13 \u003d ReaderBasedJsonParser: char[] _nameCopyBuffer\u003e\n  return\n}",
      "B9 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B11 {\n  $r14 \u003d TextBuffer _textBuffer\u003e\n  $r15 \u003d $r14.getTextBuffer()\n  return\n}",
      "B12 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d $r10.asCharArray()\n  return\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B13",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B1 --\u003e B11",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getTextLength",
    "signature": "int getTextLength()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                return _parsingContext.getCurrentName().length();\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.size();\r\n            default:\r\n                return _currToken.asCharArray().length;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If(switch-on $i0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  JsonToken _currToken\u003e; }\n}",
      "B2 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $r4 \u003d $r3.getCurrentName()\n  $i1 \u003d $r4.length()\n  return\n}",
      "B3 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B5 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r7.size()\n  return\n}",
      "B6 {\n  $r5 \u003d JsonToken _currToken\u003e\n  $r6 \u003d $r5.asCharArray()\n  $i2 \u003d lengthof $r6\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B5",
      "B1 --\u003e B6",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getTextOffset",
    "signature": "int getTextOffset()",
    "visibility": "public",
    "body": "{\r\n    // Most have offset of 0, only some may have other values:\r\n    if (_currToken !\u003d null) {\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                return 0;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextOffset();\r\n            default:\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B6",
      "B1 : If(switch-on $i0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  TextBuffer _textBuffer\u003e;     default: goto return 0; }\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B5 {\n  $r3 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r3.getTextOffset()\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B5",
      "B1 --\u003e B6",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "getBinaryValue",
    "signature": "byte[] getBinaryValue(com.fasterxml.jackson.core.Base64Variant)",
    "visibility": "public",
    "body": "{\r\n    if ((_currToken \u003d\u003d JsonToken.VALUE_EMBEDDED_OBJECT) \u0026\u0026 (_binaryValue !\u003d null)) {\r\n        return _binaryValue;\r\n    }\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    // To ensure that we won\u0027t see inconsistent data, better clear up state\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        /* let\u0027s clear incomplete only now; allows for accessing other\r\n             * textual content in error cases\r\n             */\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B3",
      "B1 : If($r13 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($r4 \u003d\u003d $r3) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B9",
      "B9 : If($r5 !\u003d null) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  Base64Variant\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_EMBEDDED_OBJECT\u003e\n  if ($r2 !\u003d $r1) goto B1 else B3\n}",
      "B1 {\n  $r13 \u003d ReaderBasedJsonParser: byte[] _binaryValue\u003e\n  if ($r13 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r14 \u003d ReaderBasedJsonParser: byte[] _binaryValue\u003e\n  return\n}",
      "B3 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 \u003d\u003d $r3) goto B4 else B5\n}",
      "B4 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d String.valueOf($r10)\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportError($r12)\n}",
      "B5 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B6 else B9\n}",
      "B6 {\n  $r9 \u003d r0._decodeBase64(r6)\n  ReaderBasedJsonParser: byte[] _binaryValue\u003e \u003d $r9\n  goto B8\n}",
      "B7 {\n  $r15 :\u003d @caughtexception\n  $r17 \u003d String.valueOf(r6)\n  $r16 \u003d $r15.getMessage()\n  $r18 \u003d dynInvoke makeConcatWithConstants($r17, $r16)\n  $r19 \u003d r0._constructError($r18)\n  throw $r19\n}",
      "B8 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  goto B11\n}",
      "B9 {\n  $r5 \u003d ReaderBasedJsonParser: byte[] _binaryValue\u003e\n  if ($r5 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  r20 \u003d r0._getByteArrayBuilder()\n  $r7 \u003d r0.getText()\n  r0._decodeBase64($r7, r20, r6)\n  $r8 \u003d r20.toByteArray()\n  ReaderBasedJsonParser: byte[] _binaryValue\u003e \u003d $r8\n}",
      "B11 {\n  $r21 \u003d ReaderBasedJsonParser: byte[] _binaryValue\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_decodeBase64(...1)",
        "body": "{\r\n    ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n    //main_loop:\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        char ch;\r\n        do {\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                _loadMoreGuaranteed();\r\n            }\r\n            ch \u003d _inputBuffer[_inputPtr++];\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (ch \u003d\u003d \u0027\"\u0027) {\r\n                // reached the end, fair and square?\r\n                return builder.toByteArray();\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    builder.append(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // Ok, must get more padding chars, then\r\n                if (_inputPtr \u003e\u003d _inputEnd) {\r\n                    _loadMoreGuaranteed();\r\n                }\r\n                ch \u003d _inputBuffer[_inputPtr++];\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if (_decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                builder.append(decodedData);\r\n                continue;\r\n            }\r\n            // otherwise we got escaped other char, to be processed below\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    builder.appendTwoBytes(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // With padding we only get 2 bytes; but we have\r\n                // to shift it a bit so it is identical to triplet\r\n                // case with partial output.\r\n                // 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are\r\n                // dummies, need to discard:\r\n                decodedData \u003e\u003e\u003d 2;\r\n                builder.appendTwoBytes(decodedData);\r\n                continue;\r\n            }\r\n            // otherwise we got escaped other char, to be processed below\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        builder.appendThreeBytes(decodedData);\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_getByteArrayBuilder(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_decodeBase64(...3)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_constructError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "readBinaryValue",
    "signature": "int readBinaryValue(com.fasterxml.jackson.core.Base64Variant,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    // if we have already read the token, just use whatever we may have\r\n    if (!_tokenIncomplete || _currToken !\u003d JsonToken.VALUE_STRING) {\r\n        byte[] b \u003d getBinaryValue(b64variant);\r\n        out.write(b);\r\n        return b.length;\r\n    }\r\n    // otherwise do \"real\" incremental parsing...\r\n    byte[] buf \u003d _ioContext.allocBase64Buffer();\r\n    try {\r\n        return _readBinary(b64variant, out, buf);\r\n    } finally {\r\n        _ioContext.releaseBase64Buffer(buf);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B1 : If($r4 \u003d\u003d $r3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  Base64Variant\n  OutputStream\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 \u003d\u003d $r3) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d r0.getBinaryValue(r1)\n  r2.write($r7)\n  $i0 \u003d lengthof $r7\n  return\n}",
      "B3 {\n  $r5 \u003d IOContext _ioContext\u003e\n  r10 \u003d $r5.allocBase64Buffer()\n  i1 \u003d r0._readBinary(r1, r2, r10)\n  $r6 \u003d IOContext _ioContext\u003e\n  $r6.releaseBase64Buffer(r10)\n  return\n}",
      "B4 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d IOContext _ioContext\u003e\n  $r9.releaseBase64Buffer(r10)\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#getBinaryValue(...1)",
        "body": "{\r\n    if ((_currToken \u003d\u003d JsonToken.VALUE_EMBEDDED_OBJECT) \u0026\u0026 (_binaryValue !\u003d null)) {\r\n        return _binaryValue;\r\n    }\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    // To ensure that we won\u0027t see inconsistent data, better clear up state\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        /* let\u0027s clear incomplete only now; allows for accessing other\r\n             * textual content in error cases\r\n             */\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_readBinary(...3)",
        "body": "{\r\n    int outputPtr \u003d 0;\r\n    final int outputEnd \u003d buffer.length - 3;\r\n    int outputCount \u003d 0;\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        char ch;\r\n        do {\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                _loadMoreGuaranteed();\r\n            }\r\n            ch \u003d _inputBuffer[_inputPtr++];\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            // reached the end, fair and square?\r\n            if (ch \u003d\u003d \u0027\"\u0027) {\r\n                break;\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        // enough room? If not, flush\r\n        if (outputPtr \u003e outputEnd) {\r\n            outputCount +\u003d outputPtr;\r\n            out.write(buffer, 0, outputPtr);\r\n            outputPtr \u003d 0;\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // Ok, must get padding\r\n                if (_inputPtr \u003e\u003d _inputEnd) {\r\n                    _loadMoreGuaranteed();\r\n                }\r\n                ch \u003d _inputBuffer[_inputPtr++];\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if (_decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++];\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                /* With padding we only get 2 bytes; but we have\r\n                     * to shift it a bit so it is identical to triplet\r\n                     * case with partial output.\r\n                     * 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are\r\n                     * dummies, need to discard:\r\n                     */\r\n                decodedData \u003e\u003e\u003d 2;\r\n                buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 16);\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n        buffer[outputPtr++] \u003d (byte) decodedData;\r\n    }\r\n    _tokenIncomplete \u003d false;\r\n    if (outputPtr \u003e 0) {\r\n        outputCount +\u003d outputPtr;\r\n        out.write(buffer, 0, outputPtr);\r\n    }\r\n    return outputCount;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Should actually close/release things\r\n        // like input source, symbol table and recyclable buffers now.\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for Object contexts, since\r\n         * the intermediate \u0027expect-value\u0027 state is never retained.\r\n         */\r\n    boolean inObject \u003d _parsingContext.inObject();\r\n    if (inObject) {\r\n        // First, field name itself:\r\n        _updateNameLocation();\r\n        String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n        _parsingContext.setCurrentName(name);\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        i \u003d _skipColon();\r\n    }\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            t \u003d JsonToken.VALUE_STRING;\r\n            break;\r\n        case \u0027[\u0027:\r\n            if (!inObject) {\r\n                createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            if (!inObject) {\r\n                createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027}\u0027:\r\n            // Error: } is not valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(i, \"expected a value\");\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    if (inObject) {\r\n        _nextToken \u003d t;\r\n        return _currToken;\r\n    }\r\n    return _updateToken(t);\r\n}",
    "nodes": 39,
    "edges": 57,
    "cc": 20,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i9 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i0 !\u003d 125) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B12",
      "B9 : If($i7 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($i8 !\u003d 125) → B11 | else → B12",
      "B12 : If($z3 \u003d\u003d false) → B13 | else → B17",
      "B13 : If(i10 !\u003d 34) → B14 | else → B15",
      "B17 : If(switch-on i10) → B18 | else → B30",
      "B19 : If($z3 !\u003d 0) → B20 | else → B21",
      "B22 : If($z3 !\u003d 0) → B23 | else → B24",
      "B30 : If($z2 \u003d\u003d false) → B31 | else → B32",
      "B36 : If($z3 \u003d\u003d false) → B37 | else → B38"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d r0._nextAfterName()\n  return\n}",
      "B2 {\n  ReaderBasedJsonParser: int _numTypesValid\u003e \u003d 0\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i9 \u003d r0._skipWSOrEnd()\n  i10 \u003d $i9\n  if ($i9 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  $r12 \u003d r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  ReaderBasedJsonParser: byte[] _binaryValue\u003e \u003d null\n  $i0 \u003d $i9 | 32\n  if ($i0 !\u003d 125) goto B7 else B8\n}",
      "B7 {\n  r0._closeScope($i9)\n  $r11 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B8 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  i10 \u003d r0._skipComma($i9)\n  $i6 \u003d ReaderBasedJsonParser: int _features\u003e\n  $i5 \u003d ReaderBasedJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i7 \u003d $i6 \u0026 $i5\n  if ($i7 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $i8 \u003d i10 | 32\n  if ($i8 !\u003d 125) goto B11 else B12\n}",
      "B11 {\n  r0._closeScope(i10)\n  $r10 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B12 {\n  $r14 \u003d JsonReadContext _parsingContext\u003e\n  $z3 \u003d $r14.inObject()\n  if ($z3 \u003d\u003d false) goto B13 else B17\n}",
      "B13 {\n  r0._updateNameLocation()\n  if (i10 !\u003d 34) goto B14 else B15\n}",
      "B14 {\n  $r15 \u003d r0._parseName()\n  goto B16\n}",
      "B15 {\n  $r15 \u003d r0._handleOddName(i10)\n}",
      "B16 {\n  $r8 \u003d JsonReadContext _parsingContext\u003e\n  $r8.setCurrentName($r15)\n  $r9 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r9)\n  i10 \u003d r0._skipColon()\n}",
      "B17 {\n  r0._updateLocation()\n  JsonToken _handleOddValue(int)\u003e(i10); }\n}",
      "B18 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  r16 \u003d JsonToken VALUE_STRING\u003e\n  goto B36\n}",
      "B19 {\n  if ($z3 !\u003d 0) goto B20 else B21\n}",
      "B20 {\n  $i4 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n}",
      "B21 {\n  r16 \u003d JsonToken START_ARRAY\u003e\n  goto B36\n}",
      "B22 {\n  if ($z3 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B24 {\n  r16 \u003d JsonToken START_OBJECT\u003e\n  goto B36\n}",
      "B25 {\n  r0._reportUnexpectedChar(i10, \"expected a value\")\n}",
      "B26 {\n  r0._matchTrue()\n  r16 \u003d JsonToken VALUE_TRUE\u003e\n  goto B36\n}",
      "B27 {\n  r0._matchFalse()\n  r16 \u003d JsonToken VALUE_FALSE\u003e\n  goto B36\n}",
      "B28 {\n  r0._matchNull()\n  r16 \u003d JsonToken VALUE_NULL\u003e\n  goto B36\n}",
      "B29 {\n  r16 \u003d r0._parseSignedNumber(1)\n  goto B36\n}",
      "B30 {\n  $r6 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r7 \u003d $r6.mappedFeature()\n  $z2 \u003d r0.isEnabled($r7)\n  if ($z2 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  r16 \u003d r0._parseSignedNumber(0)\n  goto B36\n}",
      "B32 {\n  r16 \u003d r0._handleOddValue(i10)\n  goto B36\n}",
      "B33 {\n  r16 \u003d r0._parseFloatThatStartsWithPeriod(0)\n  goto B36\n}",
      "B34 {\n  r16 \u003d r0._parseUnsignedNumber(i10)\n  goto B36\n}",
      "B35 {\n  r16 \u003d r0._handleOddValue(i10)\n}",
      "B36 {\n  if ($z3 \u003d\u003d false) goto B37 else B38\n}",
      "B37 {\n  JsonToken _nextToken\u003e \u003d r16\n  $r5 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B38 {\n  $r4 \u003d r0._updateToken(r16)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B30",
      "B17 --\u003e B29",
      "B17 --\u003e B33",
      "B17 --\u003e B34",
      "B17 --\u003e B19",
      "B17 --\u003e B27",
      "B17 --\u003e B28",
      "B17 --\u003e B26",
      "B17 --\u003e B22",
      "B17 --\u003e B25",
      "B17 --\u003e B35",
      "B18 --\u003e B36",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B36",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B36",
      "B25 --\u003e B26",
      "B26 --\u003e B36",
      "B27 --\u003e B36",
      "B28 --\u003e B36",
      "B29 --\u003e B36",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B36",
      "B32 --\u003e B36",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B36 --\u003e B38",
      "B37 --\u003e [EXIT]",
      "B38 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_parseName(...0)",
        "body": "{\r\n    // First: let\u0027s try to see if we have a simple name: one that does\r\n    // not cross input buffer boundary, and does not contain escape sequences.\r\n    int ptr \u003d _inputPtr;\r\n    int hash \u003d _hashSeed;\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    while (ptr \u003c _inputEnd) {\r\n        int ch \u003d _inputBuffer[ptr];\r\n        if (ch \u003c codes.length \u0026\u0026 codes[ch] !\u003d 0) {\r\n            if (ch \u003d\u003d \u0027\"\u0027) {\r\n                final int start \u003d _inputPtr;\r\n                // to skip the quote\r\n                _inputPtr \u003d ptr + 1;\r\n                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n            }\r\n            break;\r\n        }\r\n        hash \u003d (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\r\n        ++ptr;\r\n    }\r\n    int start \u003d _inputPtr;\r\n    _inputPtr \u003d ptr;\r\n    return _parseName2(start, hash, INT_QUOTE);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_handleOddName(...1)",
        "body": "{\r\n    // [JACKSON-173]: allow single quotes\r\n    if (i \u003d\u003d \u0027\\\u0027\u0027 \u0026\u0026 (_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n        return _parseAposName();\r\n    }\r\n    // [JACKSON-69]: allow unquoted names if feature enabled:\r\n    if ((_features \u0026 FEAT_MASK_ALLOW_UNQUOTED_NAMES) \u003d\u003d 0) {\r\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\r\n    }\r\n    final int[] codes \u003d CharTypes.getInputCodeLatin1JsNames();\r\n    final int maxCode \u003d codes.length;\r\n    // Also: first char must be a valid name char, but NOT be number\r\n    boolean firstOk;\r\n    if (i \u003c maxCode) {\r\n        // identifier, or a number ([Issue#102])\r\n        firstOk \u003d (codes[i] \u003d\u003d 0);\r\n    } else {\r\n        firstOk \u003d Character.isJavaIdentifierPart((char) i);\r\n    }\r\n    if (!firstOk) {\r\n        _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\r\n    }\r\n    int ptr \u003d _inputPtr;\r\n    int hash \u003d _hashSeed;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode) {\r\n                if (codes[ch] !\u003d 0) {\r\n                    // -1 to bring back first char\r\n                    final int start \u003d _inputPtr - 1;\r\n                    _inputPtr \u003d ptr;\r\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n                }\r\n            } else if (!Character.isJavaIdentifierPart((char) ch)) {\r\n                // -1 to bring back first char\r\n                final int start \u003d _inputPtr - 1;\r\n                _inputPtr \u003d ptr;\r\n                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n            }\r\n            hash \u003d (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    int start \u003d _inputPtr - 1;\r\n    _inputPtr \u003d ptr;\r\n    return _handleOddName2(start, hash, codes);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++];\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_matchFalse(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 4) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027a\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027s\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027e\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"false\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_handleOddValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(i) {\r\n        case \u0027\\\u0027\u0027:\r\n            /* Allow single quotes? Unlike with regular Strings, we\u0027ll eagerly parse\r\n             * contents; this so that there\u0027s no need to store information on quote char used.\r\n             * Also, no separation to fast/slow parsing; we\u0027ll just do\r\n             * one regular (~\u003d slowish) parsing, to keep code simple\r\n             */\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027]\u0027:\r\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\r\n             *   we may allow \"missing values\", that is, encountering a trailing\r\n             *   comma or closing marker where value would be expected\r\n             */\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                if (!_loadMore()) {\r\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\r\n                }\r\n            }\r\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(i)) {\r\n        _reportInvalidToken(\"\" + ((char) i), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(i, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_matchTrue(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027r\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027u\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027e\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"true\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartRow \u003d _currInputRow;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_parseSignedNumber(...1)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    // 26-Jun-2022, tatu: We always have a sign; positive should be allowed as deviation\r\n    //      But unfortunately that won\u0027t yet work\r\n    // to include sign/digit already read\r\n    int startPtr \u003d negative ? ptr - 1 : ptr;\r\n    final int inputEnd \u003d _inputEnd;\r\n    if (ptr \u003e\u003d inputEnd) {\r\n        return _parseNumber2(negative, startPtr);\r\n    }\r\n    int ch \u003d _inputBuffer[ptr++];\r\n    // First check: must have a digit to follow minus sign\r\n    if (ch \u003e INT_9 || ch \u003c INT_0) {\r\n        _inputPtr \u003d ptr;\r\n        if (ch \u003d\u003d INT_PERIOD) {\r\n            return _parseFloatThatStartsWithPeriod(negative);\r\n        }\r\n        return _handleInvalidNumberStart(ch, negative, true);\r\n    }\r\n    // One special case, leading zero(es):\r\n    if (ch \u003d\u003d INT_0) {\r\n        return _parseNumber2(negative, startPtr);\r\n    }\r\n    // already got one\r\n    int intLen \u003d 1;\r\n    // First let\u0027s get the obligatory integer part:\r\n    int_loop: while (true) {\r\n        if (ptr \u003e\u003d inputEnd) {\r\n            return _parseNumber2(negative, startPtr);\r\n        }\r\n        ch \u003d _inputBuffer[ptr++];\r\n        if (ch \u003c INT_0 || ch \u003e INT_9) {\r\n            break int_loop;\r\n        }\r\n        ++intLen;\r\n    }\r\n    if (ch \u003d\u003d INT_PERIOD || (ch | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        _inputPtr \u003d ptr;\r\n        return _parseFloat(ch, startPtr, ptr, negative, intLen);\r\n    }\r\n    --ptr;\r\n    _inputPtr \u003d ptr;\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(ch);\r\n    }\r\n    int len \u003d ptr - startPtr;\r\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\r\n    return resetInt(negative, intLen);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipComma(...1)",
        "body": "{\r\n    if (i !\u003d INT_COMMA) {\r\n        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipAfterComma2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003c INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipAfterComma2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    /* Although we will always be complete with respect to textual\r\n         * representation (that is, all characters will be parsed),\r\n         * actual conversion to a number is deferred. Thus, need to\r\n         * note that no representations are valid yet\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    // to include digit already read\r\n    int startPtr \u003d ptr - 1;\r\n    final int inputLen \u003d _inputEnd;\r\n    // One special case, leading zero(es):\r\n    if (ch \u003d\u003d INT_0) {\r\n        return _parseNumber2(false, startPtr);\r\n    }\r\n    /* First, let\u0027s see if the whole number is contained within\r\n         * the input buffer unsplit. This should be the common case;\r\n         * and to simplify processing, we will just reparse contents\r\n         * in the alternative case (number split on buffer boundary)\r\n         */\r\n    // already got one\r\n    int intLen \u003d 1;\r\n    // First let\u0027s get the obligatory integer part:\r\n    int_loop: while (true) {\r\n        if (ptr \u003e\u003d inputLen) {\r\n            _inputPtr \u003d startPtr;\r\n            return _parseNumber2(false, startPtr);\r\n        }\r\n        ch \u003d _inputBuffer[ptr++];\r\n        if (ch \u003c INT_0 || ch \u003e INT_9) {\r\n            break int_loop;\r\n        }\r\n        ++intLen;\r\n    }\r\n    if (ch \u003d\u003d INT_PERIOD || (ch | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        _inputPtr \u003d ptr;\r\n        return _parseFloat(ch, startPtr, ptr, false, intLen);\r\n    }\r\n    // Got it all: let\u0027s add to text buffer for parsing, access\r\n    // need to push back following separator\r\n    --ptr;\r\n    _inputPtr \u003d ptr;\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(ch);\r\n    }\r\n    int len \u003d ptr - startPtr;\r\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_matchNull(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027u\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"null\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_parseFloatThatStartsWithPeriod(...1)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleOddValue(\u0027.\u0027);\r\n    }\r\n    // 26-Jun-2022, tatu: At this point it is assumed that the whole input is\r\n    //    within input buffer so we can \"rewind\" not just one but two characters\r\n    //    (leading sign, period) within same buffer. Caller must ensure this is\r\n    //    the case.\r\n    //    Little bit suspicious of code paths that would go to \"_parseNumber2(...)\"\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    int startPtr \u003d _inputPtr - 1;\r\n    if (neg) {\r\n        --startPtr;\r\n    }\r\n    return _parseFloat(INT_PERIOD, startPtr, _inputPtr, neg, 0);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inArray()) {\r\n            _reportMismatchedEndMarker(i, \u0027}\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inObject()) {\r\n            _reportMismatchedEndMarker(i, \u0027]\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    int inPtr \u003d _inputPtr;\r\n    int inLen \u003d _inputEnd;\r\n    char[] inBuf \u003d _inputBuffer;\r\n    while (true) {\r\n        if (inPtr \u003e\u003d inLen) {\r\n            _inputPtr \u003d inPtr;\r\n            if (!_loadMore()) {\r\n                _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING);\r\n            }\r\n            inPtr \u003d _inputPtr;\r\n            inLen \u003d _inputEnd;\r\n        }\r\n        char c \u003d inBuf[inPtr++];\r\n        int i \u003d c;\r\n        if (i \u003c\u003d INT_BACKSLASH) {\r\n            if (i \u003d\u003d INT_BACKSLASH) {\r\n                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\r\n                // does that affect decoding? For now let\u0027s assume it does not.\r\n                _inputPtr \u003d inPtr;\r\n                /*c \u003d */\r\n                _decodeEscaped();\r\n                inPtr \u003d _inputPtr;\r\n                inLen \u003d _inputEnd;\r\n            } else if (i \u003c\u003d INT_QUOTE) {\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    break;\r\n                }\r\n                if (i \u003c INT_SPACE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    _throwUnquotedSpace(i, \"string value\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_skipColon(...0)",
        "body": "{\r\n    if ((_inputPtr + 4) \u003e\u003d _inputEnd) {\r\n        return _skipColon2(false);\r\n    }\r\n    char c \u003d _inputBuffer[_inputPtr];\r\n    if (c \u003d\u003d \u0027:\u0027) {\r\n        // common case, no leading space\r\n        int i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027) {\r\n        c \u003d _inputBuffer[++_inputPtr];\r\n    }\r\n    if (c \u003d\u003d \u0027:\u0027) {\r\n        int i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(true);\r\n    }\r\n    return _skipColon2(false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "finishToken",
    "signature": "void finishToken()",
    "visibility": "public",
    "body": "{\r\n    if (_tokenIncomplete) {\r\n        _tokenIncomplete \u003d false;\r\n        // only strings can be incomplete\r\n        _finishString();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextFieldName",
    "signature": "boolean nextFieldName(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    // // // Note: most of code below is copied from nextToken()\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        _nextAfterName();\r\n        return false;\r\n    }\r\n    if (_tokenIncomplete) {\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        close();\r\n        _updateTokenToNull();\r\n        return false;\r\n    }\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return false;\r\n    }\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        _nextTokenNotInObject(i);\r\n        return false;\r\n    }\r\n    _updateNameLocation();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        // when doing literal match, must consider escaping:\r\n        char[] nameChars \u003d sstr.asQuotedChars();\r\n        final int len \u003d nameChars.length;\r\n        // Require 4 more bytes for faster skipping of colon that follows name\r\n        if ((_inputPtr + len + 4) \u003c _inputEnd) {\r\n            // maybe...\r\n            // first check length match by\r\n            final int end \u003d _inputPtr + len;\r\n            if (_inputBuffer[end] \u003d\u003d \u0027\"\u0027) {\r\n                int offset \u003d 0;\r\n                int ptr \u003d _inputPtr;\r\n                while (true) {\r\n                    if (ptr \u003d\u003d end) {\r\n                        // yes, match!\r\n                        _parsingContext.setCurrentName(sstr.getValue());\r\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\r\n                        return true;\r\n                    }\r\n                    if (nameChars[offset] !\u003d _inputBuffer[ptr]) {\r\n                        break;\r\n                    }\r\n                    ++offset;\r\n                    ++ptr;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _isNextTokenNameMaybe(i, sstr.getValue());\r\n}",
    "nodes": 24,
    "edges": 30,
    "cc": 8,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i17 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i0 !\u003d 125) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B12",
      "B9 : If($i15 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($i16 !\u003d 125) → B11 | else → B12",
      "B12 : If($z2 !\u003d 0) → B13 | else → B14",
      "B14 : If(i18 !\u003d 34) → B15 | else → B23",
      "B15 : If($i5 \u003e\u003d $i4) → B16 | else → B23",
      "B16 : If($i21 !\u003d 34) → B17 | else → B23",
      "B18 : If(i20 !\u003d i7) → B19 | else → B20",
      "B20 : If($i22 \u003d\u003d $i23) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  SerializableString\n  ReaderBasedJsonParser: int _numTypesValid\u003e \u003d 0\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0._nextAfterName()\n  return\n}",
      "B2 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i17 \u003d r0._skipWSOrEnd()\n  i18 \u003d $i17\n  if ($i17 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  ReaderBasedJsonParser: byte[] _binaryValue\u003e \u003d null\n  $i0 \u003d $i17 | 32\n  if ($i0 !\u003d 125) goto B7 else B8\n}",
      "B7 {\n  r0._closeScope($i17)\n  return\n}",
      "B8 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  i18 \u003d r0._skipComma($i17)\n  $i14 \u003d ReaderBasedJsonParser: int _features\u003e\n  $i13 \u003d ReaderBasedJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i15 \u003d $i14 \u0026 $i13\n  if ($i15 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $i16 \u003d i18 | 32\n  if ($i16 !\u003d 125) goto B11 else B12\n}",
      "B11 {\n  r0._closeScope(i18)\n  return\n}",
      "B12 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $z2 \u003d $r10.inObject()\n  if ($z2 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  r0._updateLocation()\n  r0._nextTokenNotInObject(i18)\n  return\n}",
      "B14 {\n  r0._updateNameLocation()\n  if (i18 !\u003d 34) goto B15 else B23\n}",
      "B15 {\n  r5 \u003d r4.asQuotedChars()\n  i1 \u003d lengthof r5\n  $i2 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n  $i3 \u003d $i2 + i1\n  $i5 \u003d $i3 + 4\n  $i4 \u003d ReaderBasedJsonParser: int _inputEnd\u003e\n  if ($i5 \u003e\u003d $i4) goto B16 else B23\n}",
      "B16 {\n  $i6 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n  i7 \u003d $i6 + i1\n  $r6 \u003d ReaderBasedJsonParser: char[] _inputBuffer\u003e\n  $c8 \u003d $r6[i7]\n  $i21 \u003d (int) $c8\n  if ($i21 !\u003d 34) goto B17 else B23\n}",
      "B17 {\n  i19 \u003d 0\n  i20 \u003d ReaderBasedJsonParser: int _inputPtr\u003e\n}",
      "B18 {\n  if (i20 !\u003d i7) goto B19 else B20\n}",
      "B19 {\n  $r8 \u003d JsonReadContext _parsingContext\u003e\n  $r9 \u003d r4.getValue()\n  $r8.setCurrentName($r9)\n  $i11 \u003d i20 + 1\n  $i12 \u003d r0._skipColonFast($i11)\n  r0._isNextTokenNameYes($i12)\n  return\n}",
      "B20 {\n  $c10 \u003d r5[i19]\n  $r7 \u003d ReaderBasedJsonParser: char[] _inputBuffer\u003e\n  $c9 \u003d $r7[i20]\n  $i22 \u003d (int) $c10\n  $i23 \u003d (int) $c9\n  if ($i22 \u003d\u003d $i23) goto B21 else B22\n}",
      "B21 {\n  goto B23\n}",
      "B22 {\n  i19 \u003d i19 + 1\n  i20 \u003d i20 + 1\n  goto B18\n}",
      "B23 {\n  $r11 \u003d r4.getValue()\n  $z3 \u003d r0._isNextTokenNameMaybe(i18, $r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B23",
      "B15 --\u003e B16",
      "B15 --\u003e B23",
      "B16 --\u003e B17",
      "B16 --\u003e B23",
      "B17 --\u003e B18",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B18",
      "B23 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_skipColonFast(...1)",
        "body": "{\r\n    int i \u003d _inputBuffer[ptr++];\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputBuffer[ptr++];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                _inputPtr \u003d ptr;\r\n                return i;\r\n            }\r\n        } else if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[ptr++];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                    _inputPtr \u003d ptr;\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        _inputPtr \u003d ptr - 1;\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputBuffer[ptr++];\r\n    }\r\n    boolean gotColon \u003d (i \u003d\u003d INT_COLON);\r\n    if (gotColon) {\r\n        i \u003d _inputBuffer[ptr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                _inputPtr \u003d ptr;\r\n                return i;\r\n            }\r\n        } else if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[ptr++];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                    _inputPtr \u003d ptr;\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _inputPtr \u003d ptr - 1;\r\n    return _skipColon2(gotColon);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++];\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseSignedNumber(true));\r\n        /* Should we have separate handling for plus? Although\r\n             * it is not allowed per se, it may be erroneously used,\r\n             * and could be indicated by a more specific error message.\r\n             */\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n        /*\r\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\r\n         * The Check is for missing values. In case of missing values in an array, the next token will be either \u0027,\u0027 or \u0027]\u0027.\r\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,)\r\n         * so that the existing flow goes back to checking the next token which will be comma again and\r\n         * it continues the parsing.\r\n         * Also the case returns NULL as current token in case of \u0027,\u0027 or \u0027]\u0027.\r\n         */\r\n        // case \u0027]\u0027:  // 11-May-2020, tatu: related to [core#616], this should never be reached\r\n        case \u0027,\u0027:\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return _updateToken(JsonToken.VALUE_NULL);\r\n                }\r\n            }\r\n    }\r\n    return _updateToken(_handleOddValue(i));\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartRow \u003d _currInputRow;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_isNextTokenNameMaybe(...2)",
        "body": "{\r\n    // // // and this is back to standard nextToken()\r\n    String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n    _parsingContext.setCurrentName(name);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return nameToMatch.equals(name);\r\n    }\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    _nextToken \u003d t;\r\n    return nameToMatch.equals(name);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipComma(...1)",
        "body": "{\r\n    if (i !\u003d INT_COMMA) {\r\n        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipAfterComma2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003c INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipAfterComma2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inArray()) {\r\n            _reportMismatchedEndMarker(i, \u0027}\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inObject()) {\r\n            _reportMismatchedEndMarker(i, \u0027]\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_isNextTokenNameYes(...1)",
        "body": "{\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    _updateLocation();\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            _nextToken \u003d JsonToken.VALUE_STRING;\r\n            return;\r\n        case \u0027[\u0027:\r\n            _nextToken \u003d JsonToken.START_ARRAY;\r\n            return;\r\n        case \u0027{\u0027:\r\n            _nextToken \u003d JsonToken.START_OBJECT;\r\n            return;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            _nextToken \u003d JsonToken.VALUE_TRUE;\r\n            return;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            _nextToken \u003d JsonToken.VALUE_FALSE;\r\n            return;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            _nextToken \u003d JsonToken.VALUE_NULL;\r\n            return;\r\n        case \u0027-\u0027:\r\n            _nextToken \u003d _parseSignedNumber(true);\r\n            return;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                _nextToken \u003d _parseSignedNumber(false);\r\n            } else {\r\n                _nextToken \u003d _handleOddValue(i);\r\n            }\r\n            return;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            _nextToken \u003d _parseFloatThatStartsWithPeriod(false);\r\n            return;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            _nextToken \u003d _parseUnsignedNumber(i);\r\n            return;\r\n    }\r\n    _nextToken \u003d _handleOddValue(i);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    int inPtr \u003d _inputPtr;\r\n    int inLen \u003d _inputEnd;\r\n    char[] inBuf \u003d _inputBuffer;\r\n    while (true) {\r\n        if (inPtr \u003e\u003d inLen) {\r\n            _inputPtr \u003d inPtr;\r\n            if (!_loadMore()) {\r\n                _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING);\r\n            }\r\n            inPtr \u003d _inputPtr;\r\n            inLen \u003d _inputEnd;\r\n        }\r\n        char c \u003d inBuf[inPtr++];\r\n        int i \u003d c;\r\n        if (i \u003c\u003d INT_BACKSLASH) {\r\n            if (i \u003d\u003d INT_BACKSLASH) {\r\n                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\r\n                // does that affect decoding? For now let\u0027s assume it does not.\r\n                _inputPtr \u003d inPtr;\r\n                /*c \u003d */\r\n                _decodeEscaped();\r\n                inPtr \u003d _inputPtr;\r\n                inLen \u003d _inputEnd;\r\n            } else if (i \u003c\u003d INT_QUOTE) {\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    break;\r\n                }\r\n                if (i \u003c INT_SPACE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    _throwUnquotedSpace(i, \"string value\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextFieldName",
    "signature": "java.lang.String nextFieldName()",
    "visibility": "public",
    "body": "{\r\n    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        _nextAfterName();\r\n        return null;\r\n    }\r\n    if (_tokenIncomplete) {\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        close();\r\n        _updateTokenToNull();\r\n        return null;\r\n    }\r\n    _binaryValue \u003d null;\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return null;\r\n    }\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        _nextTokenNotInObject(i);\r\n        return null;\r\n    }\r\n    _updateNameLocation();\r\n    String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n    _parsingContext.setCurrentName(name);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return name;\r\n    }\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    _nextToken \u003d t;\r\n    return name;\r\n}",
    "nodes": 33,
    "edges": 46,
    "cc": 15,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i6 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i0 !\u003d 125) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B12",
      "B9 : If($i4 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($i5 !\u003d 125) → B11 | else → B12",
      "B12 : If($z3 !\u003d 0) → B13 | else → B14",
      "B14 : If(i7 !\u003d 34) → B15 | else → B16",
      "B17 : If($i1 !\u003d 34) → B18 | else → B19",
      "B19 : If(switch-on $i1) → B21 | else → B20",
      "B21 : If($z2 \u003d\u003d false) → B22 | else → B23"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  ReaderBasedJsonParser: int _numTypesValid\u003e \u003d 0\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0._nextAfterName()\n  return\n}",
      "B2 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i6 \u003d r0._skipWSOrEnd()\n  i7 \u003d $i6\n  if ($i6 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  ReaderBasedJsonParser: byte[] _binaryValue\u003e \u003d null\n  $i0 \u003d $i6 | 32\n  if ($i0 !\u003d 125) goto B7 else B8\n}",
      "B7 {\n  r0._closeScope($i6)\n  return\n}",
      "B8 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B9 else B12\n}",
      "B9 {\n  i7 \u003d r0._skipComma($i6)\n  $i3 \u003d ReaderBasedJsonParser: int _features\u003e\n  $i2 \u003d ReaderBasedJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i4 \u003d $i3 \u0026 $i2\n  if ($i4 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $i5 \u003d i7 | 32\n  if ($i5 !\u003d 125) goto B11 else B12\n}",
      "B11 {\n  r0._closeScope(i7)\n  return\n}",
      "B12 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $z3 \u003d $r10.inObject()\n  if ($z3 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  r0._updateLocation()\n  r0._nextTokenNotInObject(i7)\n  return\n}",
      "B14 {\n  r0._updateNameLocation()\n  if (i7 !\u003d 34) goto B15 else B16\n}",
      "B15 {\n  $r11 \u003d r0._parseName()\n  goto B17\n}",
      "B16 {\n  $r11 \u003d r0._handleOddName(i7)\n}",
      "B17 {\n  r4 \u003d $r11\n  $r5 \u003d JsonReadContext _parsingContext\u003e\n  $r5.setCurrentName($r11)\n  $r6 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r6)\n  $i1 \u003d r0._skipColon()\n  r0._updateLocation()\n  if ($i1 !\u003d 34) goto B18 else B19\n}",
      "B18 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  return\n}",
      "B19 {\n  JsonToken _handleOddValue(int)\u003e($i1); }\n}",
      "B20 {\n  r12 \u003d r0._parseSignedNumber(1)\n  goto B32\n}",
      "B21 {\n  $r7 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r8 \u003d $r7.mappedFeature()\n  $z2 \u003d r0.isEnabled($r8)\n  if ($z2 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  r12 \u003d r0._parseSignedNumber(0)\n  goto B32\n}",
      "B23 {\n  r12 \u003d r0._handleOddValue($i1)\n  goto B32\n}",
      "B24 {\n  r12 \u003d r0._parseFloatThatStartsWithPeriod(0)\n  goto B32\n}",
      "B25 {\n  r12 \u003d r0._parseUnsignedNumber($i1)\n  goto B32\n}",
      "B26 {\n  r0._matchFalse()\n  r12 \u003d JsonToken VALUE_FALSE\u003e\n  goto B32\n}",
      "B27 {\n  r0._matchNull()\n  r12 \u003d JsonToken VALUE_NULL\u003e\n  goto B32\n}",
      "B28 {\n  r0._matchTrue()\n  r12 \u003d JsonToken VALUE_TRUE\u003e\n  goto B32\n}",
      "B29 {\n  r12 \u003d JsonToken START_ARRAY\u003e\n  goto B32\n}",
      "B30 {\n  r12 \u003d JsonToken START_OBJECT\u003e\n  goto B32\n}",
      "B31 {\n  r12 \u003d r0._handleOddValue($i1)\n}",
      "B32 {\n  JsonToken _nextToken\u003e \u003d r12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B21",
      "B19 --\u003e B20",
      "B19 --\u003e B24",
      "B19 --\u003e B25",
      "B19 --\u003e B29",
      "B19 --\u003e B26",
      "B19 --\u003e B27",
      "B19 --\u003e B28",
      "B19 --\u003e B30",
      "B19 --\u003e B31",
      "B20 --\u003e B32",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B32",
      "B23 --\u003e B32",
      "B24 --\u003e B32",
      "B25 --\u003e B32",
      "B26 --\u003e B32",
      "B27 --\u003e B32",
      "B28 --\u003e B32",
      "B29 --\u003e B32",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_parseName(...0)",
        "body": "{\r\n    // First: let\u0027s try to see if we have a simple name: one that does\r\n    // not cross input buffer boundary, and does not contain escape sequences.\r\n    int ptr \u003d _inputPtr;\r\n    int hash \u003d _hashSeed;\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    while (ptr \u003c _inputEnd) {\r\n        int ch \u003d _inputBuffer[ptr];\r\n        if (ch \u003c codes.length \u0026\u0026 codes[ch] !\u003d 0) {\r\n            if (ch \u003d\u003d \u0027\"\u0027) {\r\n                final int start \u003d _inputPtr;\r\n                // to skip the quote\r\n                _inputPtr \u003d ptr + 1;\r\n                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n            }\r\n            break;\r\n        }\r\n        hash \u003d (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\r\n        ++ptr;\r\n    }\r\n    int start \u003d _inputPtr;\r\n    _inputPtr \u003d ptr;\r\n    return _parseName2(start, hash, INT_QUOTE);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_handleOddName(...1)",
        "body": "{\r\n    // [JACKSON-173]: allow single quotes\r\n    if (i \u003d\u003d \u0027\\\u0027\u0027 \u0026\u0026 (_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n        return _parseAposName();\r\n    }\r\n    // [JACKSON-69]: allow unquoted names if feature enabled:\r\n    if ((_features \u0026 FEAT_MASK_ALLOW_UNQUOTED_NAMES) \u003d\u003d 0) {\r\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\r\n    }\r\n    final int[] codes \u003d CharTypes.getInputCodeLatin1JsNames();\r\n    final int maxCode \u003d codes.length;\r\n    // Also: first char must be a valid name char, but NOT be number\r\n    boolean firstOk;\r\n    if (i \u003c maxCode) {\r\n        // identifier, or a number ([Issue#102])\r\n        firstOk \u003d (codes[i] \u003d\u003d 0);\r\n    } else {\r\n        firstOk \u003d Character.isJavaIdentifierPart((char) i);\r\n    }\r\n    if (!firstOk) {\r\n        _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\r\n    }\r\n    int ptr \u003d _inputPtr;\r\n    int hash \u003d _hashSeed;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode) {\r\n                if (codes[ch] !\u003d 0) {\r\n                    // -1 to bring back first char\r\n                    final int start \u003d _inputPtr - 1;\r\n                    _inputPtr \u003d ptr;\r\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n                }\r\n            } else if (!Character.isJavaIdentifierPart((char) ch)) {\r\n                // -1 to bring back first char\r\n                final int start \u003d _inputPtr - 1;\r\n                _inputPtr \u003d ptr;\r\n                return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\r\n            }\r\n            hash \u003d (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    int start \u003d _inputPtr - 1;\r\n    _inputPtr \u003d ptr;\r\n    return _handleOddName2(start, hash, codes);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++];\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_handleOddValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(i) {\r\n        case \u0027\\\u0027\u0027:\r\n            /* Allow single quotes? Unlike with regular Strings, we\u0027ll eagerly parse\r\n             * contents; this so that there\u0027s no need to store information on quote char used.\r\n             * Also, no separation to fast/slow parsing; we\u0027ll just do\r\n             * one regular (~\u003d slowish) parsing, to keep code simple\r\n             */\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027]\u0027:\r\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\r\n             *   we may allow \"missing values\", that is, encountering a trailing\r\n             *   comma or closing marker where value would be expected\r\n             */\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                if (!_loadMore()) {\r\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\r\n                }\r\n            }\r\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(i)) {\r\n        _reportInvalidToken(\"\" + ((char) i), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(i, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_matchFalse(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 4) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027a\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027s\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027e\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"false\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_matchTrue(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027r\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027u\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027e\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"true\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseSignedNumber(true));\r\n        /* Should we have separate handling for plus? Although\r\n             * it is not allowed per se, it may be erroneously used,\r\n             * and could be indicated by a more specific error message.\r\n             */\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n        /*\r\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\r\n         * The Check is for missing values. In case of missing values in an array, the next token will be either \u0027,\u0027 or \u0027]\u0027.\r\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,)\r\n         * so that the existing flow goes back to checking the next token which will be comma again and\r\n         * it continues the parsing.\r\n         * Also the case returns NULL as current token in case of \u0027,\u0027 or \u0027]\u0027.\r\n         */\r\n        // case \u0027]\u0027:  // 11-May-2020, tatu: related to [core#616], this should never be reached\r\n        case \u0027,\u0027:\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return _updateToken(JsonToken.VALUE_NULL);\r\n                }\r\n            }\r\n    }\r\n    return _updateToken(_handleOddValue(i));\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartRow \u003d _currInputRow;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_parseSignedNumber(...1)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    // 26-Jun-2022, tatu: We always have a sign; positive should be allowed as deviation\r\n    //      But unfortunately that won\u0027t yet work\r\n    // to include sign/digit already read\r\n    int startPtr \u003d negative ? ptr - 1 : ptr;\r\n    final int inputEnd \u003d _inputEnd;\r\n    if (ptr \u003e\u003d inputEnd) {\r\n        return _parseNumber2(negative, startPtr);\r\n    }\r\n    int ch \u003d _inputBuffer[ptr++];\r\n    // First check: must have a digit to follow minus sign\r\n    if (ch \u003e INT_9 || ch \u003c INT_0) {\r\n        _inputPtr \u003d ptr;\r\n        if (ch \u003d\u003d INT_PERIOD) {\r\n            return _parseFloatThatStartsWithPeriod(negative);\r\n        }\r\n        return _handleInvalidNumberStart(ch, negative, true);\r\n    }\r\n    // One special case, leading zero(es):\r\n    if (ch \u003d\u003d INT_0) {\r\n        return _parseNumber2(negative, startPtr);\r\n    }\r\n    // already got one\r\n    int intLen \u003d 1;\r\n    // First let\u0027s get the obligatory integer part:\r\n    int_loop: while (true) {\r\n        if (ptr \u003e\u003d inputEnd) {\r\n            return _parseNumber2(negative, startPtr);\r\n        }\r\n        ch \u003d _inputBuffer[ptr++];\r\n        if (ch \u003c INT_0 || ch \u003e INT_9) {\r\n            break int_loop;\r\n        }\r\n        ++intLen;\r\n    }\r\n    if (ch \u003d\u003d INT_PERIOD || (ch | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        _inputPtr \u003d ptr;\r\n        return _parseFloat(ch, startPtr, ptr, negative, intLen);\r\n    }\r\n    --ptr;\r\n    _inputPtr \u003d ptr;\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(ch);\r\n    }\r\n    int len \u003d ptr - startPtr;\r\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\r\n    return resetInt(negative, intLen);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipComma(...1)",
        "body": "{\r\n    if (i !\u003d INT_COMMA) {\r\n        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipAfterComma2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003c INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipAfterComma2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateLocation(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    /* Although we will always be complete with respect to textual\r\n         * representation (that is, all characters will be parsed),\r\n         * actual conversion to a number is deferred. Thus, need to\r\n         * note that no representations are valid yet\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    // to include digit already read\r\n    int startPtr \u003d ptr - 1;\r\n    final int inputLen \u003d _inputEnd;\r\n    // One special case, leading zero(es):\r\n    if (ch \u003d\u003d INT_0) {\r\n        return _parseNumber2(false, startPtr);\r\n    }\r\n    /* First, let\u0027s see if the whole number is contained within\r\n         * the input buffer unsplit. This should be the common case;\r\n         * and to simplify processing, we will just reparse contents\r\n         * in the alternative case (number split on buffer boundary)\r\n         */\r\n    // already got one\r\n    int intLen \u003d 1;\r\n    // First let\u0027s get the obligatory integer part:\r\n    int_loop: while (true) {\r\n        if (ptr \u003e\u003d inputLen) {\r\n            _inputPtr \u003d startPtr;\r\n            return _parseNumber2(false, startPtr);\r\n        }\r\n        ch \u003d _inputBuffer[ptr++];\r\n        if (ch \u003c INT_0 || ch \u003e INT_9) {\r\n            break int_loop;\r\n        }\r\n        ++intLen;\r\n    }\r\n    if (ch \u003d\u003d INT_PERIOD || (ch | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        _inputPtr \u003d ptr;\r\n        return _parseFloat(ch, startPtr, ptr, false, intLen);\r\n    }\r\n    // Got it all: let\u0027s add to text buffer for parsing, access\r\n    // need to push back following separator\r\n    --ptr;\r\n    _inputPtr \u003d ptr;\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(ch);\r\n    }\r\n    int len \u003d ptr - startPtr;\r\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_matchNull(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        final char[] b \u003d _inputBuffer;\r\n        if (b[ptr] \u003d\u003d \u0027u\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027 \u0026\u0026 b[++ptr] \u003d\u003d \u0027l\u0027) {\r\n            char c \u003d b[++ptr];\r\n            if (c \u003c \u00270\u0027 || c \u003d\u003d \u0027]\u0027 || c \u003d\u003d \u0027}\u0027) {\r\n                // expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // buffer boundary, or problem, offline\r\n    _matchToken(\"null\", 1);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_parseFloatThatStartsWithPeriod(...1)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleOddValue(\u0027.\u0027);\r\n    }\r\n    // 26-Jun-2022, tatu: At this point it is assumed that the whole input is\r\n    //    within input buffer so we can \"rewind\" not just one but two characters\r\n    //    (leading sign, period) within same buffer. Caller must ensure this is\r\n    //    the case.\r\n    //    Little bit suspicious of code paths that would go to \"_parseNumber2(...)\"\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    int startPtr \u003d _inputPtr - 1;\r\n    if (neg) {\r\n        --startPtr;\r\n    }\r\n    return _parseFloat(INT_PERIOD, startPtr, _inputPtr, neg, 0);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inArray()) {\r\n            _reportMismatchedEndMarker(i, \u0027}\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _updateLocation();\r\n        if (!_parsingContext.inObject()) {\r\n            _reportMismatchedEndMarker(i, \u0027]\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    int inPtr \u003d _inputPtr;\r\n    int inLen \u003d _inputEnd;\r\n    char[] inBuf \u003d _inputBuffer;\r\n    while (true) {\r\n        if (inPtr \u003e\u003d inLen) {\r\n            _inputPtr \u003d inPtr;\r\n            if (!_loadMore()) {\r\n                _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.VALUE_STRING);\r\n            }\r\n            inPtr \u003d _inputPtr;\r\n            inLen \u003d _inputEnd;\r\n        }\r\n        char c \u003d inBuf[inPtr++];\r\n        int i \u003d c;\r\n        if (i \u003c\u003d INT_BACKSLASH) {\r\n            if (i \u003d\u003d INT_BACKSLASH) {\r\n                // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\r\n                // does that affect decoding? For now let\u0027s assume it does not.\r\n                _inputPtr \u003d inPtr;\r\n                /*c \u003d */\r\n                _decodeEscaped();\r\n                inPtr \u003d _inputPtr;\r\n                inLen \u003d _inputEnd;\r\n            } else if (i \u003c\u003d INT_QUOTE) {\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    break;\r\n                }\r\n                if (i \u003c INT_SPACE) {\r\n                    _inputPtr \u003d inPtr;\r\n                    _throwUnquotedSpace(i, \"string value\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_skipColon(...0)",
        "body": "{\r\n    if ((_inputPtr + 4) \u003e\u003d _inputEnd) {\r\n        return _skipColon2(false);\r\n    }\r\n    char c \u003d _inputBuffer[_inputPtr];\r\n    if (c \u003d\u003d \u0027:\u0027) {\r\n        // common case, no leading space\r\n        int i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027) {\r\n        c \u003d _inputBuffer[++_inputPtr];\r\n    }\r\n    if (c \u003d\u003d \u0027:\u0027) {\r\n        int i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(true);\r\n    }\r\n    return _skipColon2(false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextTextValue",
    "signature": "java.lang.String nextTextValue()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n            if (_tokenIncomplete) {\r\n                _tokenIncomplete \u003d false;\r\n                _finishString();\r\n            }\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_STRING) ? getText() : null;\r\n}",
    "nodes": 14,
    "edges": 17,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(r5 !\u003d $r7) → B6 | else → B7",
      "B7 : If(r5 !\u003d $r8) → B8 | else → B9",
      "B10 : If($r4 !\u003d $r3) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  ReaderBasedJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_STRING\u003e\n  if (r5 !\u003d $r6) goto B2 else B5\n}",
      "B2 {\n  $z0 \u003d ReaderBasedJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  ReaderBasedJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B4 {\n  $r9 \u003d TextBuffer _textBuffer\u003e\n  $r10 \u003d $r9.contentsAsString()\n  return\n}",
      "B5 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i3, $i2)\n  goto B9\n}",
      "B7 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i0 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i1, $i0)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 !\u003d $r3) goto B11 else B12\n}",
      "B11 {\n  $r11 \u003d r0.getText()\n  goto B13\n}",
      "B12 {\n  $r11 \u003d null\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#_finishString(...0)",
        "body": "{\r\n    /* First: let\u0027s try to see if we have simple String value: one\r\n         * that does not cross input buffer boundary, and does not\r\n         * contain escape sequences.\r\n         */\r\n    int ptr \u003d _inputPtr;\r\n    final int inputLen \u003d _inputEnd;\r\n    if (ptr \u003c inputLen) {\r\n        final int[] codes \u003d INPUT_CODES_LATIN1;\r\n        final int maxCode \u003d codes.length;\r\n        do {\r\n            int ch \u003d _inputBuffer[ptr];\r\n            if (ch \u003c maxCode \u0026\u0026 codes[ch] !\u003d 0) {\r\n                if (ch \u003d\u003d \u0027\"\u0027) {\r\n                    _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n                    _inputPtr \u003d ptr + 1;\r\n                    // Yes, we got it all\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n            ++ptr;\r\n        } while (ptr \u003c inputLen);\r\n    }\r\n    // Either ran out of input, or bumped into an escape sequence...\r\n    _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr));\r\n    _inputPtr \u003d ptr;\r\n    _finishString2();\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Should actually close/release things\r\n        // like input source, symbol table and recyclable buffers now.\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for Object contexts, since\r\n         * the intermediate \u0027expect-value\u0027 state is never retained.\r\n         */\r\n    boolean inObject \u003d _parsingContext.inObject();\r\n    if (inObject) {\r\n        // First, field name itself:\r\n        _updateNameLocation();\r\n        String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n        _parsingContext.setCurrentName(name);\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        i \u003d _skipColon();\r\n    }\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            t \u003d JsonToken.VALUE_STRING;\r\n            break;\r\n        case \u0027[\u0027:\r\n            if (!inObject) {\r\n                createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            if (!inObject) {\r\n                createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027}\u0027:\r\n            // Error: } is not valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(i, \"expected a value\");\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    if (inObject) {\r\n        _nextToken \u003d t;\r\n        return _currToken;\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextIntValue",
    "signature": "int nextIntValue(int)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getIntValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  i0 :\u003d @parameter0: int\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  ReaderBasedJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $i5 \u003d r0.getIntValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $i6 \u003d r0.getIntValue()\n  goto B11\n}",
      "B10 {\n  $i6 \u003d i0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#getIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Should actually close/release things\r\n        // like input source, symbol table and recyclable buffers now.\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for Object contexts, since\r\n         * the intermediate \u0027expect-value\u0027 state is never retained.\r\n         */\r\n    boolean inObject \u003d _parsingContext.inObject();\r\n    if (inObject) {\r\n        // First, field name itself:\r\n        _updateNameLocation();\r\n        String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n        _parsingContext.setCurrentName(name);\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        i \u003d _skipColon();\r\n    }\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            t \u003d JsonToken.VALUE_STRING;\r\n            break;\r\n        case \u0027[\u0027:\r\n            if (!inObject) {\r\n                createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            if (!inObject) {\r\n                createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027}\u0027:\r\n            // Error: } is not valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(i, \"expected a value\");\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    if (inObject) {\r\n        _nextToken \u003d t;\r\n        return _currToken;\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextLongValue",
    "signature": "long nextLongValue(long)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getLongValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  l0 :\u003d @parameter0: long\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  ReaderBasedJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $l5 \u003d r0.getLongValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $l6 \u003d r0.getLongValue()\n  goto B11\n}",
      "B10 {\n  $l6 \u003d l0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#getLongValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Should actually close/release things\r\n        // like input source, symbol table and recyclable buffers now.\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for Object contexts, since\r\n         * the intermediate \u0027expect-value\u0027 state is never retained.\r\n         */\r\n    boolean inObject \u003d _parsingContext.inObject();\r\n    if (inObject) {\r\n        // First, field name itself:\r\n        _updateNameLocation();\r\n        String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n        _parsingContext.setCurrentName(name);\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        i \u003d _skipColon();\r\n    }\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            t \u003d JsonToken.VALUE_STRING;\r\n            break;\r\n        case \u0027[\u0027:\r\n            if (!inObject) {\r\n                createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            if (!inObject) {\r\n                createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027}\u0027:\r\n            // Error: } is not valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(i, \"expected a value\");\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    if (inObject) {\r\n        _nextToken \u003d t;\r\n        return _currToken;\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "nextBooleanValue",
    "signature": "java.lang.Boolean nextBooleanValue()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_TRUE) {\r\n            return Boolean.TRUE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.VALUE_FALSE) {\r\n            return Boolean.FALSE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    JsonToken t \u003d nextToken();\r\n    if (t !\u003d null) {\r\n        int id \u003d t.id();\r\n        if (id \u003d\u003d ID_TRUE)\r\n            return Boolean.TRUE;\r\n        if (id \u003d\u003d ID_FALSE)\r\n            return Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 16,
    "edges": 18,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r11 !\u003d $r5) → B2 | else → B3",
      "B3 : If(r11 !\u003d $r6) → B4 | else → B5",
      "B5 : If(r11 !\u003d $r7) → B6 | else → B7",
      "B7 : If(r11 !\u003d $r8) → B8 | else → B9",
      "B10 : If(r12 \u003d\u003d null) → B11 | else → B15",
      "B11 : If(i0 !\u003d 9) → B12 | else → B13",
      "B13 : If(i0 !\u003d 10) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  ReaderBasedJsonParser: boolean _nameCopied\u003e \u003d 0\n  r11 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r11)\n  $r5 \u003d JsonToken VALUE_TRUE\u003e\n  if (r11 !\u003d $r5) goto B2 else B3\n}",
      "B2 {\n  $r10 \u003d Boolean TRUE\u003e\n  return\n}",
      "B3 {\n  $r6 \u003d JsonToken VALUE_FALSE\u003e\n  if (r11 !\u003d $r6) goto B4 else B5\n}",
      "B4 {\n  $r9 \u003d Boolean FALSE\u003e\n  return\n}",
      "B5 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r11 !\u003d $r7) goto B6 else B7\n}",
      "B6 {\n  $i4 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B9\n}",
      "B7 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r11 !\u003d $r8) goto B8 else B9\n}",
      "B8 {\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  r12 \u003d r0.nextToken()\n  if (r12 \u003d\u003d null) goto B11 else B15\n}",
      "B11 {\n  i0 \u003d r12.id()\n  if (i0 !\u003d 9) goto B12 else B13\n}",
      "B12 {\n  $r4 \u003d Boolean TRUE\u003e\n  return\n}",
      "B13 {\n  if (i0 !\u003d 10) goto B14 else B15\n}",
      "B14 {\n  $r3 \u003d Boolean FALSE\u003e\n  return\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B15",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "ReaderBasedJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Should actually close/release things\r\n        // like input source, symbol table and recyclable buffers now.\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        i \u003d _skipComma(i);\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for Object contexts, since\r\n         * the intermediate \u0027expect-value\u0027 state is never retained.\r\n         */\r\n    boolean inObject \u003d _parsingContext.inObject();\r\n    if (inObject) {\r\n        // First, field name itself:\r\n        _updateNameLocation();\r\n        String name \u003d (i \u003d\u003d INT_QUOTE) ? _parseName() : _handleOddName(i);\r\n        _parsingContext.setCurrentName(name);\r\n        _updateToken(JsonToken.FIELD_NAME);\r\n        i \u003d _skipColon();\r\n    }\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it?\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            t \u003d JsonToken.VALUE_STRING;\r\n            break;\r\n        case \u0027[\u0027:\r\n            if (!inObject) {\r\n                createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            if (!inObject) {\r\n                createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            }\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027}\u0027:\r\n            // Error: } is not valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(i, \"expected a value\");\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleOddValue(i);\r\n            }\r\n            break;\r\n        case // [core#61]]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleOddValue(i);\r\n            break;\r\n    }\r\n    if (inObject) {\r\n        _nextToken \u003d t;\r\n        return _currToken;\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "ReaderBasedJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser",
    "methodName": "currentTokenLocation",
    "signature": "com.fasterxml.jackson.core.JsonLocation currentTokenLocation()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        long total \u003d _currInputProcessed + (_nameStartOffset - 1);\r\n        return new JsonLocation(_contentReference(), -1L, total, _nameStartRow, _nameStartCol);\r\n    }\r\n    return new JsonLocation(_contentReference(), -1L, _tokenInputTotal - 1, _tokenInputRow, _tokenInputCol);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ReaderBasedJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $l6 \u003d ReaderBasedJsonParser: long _currInputProcessed\u003e\n  $l4 \u003d ReaderBasedJsonParser: long _nameStartOffset\u003e\n  $l5 \u003d $l4 - 1L\n  l7 \u003d $l6 + $l5\n  $r5 \u003d JsonLocation\n  $r6 \u003d r0._contentReference()\n  $i9 \u003d ReaderBasedJsonParser: int _nameStartRow\u003e\n  $i8 \u003d ReaderBasedJsonParser: int _nameStartCol\u003e\n  new JsonLocation($r6, -1L, l7, $i9, $i8)\n  return\n}",
      "B2 {\n  $r3 \u003d JsonLocation\n  $r4 \u003d r0._contentReference()\n  $l0 \u003d ReaderBasedJsonParser: long _tokenInputTotal\u003e\n  $l3 \u003d $l0 - 1L\n  $i2 \u003d ReaderBasedJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d ReaderBasedJsonParser: int _tokenInputCol\u003e\n  new JsonLocation($r4, -1L, $l3, $i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReaderBasedJsonParser#_contentReference(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getText",
    "signature": "java.lang.String getText()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r7 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $r6 \u003d $r5.contentsAsString()\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken _currToken\u003e\n  $r4 \u003d r0._getText2($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_getText2(...1)",
        "body": "{\r\n    if (t \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(t.id()) {\r\n        case ID_FIELD_NAME:\r\n            return _parsingContext.getCurrentName();\r\n        case ID_STRING:\r\n        // fall through\r\n        case ID_NUMBER_INT:\r\n        case ID_NUMBER_FLOAT:\r\n            return _textBuffer.contentsAsString();\r\n        default:\r\n            return t.asString();\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getText",
    "signature": "int getText(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsToWriter(writer);\r\n    }\r\n    if (t \u003d\u003d JsonToken.FIELD_NAME) {\r\n        String n \u003d _parsingContext.getCurrentName();\r\n        writer.write(n);\r\n        return n.length();\r\n    }\r\n    if (t !\u003d null) {\r\n        if (t.isNumeric()) {\r\n            return _textBuffer.contentsToWriter(writer);\r\n        }\r\n        char[] ch \u003d t.asCharArray();\r\n        writer.write(ch);\r\n        return ch.length;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d $r2) → B1 | else → B4",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(r1 !\u003d $r3) → B5 | else → B6",
      "B6 : If(r1 \u003d\u003d null) → B7 | else → B10",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  Writer\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_STRING\u003e\n  if (r1 !\u003d $r2) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r7.contentsToWriter(r4)\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if (r1 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d JsonReadContext _parsingContext\u003e\n  r8 \u003d $r6.getCurrentName()\n  r4.write(r8)\n  $i2 \u003d r8.length()\n  return\n}",
      "B6 {\n  if (r1 \u003d\u003d null) goto B7 else B10\n}",
      "B7 {\n  $z0 \u003d r1.isNumeric()\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r5.contentsToWriter(r4)\n  return\n}",
      "B9 {\n  r9 \u003d r1.asCharArray()\n  r4.write(r9)\n  $i0 \u003d lengthof r9\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_finishString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(null);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r9 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $r8 \u003d $r7.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r5 \u003d r0.getValueAsString(null)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#currentName(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(defValue);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  String\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r10 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r8 \u003d TextBuffer _textBuffer\u003e\n  $r9 \u003d $r8.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r6 \u003d r0.getValueAsString(r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#currentName(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getValueAsInt",
    "signature": "int getValueAsInt()",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if ((t \u003d\u003d JsonToken.VALUE_NUMBER_INT) || (t \u003d\u003d JsonToken.VALUE_NUMBER_FLOAT)) {\r\n        // inlined \u0027getIntValue()\u0027\r\n        if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n            if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n                return _parseIntValue();\r\n            }\r\n            if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n                convertNumberToInt();\r\n            }\r\n        }\r\n        return _numberInt;\r\n    }\r\n    return super.getValueAsInt(0);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If(r1 !\u003d $r3) → B2 | else → B8",
      "B2 : If($i1 !\u003d 0) → B3 | else → B7",
      "B3 : If($i2 !\u003d 0) → B4 | else → B5",
      "B5 : If($i4 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonToken VALUE_NUMBER_FLOAT\u003e\n  if (r1 !\u003d $r3) goto B2 else B8\n}",
      "B2 {\n  $i0 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  $i2 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i5 \u003d r0._parseIntValue()\n  return\n}",
      "B5 {\n  $i3 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r0.convertNumberToInt()\n}",
      "B7 {\n  $i7 \u003d UTF8DataInputJsonParser: int _numberInt\u003e\n  return\n}",
      "B8 {\n  $i6 \u003d r0.getValueAsInt(0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_parseIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#convertNumberToInt(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getValueAsInt",
    "signature": "int getValueAsInt(int)",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if ((t \u003d\u003d JsonToken.VALUE_NUMBER_INT) || (t \u003d\u003d JsonToken.VALUE_NUMBER_FLOAT)) {\r\n        // inlined \u0027getIntValue()\u0027\r\n        if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n            if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n                return _parseIntValue();\r\n            }\r\n            if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n                convertNumberToInt();\r\n            }\r\n        }\r\n        return _numberInt;\r\n    }\r\n    return super.getValueAsInt(defValue);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If(r1 !\u003d $r3) → B2 | else → B8",
      "B2 : If($i1 !\u003d 0) → B3 | else → B7",
      "B3 : If($i2 !\u003d 0) → B4 | else → B5",
      "B5 : If($i4 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  i6 :\u003d @parameter0: int\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonToken VALUE_NUMBER_FLOAT\u003e\n  if (r1 !\u003d $r3) goto B2 else B8\n}",
      "B2 {\n  $i0 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  $i2 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i5 \u003d r0._parseIntValue()\n  return\n}",
      "B5 {\n  $i3 \u003d UTF8DataInputJsonParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r0.convertNumberToInt()\n}",
      "B7 {\n  $i8 \u003d UTF8DataInputJsonParser: int _numberInt\u003e\n  return\n}",
      "B8 {\n  $i7 \u003d r0.getValueAsInt(i6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_parseIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#convertNumberToInt(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getTextCharacters",
    "signature": "char[] getTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                if (!_nameCopied) {\r\n                    String name \u003d _parsingContext.getCurrentName();\r\n                    int nameLen \u003d name.length();\r\n                    if (_nameCopyBuffer \u003d\u003d null) {\r\n                        _nameCopyBuffer \u003d _ioContext.allocNameCopyBuffer(nameLen);\r\n                    } else if (_nameCopyBuffer.length \u003c nameLen) {\r\n                        _nameCopyBuffer \u003d new char[nameLen];\r\n                    }\r\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\r\n                    _nameCopied \u003d true;\r\n                }\r\n                return _nameCopyBuffer;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextBuffer();\r\n            default:\r\n                return _currToken.asCharArray();\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B13",
      "B1 : If(switch-on $i0) → B2 | else → B9",
      "B2 : If($z1 !\u003d 0) → B3 | else → B8",
      "B3 : If($r5 !\u003d null) → B4 | else → B5",
      "B5 : If($i2 \u003e\u003d i1) → B6 | else → B7",
      "B9 : If($z0 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B13\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  JsonToken _currToken\u003e; }\n}",
      "B2 {\n  $z1 \u003d UTF8DataInputJsonParser: boolean _nameCopied\u003e\n  if ($z1 !\u003d 0) goto B3 else B8\n}",
      "B3 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  r4 \u003d $r3.getCurrentName()\n  i1 \u003d r4.length()\n  $r5 \u003d UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e\n  if ($r5 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d IOContext _ioContext\u003e\n  $r9 \u003d $r8.allocNameCopyBuffer(i1)\n  UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e \u003d $r9\n  goto B7\n}",
      "B5 {\n  $r6 \u003d UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e\n  $i2 \u003d lengthof $r6\n  if ($i2 \u003e\u003d i1) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d newarray (char)[i1]\n  UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e \u003d $r7\n}",
      "B7 {\n  $r12 \u003d UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e\n  r4.getChars(0, i1, $r12, 0)\n  UTF8DataInputJsonParser: boolean _nameCopied\u003e \u003d 1\n}",
      "B8 {\n  $r13 \u003d UTF8DataInputJsonParser: char[] _nameCopyBuffer\u003e\n  return\n}",
      "B9 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B11 {\n  $r14 \u003d TextBuffer _textBuffer\u003e\n  $r15 \u003d $r14.getTextBuffer()\n  return\n}",
      "B12 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d $r10.asCharArray()\n  return\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B13",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B1 --\u003e B11",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_finishString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getTextLength",
    "signature": "int getTextLength()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.size();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _parsingContext.getCurrentName().length();\r\n    }\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        if (_currToken.isNumeric()) {\r\n            return _textBuffer.size();\r\n        }\r\n        return _currToken.asCharArray().length;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6",
      "B6 : If($r5 \u003d\u003d null) → B7 | else → B10",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r12 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r12.size()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $r11 \u003d $r10.getCurrentName()\n  $i2 \u003d $r11.length()\n  return\n}",
      "B6 {\n  $r5 \u003d JsonToken _currToken\u003e\n  if ($r5 \u003d\u003d null) goto B7 else B10\n}",
      "B7 {\n  $r6 \u003d JsonToken _currToken\u003e\n  $z0 \u003d $r6.isNumeric()\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r9.size()\n  return\n}",
      "B9 {\n  $r7 \u003d JsonToken _currToken\u003e\n  $r8 \u003d $r7.asCharArray()\n  $i0 \u003d lengthof $r8\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_finishString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getTextOffset",
    "signature": "int getTextOffset()",
    "visibility": "public",
    "body": "{\r\n    // Most have offset of 0, only some may have other values:\r\n    if (_currToken !\u003d null) {\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                return 0;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextOffset();\r\n            default:\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B6",
      "B1 : If(switch-on $i0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  TextBuffer _textBuffer\u003e;     default: goto return 0; }\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B5 {\n  $r3 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r3.getTextOffset()\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B5",
      "B1 --\u003e B6",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_finishString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "getBinaryValue",
    "signature": "byte[] getBinaryValue(com.fasterxml.jackson.core.Base64Variant)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING \u0026\u0026 (_currToken !\u003d JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue \u003d\u003d null)) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    /* To ensure that we won\u0027t see inconsistent data, better clear up\r\n         * state...\r\n         */\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        /* let\u0027s clear incomplete only now; allows for accessing other\r\n             * textual content in error cases\r\n             */\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B4",
      "B1 : If($r9 !\u003d $r8) → B2 | else → B3",
      "B2 : If($r13 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B8",
      "B8 : If($r3 !\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  Base64Variant\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $r9 \u003d JsonToken _currToken\u003e\n  $r8 \u003d JsonToken VALUE_EMBEDDED_OBJECT\u003e\n  if ($r9 !\u003d $r8) goto B2 else B3\n}",
      "B2 {\n  $r13 \u003d UTF8DataInputJsonParser: byte[] _binaryValue\u003e\n  if ($r13 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d String.valueOf($r10)\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportError($r12)\n}",
      "B4 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $r7 \u003d r0._decodeBase64(r4)\n  UTF8DataInputJsonParser: byte[] _binaryValue\u003e \u003d $r7\n  goto B7\n}",
      "B6 {\n  $r14 :\u003d @caughtexception\n  $r16 \u003d String.valueOf(r4)\n  $r15 \u003d $r14.getMessage()\n  $r17 \u003d dynInvoke makeConcatWithConstants($r16, $r15)\n  $r18 \u003d r0._constructError($r17)\n  throw $r18\n}",
      "B7 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  goto B10\n}",
      "B8 {\n  $r3 \u003d UTF8DataInputJsonParser: byte[] _binaryValue\u003e\n  if ($r3 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  r19 \u003d r0._getByteArrayBuilder()\n  $r5 \u003d r0.getText()\n  r0._decodeBase64($r5, r19, r4)\n  $r6 \u003d r19.toByteArray()\n  UTF8DataInputJsonParser: byte[] _binaryValue\u003e \u003d $r6\n}",
      "B10 {\n  $r20 \u003d UTF8DataInputJsonParser: byte[] _binaryValue\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_decodeBase64(...1)",
        "body": "{\r\n    ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n    //main_loop:\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        int ch;\r\n        do {\r\n            ch \u003d _inputData.readUnsignedByte();\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            // reached the end, fair and square?\r\n            if (ch \u003d\u003d INT_QUOTE) {\r\n                return builder.toByteArray();\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    builder.append(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                ch \u003d _inputData.readUnsignedByte();\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if ((ch !\u003d INT_BACKSLASH) || _decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                builder.append(decodedData);\r\n                continue;\r\n            }\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    builder.appendTwoBytes(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                /* With padding we only get 2 bytes; but we have\r\n                     * to shift it a bit so it is identical to triplet\r\n                     * case with partial output.\r\n                     * 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are\r\n                     * dummies, need to discard:\r\n                     */\r\n                decodedData \u003e\u003e\u003d 2;\r\n                builder.appendTwoBytes(decodedData);\r\n                continue;\r\n            }\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        builder.appendThreeBytes(decodedData);\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_getByteArrayBuilder(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_decodeBase64(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_constructError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "readBinaryValue",
    "signature": "int readBinaryValue(com.fasterxml.jackson.core.Base64Variant,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    // if we have already read the token, just use whatever we may have\r\n    if (!_tokenIncomplete || _currToken !\u003d JsonToken.VALUE_STRING) {\r\n        byte[] b \u003d getBinaryValue(b64variant);\r\n        out.write(b);\r\n        return b.length;\r\n    }\r\n    // otherwise do \"real\" incremental parsing...\r\n    byte[] buf \u003d _ioContext.allocBase64Buffer();\r\n    try {\r\n        return _readBinary(b64variant, out, buf);\r\n    } finally {\r\n        _ioContext.releaseBase64Buffer(buf);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B1 : If($r4 \u003d\u003d $r3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  Base64Variant\n  OutputStream\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 \u003d\u003d $r3) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d r0.getBinaryValue(r1)\n  r2.write($r7)\n  $i0 \u003d lengthof $r7\n  return\n}",
      "B3 {\n  $r5 \u003d IOContext _ioContext\u003e\n  r10 \u003d $r5.allocBase64Buffer()\n  i1 \u003d r0._readBinary(r1, r2, r10)\n  $r6 \u003d IOContext _ioContext\u003e\n  $r6.releaseBase64Buffer(r10)\n  return\n}",
      "B4 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d IOContext _ioContext\u003e\n  $r9.releaseBase64Buffer(r10)\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#getBinaryValue(...1)",
        "body": "{\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING \u0026\u0026 (_currToken !\u003d JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue \u003d\u003d null)) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    /* To ensure that we won\u0027t see inconsistent data, better clear up\r\n         * state...\r\n         */\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        /* let\u0027s clear incomplete only now; allows for accessing other\r\n             * textual content in error cases\r\n             */\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_readBinary(...3)",
        "body": "{\r\n    int outputPtr \u003d 0;\r\n    final int outputEnd \u003d buffer.length - 3;\r\n    int outputCount \u003d 0;\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        int ch;\r\n        do {\r\n            ch \u003d _inputData.readUnsignedByte();\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            // reached the end, fair and square?\r\n            if (ch \u003d\u003d INT_QUOTE) {\r\n                break;\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        // enough room? If not, flush\r\n        if (outputPtr \u003e outputEnd) {\r\n            outputCount +\u003d outputPtr;\r\n            out.write(buffer, 0, outputPtr);\r\n            outputPtr \u003d 0;\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // Ok, must get padding\r\n                ch \u003d _inputData.readUnsignedByte();\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if ((ch !\u003d INT_BACKSLASH) || _decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        ch \u003d _inputData.readUnsignedByte();\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                /* With padding we only get 2 bytes; but we have\r\n                     * to shift it a bit so it is identical to triplet\r\n                     * case with partial output.\r\n                     * 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are\r\n                     * dummies, need to discard:\r\n                     */\r\n                decodedData \u003e\u003e\u003d 2;\r\n                buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 16);\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n        buffer[outputPtr++] \u003d (byte) decodedData;\r\n    }\r\n    _tokenIncomplete \u003d false;\r\n    if (outputPtr \u003e 0) {\r\n        outputCount +\u003d outputPtr;\r\n        out.write(buffer, 0, outputPtr);\r\n    }\r\n    return outputCount;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    if (_closed) {\r\n        return null;\r\n    }\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for\r\n         * Object contexts, since the intermediate \u0027expect-value\u0027\r\n         * state is never retained.\r\n         */\r\n    if (!_parsingContext.inObject()) {\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}",
    "nodes": 34,
    "edges": 47,
    "cc": 15,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r2 !\u003d $r1) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($i7 \u003e\u003d 0) → B7 | else → B8",
      "B8 : If($i1 !\u003d 125) → B9 | else → B10",
      "B10 : If($z2 \u003d\u003d false) → B11 | else → B16",
      "B11 : If($i7 \u003d\u003d 44) → B12 | else → B13",
      "B13 : If($i4 \u003d\u003d false) → B14 | else → B16",
      "B14 : If($i5 !\u003d 125) → B15 | else → B16",
      "B16 : If($z4 !\u003d 0) → B17 | else → B18",
      "B18 : If(i9 !\u003d 34) → B19 | else → B20",
      "B20 : If(switch-on i9) → B22 | else → B21",
      "B22 : If($z3 \u003d\u003d false) → B23 | else → B24"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $z0 \u003d UTF8DataInputJsonParser: boolean _closed\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B3 else B4\n}",
      "B3 {\n  $r18 \u003d r0._nextAfterName()\n  return\n}",
      "B4 {\n  UTF8DataInputJsonParser: int _numTypesValid\u003e \u003d 0\n  $z1 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r0._skipString()\n}",
      "B6 {\n  $i7 \u003d r0._skipWSOrEnd()\n  i8 \u003d $i7\n  if ($i7 \u003e\u003d 0) goto B7 else B8\n}",
      "B7 {\n  r0.close()\n  $r17 \u003d r0._updateTokenToNull()\n  return\n}",
      "B8 {\n  UTF8DataInputJsonParser: byte[] _binaryValue\u003e \u003d null\n  $i0 \u003d UTF8DataInputJsonParser: int _currInputRow\u003e\n  UTF8DataInputJsonParser: int _tokenInputRow\u003e \u003d $i0\n  $i1 \u003d $i7 | 32\n  if ($i1 !\u003d 125) goto B9 else B10\n}",
      "B9 {\n  r0._closeScope($i7)\n  $r16 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B10 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z2 \u003d $r3.expectComma()\n  if ($z2 \u003d\u003d false) goto B11 else B16\n}",
      "B11 {\n  if ($i7 \u003d\u003d 44) goto B12 else B13\n}",
      "B12 {\n  $r13 \u003d JsonReadContext _parsingContext\u003e\n  $r14 \u003d $r13.typeDesc()\n  $r15 \u003d dynInvoke makeConcatWithConstants($r14)\n  r0._reportUnexpectedChar($i7, $r15)\n}",
      "B13 {\n  $i6 \u003d r0._skipWS()\n  i8 \u003d $i6\n  $i3 \u003d UTF8DataInputJsonParser: int _features\u003e\n  $i2 \u003d UTF8DataInputJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i4 \u003d $i3 \u0026 $i2\n  if ($i4 \u003d\u003d false) goto B14 else B16\n}",
      "B14 {\n  $i5 \u003d $i6 | 32\n  if ($i5 !\u003d 125) goto B15 else B16\n}",
      "B15 {\n  r0._closeScope($i6)\n  $r12 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B16 {\n  $r19 \u003d JsonReadContext _parsingContext\u003e\n  $z4 \u003d $r19.inObject()\n  if ($z4 !\u003d 0) goto B17 else B18\n}",
      "B17 {\n  $r11 \u003d r0._nextTokenNotInObject(i8)\n  return\n}",
      "B18 {\n  r4 \u003d r0._parseName(i8)\n  $r5 \u003d JsonReadContext _parsingContext\u003e\n  $r5.setCurrentName(r4)\n  $r6 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r6)\n  i9 \u003d r0._skipColon()\n  if (i9 !\u003d 34) goto B19 else B20\n}",
      "B19 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  $r10 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B20 {\n  JsonToken _handleUnexpectedValue(int)\u003e(i9); }\n}",
      "B21 {\n  r20 \u003d r0._parseNegNumber()\n  goto B33\n}",
      "B22 {\n  $r7 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r8 \u003d $r7.mappedFeature()\n  $z3 \u003d r0.isEnabled($r8)\n  if ($z3 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  r20 \u003d r0._parsePosNumber()\n  goto B33\n}",
      "B24 {\n  r20 \u003d r0._handleUnexpectedValue(i9)\n  goto B33\n}",
      "B25 {\n  r20 \u003d r0._parseFloatThatStartsWithPeriod(0, 0)\n  goto B33\n}",
      "B26 {\n  r20 \u003d r0._parseUnsignedNumber(i9)\n  goto B33\n}",
      "B27 {\n  r0._matchToken(\"false\", 1)\n  r20 \u003d JsonToken VALUE_FALSE\u003e\n  goto B33\n}",
      "B28 {\n  r0._matchToken(\"null\", 1)\n  r20 \u003d JsonToken VALUE_NULL\u003e\n  goto B33\n}",
      "B29 {\n  r0._matchToken(\"true\", 1)\n  r20 \u003d JsonToken VALUE_TRUE\u003e\n  goto B33\n}",
      "B30 {\n  r20 \u003d JsonToken START_ARRAY\u003e\n  goto B33\n}",
      "B31 {\n  r20 \u003d JsonToken START_OBJECT\u003e\n  goto B33\n}",
      "B32 {\n  r20 \u003d r0._handleUnexpectedValue(i9)\n}",
      "B33 {\n  JsonToken _nextToken\u003e \u003d r20\n  $r21 \u003d JsonToken _currToken\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B22",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B20 --\u003e B26",
      "B20 --\u003e B30",
      "B20 --\u003e B27",
      "B20 --\u003e B28",
      "B20 --\u003e B29",
      "B20 --\u003e B31",
      "B20 --\u003e B32",
      "B21 --\u003e B33",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B33",
      "B24 --\u003e B33",
      "B25 --\u003e B33",
      "B26 --\u003e B33",
      "B27 --\u003e B33",
      "B28 --\u003e B33",
      "B29 --\u003e B33",
      "B30 --\u003e B33",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_parseName(...1)",
        "body": "{\r\n    if (i !\u003d INT_QUOTE) {\r\n        return _handleOddName(i);\r\n    }\r\n    // If so, can also unroll loops nicely\r\n    /* 25-Nov-2008, tatu: This may seem weird, but here we do\r\n         *   NOT want to worry about UTF-8 decoding. Rather, we\u0027ll\r\n         *   assume that part is ok (if not it will get caught\r\n         *   later on), and just handle quotes and backslashes here.\r\n         */\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    int q \u003d _inputData.readUnsignedByte();\r\n    if (codes[q] \u003d\u003d 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (codes[i] \u003d\u003d 0) {\r\n            q \u003d (q \u003c\u003c 8) | i;\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (codes[i] \u003d\u003d 0) {\r\n                q \u003d (q \u003c\u003c 8) | i;\r\n                i \u003d _inputData.readUnsignedByte();\r\n                if (codes[i] \u003d\u003d 0) {\r\n                    q \u003d (q \u003c\u003c 8) | i;\r\n                    i \u003d _inputData.readUnsignedByte();\r\n                    if (codes[i] \u003d\u003d 0) {\r\n                        _quad1 \u003d q;\r\n                        return _parseMediumName(i);\r\n                    }\r\n                    if (i \u003d\u003d INT_QUOTE) {\r\n                        // 4 byte/char case or broken\r\n                        return findName(q, 4);\r\n                    }\r\n                    return parseName(q, i, 4);\r\n                }\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    // 3 byte/char case or broken\r\n                    return findName(q, 3);\r\n                }\r\n                return parseName(q, i, 3);\r\n            }\r\n            if (i \u003d\u003d INT_QUOTE) {\r\n                // 2 byte/char case or broken\r\n                return findName(q, 2);\r\n            }\r\n            return parseName(q, i, 2);\r\n        }\r\n        if (i \u003d\u003d INT_QUOTE) {\r\n            // one byte/char case or broken\r\n            return findName(q, 1);\r\n        }\r\n        return parseName(q, i, 1);\r\n    }\r\n    if (q \u003d\u003d INT_QUOTE) {\r\n        // special case, \"\"\r\n        return \"\";\r\n    }\r\n    // quoting or invalid char\r\n    return parseName(0, q, 0);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_parsePosNumber(...0)",
        "body": "{\r\n    return _parseSignedNumber(false);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_matchToken(...2)",
        "body": "{\r\n    final int len \u003d matchStr.length();\r\n    do {\r\n        int ch \u003d _inputData.readUnsignedByte();\r\n        if (ch !\u003d matchStr.charAt(i)) {\r\n            _reportInvalidToken(ch, matchStr.substring(0, i));\r\n        }\r\n    } while (++i \u003c len);\r\n    int ch \u003d _inputData.readUnsignedByte();\r\n    if (ch \u003e\u003d \u00270\u0027 \u0026\u0026 ch !\u003d \u0027]\u0027 \u0026\u0026 ch !\u003d \u0027}\u0027) {\r\n        // expected/allowed chars\r\n        _checkMatchEnd(matchStr, i, ch);\r\n    }\r\n    _nextByte \u003d ch;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    int i \u003d _nextByte;\r\n    if (i \u003c 0) {\r\n        try {\r\n            i \u003d _inputData.readUnsignedByte();\r\n        } catch (EOFException e) {\r\n            return _eofAsNextChar();\r\n        }\r\n    } else {\r\n        _nextByte \u003d -1;\r\n    }\r\n    while (true) {\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipWSComment(i);\r\n            }\r\n            return i;\r\n        } else {\r\n            // 06-May-2016, tatu: Could verify validity of WS, but for now why bother.\r\n            //   ... but line number is useful thingy\r\n            if (i \u003d\u003d INT_CR || i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n            }\r\n        }\r\n        try {\r\n            i \u003d _inputData.readUnsignedByte();\r\n        } catch (EOFException e) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseNegNumber());\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                return _updateToken(_parsePosNumber());\r\n            }\r\n            return _updateToken(_handleUnexpectedValue(i));\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false, false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n    }\r\n    return _updateToken(_handleUnexpectedValue(i));\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseNegNumber(...0)",
        "body": "{\r\n    return _parseSignedNumber(true);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr;\r\n    // One special case: if first char is 0, must not be followed by a digit.\r\n    // Gets a bit tricky as we only want to retain 0 if it\u0027s the full value\r\n    if (c \u003d\u003d INT_0) {\r\n        c \u003d _handleLeadingZeroes();\r\n        if (c \u003c\u003d INT_9 \u0026\u0026 c \u003e\u003d INT_0) {\r\n            // skip if followed by digit\r\n            outPtr \u003d 0;\r\n        } else if (c \u003d\u003d \u0027x\u0027 || c \u003d\u003d \u0027X\u0027) {\r\n            return _handleInvalidNumberStart(c, false);\r\n        } else {\r\n            outBuf[0] \u003d \u00270\u0027;\r\n            outPtr \u003d 1;\r\n        }\r\n    } else {\r\n        outBuf[0] \u003d (char) c;\r\n        c \u003d _inputData.readUnsignedByte();\r\n        outPtr \u003d 1;\r\n    }\r\n    int intLen \u003d outPtr;\r\n    // With this, we have a nice and tight loop:\r\n    while (c \u003c\u003d INT_9 \u0026\u0026 c \u003e\u003d INT_0) {\r\n        ++intLen;\r\n        if (outPtr \u003e\u003d outBuf.length) {\r\n            outBuf \u003d _textBuffer.finishCurrentSegment();\r\n            outPtr \u003d 0;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n        c \u003d _inputData.readUnsignedByte();\r\n    }\r\n    if (c \u003d\u003d \u0027.\u0027 || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, false, intLen);\r\n    }\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per [core#105], need separating space between root values; check here\r\n    _nextByte \u003d c;\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace();\r\n    }\r\n    // And there we have it!\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipWS(...0)",
        "body": "{\r\n    int i \u003d _nextByte;\r\n    if (i \u003c 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    } else {\r\n        _nextByte \u003d -1;\r\n    }\r\n    while (true) {\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipWSComment(i);\r\n            }\r\n            return i;\r\n        } else {\r\n            // 06-May-2016, tatu: Could verify validity of WS, but for now why bother.\r\n            //   ... but line number is useful thingy\r\n            if (i \u003d\u003d INT_CR || i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n            }\r\n        }\r\n        i \u003d _inputData.readUnsignedByte();\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        if (!_parsingContext.inArray()) {\r\n            _reportMismatchedEndMarker(i, \u0027}\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        if (!_parsingContext.inObject()) {\r\n            _reportMismatchedEndMarker(i, \u0027]\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseFloatThatStartsWithPeriod(...2)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleUnexpectedValue(INT_PERIOD);\r\n    }\r\n    final char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    if (neg) {\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    // Need to be fully UTF-8 aware here:\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    main_loop: while (true) {\r\n        int c;\r\n        ascii_loop: while (true) {\r\n            c \u003d _inputData.readUnsignedByte();\r\n            if (codes[c] !\u003d 0) {\r\n                break ascii_loop;\r\n            }\r\n        }\r\n        // Ok: end marker, escape or multi-byte?\r\n        if (c \u003d\u003d INT_QUOTE) {\r\n            break main_loop;\r\n        }\r\n        switch(codes[c]) {\r\n            case // backslash\r\n            1:\r\n                _decodeEscaped();\r\n                break;\r\n            case // 2-byte UTF\r\n            2:\r\n                _skipUtf8_2();\r\n                break;\r\n            case // 3-byte UTF\r\n            3:\r\n                _skipUtf8_3();\r\n                break;\r\n            case // 4-byte UTF\r\n            4:\r\n                _skipUtf8_4();\r\n                break;\r\n            default:\r\n                if (c \u003c INT_SPACE) {\r\n                    _throwUnquotedSpace(c, \"string value\");\r\n                } else {\r\n                    // Is this good enough error message?\r\n                    _reportInvalidChar(c);\r\n                }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_handleUnexpectedValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            /* !!! TODO: 08-May-2016, tatu: To support `Feature.ALLOW_MISSING_VALUES` would\r\n             *    need handling here...\r\n             */\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    //               _inputPtr--;\r\n                    _nextByte \u003d c;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n        // fall through\r\n        case \u0027}\u0027:\r\n            // Error: neither is valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(c, \"expected a value\");\r\n        case \u0027\\\u0027\u0027:\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            return _handleInvalidNumberStart(_inputData.readUnsignedByte(), false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(c)) {\r\n        _reportInvalidToken(c, \"\" + ((char) c), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(c, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipColon(...0)",
        "body": "{\r\n    int i \u003d _nextByte;\r\n    if (i \u003c 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    } else {\r\n        _nextByte \u003d -1;\r\n    }\r\n    // Fast path: colon with optional single-space/tab before and/or after:\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(i, true);\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(i, true);\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(i, true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    }\r\n    if (i \u003d\u003d INT_COLON) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(i, true);\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(i, true);\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(i, true);\r\n    }\r\n    return _skipColon2(i, false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "finishToken",
    "signature": "void finishToken()",
    "visibility": "public",
    "body": "{\r\n    if (_tokenIncomplete) {\r\n        _tokenIncomplete \u003d false;\r\n        // only strings can be incomplete\r\n        _finishString();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_finishString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextFieldName",
    "signature": "java.lang.String nextFieldName()",
    "visibility": "public",
    "body": "{\r\n    // // // Note: this is almost a verbatim copy of nextToken()\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        _nextAfterName();\r\n        return null;\r\n    }\r\n    if (_tokenIncomplete) {\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWS();\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return null;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (!_parsingContext.inObject()) {\r\n        _nextTokenNotInObject(i);\r\n        return null;\r\n    }\r\n    final String nameStr \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(nameStr);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return nameStr;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return nameStr;\r\n}",
    "nodes": 30,
    "edges": 43,
    "cc": 15,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i1 !\u003d 125) → B5 | else → B6",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B12",
      "B7 : If($i7 \u003d\u003d 44) → B8 | else → B9",
      "B9 : If($i4 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($i5 !\u003d 125) → B11 | else → B12",
      "B12 : If($z3 !\u003d 0) → B13 | else → B14",
      "B14 : If(i9 !\u003d 34) → B15 | else → B16",
      "B16 : If(switch-on i9) → B18 | else → B17",
      "B18 : If($z2 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  UTF8DataInputJsonParser: int _numTypesValid\u003e \u003d 0\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0._nextAfterName()\n  return\n}",
      "B2 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i7 \u003d r0._skipWS()\n  i8 \u003d $i7\n  UTF8DataInputJsonParser: byte[] _binaryValue\u003e \u003d null\n  $i0 \u003d UTF8DataInputJsonParser: int _currInputRow\u003e\n  UTF8DataInputJsonParser: int _tokenInputRow\u003e \u003d $i0\n  $i1 \u003d $i7 | 32\n  if ($i1 !\u003d 125) goto B5 else B6\n}",
      "B5 {\n  r0._closeScope($i7)\n  return\n}",
      "B6 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B7 else B12\n}",
      "B7 {\n  if ($i7 \u003d\u003d 44) goto B8 else B9\n}",
      "B8 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $r11 \u003d $r10.typeDesc()\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportUnexpectedChar($i7, $r12)\n}",
      "B9 {\n  $i6 \u003d r0._skipWS()\n  i8 \u003d $i6\n  $i3 \u003d UTF8DataInputJsonParser: int _features\u003e\n  $i2 \u003d UTF8DataInputJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i4 \u003d $i3 \u0026 $i2\n  if ($i4 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $i5 \u003d $i6 | 32\n  if ($i5 !\u003d 125) goto B11 else B12\n}",
      "B11 {\n  r0._closeScope($i6)\n  return\n}",
      "B12 {\n  $r13 \u003d JsonReadContext _parsingContext\u003e\n  $z3 \u003d $r13.inObject()\n  if ($z3 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  r0._nextTokenNotInObject(i8)\n  return\n}",
      "B14 {\n  r4 \u003d r0._parseName(i8)\n  $r5 \u003d JsonReadContext _parsingContext\u003e\n  $r5.setCurrentName(r4)\n  $r6 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r6)\n  i9 \u003d r0._skipColon()\n  if (i9 !\u003d 34) goto B15 else B16\n}",
      "B15 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  return\n}",
      "B16 {\n  JsonToken _handleUnexpectedValue(int)\u003e(i9); }\n}",
      "B17 {\n  r14 \u003d r0._parseNegNumber()\n  goto B29\n}",
      "B18 {\n  $r7 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r8 \u003d $r7.mappedFeature()\n  $z2 \u003d r0.isEnabled($r8)\n  if ($z2 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  r14 \u003d r0._parsePosNumber()\n  goto B29\n}",
      "B20 {\n  r14 \u003d r0._handleUnexpectedValue(i9)\n  goto B29\n}",
      "B21 {\n  r0._parseFloatThatStartsWithPeriod(0, 0)\n}",
      "B22 {\n  r14 \u003d r0._parseUnsignedNumber(i9)\n  goto B29\n}",
      "B23 {\n  r0._matchToken(\"false\", 1)\n  r14 \u003d JsonToken VALUE_FALSE\u003e\n  goto B29\n}",
      "B24 {\n  r0._matchToken(\"null\", 1)\n  r14 \u003d JsonToken VALUE_NULL\u003e\n  goto B29\n}",
      "B25 {\n  r0._matchToken(\"true\", 1)\n  r14 \u003d JsonToken VALUE_TRUE\u003e\n  goto B29\n}",
      "B26 {\n  r14 \u003d JsonToken START_ARRAY\u003e\n  goto B29\n}",
      "B27 {\n  r14 \u003d JsonToken START_OBJECT\u003e\n  goto B29\n}",
      "B28 {\n  r14 \u003d r0._handleUnexpectedValue(i9)\n}",
      "B29 {\n  JsonToken _nextToken\u003e \u003d r14\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B12",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B18",
      "B16 --\u003e B17",
      "B16 --\u003e B21",
      "B16 --\u003e B22",
      "B16 --\u003e B26",
      "B16 --\u003e B23",
      "B16 --\u003e B24",
      "B16 --\u003e B25",
      "B16 --\u003e B27",
      "B16 --\u003e B28",
      "B17 --\u003e B29",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B29",
      "B20 --\u003e B29",
      "B21 --\u003e B22",
      "B22 --\u003e B29",
      "B23 --\u003e B29",
      "B24 --\u003e B29",
      "B25 --\u003e B29",
      "B26 --\u003e B29",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#_parseName(...1)",
        "body": "{\r\n    if (i !\u003d INT_QUOTE) {\r\n        return _handleOddName(i);\r\n    }\r\n    // If so, can also unroll loops nicely\r\n    /* 25-Nov-2008, tatu: This may seem weird, but here we do\r\n         *   NOT want to worry about UTF-8 decoding. Rather, we\u0027ll\r\n         *   assume that part is ok (if not it will get caught\r\n         *   later on), and just handle quotes and backslashes here.\r\n         */\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    int q \u003d _inputData.readUnsignedByte();\r\n    if (codes[q] \u003d\u003d 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (codes[i] \u003d\u003d 0) {\r\n            q \u003d (q \u003c\u003c 8) | i;\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (codes[i] \u003d\u003d 0) {\r\n                q \u003d (q \u003c\u003c 8) | i;\r\n                i \u003d _inputData.readUnsignedByte();\r\n                if (codes[i] \u003d\u003d 0) {\r\n                    q \u003d (q \u003c\u003c 8) | i;\r\n                    i \u003d _inputData.readUnsignedByte();\r\n                    if (codes[i] \u003d\u003d 0) {\r\n                        _quad1 \u003d q;\r\n                        return _parseMediumName(i);\r\n                    }\r\n                    if (i \u003d\u003d INT_QUOTE) {\r\n                        // 4 byte/char case or broken\r\n                        return findName(q, 4);\r\n                    }\r\n                    return parseName(q, i, 4);\r\n                }\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    // 3 byte/char case or broken\r\n                    return findName(q, 3);\r\n                }\r\n                return parseName(q, i, 3);\r\n            }\r\n            if (i \u003d\u003d INT_QUOTE) {\r\n                // 2 byte/char case or broken\r\n                return findName(q, 2);\r\n            }\r\n            return parseName(q, i, 2);\r\n        }\r\n        if (i \u003d\u003d INT_QUOTE) {\r\n            // one byte/char case or broken\r\n            return findName(q, 1);\r\n        }\r\n        return parseName(q, i, 1);\r\n    }\r\n    if (q \u003d\u003d INT_QUOTE) {\r\n        // special case, \"\"\r\n        return \"\";\r\n    }\r\n    // quoting or invalid char\r\n    return parseName(0, q, 0);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_parsePosNumber(...0)",
        "body": "{\r\n    return _parseSignedNumber(false);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_matchToken(...2)",
        "body": "{\r\n    final int len \u003d matchStr.length();\r\n    do {\r\n        int ch \u003d _inputData.readUnsignedByte();\r\n        if (ch !\u003d matchStr.charAt(i)) {\r\n            _reportInvalidToken(ch, matchStr.substring(0, i));\r\n        }\r\n    } while (++i \u003c len);\r\n    int ch \u003d _inputData.readUnsignedByte();\r\n    if (ch \u003e\u003d \u00270\u0027 \u0026\u0026 ch !\u003d \u0027]\u0027 \u0026\u0026 ch !\u003d \u0027}\u0027) {\r\n        // expected/allowed chars\r\n        _checkMatchEnd(matchStr, i, ch);\r\n    }\r\n    _nextByte \u003d ch;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseNegNumber());\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                return _updateToken(_parsePosNumber());\r\n            }\r\n            return _updateToken(_handleUnexpectedValue(i));\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false, false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n    }\r\n    return _updateToken(_handleUnexpectedValue(i));\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseNegNumber(...0)",
        "body": "{\r\n    return _parseSignedNumber(true);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr;\r\n    // One special case: if first char is 0, must not be followed by a digit.\r\n    // Gets a bit tricky as we only want to retain 0 if it\u0027s the full value\r\n    if (c \u003d\u003d INT_0) {\r\n        c \u003d _handleLeadingZeroes();\r\n        if (c \u003c\u003d INT_9 \u0026\u0026 c \u003e\u003d INT_0) {\r\n            // skip if followed by digit\r\n            outPtr \u003d 0;\r\n        } else if (c \u003d\u003d \u0027x\u0027 || c \u003d\u003d \u0027X\u0027) {\r\n            return _handleInvalidNumberStart(c, false);\r\n        } else {\r\n            outBuf[0] \u003d \u00270\u0027;\r\n            outPtr \u003d 1;\r\n        }\r\n    } else {\r\n        outBuf[0] \u003d (char) c;\r\n        c \u003d _inputData.readUnsignedByte();\r\n        outPtr \u003d 1;\r\n    }\r\n    int intLen \u003d outPtr;\r\n    // With this, we have a nice and tight loop:\r\n    while (c \u003c\u003d INT_9 \u0026\u0026 c \u003e\u003d INT_0) {\r\n        ++intLen;\r\n        if (outPtr \u003e\u003d outBuf.length) {\r\n            outBuf \u003d _textBuffer.finishCurrentSegment();\r\n            outPtr \u003d 0;\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n        c \u003d _inputData.readUnsignedByte();\r\n    }\r\n    if (c \u003d\u003d \u0027.\u0027 || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, false, intLen);\r\n    }\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per [core#105], need separating space between root values; check here\r\n    _nextByte \u003d c;\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace();\r\n    }\r\n    // And there we have it!\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipWS(...0)",
        "body": "{\r\n    int i \u003d _nextByte;\r\n    if (i \u003c 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    } else {\r\n        _nextByte \u003d -1;\r\n    }\r\n    while (true) {\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipWSComment(i);\r\n            }\r\n            return i;\r\n        } else {\r\n            // 06-May-2016, tatu: Could verify validity of WS, but for now why bother.\r\n            //   ... but line number is useful thingy\r\n            if (i \u003d\u003d INT_CR || i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n            }\r\n        }\r\n        i \u003d _inputData.readUnsignedByte();\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        if (!_parsingContext.inArray()) {\r\n            _reportMismatchedEndMarker(i, \u0027}\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        if (!_parsingContext.inObject()) {\r\n            _reportMismatchedEndMarker(i, \u0027]\u0027);\r\n        }\r\n        _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_parseFloatThatStartsWithPeriod(...2)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleUnexpectedValue(INT_PERIOD);\r\n    }\r\n    final char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    if (neg) {\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    // Need to be fully UTF-8 aware here:\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    main_loop: while (true) {\r\n        int c;\r\n        ascii_loop: while (true) {\r\n            c \u003d _inputData.readUnsignedByte();\r\n            if (codes[c] !\u003d 0) {\r\n                break ascii_loop;\r\n            }\r\n        }\r\n        // Ok: end marker, escape or multi-byte?\r\n        if (c \u003d\u003d INT_QUOTE) {\r\n            break main_loop;\r\n        }\r\n        switch(codes[c]) {\r\n            case // backslash\r\n            1:\r\n                _decodeEscaped();\r\n                break;\r\n            case // 2-byte UTF\r\n            2:\r\n                _skipUtf8_2();\r\n                break;\r\n            case // 3-byte UTF\r\n            3:\r\n                _skipUtf8_3();\r\n                break;\r\n            case // 4-byte UTF\r\n            4:\r\n                _skipUtf8_4();\r\n                break;\r\n            default:\r\n                if (c \u003c INT_SPACE) {\r\n                    _throwUnquotedSpace(c, \"string value\");\r\n                } else {\r\n                    // Is this good enough error message?\r\n                    _reportInvalidChar(c);\r\n                }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#_handleUnexpectedValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            /* !!! TODO: 08-May-2016, tatu: To support `Feature.ALLOW_MISSING_VALUES` would\r\n             *    need handling here...\r\n             */\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    //               _inputPtr--;\r\n                    _nextByte \u003d c;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n        // fall through\r\n        case \u0027}\u0027:\r\n            // Error: neither is valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(c, \"expected a value\");\r\n        case \u0027\\\u0027\u0027:\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            return _handleInvalidNumberStart(_inputData.readUnsignedByte(), false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(c)) {\r\n        _reportInvalidToken(c, \"\" + ((char) c), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(c, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_skipColon(...0)",
        "body": "{\r\n    int i \u003d _nextByte;\r\n    if (i \u003c 0) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    } else {\r\n        _nextByte \u003d -1;\r\n    }\r\n    // Fast path: colon with optional single-space/tab before and/or after:\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(i, true);\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(i, true);\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(i, true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n    }\r\n    if (i \u003d\u003d INT_COLON) {\r\n        i \u003d _inputData.readUnsignedByte();\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(i, true);\r\n            }\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputData.readUnsignedByte();\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(i, true);\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(i, true);\r\n    }\r\n    return _skipColon2(i, false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextTextValue",
    "signature": "java.lang.String nextTextValue()",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n            if (_tokenIncomplete) {\r\n                _tokenIncomplete \u003d false;\r\n                return _finishAndReturnString();\r\n            }\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_STRING) ? getText() : null;\r\n}",
    "nodes": 14,
    "edges": 16,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(r5 !\u003d $r7) → B6 | else → B7",
      "B7 : If(r5 !\u003d $r8) → B8 | else → B9",
      "B10 : If($r4 !\u003d $r3) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  UTF8DataInputJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_STRING\u003e\n  if (r5 !\u003d $r6) goto B2 else B5\n}",
      "B2 {\n  $z0 \u003d UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  UTF8DataInputJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r11 \u003d r0._finishAndReturnString()\n  return\n}",
      "B4 {\n  $r9 \u003d TextBuffer _textBuffer\u003e\n  $r10 \u003d $r9.contentsAsString()\n  return\n}",
      "B5 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i2 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i3, $i2)\n  goto B9\n}",
      "B7 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i0 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i1, $i0)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 !\u003d $r3) goto B11 else B12\n}",
      "B11 {\n  $r12 \u003d r0.getText()\n  goto B13\n}",
      "B12 {\n  $r12 \u003d null\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#nextToken(...0)",
        "body": "{\r\n    if (_closed) {\r\n        return null;\r\n    }\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for\r\n         * Object contexts, since the intermediate \u0027expect-value\u0027\r\n         * state is never retained.\r\n         */\r\n    if (!_parsingContext.inObject()) {\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int outEnd \u003d outBuf.length;\r\n    do {\r\n        int c \u003d _inputData.readUnsignedByte();\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            _finishString2(outBuf, outPtr, c);\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    } while (outPtr \u003c outEnd);\r\n    _finishString2(outBuf, outPtr, _inputData.readUnsignedByte());\r\n    return _textBuffer.contentsAsString();\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextIntValue",
    "signature": "int nextIntValue(int)",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getIntValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  i0 :\u003d @parameter0: int\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  UTF8DataInputJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $i5 \u003d r0.getIntValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $i6 \u003d r0.getIntValue()\n  goto B11\n}",
      "B10 {\n  $i6 \u003d i0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#getIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#nextToken(...0)",
        "body": "{\r\n    if (_closed) {\r\n        return null;\r\n    }\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for\r\n         * Object contexts, since the intermediate \u0027expect-value\u0027\r\n         * state is never retained.\r\n         */\r\n    if (!_parsingContext.inObject()) {\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextLongValue",
    "signature": "long nextLongValue(long)",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getLongValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  l0 :\u003d @parameter0: long\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  UTF8DataInputJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $l5 \u003d r0.getLongValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $l6 \u003d r0.getLongValue()\n  goto B11\n}",
      "B10 {\n  $l6 \u003d l0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#getLongValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#nextToken(...0)",
        "body": "{\r\n    if (_closed) {\r\n        return null;\r\n    }\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for\r\n         * Object contexts, since the intermediate \u0027expect-value\u0027\r\n         * state is never retained.\r\n         */\r\n    if (!_parsingContext.inObject()) {\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8DataInputJsonParser",
    "methodName": "nextBooleanValue",
    "signature": "java.lang.Boolean nextBooleanValue()",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_TRUE) {\r\n            return Boolean.TRUE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.VALUE_FALSE) {\r\n            return Boolean.FALSE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    JsonToken t \u003d nextToken();\r\n    if (t \u003d\u003d JsonToken.VALUE_TRUE) {\r\n        return Boolean.TRUE;\r\n    }\r\n    if (t \u003d\u003d JsonToken.VALUE_FALSE) {\r\n        return Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 15,
    "edges": 16,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r13 !\u003d $r7) → B2 | else → B3",
      "B3 : If(r13 !\u003d $r8) → B4 | else → B5",
      "B5 : If(r13 !\u003d $r9) → B6 | else → B7",
      "B7 : If(r13 !\u003d $r10) → B8 | else → B9",
      "B10 : If(r14 !\u003d $r3) → B11 | else → B12",
      "B12 : If(r14 !\u003d $r4) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  UTF8DataInputJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  UTF8DataInputJsonParser: boolean _nameCopied\u003e \u003d 0\n  r13 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r13)\n  $r7 \u003d JsonToken VALUE_TRUE\u003e\n  if (r13 !\u003d $r7) goto B2 else B3\n}",
      "B2 {\n  $r12 \u003d Boolean TRUE\u003e\n  return\n}",
      "B3 {\n  $r8 \u003d JsonToken VALUE_FALSE\u003e\n  if (r13 !\u003d $r8) goto B4 else B5\n}",
      "B4 {\n  $r11 \u003d Boolean FALSE\u003e\n  return\n}",
      "B5 {\n  $r9 \u003d JsonToken START_ARRAY\u003e\n  if (r13 !\u003d $r9) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i2 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i3, $i2)\n  goto B9\n}",
      "B7 {\n  $r10 \u003d JsonToken START_OBJECT\u003e\n  if (r13 !\u003d $r10) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d UTF8DataInputJsonParser: int _tokenInputRow\u003e\n  $i0 \u003d UTF8DataInputJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i1, $i0)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  r14 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_TRUE\u003e\n  if (r14 !\u003d $r3) goto B11 else B12\n}",
      "B11 {\n  $r6 \u003d Boolean TRUE\u003e\n  return\n}",
      "B12 {\n  $r4 \u003d JsonToken VALUE_FALSE\u003e\n  if (r14 !\u003d $r4) goto B13 else B14\n}",
      "B13 {\n  $r5 \u003d Boolean FALSE\u003e\n  return\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8DataInputJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8DataInputJsonParser#nextToken(...0)",
        "body": "{\r\n    if (_closed) {\r\n        return null;\r\n    }\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    _tokenInputRow \u003d _currInputRow;\r\n    // Closing scope?\r\n    if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n        // ~ \u0027}]\u0027\r\n        _closeScope(i);\r\n        return _currToken;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i | 0x20) \u003d\u003d INT_RCURLY) {\r\n                // ~ \u0027}]\u0027\r\n                _closeScope(i);\r\n                return _currToken;\r\n            }\r\n        }\r\n    }\r\n    /* And should we now have a name? Always true for\r\n         * Object contexts, since the intermediate \u0027expect-value\u0027\r\n         * state is never retained.\r\n         */\r\n    if (!_parsingContext.inObject()) {\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseNegNumber();\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parsePosNumber();\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // as per [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchToken(\"false\", 1);\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchToken(\"null\", 1);\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchToken(\"true\", 1);\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8DataInputJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _writePPFieldName(name);\r\n        return;\r\n    }\r\n    final int status \u003d _writeContext.writeFieldName(name);\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA) {\r\n        // need comma\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_COMMA;\r\n    }\r\n    /* To support [JACKSON-46], we\u0027ll do this:\r\n         * (Question: should quoting of spaces (etc) still be enabled?)\r\n         */\r\n    if (_cfgUnqNames) {\r\n        _writeStringSegments(name, false);\r\n        return;\r\n    }\r\n    final int len \u003d name.length();\r\n    // Does it fit in buffer?\r\n    if (len \u003e _charBufferLength) {\r\n        // no, offline\r\n        _writeStringSegments(name, true);\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // But as one segment, or multiple?\r\n    if (len \u003c\u003d _outputMaxContiguous) {\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(name, 0, len);\r\n    } else {\r\n        _writeStringSegments(name, 0, len);\r\n    }\r\n    // and closing quotes; need room for one more char:\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 22,
    "edges": 28,
    "cc": 8,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 4) → B3 | else → B4",
      "B4 : If(i0 !\u003d 1) → B5 | else → B8",
      "B5 : If($i18 \u003c $i17) → B6 | else → B7",
      "B8 : If($z0 \u003d\u003d false) → B9 | else → B10",
      "B10 : If(i1 \u003c\u003d $i2) → B11 | else → B12",
      "B12 : If($i4 \u003c $i3) → B13 | else → B14",
      "B14 : If(i1 \u003e $i8) → B15 | else → B18",
      "B15 : If($i16 \u003c\u003d $i15) → B16 | else → B17",
      "B19 : If($i10 \u003c $i9) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  String\n  $r1 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writePPFieldName(r2)\n  return\n}",
      "B2 {\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  i0 \u003d $r3.writeFieldName(r2)\n  if (i0 !\u003d 4) goto B3 else B4\n}",
      "B3 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B4 {\n  if (i0 !\u003d 1) goto B5 else B8\n}",
      "B5 {\n  $i18 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i17 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i18 \u003c $i17) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r6 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i19 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i20 \u003d $i19 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i20\n  $r6[$i19] \u003d 44\n}",
      "B8 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgUnqNames\u003e\n  if ($z0 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r0._writeStringSegments(r2, 0)\n  return\n}",
      "B10 {\n  i1 \u003d r2.length()\n  $i2 \u003d UTF8JsonGenerator: int _charBufferLength\u003e\n  if (i1 \u003c\u003d $i2) goto B11 else B12\n}",
      "B11 {\n  r0._writeStringSegments(r2, 1)\n  return\n}",
      "B12 {\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i4 \u003c $i3) goto B13 else B14\n}",
      "B13 {\n  r0._flushBuffer()\n}",
      "B14 {\n  $r4 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i5 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i6 \u003d $i5 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i6\n  $b7 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r4[$i5] \u003d $b7\n  $i8 \u003d UTF8JsonGenerator: int _outputMaxContiguous\u003e\n  if (i1 \u003e $i8) goto B15 else B18\n}",
      "B15 {\n  $i14 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i16 \u003d $i14 + i1\n  $i15 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i16 \u003c\u003d $i15) goto B16 else B17\n}",
      "B16 {\n  r0._flushBuffer()\n}",
      "B17 {\n  r0._writeStringSegment(r2, 0, i1)\n  goto B19\n}",
      "B18 {\n  r0._writeStringSegments(r2, 0, i1)\n}",
      "B19 {\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i9 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i10 \u003c $i9) goto B20 else B21\n}",
      "B20 {\n  r0._flushBuffer()\n}",
      "B21 {\n  $r5 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i11 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i12 \u003d $i11 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i12\n  $b13 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r5[$i11] \u003d $b13\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writePPFieldName(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeFieldName(name);\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    if ((status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\r\n        _cfgPrettyPrinter.writeObjectEntrySeparator(this);\r\n    } else {\r\n        _cfgPrettyPrinter.beforeObjectEntries(this);\r\n    }\r\n    if (_cfgUnqNames) {\r\n        _writeStringSegments(name, false);\r\n        return;\r\n    }\r\n    final int len \u003d name.length();\r\n    if (len \u003e _charBufferLength) {\r\n        _writeStringSegments(name, true);\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    name.getChars(0, len, _charBuffer, 0);\r\n    // But as one segment, or multiple?\r\n    if (len \u003c\u003d _outputMaxContiguous) {\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(_charBuffer, 0, len);\r\n    } else {\r\n        _writeStringSegments(_charBuffer, 0, len);\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegment(...3)",
        "body": "{\r\n    // note: caller MUST ensure (via flushing) there\u0027s room for ASCII only\r\n    // Fast+tight loop for ASCII-only, no-escaping-needed output\r\n    // becomes end marker, then\r\n    len +\u003d offset;\r\n    int outputPtr \u003d _outputTail;\r\n    final byte[] outputBuffer \u003d _outputBuffer;\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    while (offset \u003c len) {\r\n        int ch \u003d cbuf[offset];\r\n        // note: here we know that (ch \u003e 0x7F) will cover case of escaping non-ASCII too:\r\n        if (ch \u003e 0x7F || escCodes[ch] !\u003d 0) {\r\n            break;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) ch;\r\n        ++offset;\r\n    }\r\n    _outputTail \u003d outputPtr;\r\n    if (offset \u003c len) {\r\n        if (_characterEscapes !\u003d null) {\r\n            _writeCustomStringSegment2(cbuf, offset, len);\r\n        } else if (_maximumNonEscapedChar \u003d\u003d 0) {\r\n            _writeStringSegment2(cbuf, offset, len);\r\n        } else {\r\n            _writeStringSegmentASCII2(cbuf, offset, len);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegments(...3)",
        "body": "{\r\n    do {\r\n        int len \u003d Math.min(_outputMaxContiguous, totalLen);\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(cbuf, offset, len);\r\n        offset +\u003d len;\r\n        totalLen -\u003d len;\r\n    } while (totalLen \u003e 0);\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegments(...2)",
        "body": "{\r\n    if (addQuotes) {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    }\r\n    int left \u003d text.length();\r\n    int offset \u003d 0;\r\n    while (left \u003e 0) {\r\n        int len \u003d Math.min(_outputMaxContiguous, left);\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(text, offset, len);\r\n        offset +\u003d len;\r\n        left -\u003d len;\r\n    }\r\n    if (addQuotes) {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _writePPFieldName(name);\r\n        return;\r\n    }\r\n    final int status \u003d _writeContext.writeFieldName(name.getValue());\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA) {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_COMMA;\r\n    }\r\n    if (_cfgUnqNames) {\r\n        _writeUnq(name);\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    int len \u003d name.appendQuotedUTF8(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        // couldn\u0027t append, bit longer processing\r\n        _writeBytes(name.asQuotedUTF8());\r\n    } else {\r\n        _outputTail +\u003d len;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 18,
    "edges": 23,
    "cc": 7,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(i0 !\u003d 4) → B3 | else → B4",
      "B4 : If(i0 !\u003d 1) → B5 | else → B8",
      "B5 : If($i16 \u003c $i15) → B6 | else → B7",
      "B8 : If($z0 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($i2 \u003c $i1) → B11 | else → B12",
      "B12 : If($i14 \u003e\u003d 0) → B13 | else → B14",
      "B15 : If($i10 \u003c $i9) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  SerializableString\n  $r1 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writePPFieldName(r2)\n  return\n}",
      "B2 {\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $r4 \u003d r2.getValue()\n  i0 \u003d $r3.writeFieldName($r4)\n  if (i0 !\u003d 4) goto B3 else B4\n}",
      "B3 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B4 {\n  if (i0 !\u003d 1) goto B5 else B8\n}",
      "B5 {\n  $i16 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i15 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i16 \u003c $i15) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r9 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i17 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i18 \u003d $i17 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i18\n  $r9[$i17] \u003d 44\n}",
      "B8 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgUnqNames\u003e\n  if ($z0 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  r0._writeUnq(r2)\n  return\n}",
      "B10 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B11 else B12\n}",
      "B11 {\n  r0._flushBuffer()\n}",
      "B12 {\n  $r5 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $b5 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r5[$i3] \u003d $b5\n  $r6 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i6 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i14 \u003d r2.appendQuotedUTF8($r6, $i6)\n  if ($i14 \u003e\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $r8 \u003d r2.asQuotedUTF8()\n  r0._writeBytes($r8)\n  goto B15\n}",
      "B14 {\n  $i7 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d $i7 + $i14\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i8\n}",
      "B15 {\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i9 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i10 \u003c $i9) goto B16 else B17\n}",
      "B16 {\n  r0._flushBuffer()\n}",
      "B17 {\n  $r7 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i11 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i12 \u003d $i11 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i12\n  $b13 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r7[$i11] \u003d $b13\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeUnq(...1)",
        "body": "{\r\n    int len \u003d name.appendQuotedUTF8(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        _writeBytes(name.asQuotedUTF8());\r\n    } else {\r\n        _outputTail +\u003d len;\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writePPFieldName(...1)",
        "body": "{\r\n    int status \u003d _writeContext.writeFieldName(name);\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    if ((status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\r\n        _cfgPrettyPrinter.writeObjectEntrySeparator(this);\r\n    } else {\r\n        _cfgPrettyPrinter.beforeObjectEntries(this);\r\n    }\r\n    if (_cfgUnqNames) {\r\n        _writeStringSegments(name, false);\r\n        return;\r\n    }\r\n    final int len \u003d name.length();\r\n    if (len \u003e _charBufferLength) {\r\n        _writeStringSegments(name, true);\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    name.getChars(0, len, _charBuffer, 0);\r\n    // But as one segment, or multiple?\r\n    if (len \u003c\u003d _outputMaxContiguous) {\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(_charBuffer, 0, len);\r\n    } else {\r\n        _writeStringSegments(_charBuffer, 0, len);\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeBytes(...1)",
        "body": "{\r\n    final int len \u003d bytes.length;\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n        // still not enough?\r\n        if (len \u003e MAX_BYTES_TO_BUFFER) {\r\n            _outputStream.write(bytes, 0, len);\r\n            return;\r\n        }\r\n    }\r\n    System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_LBRACKET;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r0._verifyValueWrite(\"start an array\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildArrayContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r7.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r6 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $r6[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext(currentValue);\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_LBRACKET;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Object\n  r0._verifyValueWrite(\"start an array\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d $r2.createChildArrayContext(r1)\n  JsonWriteContext _writeContext\u003e \u003d $r3\n  $r5 \u003d r0.streamWriteConstraints()\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getNestingDepth()\n  $r5.validateNestingDepth($i0)\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r8.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r7 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $r7[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext(currentValue);\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_LBRACKET;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Object\n  i5 :\u003d @parameter1: int\n  r0._verifyValueWrite(\"start an array\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d $r2.createChildArrayContext(r1)\n  JsonWriteContext _writeContext\u003e \u003d $r3\n  $r5 \u003d r0.streamWriteConstraints()\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getNestingDepth()\n  $r5.validateNestingDepth($i0)\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r8.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r7 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $r7[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeEndArray",
    "signature": "void writeEndArray()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_RBRACKET;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i1 \u003c $i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inArray()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d JsonWriteContext _writeContext\u003e\n  $r7 \u003d $r6.typeDesc()\n  $r8 \u003d dynInvoke makeConcatWithConstants($r7)\n  r0._reportError($r8)\n}",
      "B2 {\n  $r2 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i4 \u003d $r4.getEntryCount()\n  $r5.writeEndArray(r0, $i4)\n  goto B7\n}",
      "B4 {\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n  $r3[$i2] \u003d 93\n}",
      "B7 {\n  $r9 \u003d JsonWriteContext _writeContext\u003e\n  $r10 \u003d $r9.clearAndGetParent()\n  JsonWriteContext _writeContext\u003e \u003d $r10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an object\");\r\n    _writeContext \u003d _writeContext.createChildObjectContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartObject(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_LCURLY;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r0._verifyValueWrite(\"start an object\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildObjectContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r7.writeStartObject(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r6 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $r6[$i3] \u003d 123\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an object\");\r\n    JsonWriteContext ctxt \u003d _writeContext.createChildObjectContext(forValue);\r\n    streamWriteConstraints().validateNestingDepth(ctxt.getNestingDepth());\r\n    _writeContext \u003d ctxt;\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartObject(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027{\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Object\n  r0._verifyValueWrite(\"start an object\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  r3 \u003d $r2.createChildObjectContext(r1)\n  $r4 \u003d r0.streamWriteConstraints()\n  $i0 \u003d r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  JsonWriteContext _writeContext\u003e \u003d r3\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r7.writeStartObject(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r6 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $r6[$i3] \u003d 123\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_RCURLY;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i1 \u003c $i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inObject()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d JsonWriteContext _writeContext\u003e\n  $r7 \u003d $r6.typeDesc()\n  $r8 \u003d dynInvoke makeConcatWithConstants($r7)\n  r0._reportError($r8)\n}",
      "B2 {\n  $r2 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i4 \u003d $r4.getEntryCount()\n  $r5.writeEndObject(r0, $i4)\n  goto B7\n}",
      "B4 {\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n  $r3[$i2] \u003d 125\n}",
      "B7 {\n  $r9 \u003d JsonWriteContext _writeContext\u003e\n  $r10 \u003d $r9.clearAndGetParent()\n  JsonWriteContext _writeContext\u003e \u003d $r10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    // First: if we can\u0027t guarantee it all fits, quoted, within output, offline\r\n    final int len \u003d text.length();\r\n    if (len \u003e _outputMaxContiguous) {\r\n        // nope: off-line handling\r\n        _writeStringSegments(text, true);\r\n        return;\r\n    }\r\n    if ((_outputTail + len) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // we checked space already above\r\n    _writeStringSegment(text, 0, len);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003c\u003d $i1) → B3 | else → B4",
      "B4 : If($i4 \u003c $i3) → B5 | else → B6",
      "B6 : If($i9 \u003c $i8) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  String\n  r0._verifyValueWrite(\"write a string\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  return\n}",
      "B2 {\n  i0 \u003d r1.length()\n  $i1 \u003d UTF8JsonGenerator: int _outputMaxContiguous\u003e\n  if (i0 \u003c\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  r0._writeStringSegments(r1, 1)\n  return\n}",
      "B4 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i2 + i0\n  $i3 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i4 \u003c $i3) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i5 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i6 \u003d $i5 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i6\n  $b7 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r2[$i5] \u003d $b7\n  r0._writeStringSegment(r1, 0, i0)\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B7 else B8\n}",
      "B7 {\n  r0._flushBuffer()\n}",
      "B8 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i11\n  $b12 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r3[$i10] \u003d $b12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegment(...3)",
        "body": "{\r\n    // note: caller MUST ensure (via flushing) there\u0027s room for ASCII only\r\n    // Fast+tight loop for ASCII-only, no-escaping-needed output\r\n    // becomes end marker, then\r\n    len +\u003d offset;\r\n    int outputPtr \u003d _outputTail;\r\n    final byte[] outputBuffer \u003d _outputBuffer;\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    while (offset \u003c len) {\r\n        int ch \u003d cbuf[offset];\r\n        // note: here we know that (ch \u003e 0x7F) will cover case of escaping non-ASCII too:\r\n        if (ch \u003e 0x7F || escCodes[ch] !\u003d 0) {\r\n            break;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) ch;\r\n        ++offset;\r\n    }\r\n    _outputTail \u003d outputPtr;\r\n    if (offset \u003c len) {\r\n        if (_characterEscapes !\u003d null) {\r\n            _writeCustomStringSegment2(cbuf, offset, len);\r\n        } else if (_maximumNonEscapedChar \u003d\u003d 0) {\r\n            _writeStringSegment2(cbuf, offset, len);\r\n        } else {\r\n            _writeStringSegmentASCII2(cbuf, offset, len);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\r\n    _outputTail +\u003d 4;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegments(...2)",
        "body": "{\r\n    if (addQuotes) {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    }\r\n    int left \u003d text.length();\r\n    int offset \u003d 0;\r\n    while (left \u003e 0) {\r\n        int len \u003d Math.min(_outputMaxContiguous, left);\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(text, offset, len);\r\n        offset +\u003d len;\r\n        left -\u003d len;\r\n    }\r\n    if (addQuotes) {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(java.io.Reader,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (reader \u003d\u003d null) {\r\n        _reportError(\"null reader\");\r\n        // just to block warnings by lgtm.com\r\n        return;\r\n    }\r\n    int toRead \u003d (len \u003e\u003d 0) ? len : Integer.MAX_VALUE;\r\n    final char[] buf \u003d _charBuffer;\r\n    // Add leading quote\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // read\r\n    while (toRead \u003e 0) {\r\n        int toReadNow \u003d Math.min(toRead, buf.length);\r\n        int numRead \u003d reader.read(buf, 0, toReadNow);\r\n        if (numRead \u003c\u003d 0) {\r\n            break;\r\n        }\r\n        if ((_outputTail + len) \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegments(buf, 0, numRead);\r\n        //decrease tracker\r\n        toRead -\u003d numRead;\r\n    }\r\n    // Add trailing quote\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    if (toRead \u003e 0 \u0026\u0026 len \u003e\u003d 0) {\r\n        _reportError(\"Didn\u0027t read enough from reader\");\r\n    }\r\n}",
    "nodes": 20,
    "edges": 27,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003c 0) → B3 | else → B4",
      "B5 : If($i2 \u003c $i1) → B6 | else → B7",
      "B8 : If(i18 \u003c\u003d 0) → B9 | else → B14",
      "B9 : If(i13 \u003e 0) → B10 | else → B11",
      "B11 : If($i16 \u003c $i15) → B12 | else → B13",
      "B14 : If($i7 \u003c $i6) → B15 | else → B16",
      "B16 : If(i18 \u003c\u003d 0) → B17 | else → B19",
      "B17 : If(i0 \u003c 0) → B18 | else → B19"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Reader\n  i0 :\u003d @parameter1: int\n  r0._verifyValueWrite(\"write a string\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"null reader\")\n  return\n}",
      "B2 {\n  if (i0 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $i17 \u003d i0\n  goto B5\n}",
      "B4 {\n  $i17 \u003d 2147483647\n}",
      "B5 {\n  i18 \u003d $i17\n  $r4 \u003d UTF8JsonGenerator: char[] _charBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i4\n  $b5 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r2[$i3] \u003d $b5\n}",
      "B8 {\n  if (i18 \u003c\u003d 0) goto B9 else B14\n}",
      "B9 {\n  $i11 \u003d lengthof $r4\n  i12 \u003d Math.min(i18, $i11)\n  i13 \u003d r1.read($r4, 0, i12)\n  if (i13 \u003e 0) goto B10 else B11\n}",
      "B10 {\n  goto B14\n}",
      "B11 {\n  $i14 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i16 \u003d $i14 + i0\n  $i15 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i16 \u003c $i15) goto B12 else B13\n}",
      "B12 {\n  r0._flushBuffer()\n}",
      "B13 {\n  r0._writeStringSegments($r4, 0, i13)\n  i18 \u003d i18 - i13\n  goto B8\n}",
      "B14 {\n  $i7 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i6 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i7 \u003c $i6) goto B15 else B16\n}",
      "B15 {\n  r0._flushBuffer()\n}",
      "B16 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i9 \u003d $i8 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i9\n  $b10 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r3[$i8] \u003d $b10\n  if (i18 \u003c\u003d 0) goto B17 else B19\n}",
      "B17 {\n  if (i0 \u003c 0) goto B18 else B19\n}",
      "B18 {\n  r0._reportError(\"Didn\\\u0027t read enough from reader\")\n}",
      "B19 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B8",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B16 --\u003e B19",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegments(...3)",
        "body": "{\r\n    do {\r\n        int len \u003d Math.min(_outputMaxContiguous, totalLen);\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(cbuf, offset, len);\r\n        offset +\u003d len;\r\n        totalLen -\u003d len;\r\n    } while (totalLen \u003e 0);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // One or multiple segments?\r\n    if (len \u003c\u003d _outputMaxContiguous) {\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(text, offset, len);\r\n    } else {\r\n        _writeStringSegments(text, offset, len);\r\n    }\r\n    // And finally, closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If(i5 \u003e $i6) → B3 | else → B6",
      "B3 : If($i15 \u003c\u003d $i14) → B4 | else → B5",
      "B7 : If($i9 \u003c $i8) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r2 :\u003d @parameter0: char[]\n  i7 :\u003d @parameter1: int\n  i5 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a string\")\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n  $b4 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r1[$i2] \u003d $b4\n  $i6 \u003d UTF8JsonGenerator: int _outputMaxContiguous\u003e\n  if (i5 \u003e $i6) goto B3 else B6\n}",
      "B3 {\n  $i13 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i15 \u003d $i13 + i5\n  $i14 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i15 \u003c\u003d $i14) goto B4 else B5\n}",
      "B4 {\n  r0._flushBuffer()\n}",
      "B5 {\n  r0._writeStringSegment(r2, i7, i5)\n  goto B7\n}",
      "B6 {\n  r0._writeStringSegments(r2, i7, i5)\n}",
      "B7 {\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B8 else B9\n}",
      "B8 {\n  r0._flushBuffer()\n}",
      "B9 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i11\n  $b12 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r3[$i10] \u003d $b12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegment(...3)",
        "body": "{\r\n    // note: caller MUST ensure (via flushing) there\u0027s room for ASCII only\r\n    // Fast+tight loop for ASCII-only, no-escaping-needed output\r\n    // becomes end marker, then\r\n    len +\u003d offset;\r\n    int outputPtr \u003d _outputTail;\r\n    final byte[] outputBuffer \u003d _outputBuffer;\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    while (offset \u003c len) {\r\n        int ch \u003d cbuf[offset];\r\n        // note: here we know that (ch \u003e 0x7F) will cover case of escaping non-ASCII too:\r\n        if (ch \u003e 0x7F || escCodes[ch] !\u003d 0) {\r\n            break;\r\n        }\r\n        outputBuffer[outputPtr++] \u003d (byte) ch;\r\n        ++offset;\r\n    }\r\n    _outputTail \u003d outputPtr;\r\n    if (offset \u003c len) {\r\n        if (_characterEscapes !\u003d null) {\r\n            _writeCustomStringSegment2(cbuf, offset, len);\r\n        } else if (_maximumNonEscapedChar \u003d\u003d 0) {\r\n            _writeStringSegment2(cbuf, offset, len);\r\n        } else {\r\n            _writeStringSegmentASCII2(cbuf, offset, len);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeStringSegments(...3)",
        "body": "{\r\n    do {\r\n        int len \u003d Math.min(_outputMaxContiguous, totalLen);\r\n        if ((_outputTail + len) \u003e _outputEnd) {\r\n            // caller must ensure enough space\r\n            _flushBuffer();\r\n        }\r\n        _writeStringSegment(cbuf, offset, len);\r\n        offset +\u003d len;\r\n        totalLen -\u003d len;\r\n    } while (totalLen \u003e 0);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    int len \u003d text.appendQuotedUTF8(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        _writeBytes(text.asQuotedUTF8());\r\n    } else {\r\n        _outputTail +\u003d len;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If($i13 \u003e\u003d 0) → B3 | else → B4",
      "B5 : If($i9 \u003c $i8) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  SerializableString\n  r0._verifyValueWrite(\"write a string\")\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n  $b4 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r1[$i2] \u003d $b4\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i5 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i13 \u003d r2.appendQuotedUTF8($r3, $i5)\n  if ($i13 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d r2.asQuotedUTF8()\n  r0._writeBytes($r5)\n  goto B5\n}",
      "B4 {\n  $i6 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i7 \u003d $i6 + $i13\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i7\n}",
      "B5 {\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r4 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i11\n  $b12 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r4[$i10] \u003d $b12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeBytes(...1)",
        "body": "{\r\n    final int len \u003d bytes.length;\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n        // still not enough?\r\n        if (len \u003e MAX_BYTES_TO_BUFFER) {\r\n            _outputStream.write(bytes, 0, len);\r\n            return;\r\n        }\r\n    }\r\n    System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRawUTF8String",
    "signature": "void writeRawUTF8String(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForByteArray(text, offset, len);\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeBytes(text, offset, len);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i3 \u003c $i2) → B1 | else → B2",
      "B2 : If($i8 \u003c $i7) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForByteArray(r1, i0, i1)\n  r0._verifyValueWrite(\"write a string\")\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i3 \u003c $i2) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  $b6 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r2[$i4] \u003d $b6\n  r0._writeBytes(r1, i0, i1)\n  $i8 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i7 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i8 \u003c $i7) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i10\n  $b11 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r3[$i9] \u003d $b11\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_checkRangeBoundsForByteArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeBytes(...3)",
        "body": "{\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n        // still not enough?\r\n        if (len \u003e MAX_BYTES_TO_BUFFER) {\r\n            _outputStream.write(bytes, offset, len);\r\n            return;\r\n        }\r\n    }\r\n    System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeUTF8String",
    "signature": "void writeUTF8String(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForByteArray(text, offset, len);\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // One or multiple segments?\r\n    if (len \u003c\u003d _outputMaxContiguous) {\r\n        _writeUTF8Segment(text, offset, len);\r\n    } else {\r\n        _writeUTF8Segments(text, offset, len);\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i3 \u003c $i2) → B1 | else → B2",
      "B2 : If(i1 \u003e $i7) → B3 | else → B4",
      "B5 : If($i9 \u003c $i8) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForByteArray(r1, i0, i1)\n  r0._verifyValueWrite(\"write a string\")\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i3 \u003c $i2) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  $b6 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r2[$i4] \u003d $b6\n  $i7 \u003d UTF8JsonGenerator: int _outputMaxContiguous\u003e\n  if (i1 \u003e $i7) goto B3 else B4\n}",
      "B3 {\n  r0._writeUTF8Segment(r1, i0, i1)\n  goto B5\n}",
      "B4 {\n  r0._writeUTF8Segments(r1, i0, i1)\n}",
      "B5 {\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i11\n  $b12 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r3[$i10] \u003d $b12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_checkRangeBoundsForByteArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_writeUTF8Segments(...3)",
        "body": "{\r\n    do {\r\n        int len \u003d Math.min(_outputMaxContiguous, totalLen);\r\n        _writeUTF8Segment(utf8, offset, len);\r\n        offset +\u003d len;\r\n        totalLen -\u003d len;\r\n    } while (totalLen \u003e 0);\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeUTF8Segment(...3)",
        "body": "{\r\n    // fast loop to see if escaping is needed; don\u0027t copy, just look\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    for (int ptr \u003d offset, end \u003d offset + len; ptr \u003c end; ) {\r\n        // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\r\n        int ch \u003d utf8[ptr++];\r\n        if ((ch \u003e\u003d 0) \u0026\u0026 escCodes[ch] !\u003d 0) {\r\n            _writeUTF8Segment2(utf8, offset, len);\r\n            return;\r\n        }\r\n    }\r\n    // yes, fine, just copy the sucker\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        // enough room or need to flush?\r\n        // but yes once we flush (caller guarantees length restriction)\r\n        _flushBuffer();\r\n    }\r\n    System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  String\n  i0 \u003d r0.length()\n  r2 \u003d UTF8JsonGenerator: char[] _charBuffer\u003e\n  $i1 \u003d lengthof r2\n  if (i0 \u003e $i1) goto B1 else B2\n}",
      "B1 {\n  r0.getChars(0, i0, r2, 0)\n  r1.writeRaw(r2, 0, i0)\n  goto B3\n}",
      "B2 {\n  r1.writeRaw(r0, 0, i0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#writeRaw(...3)",
        "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    final char[] buf \u003d _charBuffer;\r\n    final int cbufLen \u003d buf.length;\r\n    // minor optimization: see if we can just get and copy\r\n    if (len \u003c\u003d cbufLen) {\r\n        text.getChars(offset, offset + len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n        return;\r\n    }\r\n    // If not, need segmented approach. For speed, let\u0027s also use input buffer\r\n    // size that is guaranteed to fit in output buffer; each char can expand to\r\n    // at most 3 bytes, so at most 1/3 of buffer size.\r\n    final int maxChunk \u003d Math.min(cbufLen, // \u003d\u003d (1/4 + 1/16) \u003d\u003d 5/16\r\n    (_outputEnd \u003e\u003e 2) + (_outputEnd \u003e\u003e 4));\r\n    final int maxBytes \u003d maxChunk * 3;\r\n    while (len \u003e 0) {\r\n        int len2 \u003d Math.min(maxChunk, len);\r\n        text.getChars(offset, offset + len2, buf, 0);\r\n        if ((_outputTail + maxBytes) \u003e _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        // If this is NOT the last segment and if the last character looks like\r\n        // split surrogate second half, drop it\r\n        // 21-Mar-2017, tatu: Note that we could check for either `len` or `len2`;\r\n        //    point here is really that we only \"punt\" surrogate if it is NOT the\r\n        //    only character left; otherwise we\u0027d end up with a poison pill if the\r\n        //    very last character was unpaired first-surrogate\r\n        if (len2 \u003e 1) {\r\n            char ch \u003d buf[len2 - 1];\r\n            if ((ch \u003e\u003d SURR1_FIRST) \u0026\u0026 (ch \u003c\u003d SURR1_LAST)) {\r\n                --len2;\r\n            }\r\n        }\r\n        _writeRawSegment(buf, 0, len2);\r\n        offset +\u003d len2;\r\n        len -\u003d len2;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    final char[] buf \u003d _charBuffer;\r\n    final int cbufLen \u003d buf.length;\r\n    // minor optimization: see if we can just get and copy\r\n    if (len \u003c\u003d cbufLen) {\r\n        text.getChars(offset, offset + len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n        return;\r\n    }\r\n    // If not, need segmented approach. For speed, let\u0027s also use input buffer\r\n    // size that is guaranteed to fit in output buffer; each char can expand to\r\n    // at most 3 bytes, so at most 1/3 of buffer size.\r\n    final int maxChunk \u003d Math.min(cbufLen, // \u003d\u003d (1/4 + 1/16) \u003d\u003d 5/16\r\n    (_outputEnd \u003e\u003e 2) + (_outputEnd \u003e\u003e 4));\r\n    final int maxBytes \u003d maxChunk * 3;\r\n    while (len \u003e 0) {\r\n        int len2 \u003d Math.min(maxChunk, len);\r\n        text.getChars(offset, offset + len2, buf, 0);\r\n        if ((_outputTail + maxBytes) \u003e _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        // If this is NOT the last segment and if the last character looks like\r\n        // split surrogate second half, drop it\r\n        // 21-Mar-2017, tatu: Note that we could check for either `len` or `len2`;\r\n        //    point here is really that we only \"punt\" surrogate if it is NOT the\r\n        //    only character left; otherwise we\u0027d end up with a poison pill if the\r\n        //    very last character was unpaired first-surrogate\r\n        if (len2 \u003e 1) {\r\n            char ch \u003d buf[len2 - 1];\r\n            if ((ch \u003e\u003d SURR1_FIRST) \u0026\u0026 (ch \u003c\u003d SURR1_LAST)) {\r\n                --len2;\r\n            }\r\n        }\r\n        _writeRawSegment(buf, 0, len2);\r\n        offset +\u003d len2;\r\n        len -\u003d len2;\r\n    }\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i16 \u003e i0) → B1 | else → B2",
      "B3 : If(i16 \u003c\u003d 0) → B4 | else → B11",
      "B4 : If($i11 \u003c\u003d $i10) → B5 | else → B6",
      "B6 : If(i17 \u003c\u003d 1) → B7 | else → B10",
      "B7 : If($i18 \u003c $i20) → B8 | else → B10",
      "B8 : If($i21 \u003e $i23) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  String\n  i15 :\u003d @parameter1: int\n  i16 :\u003d @parameter2: int\n  r0._checkRangeBoundsForString(r1, i15, i16)\n  r2 \u003d UTF8JsonGenerator: char[] _charBuffer\u003e\n  i0 \u003d lengthof r2\n  if (i16 \u003e i0) goto B1 else B2\n}",
      "B1 {\n  $i14 \u003d i15 + i16\n  r1.getChars(i15, $i14, r2, 0)\n  r0.writeRaw(r2, 0, i16)\n  return\n}",
      "B2 {\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  $i4 \u003d $i1 \u003e\u003e 2\n  $i2 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  $i3 \u003d $i2 \u003e\u003e 4\n  $i5 \u003d $i4 + $i3\n  i6 \u003d Math.min(i0, $i5)\n  i7 \u003d i6 * 3\n}",
      "B3 {\n  if (i16 \u003c\u003d 0) goto B4 else B11\n}",
      "B4 {\n  i17 \u003d Math.min(i6, i16)\n  $i8 \u003d i15 + i17\n  r1.getChars(i15, $i8, r2, 0)\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i9 + i7\n  $i10 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i11 \u003c\u003d $i10) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  if (i17 \u003c\u003d 1) goto B7 else B10\n}",
      "B7 {\n  $i12 \u003d i17 - 1\n  c13 \u003d r2[$i12]\n  $i18 \u003d (int) c13\n  $i20 \u003d (int) 55296\n  if ($i18 \u003c $i20) goto B8 else B10\n}",
      "B8 {\n  $i21 \u003d (int) c13\n  $i23 \u003d (int) 56319\n  if ($i21 \u003e $i23) goto B9 else B10\n}",
      "B9 {\n  $i25 \u003d (int) -1\n  i17 \u003d i17 + $i25\n}",
      "B10 {\n  r0._writeRawSegment(r2, 0, i17)\n  i15 \u003d i15 + i17\n  i16 \u003d i16 - i17\n  goto B3\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B11",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B3",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeRawSegment(...3)",
        "body": "{\r\n    main_loop: while (offset \u003c end) {\r\n        inner_loop: while (true) {\r\n            int ch \u003d cbuf[offset];\r\n            if (ch \u003e 0x7F) {\r\n                break inner_loop;\r\n            }\r\n            _outputBuffer[_outputTail++] \u003d (byte) ch;\r\n            if (++offset \u003e\u003d end) {\r\n                break main_loop;\r\n            }\r\n        }\r\n        char ch \u003d cbuf[offset++];\r\n        if (ch \u003c 0x800) {\r\n            // 2-byte?\r\n            _outputBuffer[_outputTail++] \u003d (byte) (0xc0 | (ch \u003e\u003e 6));\r\n            _outputBuffer[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n        } else {\r\n            offset \u003d _outputRawMultiByteChar(ch, cbuf, offset, end);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#writeRaw(...3)",
        "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    final char[] buf \u003d _charBuffer;\r\n    final int cbufLen \u003d buf.length;\r\n    // minor optimization: see if we can just get and copy\r\n    if (len \u003c\u003d cbufLen) {\r\n        text.getChars(offset, offset + len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n        return;\r\n    }\r\n    // If not, need segmented approach. For speed, let\u0027s also use input buffer\r\n    // size that is guaranteed to fit in output buffer; each char can expand to\r\n    // at most 3 bytes, so at most 1/3 of buffer size.\r\n    final int maxChunk \u003d Math.min(cbufLen, // \u003d\u003d (1/4 + 1/16) \u003d\u003d 5/16\r\n    (_outputEnd \u003e\u003e 2) + (_outputEnd \u003e\u003e 4));\r\n    final int maxBytes \u003d maxChunk * 3;\r\n    while (len \u003e 0) {\r\n        int len2 \u003d Math.min(maxChunk, len);\r\n        text.getChars(offset, offset + len2, buf, 0);\r\n        if ((_outputTail + maxBytes) \u003e _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        // If this is NOT the last segment and if the last character looks like\r\n        // split surrogate second half, drop it\r\n        // 21-Mar-2017, tatu: Note that we could check for either `len` or `len2`;\r\n        //    point here is really that we only \"punt\" surrogate if it is NOT the\r\n        //    only character left; otherwise we\u0027d end up with a poison pill if the\r\n        //    very last character was unpaired first-surrogate\r\n        if (len2 \u003e 1) {\r\n            char ch \u003d buf[len2 - 1];\r\n            if ((ch \u003e\u003d SURR1_FIRST) \u0026\u0026 (ch \u003c\u003d SURR1_LAST)) {\r\n                --len2;\r\n            }\r\n        }\r\n        _writeRawSegment(buf, 0, len2);\r\n        offset +\u003d len2;\r\n        len -\u003d len2;\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_checkRangeBoundsForString(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    int len \u003d text.appendUnquotedUTF8(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        _writeBytes(text.asUnquotedUTF8());\r\n    } else {\r\n        _outputTail +\u003d len;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  SerializableString\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  i1 \u003d r0.appendUnquotedUTF8($r2, $i0)\n  if (i1 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.asUnquotedUTF8()\n  r1._writeBytes($r3)\n  goto B3\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + i1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeBytes(...1)",
        "body": "{\r\n    final int len \u003d bytes.length;\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n        // still not enough?\r\n        if (len \u003e MAX_BYTES_TO_BUFFER) {\r\n            _outputStream.write(bytes, 0, len);\r\n            return;\r\n        }\r\n    }\r\n    System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRawValue",
    "signature": "void writeRawValue(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_RAW);\r\n    int len \u003d text.appendUnquotedUTF8(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        _writeBytes(text.asUnquotedUTF8());\r\n    } else {\r\n        _outputTail +\u003d len;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  SerializableString\n  r0._verifyValueWrite(\"write a raw (unencoded) value\")\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  i1 \u003d r1.appendUnquotedUTF8($r2, $i0)\n  if (i1 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.asUnquotedUTF8()\n  r0._writeBytes($r3)\n  goto B3\n}",
      "B2 {\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + i1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeBytes(...1)",
        "body": "{\r\n    final int len \u003d bytes.length;\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n        // still not enough?\r\n        if (len \u003e MAX_BYTES_TO_BUFFER) {\r\n            _outputStream.write(bytes, 0, len);\r\n            return;\r\n        }\r\n    }\r\n    System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForCharArray(cbuf, offset, len);\r\n    // First: if we have 3 x charCount spaces, we know it\u0027ll fit just fine\r\n    {\r\n        int len3 \u003d len + len + len;\r\n        if ((_outputTail + len3) \u003e _outputEnd) {\r\n            // maybe we could flush?\r\n            if (_outputEnd \u003c len3) {\r\n                // wouldn\u0027t be enough...\r\n                _writeSegmentedRaw(cbuf, offset, len);\r\n                return;\r\n            }\r\n            // yes, flushing brings enough space\r\n            _flushBuffer();\r\n        }\r\n    }\r\n    // now marks the end\r\n    len +\u003d offset;\r\n    // Note: here we know there is enough room, hence no output boundary checks\r\n    main_loop: while (offset \u003c len) {\r\n        inner_loop: while (true) {\r\n            int ch \u003d cbuf[offset];\r\n            if (ch \u003e 0x7F) {\r\n                break inner_loop;\r\n            }\r\n            _outputBuffer[_outputTail++] \u003d (byte) ch;\r\n            if (++offset \u003e\u003d len) {\r\n                break main_loop;\r\n            }\r\n        }\r\n        char ch \u003d cbuf[offset++];\r\n        if (ch \u003c 0x800) {\r\n            // 2-byte?\r\n            _outputBuffer[_outputTail++] \u003d (byte) (0xc0 | (ch \u003e\u003e 6));\r\n            _outputBuffer[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n        } else {\r\n            offset \u003d _outputRawMultiByteChar(ch, cbuf, offset, len);\r\n        }\r\n    }\r\n}",
    "nodes": 16,
    "edges": 20,
    "cc": 6,
    "flowSummary": [
      "B0 : If($i3 \u003c\u003d $i2) → B1 | else → B4",
      "B1 : If($i19 \u003e\u003d i23) → B2 | else → B3",
      "B5 : If(i21 \u003e\u003d $i20) → B6 | else → B15",
      "B6 : If($i25 \u003c\u003d 127) → B7 | else → B8",
      "B8 : If(i21 \u003c $i20) → B9 | else → B10",
      "B11 : If($i26 \u003e\u003d 2048) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r1 :\u003d @parameter0: char[]\n  i21 :\u003d @parameter1: int\n  i22 :\u003d @parameter2: int\n  r0._checkRangeBoundsForCharArray(r1, i21, i22)\n  $i0 \u003d i22 + i22\n  i23 \u003d $i0 + i22\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i1 + i23\n  $i2 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i3 \u003c\u003d $i2) goto B1 else B4\n}",
      "B1 {\n  $i19 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i19 \u003e\u003d i23) goto B2 else B3\n}",
      "B2 {\n  r0._writeSegmentedRaw(r1, i21, i22)\n  return\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $i20 \u003d i22 + i21\n}",
      "B5 {\n  if (i21 \u003e\u003d $i20) goto B6 else B15\n}",
      "B6 {\n  $c7 \u003d r1[i21]\n  $i25 \u003d (int) $c7\n  if ($i25 \u003c\u003d 127) goto B7 else B8\n}",
      "B7 {\n  goto B11\n}",
      "B8 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  $b6 \u003d (byte) $c7\n  $r2[$i4] \u003d $b6\n  i21 \u003d i21 + 1\n  if (i21 \u003c $i20) goto B9 else B10\n}",
      "B9 {\n  goto B15\n}",
      "B10 {\n  goto B6\n}",
      "B11 {\n  $i8 \u003d i21\n  i21 \u003d i21 + 1\n  c24 \u003d r1[$i8]\n  $i26 \u003d (int) c24\n  if ($i26 \u003e\u003d 2048) goto B12 else B13\n}",
      "B12 {\n  $r3 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i10\n  $i27 \u003d (int) c24\n  $i11 \u003d $i27 \u003e\u003e 6\n  $i12 \u003d 192 | $i11\n  $b13 \u003d (byte) $i12\n  $r3[$i9] \u003d $b13\n  $r4 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i14 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i15 \u003d $i14 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i15\n  $c16 \u003d c24 \u0026 63\n  $s17 \u003d 128 | $c16\n  $b18 \u003d (byte) $s17\n  $r4[$i14] \u003d $b18\n  goto B14\n}",
      "B13 {\n  $i28 \u003d (int) c24\n  i21 \u003d r0._outputRawMultiByteChar($i28, r1, i21, $i20)\n}",
      "B14 {\n  goto B5\n}",
      "B15 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B15",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B6",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B5",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeSegmentedRaw(...3)",
        "body": "{\r\n    final int end \u003d _outputEnd;\r\n    final byte[] bbuf \u003d _outputBuffer;\r\n    final int inputEnd \u003d offset + len;\r\n    main_loop: while (offset \u003c inputEnd) {\r\n        inner_loop: while (true) {\r\n            int ch \u003d cbuf[offset];\r\n            if (ch \u003e 0x7F) {\r\n                break inner_loop;\r\n            }\r\n            // !!! TODO: fast(er) writes (roll input, output checks in one)\r\n            if (_outputTail \u003e\u003d end) {\r\n                _flushBuffer();\r\n            }\r\n            bbuf[_outputTail++] \u003d (byte) ch;\r\n            if (++offset \u003e\u003d inputEnd) {\r\n                break main_loop;\r\n            }\r\n        }\r\n        if ((_outputTail + 3) \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        char ch \u003d cbuf[offset++];\r\n        if (ch \u003c 0x800) {\r\n            // 2-byte?\r\n            bbuf[_outputTail++] \u003d (byte) (0xc0 | (ch \u003e\u003e 6));\r\n            bbuf[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n        } else {\r\n            offset \u003d _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_outputRawMultiByteChar(...4)",
        "body": "{\r\n    // Let\u0027s handle surrogates gracefully (as 4 byte output):\r\n    if (ch \u003e\u003d SURR1_FIRST) {\r\n        if (ch \u003c\u003d SURR2_LAST) {\r\n            // yes, outside of BMP\r\n            // Do we have second part?\r\n            if (inputOffset \u003e\u003d inputEnd || cbuf \u003d\u003d null) {\r\n                // nope... have to note down\r\n                _reportError(String.format(\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\r\n            } else {\r\n                _outputSurrogates(ch, cbuf[inputOffset]);\r\n            }\r\n            return inputOffset + 1;\r\n        }\r\n    }\r\n    final byte[] bbuf \u003d _outputBuffer;\r\n    bbuf[_outputTail++] \u003d (byte) (0xe0 | (ch \u003e\u003e 12));\r\n    bbuf[_outputTail++] \u003d (byte) (0x80 | ((ch \u003e\u003e 6) \u0026 0x3f));\r\n    bbuf[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n    return inputOffset;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_checkRangeBoundsForCharArray(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char)",
    "visibility": "public",
    "body": "{\r\n    if ((_outputTail + 3) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    final byte[] bbuf \u003d _outputBuffer;\r\n    if (ch \u003c\u003d 0x7F) {\r\n        bbuf[_outputTail++] \u003d (byte) ch;\r\n    } else if (ch \u003c 0x800) {\r\n        // 2-byte?\r\n        bbuf[_outputTail++] \u003d (byte) (0xc0 | (ch \u003e\u003e 6));\r\n        bbuf[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n    } else {\r\n        /*offset \u003d*/\r\n        _outputRawMultiByteChar(ch, null, 0, 0);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If($i17 \u003e 127) → B3 | else → B4",
      "B4 : If($i18 \u003e\u003d 2048) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  c3 :\u003d @parameter0: char\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 3\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i17 \u003d (int) c3\n  if ($i17 \u003e 127) goto B3 else B4\n}",
      "B3 {\n  $i14 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i15 \u003d $i14 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i15\n  $b16 \u003d (byte) c3\n  $r1[$i14] \u003d $b16\n  goto B7\n}",
      "B4 {\n  $i18 \u003d (int) c3\n  if ($i18 \u003e\u003d 2048) goto B5 else B6\n}",
      "B5 {\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  $i19 \u003d (int) c3\n  $i6 \u003d $i19 \u003e\u003e 6\n  $i7 \u003d 192 | $i6\n  $b8 \u003d (byte) $i7\n  $r1[$i4] \u003d $b8\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i10\n  $c11 \u003d c3 \u0026 63\n  $s12 \u003d 128 | $c11\n  $b13 \u003d (byte) $s12\n  $r1[$i9] \u003d $b13\n  goto B7\n}",
      "B6 {\n  $i20 \u003d (int) c3\n  r0._outputRawMultiByteChar($i20, null, 0, 0)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_outputRawMultiByteChar(...4)",
        "body": "{\r\n    // Let\u0027s handle surrogates gracefully (as 4 byte output):\r\n    if (ch \u003e\u003d SURR1_FIRST) {\r\n        if (ch \u003c\u003d SURR2_LAST) {\r\n            // yes, outside of BMP\r\n            // Do we have second part?\r\n            if (inputOffset \u003e\u003d inputEnd || cbuf \u003d\u003d null) {\r\n                // nope... have to note down\r\n                _reportError(String.format(\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\r\n            } else {\r\n                _outputSurrogates(ch, cbuf[inputOffset]);\r\n            }\r\n            return inputOffset + 1;\r\n        }\r\n    }\r\n    final byte[] bbuf \u003d _outputBuffer;\r\n    bbuf[_outputTail++] \u003d (byte) (0xe0 | (ch \u003e\u003e 12));\r\n    bbuf[_outputTail++] \u003d (byte) (0x80 | ((ch \u003e\u003e 6) \u0026 0x3f));\r\n    bbuf[_outputTail++] \u003d (byte) (0x80 | (ch \u0026 0x3f));\r\n    return inputOffset;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeBinary",
    "signature": "void writeBinary(com.fasterxml.jackson.core.Base64Variant,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForByteArray(data, offset, len);\r\n    _verifyValueWrite(WRITE_BINARY);\r\n    // Starting quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeBinary(b64variant, data, offset, offset + len);\r\n    // and closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i3 \u003c $i2) → B1 | else → B2",
      "B2 : If($i9 \u003c $i8) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Base64Variant\n  r1 :\u003d @parameter1: byte[]\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  r0._checkRangeBoundsForByteArray(r1, i0, i1)\n  r0._verifyValueWrite(\"write a binary value\")\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i3 \u003c $i2) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r2 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  $b6 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r2[$i4] \u003d $b6\n  $i7 \u003d i0 + i1\n  r0._writeBinary(r3, r1, i0, $i7)\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i8 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r4 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i10 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i11\n  $b12 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r4[$i10] \u003d $b12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_checkRangeBoundsForByteArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_writeBinary(...4)",
        "body": "{\r\n    // Encoding is by chunks of 3 input, 4 output chars, so:\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    // Let\u0027s also reserve room for possible (and quoted) lf char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            // note: must quote in JSON value\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    // 0, 1 or 2\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeBinary",
    "signature": "int writeBinary(com.fasterxml.jackson.core.Base64Variant,java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_BINARY);\r\n    // Starting quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    byte[] encodingBuffer \u003d _ioContext.allocBase64Buffer();\r\n    int bytes;\r\n    try {\r\n        if (dataLength \u003c 0) {\r\n            // length unknown\r\n            bytes \u003d _writeBinary(b64variant, data, encodingBuffer);\r\n        } else {\r\n            int missing \u003d _writeBinary(b64variant, data, encodingBuffer, dataLength);\r\n            if (missing \u003e 0) {\r\n                _reportError(\"Too few bytes available: missing \" + missing + \" bytes (out of \" + dataLength + \")\");\r\n            }\r\n            bytes \u003d dataLength;\r\n        }\r\n    } finally {\r\n        _ioContext.releaseBase64Buffer(encodingBuffer);\r\n    }\r\n    // and closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    return bytes;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If(i5 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(i6 \u003c\u003d 0) → B5 | else → B6",
      "B9 : If($i8 \u003c $i7) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  Base64Variant\n  InputStream\n  i5 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a binary value\")\n  $i1 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i0 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i2 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i3\n  $b4 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r1[$i2] \u003d $b4\n  $r2 \u003d IOContext _ioContext\u003e\n  $r7 \u003d $r2.allocBase64Buffer()\n  if (i5 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  i12 \u003d r0._writeBinary(r3, r4, $r7)\n  goto B7\n}",
      "B4 {\n  i6 \u003d r0._writeBinary(r3, r4, $r7, i5)\n  if (i6 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d dynInvoke makeConcatWithConstants(i6, i5)\n  r0._reportError($r6)\n}",
      "B6 {\n  i12 \u003d i5\n}",
      "B7 {\n  $r10 \u003d IOContext _ioContext\u003e\n  $r10.releaseBase64Buffer($r7)\n  goto B9\n}",
      "B8 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d IOContext _ioContext\u003e\n  $r9.releaseBase64Buffer($r7)\n  throw $r8\n}",
      "B9 {\n  $i8 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i7 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i8 \u003c $i7) goto B10 else B11\n}",
      "B10 {\n  r0._flushBuffer()\n}",
      "B11 {\n  $r5 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i9 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i10\n  $b11 \u003d UTF8JsonGenerator: byte _quoteChar\u003e\n  $r5[$i9] \u003d $b11\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeBinary(...4)",
        "body": "{\r\n    // Encoding is by chunks of 3 input, 4 output chars, so:\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    // Let\u0027s also reserve room for possible (and quoted) lf char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            // note: must quote in JSON value\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    // 0, 1 or 2\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeBinary(...3)",
        "body": "{\r\n    int inputPtr \u003d 0;\r\n    int inputEnd \u003d 0;\r\n    int lastFullOffset \u003d -3;\r\n    int bytesDone \u003d 0;\r\n    // Let\u0027s also reserve room for possible (and quoted) LF char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (true) {\r\n        if (inputPtr \u003e lastFullOffset) {\r\n            // need to load more\r\n            inputEnd \u003d _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\r\n            inputPtr \u003d 0;\r\n            if (inputEnd \u003c 3) {\r\n                // required to try to read to have at least 3 bytes\r\n                break;\r\n            }\r\n            lastFullOffset \u003d inputEnd - 3;\r\n        }\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (readBuffer[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (readBuffer[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((readBuffer[inputPtr++]) \u0026 0xFF);\r\n        bytesDone +\u003d 3;\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    if (inputPtr \u003c inputEnd) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (readBuffer[inputPtr++]) \u003c\u003c 16;\r\n        int amount \u003d 1;\r\n        if (inputPtr \u003c inputEnd) {\r\n            b24 |\u003d ((readBuffer[inputPtr]) \u0026 0xFF) \u003c\u003c 8;\r\n            amount \u003d 2;\r\n        }\r\n        bytesDone +\u003d amount;\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\r\n    }\r\n    return bytesDone;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(short)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    // up to 5 digits and possible minus sign\r\n    if ((_outputTail + 6) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedShort(s);\r\n        return;\r\n    }\r\n    _outputTail \u003d NumberOutput.outputInt(s, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  s3 :\u003d @parameter0: short\n  r0._verifyValueWrite(\"write a number\")\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 6\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._writeQuotedShort(s3)\n  return\n}",
      "B4 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i6 \u003d (int) s3\n  $i5 \u003d NumberOutput.outputInt($i6, $r1, $i4)\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeQuotedShort(...1)",
        "body": "{\r\n    if ((_outputTail + 8) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputInt(s, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    // up to 10 digits and possible minus sign\r\n    if ((_outputTail + 11) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedInt(i);\r\n        return;\r\n    }\r\n    _outputTail \u003d NumberOutput.outputInt(i, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  i3 :\u003d @parameter0: int\n  r0._verifyValueWrite(\"write a number\")\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 11\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._writeQuotedInt(i3)\n  return\n}",
      "B4 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d NumberOutput.outputInt(i3, $r1, $i4)\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeQuotedInt(...1)",
        "body": "{\r\n    if ((_outputTail + 13) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputInt(i, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(long)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedLong(l);\r\n        return;\r\n    }\r\n    if ((_outputTail + 21) \u003e\u003d _outputEnd) {\r\n        // up to 20 digits, minus sign\r\n        _flushBuffer();\r\n    }\r\n    _outputTail \u003d NumberOutput.outputLong(l, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  l3 :\u003d @parameter0: long\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedLong(l3)\n  return\n}",
      "B2 {\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 21\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d NumberOutput.outputLong(l3, $r1, $i4)\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeQuotedLong(...1)",
        "body": "{\r\n    if ((_outputTail + 23) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputLong(l, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigInteger)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (value \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(value.toString());\r\n    } else {\r\n        writeRaw(value.toString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  BigInteger\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r1.toString()\n  r0._writeQuotedRaw($r3)\n  goto B5\n}",
      "B4 {\n  $r2 \u003d r1.toString()\n  r0.writeRaw($r2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#writeRaw(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\r\n    _outputTail +\u003d 4;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(double)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgNumbersAsStrings || (NumberOutput.notFinite(d) \u0026\u0026 Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features))) {\r\n        writeString(NumberOutput.toString(d, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n        return;\r\n    }\r\n    // What is the max length for doubles? 40 chars?\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    writeRaw(NumberOutput.toString(d, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z2 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  d0 :\u003d @parameter0: double\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z2 \u003d NumberOutput.notFinite(d0)\n  if ($z2 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r5 \u003d JsonGenerator$Feature QUOTE_NON_NUMERIC_NUMBERS\u003e\n  $i0 \u003d UTF8JsonGenerator: int _features\u003e\n  $z4 \u003d $r5.enabledIn($i0)\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z1 \u003d r0.isEnabled($r1)\n  $r2 \u003d NumberOutput.toString(d0, $z1)\n  r0.writeString($r2)\n  return\n}",
      "B4 {\n  r0._verifyValueWrite(\"write a number\")\n  $r3 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z3 \u003d r0.isEnabled($r3)\n  $r4 \u003d NumberOutput.toString(d0, $z3)\n  r0.writeRaw($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#writeString(...1)",
        "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    // First: if we can\u0027t guarantee it all fits, quoted, within output, offline\r\n    final int len \u003d text.length();\r\n    if (len \u003e _outputMaxContiguous) {\r\n        // nope: off-line handling\r\n        _writeStringSegments(text, true);\r\n        return;\r\n    }\r\n    if ((_outputTail + len) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // we checked space already above\r\n    _writeStringSegment(text, 0, len);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#writeRaw(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(float)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgNumbersAsStrings || (NumberOutput.notFinite(f) \u0026\u0026 Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features))) {\r\n        writeString(NumberOutput.toString(f, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n        return;\r\n    }\r\n    // What is the max length for floats?\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    writeRaw(NumberOutput.toString(f, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z2 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  f0 :\u003d @parameter0: float\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z2 \u003d NumberOutput.notFinite(f0)\n  if ($z2 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r5 \u003d JsonGenerator$Feature QUOTE_NON_NUMERIC_NUMBERS\u003e\n  $i0 \u003d UTF8JsonGenerator: int _features\u003e\n  $z4 \u003d $r5.enabledIn($i0)\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z1 \u003d r0.isEnabled($r1)\n  $r2 \u003d NumberOutput.toString(f0, $z1)\n  r0.writeString($r2)\n  return\n}",
      "B4 {\n  r0._verifyValueWrite(\"write a number\")\n  $r3 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z3 \u003d r0.isEnabled($r3)\n  $r4 \u003d NumberOutput.toString(f0, $z3)\n  r0.writeRaw($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#writeString(...1)",
        "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    // First: if we can\u0027t guarantee it all fits, quoted, within output, offline\r\n    final int len \u003d text.length();\r\n    if (len \u003e _outputMaxContiguous) {\r\n        // nope: off-line handling\r\n        _writeStringSegments(text, true);\r\n        return;\r\n    }\r\n    if ((_outputTail + len) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // we checked space already above\r\n    _writeStringSegment(text, 0, len);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#writeRaw(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigDecimal)",
    "visibility": "public",
    "body": "{\r\n    // Don\u0027t really know max length for big decimal, no point checking\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (value \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(_asString(value));\r\n    } else {\r\n        writeRaw(_asString(value));\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  BigDecimal\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0._asString(r1)\n  r0._writeQuotedRaw($r3)\n  goto B5\n}",
      "B4 {\n  $r2 \u003d r0._asString(r1)\n  r0.writeRaw($r2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_asString(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#writeRaw(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\r\n    _outputTail +\u003d 4;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (encodedValue \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(encodedValue);\r\n    } else {\r\n        writeRaw(encodedValue);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  String\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._writeQuotedRaw(r1)\n  goto B5\n}",
      "B4 {\n  r0.writeRaw(r1)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#writeRaw(...1)",
        "body": "{\r\n    final int len \u003d text.length();\r\n    final char[] buf \u003d _charBuffer;\r\n    if (len \u003c\u003d buf.length) {\r\n        text.getChars(0, len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n    } else {\r\n        writeRaw(text, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\r\n    _outputTail +\u003d 4;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(encodedValueBuffer, offset, length);\r\n    } else {\r\n        writeRaw(encodedValueBuffer, offset, length);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d UTF8JsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedRaw(r1, i0, i1)\n  goto B3\n}",
      "B2 {\n  r0.writeRaw(r1, i0, i1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_writeQuotedRaw(...3)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(text, offset, length);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#writeRaw(...3)",
        "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    final char[] buf \u003d _charBuffer;\r\n    final int cbufLen \u003d buf.length;\r\n    // minor optimization: see if we can just get and copy\r\n    if (len \u003c\u003d cbufLen) {\r\n        text.getChars(offset, offset + len, buf, 0);\r\n        writeRaw(buf, 0, len);\r\n        return;\r\n    }\r\n    // If not, need segmented approach. For speed, let\u0027s also use input buffer\r\n    // size that is guaranteed to fit in output buffer; each char can expand to\r\n    // at most 3 bytes, so at most 1/3 of buffer size.\r\n    final int maxChunk \u003d Math.min(cbufLen, // \u003d\u003d (1/4 + 1/16) \u003d\u003d 5/16\r\n    (_outputEnd \u003e\u003e 2) + (_outputEnd \u003e\u003e 4));\r\n    final int maxBytes \u003d maxChunk * 3;\r\n    while (len \u003e 0) {\r\n        int len2 \u003d Math.min(maxChunk, len);\r\n        text.getChars(offset, offset + len2, buf, 0);\r\n        if ((_outputTail + maxBytes) \u003e _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        // If this is NOT the last segment and if the last character looks like\r\n        // split surrogate second half, drop it\r\n        // 21-Mar-2017, tatu: Note that we could check for either `len` or `len2`;\r\n        //    point here is really that we only \"punt\" surrogate if it is NOT the\r\n        //    only character left; otherwise we\u0027d end up with a poison pill if the\r\n        //    very last character was unpaired first-surrogate\r\n        if (len2 \u003e 1) {\r\n            char ch \u003d buf[len2 - 1];\r\n            if ((ch \u003e\u003d SURR1_FIRST) \u0026\u0026 (ch \u003c\u003d SURR1_LAST)) {\r\n                --len2;\r\n            }\r\n        }\r\n        _writeRawSegment(buf, 0, len2);\r\n        offset +\u003d len2;\r\n        len -\u003d len2;\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "writeBoolean",
    "signature": "void writeBoolean(boolean)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_BOOLEAN);\r\n    if ((_outputTail + 5) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    byte[] keyword \u003d state ? TRUE_BYTES : FALSE_BYTES;\r\n    int len \u003d keyword.length;\r\n    System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\r\n    _outputTail +\u003d len;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If(z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  z0 :\u003d @parameter0: boolean\n  r0._verifyValueWrite(\"write a boolean value\")\n  $i0 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 5\n  $i1 \u003d UTF8JsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  if (z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d UTF8JsonGenerator: byte[] TRUE_BYTES\u003e\n  goto B5\n}",
      "B4 {\n  $r2 \u003d UTF8JsonGenerator: byte[] FALSE_BYTES\u003e\n}",
      "B5 {\n  $i6 \u003d lengthof $r2\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  $i3 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  System.arraycopy($r2, 0, $r1, $i3, $i6)\n  $i4 \u003d UTF8JsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + $i6\n  UTF8JsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    byte b;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            b \u003d BYTE_COMMA;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            b \u003d BYTE_COLON;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                byte[] raw \u003d _rootValueSeparator.asUnquotedUTF8();\r\n                if (raw.length \u003e 0) {\r\n                    _writeBytes(raw);\r\n                }\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d b;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    _flushBuffer();\r\n    if (_outputStream !\u003d null) {\r\n        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\r\n            _outputStream.flush();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r0._flushBuffer()\n  $r1 \u003d OutputStream _outputStream\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d JsonGenerator$Feature FLUSH_PASSED_TO_STREAM\u003e\n  $z0 \u003d r0.isEnabled($r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d OutputStream _outputStream\u003e\n  $r3.flush()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8JsonGenerator",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    super.close();\r\n    // 05-Dec-2008, tatu: To add [JACKSON-27], need to close open scopes.\r\n    // First: let\u0027s see that we still have buffers...\r\n    IOException flushFail \u003d null;\r\n    try {\r\n        if ((_outputBuffer !\u003d null) \u0026\u0026 isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\r\n            while (true) {\r\n                JsonStreamContext ctxt \u003d getOutputContext();\r\n                if (ctxt.inArray()) {\r\n                    writeEndArray();\r\n                } else if (ctxt.inObject()) {\r\n                    writeEndObject();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        _flushBuffer();\r\n    } catch (IOException e) {\r\n        // 10-Jun-2022, tatu: [core#764] Need to avoid failing here; may\r\n        //    still need to close the underlying output stream\r\n        flushFail \u003d e;\r\n    }\r\n    // just to ensure we don\u0027t think there\u0027s anything buffered\r\n    _outputTail \u003d 0;\r\n    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\r\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\r\n         *   feature is enabled.\r\n         *   One downside: when using UTF8Writer, underlying buffer(s)\r\n         *   may not be properly recycled if we don\u0027t close the writer.\r\n         */\r\n    if (_outputStream !\u003d null) {\r\n        try {\r\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\r\n                _outputStream.close();\r\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\r\n                // If we can\u0027t close it, we should at least flush\r\n                _outputStream.flush();\r\n            }\r\n        } catch (IOException | RuntimeException e) {\r\n            if (flushFail !\u003d null) {\r\n                e.addSuppressed(flushFail);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    // Internal buffer(s) generator has can now be released as well\r\n    _releaseBuffers();\r\n    if (flushFail !\u003d null) {\r\n        throw flushFail;\r\n    }\r\n}",
    "nodes": 22,
    "edges": 29,
    "cc": 9,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If($z3 \u003d\u003d false) → B2 | else → B7",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z5 \u003d\u003d false) → B5 | else → B7",
      "B9 : If($r2 \u003d\u003d null) → B10 | else → B19",
      "B10 : If($z0 !\u003d 0) → B11 | else → B12",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z2 \u003d\u003d false) → B14 | else → B15",
      "B16 : If(r12 \u003d\u003d null) → B17 | else → B18",
      "B19 : If(r12 \u003d\u003d null) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  UTF8JsonGenerator\n  r0.close()\n  r12 \u003d null\n  $r1 \u003d UTF8JsonGenerator: byte[] _outputBuffer\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $r8 \u003d JsonGenerator$Feature AUTO_CLOSE_JSON_CONTENT\u003e\n  $z3 \u003d r0.isEnabled($r8)\n  if ($z3 \u003d\u003d false) goto B2 else B7\n}",
      "B2 {\n  $r9 \u003d r0.getOutputContext()\n  $z4 \u003d $r9.inArray()\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0.writeEndArray()\n  goto B6\n}",
      "B4 {\n  $z5 \u003d $r9.inObject()\n  if ($z5 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  r0.writeEndObject()\n}",
      "B6 {\n  goto B2\n}",
      "B7 {\n  r0._flushBuffer()\n  goto B9\n}",
      "B8 {\n  $r11 :\u003d @caughtexception\n  r12 \u003d $r11\n}",
      "B9 {\n  UTF8JsonGenerator: int _outputTail\u003e \u003d 0\n  $r2 \u003d OutputStream _outputStream\u003e\n  if ($r2 \u003d\u003d null) goto B10 else B19\n}",
      "B10 {\n  $r3 \u003d IOContext _ioContext\u003e\n  $z0 \u003d $r3.isResourceManaged()\n  if ($z0 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $r5 \u003d JsonGenerator$Feature AUTO_CLOSE_TARGET\u003e\n  $z1 \u003d r0.isEnabled($r5)\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r4 \u003d OutputStream _outputStream\u003e\n  $r4.close()\n  goto B15\n}",
      "B13 {\n  $r6 \u003d JsonGenerator$Feature FLUSH_PASSED_TO_STREAM\u003e\n  $z2 \u003d r0.isEnabled($r6)\n  if ($z2 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r7 \u003d OutputStream _outputStream\u003e\n  $r7.flush()\n}",
      "B15 {\n  goto B19\n}",
      "B16 {\n  $r10 :\u003d @caughtexception\n  if (r12 \u003d\u003d null) goto B17 else B18\n}",
      "B17 {\n  $r10.addSuppressed(r12)\n}",
      "B18 {\n  throw $r10\n}",
      "B19 {\n  r0._releaseBuffers()\n  if (r12 \u003d\u003d null) goto B20 else B21\n}",
      "B20 {\n  throw r12\n}",
      "B21 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B19",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8JsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#writeEndArray(...0)",
        "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_RBRACKET;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#getOutputContext(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8JsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail;\r\n    if (len \u003e 0) {\r\n        _outputTail \u003d 0;\r\n        _outputStream.write(_outputBuffer, 0, len);\r\n    }\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#writeEndObject(...0)",
        "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d BYTE_RCURLY;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8JsonGenerator#_releaseBuffers(...0)",
        "body": "{\r\n    byte[] buf \u003d _outputBuffer;\r\n    if (buf !\u003d null \u0026\u0026 _bufferRecyclable) {\r\n        _outputBuffer \u003d null;\r\n        _ioContext.releaseWriteEncodingBuffer(buf);\r\n    }\r\n    char[] cbuf \u003d _charBuffer;\r\n    if (cbuf !\u003d null) {\r\n        _charBuffer \u003d null;\r\n        _ioContext.releaseConcatBuffer(cbuf);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "releaseBuffered",
    "signature": "int releaseBuffered(java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    int count \u003d _inputEnd - _inputPtr;\r\n    if (count \u003c 1) {\r\n        return 0;\r\n    }\r\n    // let\u0027s just advance ptr to end\r\n    int origPtr \u003d _inputPtr;\r\n    _inputPtr +\u003d count;\r\n    out.write(_inputBuffer, origPtr, count);\r\n    return count;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i2 \u003e\u003d 1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  OutputStream\n  $i1 \u003d UTF8StreamJsonParser: int _inputEnd\u003e\n  $i0 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n  i2 \u003d $i1 - $i0\n  if (i2 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  i3 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n  $i4 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n  $i5 \u003d $i4 + i2\n  UTF8StreamJsonParser: int _inputPtr\u003e \u003d $i5\n  $r2 \u003d UTF8StreamJsonParser: byte[] _inputBuffer\u003e\n  r1.write($r2, i3, i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getText",
    "signature": "java.lang.String getText()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r7 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $r6 \u003d $r5.contentsAsString()\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken _currToken\u003e\n  $r4 \u003d r0._getText2($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_getText2(...1)",
        "body": "{\r\n    if (t \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    switch(t.id()) {\r\n        case ID_FIELD_NAME:\r\n            return _parsingContext.getCurrentName();\r\n        case ID_STRING:\r\n        // fall through\r\n        case ID_NUMBER_INT:\r\n        case ID_NUMBER_FLOAT:\r\n            return _textBuffer.contentsAsString();\r\n        default:\r\n            return t.asString();\r\n    }\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getText",
    "signature": "int getText(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            _finishString();\r\n        }\r\n        return _textBuffer.contentsToWriter(writer);\r\n    }\r\n    if (t \u003d\u003d JsonToken.FIELD_NAME) {\r\n        String n \u003d _parsingContext.getCurrentName();\r\n        writer.write(n);\r\n        return n.length();\r\n    }\r\n    if (t !\u003d null) {\r\n        if (t.isNumeric()) {\r\n            return _textBuffer.contentsToWriter(writer);\r\n        }\r\n        char[] ch \u003d t.asCharArray();\r\n        writer.write(ch);\r\n        return ch.length;\r\n    }\r\n    return 0;\r\n}",
    "nodes": 11,
    "edges": 11,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d $r2) → B1 | else → B4",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(r1 !\u003d $r3) → B5 | else → B6",
      "B6 : If(r1 \u003d\u003d null) → B7 | else → B10",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  Writer\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_STRING\u003e\n  if (r1 !\u003d $r2) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r7.contentsToWriter(r4)\n  return\n}",
      "B4 {\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if (r1 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d JsonReadContext _parsingContext\u003e\n  r8 \u003d $r6.getCurrentName()\n  r4.write(r8)\n  $i2 \u003d r8.length()\n  return\n}",
      "B6 {\n  if (r1 \u003d\u003d null) goto B7 else B10\n}",
      "B7 {\n  $z0 \u003d r1.isNumeric()\n  if ($z0 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r5.contentsToWriter(r4)\n  return\n}",
      "B9 {\n  r9 \u003d r1.asCharArray()\n  r4.write(r9)\n  $i0 \u003d lengthof r9\n  return\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_finishString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(null);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r9 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $r8 \u003d $r7.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r5 \u003d r0.getValueAsString(null)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#currentName(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getValueAsString",
    "signature": "java.lang.String getValueAsString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return currentName();\r\n    }\r\n    return super.getValueAsString(defValue);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3",
      "B4 : If($r4 !\u003d $r3) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  String\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 !\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r10 \u003d r0._finishAndReturnString()\n  return\n}",
      "B3 {\n  $r8 \u003d TextBuffer _textBuffer\u003e\n  $r9 \u003d $r8.contentsAsString()\n  return\n}",
      "B4 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken FIELD_NAME\u003e\n  if ($r4 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d r0.currentName()\n  return\n}",
      "B6 {\n  $r6 \u003d r0.getValueAsString(r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#currentName(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n    return _textBuffer.contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getValueAsInt",
    "signature": "int getValueAsInt()",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if ((t \u003d\u003d JsonToken.VALUE_NUMBER_INT) || (t \u003d\u003d JsonToken.VALUE_NUMBER_FLOAT)) {\r\n        // inlined \u0027getIntValue()\u0027\r\n        if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n            if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n                return _parseIntValue();\r\n            }\r\n            if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n                convertNumberToInt();\r\n            }\r\n        }\r\n        return _numberInt;\r\n    }\r\n    return super.getValueAsInt(0);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If(r1 !\u003d $r3) → B2 | else → B8",
      "B2 : If($i1 !\u003d 0) → B3 | else → B7",
      "B3 : If($i2 !\u003d 0) → B4 | else → B5",
      "B5 : If($i4 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonToken VALUE_NUMBER_FLOAT\u003e\n  if (r1 !\u003d $r3) goto B2 else B8\n}",
      "B2 {\n  $i0 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  $i2 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i5 \u003d r0._parseIntValue()\n  return\n}",
      "B5 {\n  $i3 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r0.convertNumberToInt()\n}",
      "B7 {\n  $i7 \u003d UTF8StreamJsonParser: int _numberInt\u003e\n  return\n}",
      "B8 {\n  $i6 \u003d r0.getValueAsInt(0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_parseIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#convertNumberToInt(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getValueAsInt",
    "signature": "int getValueAsInt(int)",
    "visibility": "public",
    "body": "{\r\n    JsonToken t \u003d _currToken;\r\n    if ((t \u003d\u003d JsonToken.VALUE_NUMBER_INT) || (t \u003d\u003d JsonToken.VALUE_NUMBER_FLOAT)) {\r\n        // inlined \u0027getIntValue()\u0027\r\n        if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n            if (_numTypesValid \u003d\u003d NR_UNKNOWN) {\r\n                return _parseIntValue();\r\n            }\r\n            if ((_numTypesValid \u0026 NR_INT) \u003d\u003d 0) {\r\n                convertNumberToInt();\r\n            }\r\n        }\r\n        return _numberInt;\r\n    }\r\n    return super.getValueAsInt(defValue);\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B2",
      "B1 : If(r1 !\u003d $r3) → B2 | else → B8",
      "B2 : If($i1 !\u003d 0) → B3 | else → B7",
      "B3 : If($i2 !\u003d 0) → B4 | else → B5",
      "B5 : If($i4 !\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  i6 :\u003d @parameter0: int\n  r1 \u003d JsonToken _currToken\u003e\n  $r2 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonToken VALUE_NUMBER_FLOAT\u003e\n  if (r1 !\u003d $r3) goto B2 else B8\n}",
      "B2 {\n  $i0 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  $i1 \u003d $i0 \u0026 1\n  if ($i1 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  $i2 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  if ($i2 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i5 \u003d r0._parseIntValue()\n  return\n}",
      "B5 {\n  $i3 \u003d UTF8StreamJsonParser: int _numTypesValid\u003e\n  $i4 \u003d $i3 \u0026 1\n  if ($i4 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r0.convertNumberToInt()\n}",
      "B7 {\n  $i8 \u003d UTF8StreamJsonParser: int _numberInt\u003e\n  return\n}",
      "B8 {\n  $i7 \u003d r0.getValueAsInt(i6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B8",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_parseIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#convertNumberToInt(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getTextCharacters",
    "signature": "char[] getTextCharacters()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                if (!_nameCopied) {\r\n                    String name \u003d _parsingContext.getCurrentName();\r\n                    int nameLen \u003d name.length();\r\n                    if (_nameCopyBuffer \u003d\u003d null) {\r\n                        _nameCopyBuffer \u003d _ioContext.allocNameCopyBuffer(nameLen);\r\n                    } else if (_nameCopyBuffer.length \u003c nameLen) {\r\n                        _nameCopyBuffer \u003d new char[nameLen];\r\n                    }\r\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\r\n                    _nameCopied \u003d true;\r\n                }\r\n                return _nameCopyBuffer;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextBuffer();\r\n            default:\r\n                return _currToken.asCharArray();\r\n        }\r\n    }\r\n    return null;\r\n}",
    "nodes": 14,
    "edges": 18,
    "cc": 6,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B13",
      "B1 : If(switch-on $i0) → B2 | else → B9",
      "B2 : If($z1 !\u003d 0) → B3 | else → B8",
      "B3 : If($r5 !\u003d null) → B4 | else → B5",
      "B5 : If($i2 \u003e\u003d i1) → B6 | else → B7",
      "B9 : If($z0 \u003d\u003d false) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B13\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  JsonToken _currToken\u003e; }\n}",
      "B2 {\n  $z1 \u003d UTF8StreamJsonParser: boolean _nameCopied\u003e\n  if ($z1 !\u003d 0) goto B3 else B8\n}",
      "B3 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  r4 \u003d $r3.getCurrentName()\n  i1 \u003d r4.length()\n  $r5 \u003d UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e\n  if ($r5 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d IOContext _ioContext\u003e\n  $r9 \u003d $r8.allocNameCopyBuffer(i1)\n  UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e \u003d $r9\n  goto B7\n}",
      "B5 {\n  $r6 \u003d UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e\n  $i2 \u003d lengthof $r6\n  if ($i2 \u003e\u003d i1) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d newarray (char)[i1]\n  UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e \u003d $r7\n}",
      "B7 {\n  $r12 \u003d UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e\n  r4.getChars(0, i1, $r12, 0)\n  UTF8StreamJsonParser: boolean _nameCopied\u003e \u003d 1\n}",
      "B8 {\n  $r13 \u003d UTF8StreamJsonParser: char[] _nameCopyBuffer\u003e\n  return\n}",
      "B9 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B11 {\n  $r14 \u003d TextBuffer _textBuffer\u003e\n  $r15 \u003d $r14.getTextBuffer()\n  return\n}",
      "B12 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d $r10.asCharArray()\n  return\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B13",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B1 --\u003e B11",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_finishString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getTextLength",
    "signature": "int getTextLength()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d null) {\r\n        // null only before/after document\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                return _parsingContext.getCurrentName().length();\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.size();\r\n            default:\r\n                return _currToken.asCharArray().length;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If(switch-on $i0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  JsonToken _currToken\u003e; }\n}",
      "B2 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $r4 \u003d $r3.getCurrentName()\n  $i1 \u003d $r4.length()\n  return\n}",
      "B3 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B5 {\n  $r7 \u003d TextBuffer _textBuffer\u003e\n  $i3 \u003d $r7.size()\n  return\n}",
      "B6 {\n  $r5 \u003d JsonToken _currToken\u003e\n  $r6 \u003d $r5.asCharArray()\n  $i2 \u003d lengthof $r6\n  return\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B5",
      "B1 --\u003e B6",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_finishString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getTextOffset",
    "signature": "int getTextOffset()",
    "visibility": "public",
    "body": "{\r\n    // Most have offset of 0, only some may have other values:\r\n    if (_currToken !\u003d null) {\r\n        switch(_currToken.id()) {\r\n            case ID_FIELD_NAME:\r\n                return 0;\r\n            case ID_STRING:\r\n                if (_tokenIncomplete) {\r\n                    _tokenIncomplete \u003d false;\r\n                    // only strings can be incomplete\r\n                    _finishString();\r\n                }\r\n            // fall through\r\n            case ID_NUMBER_INT:\r\n            case ID_NUMBER_FLOAT:\r\n                return _textBuffer.getTextOffset();\r\n            default:\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B6",
      "B1 : If(switch-on $i0) → B2 | else → B3",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r1 \u003d JsonToken _currToken\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B6\n}",
      "B1 {\n  $r2 \u003d JsonToken _currToken\u003e\n  $i0 \u003d $r2.id()\n  TextBuffer _textBuffer\u003e;     default: goto return 0; }\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B5 {\n  $r3 \u003d TextBuffer _textBuffer\u003e\n  $i1 \u003d $r3.getTextOffset()\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B1 --\u003e B5",
      "B1 --\u003e B6",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_finishString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "getBinaryValue",
    "signature": "byte[] getBinaryValue(com.fasterxml.jackson.core.Base64Variant)",
    "visibility": "public",
    "body": "{\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING \u0026\u0026 (_currToken !\u003d JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue \u003d\u003d null)) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    // To ensure that we won\u0027t see inconsistent data, better clear up state...\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        // let\u0027s clear incomplete only now; allows for accessing other textual content in error cases\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d $r1) → B1 | else → B4",
      "B1 : If($r9 !\u003d $r8) → B2 | else → B3",
      "B2 : If($r13 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B8",
      "B8 : If($r3 !\u003d null) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  Base64Variant\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken VALUE_STRING\u003e\n  if ($r2 \u003d\u003d $r1) goto B1 else B4\n}",
      "B1 {\n  $r9 \u003d JsonToken _currToken\u003e\n  $r8 \u003d JsonToken VALUE_EMBEDDED_OBJECT\u003e\n  if ($r9 !\u003d $r8) goto B2 else B3\n}",
      "B2 {\n  $r13 \u003d UTF8StreamJsonParser: byte[] _binaryValue\u003e\n  if ($r13 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r10 \u003d JsonToken _currToken\u003e\n  $r11 \u003d String.valueOf($r10)\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportError($r12)\n}",
      "B4 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B5 else B8\n}",
      "B5 {\n  $r7 \u003d r0._decodeBase64(r4)\n  UTF8StreamJsonParser: byte[] _binaryValue\u003e \u003d $r7\n  goto B7\n}",
      "B6 {\n  $r14 :\u003d @caughtexception\n  $r16 \u003d String.valueOf(r4)\n  $r15 \u003d $r14.getMessage()\n  $r17 \u003d dynInvoke makeConcatWithConstants($r16, $r15)\n  $r18 \u003d r0._constructError($r17)\n  throw $r18\n}",
      "B7 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  goto B10\n}",
      "B8 {\n  $r3 \u003d UTF8StreamJsonParser: byte[] _binaryValue\u003e\n  if ($r3 !\u003d null) goto B9 else B10\n}",
      "B9 {\n  r19 \u003d r0._getByteArrayBuilder()\n  $r5 \u003d r0.getText()\n  r0._decodeBase64($r5, r19, r4)\n  $r6 \u003d r19.toByteArray()\n  UTF8StreamJsonParser: byte[] _binaryValue\u003e \u003d $r6\n}",
      "B10 {\n  $r20 \u003d UTF8StreamJsonParser: byte[] _binaryValue\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_decodeBase64(...1)",
        "body": "{\r\n    ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        int ch;\r\n        do {\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                _loadMoreGuaranteed();\r\n            }\r\n            ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            // reached the end, fair and square?\r\n            if (ch \u003d\u003d INT_QUOTE) {\r\n                return builder.toByteArray();\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    builder.append(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // Ok, must get padding\r\n                if (_inputPtr \u003e\u003d _inputEnd) {\r\n                    _loadMoreGuaranteed();\r\n                }\r\n                ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if (_decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                builder.append(decodedData);\r\n                continue;\r\n            }\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    builder.appendTwoBytes(decodedData);\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    return builder.toByteArray();\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // With padding we only get 2 bytes; but we have to shift it\r\n                // a bit so it is identical to triplet case with partial output.\r\n                // 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are dummies, need to discard:\r\n                decodedData \u003e\u003e\u003d 2;\r\n                builder.appendTwoBytes(decodedData);\r\n                continue;\r\n            }\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        builder.appendThreeBytes(decodedData);\r\n    }\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_getByteArrayBuilder(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_decodeBase64(...3)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_constructError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "readBinaryValue",
    "signature": "int readBinaryValue(com.fasterxml.jackson.core.Base64Variant,java.io.OutputStream)",
    "visibility": "public",
    "body": "{\r\n    // if we have already read the token, just use whatever we may have\r\n    if (!_tokenIncomplete || _currToken !\u003d JsonToken.VALUE_STRING) {\r\n        byte[] b \u003d getBinaryValue(b64variant);\r\n        out.write(b);\r\n        return b.length;\r\n    }\r\n    // otherwise do \"real\" incremental parsing...\r\n    byte[] buf \u003d _ioContext.allocBase64Buffer();\r\n    try {\r\n        return _readBinary(b64variant, out, buf);\r\n    } finally {\r\n        _ioContext.releaseBase64Buffer(buf);\r\n    }\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B1 : If($r4 \u003d\u003d $r3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  Base64Variant\n  OutputStream\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonToken _currToken\u003e\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 \u003d\u003d $r3) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d r0.getBinaryValue(r1)\n  r2.write($r7)\n  $i0 \u003d lengthof $r7\n  return\n}",
      "B3 {\n  $r5 \u003d IOContext _ioContext\u003e\n  r10 \u003d $r5.allocBase64Buffer()\n  i1 \u003d r0._readBinary(r1, r2, r10)\n  $r6 \u003d IOContext _ioContext\u003e\n  $r6.releaseBase64Buffer(r10)\n  return\n}",
      "B4 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d IOContext _ioContext\u003e\n  $r9.releaseBase64Buffer(r10)\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#getBinaryValue(...1)",
        "body": "{\r\n    if (_currToken !\u003d JsonToken.VALUE_STRING \u0026\u0026 (_currToken !\u003d JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue \u003d\u003d null)) {\r\n        _reportError(\"Current token (\" + _currToken + \") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\r\n    }\r\n    // To ensure that we won\u0027t see inconsistent data, better clear up state...\r\n    if (_tokenIncomplete) {\r\n        try {\r\n            _binaryValue \u003d _decodeBase64(b64variant);\r\n        } catch (IllegalArgumentException iae) {\r\n            throw _constructError(\"Failed to decode VALUE_STRING as base64 (\" + b64variant + \"): \" + iae.getMessage());\r\n        }\r\n        // let\u0027s clear incomplete only now; allows for accessing other textual content in error cases\r\n        _tokenIncomplete \u003d false;\r\n    } else {\r\n        // may actually require conversion...\r\n        if (_binaryValue \u003d\u003d null) {\r\n            @SuppressWarnings(\"resource\")\r\n            ByteArrayBuilder builder \u003d _getByteArrayBuilder();\r\n            _decodeBase64(getText(), builder, b64variant);\r\n            _binaryValue \u003d builder.toByteArray();\r\n        }\r\n    }\r\n    return _binaryValue;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_readBinary(...3)",
        "body": "{\r\n    int outputPtr \u003d 0;\r\n    final int outputEnd \u003d buffer.length - 3;\r\n    int outputCount \u003d 0;\r\n    while (true) {\r\n        // first, we\u0027ll skip preceding white space, if any\r\n        int ch;\r\n        do {\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                _loadMoreGuaranteed();\r\n            }\r\n            ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        } while (ch \u003c\u003d INT_SPACE);\r\n        int bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            // reached the end, fair and square?\r\n            if (ch \u003d\u003d INT_QUOTE) {\r\n                break;\r\n            }\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 0);\r\n            if (bits \u003c 0) {\r\n                // white space to skip\r\n                continue;\r\n            }\r\n        }\r\n        // enough room? If not, flush\r\n        if (outputPtr \u003e outputEnd) {\r\n            outputCount +\u003d outputPtr;\r\n            out.write(buffer, 0, outputPtr);\r\n            outputPtr \u003d 0;\r\n        }\r\n        int decodedData \u003d bits;\r\n        // then second base64 char; can\u0027t get padding yet, nor ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            bits \u003d _decodeBase64Escape(b64variant, ch, 1);\r\n        }\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // third base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        // First branch: can get padding (-\u003e 1 byte)\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 4;\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 2);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // Ok, must get padding\r\n                if (_inputPtr \u003e\u003d _inputEnd) {\r\n                    _loadMoreGuaranteed();\r\n                }\r\n                ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n                if (!b64variant.usesPaddingChar(ch)) {\r\n                    if (_decodeBase64Escape(b64variant, ch, 3) !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character \u0027\" + b64variant.getPaddingChar() + \"\u0027\");\r\n                    }\r\n                }\r\n                // Got 12 bits, only need 8, need to shift\r\n                decodedData \u003e\u003e\u003d 4;\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // Nope, 2 or 3 bytes\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        // fourth and last base64 char; can be padding, but not ws\r\n        if (_inputPtr \u003e\u003d _inputEnd) {\r\n            _loadMoreGuaranteed();\r\n        }\r\n        ch \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        bits \u003d b64variant.decodeBase64Char(ch);\r\n        if (bits \u003c 0) {\r\n            if (bits !\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                // as per [JACKSON-631], could also just be \u0027missing\u0027  padding\r\n                if (ch \u003d\u003d INT_QUOTE) {\r\n                    decodedData \u003e\u003e\u003d 2;\r\n                    buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                    buffer[outputPtr++] \u003d (byte) decodedData;\r\n                    if (b64variant.requiresPaddingOnRead()) {\r\n                        // to keep parser state bit more consistent\r\n                        --_inputPtr;\r\n                        _handleBase64MissingPadding(b64variant);\r\n                    }\r\n                    break;\r\n                }\r\n                bits \u003d _decodeBase64Escape(b64variant, ch, 3);\r\n            }\r\n            if (bits \u003d\u003d Base64Variant.BASE64_VALUE_PADDING) {\r\n                /* With padding we only get 2 bytes; but we have\r\n                     * to shift it a bit so it is identical to triplet\r\n                     * case with partial output.\r\n                     * 3 chars gives 3x6 \u003d\u003d 18 bits, of which 2 are\r\n                     * dummies, need to discard:\r\n                     */\r\n                decodedData \u003e\u003e\u003d 2;\r\n                buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n                buffer[outputPtr++] \u003d (byte) decodedData;\r\n                continue;\r\n            }\r\n        }\r\n        // otherwise, our triplet is now complete\r\n        decodedData \u003d (decodedData \u003c\u003c 6) | bits;\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 16);\r\n        buffer[outputPtr++] \u003d (byte) (decodedData \u003e\u003e 8);\r\n        buffer[outputPtr++] \u003d (byte) decodedData;\r\n    }\r\n    _tokenIncomplete \u003d false;\r\n    if (outputPtr \u003e 0) {\r\n        outputCount +\u003d outputPtr;\r\n        out.write(buffer, 0, outputPtr);\r\n    }\r\n    return outputCount;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        return _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                return _closeScope(i);\r\n            }\r\n        }\r\n    }\r\n    // And should we now have a name? Always true for Object contexts\r\n    // since the intermediate \u0027expect-value\u0027 state is never retained.\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    _updateNameLocation();\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}",
    "nodes": 35,
    "edges": 49,
    "cc": 16,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i4 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i4 !\u003d 93) → B7 | else → B8",
      "B8 : If($i4 !\u003d 125) → B9 | else → B10",
      "B10 : If($z1 \u003d\u003d false) → B11 | else → B17",
      "B11 : If($i4 \u003d\u003d 44) → B12 | else → B13",
      "B13 : If($i2 \u003d\u003d false) → B14 | else → B17",
      "B14 : If($i3 \u003d\u003d 93) → B15 | else → B16",
      "B15 : If($i3 !\u003d 125) → B16 | else → B17",
      "B17 : If($z3 !\u003d 0) → B18 | else → B19",
      "B19 : If(i6 !\u003d 34) → B20 | else → B21",
      "B21 : If(switch-on i6) → B23 | else → B22",
      "B23 : If($z2 \u003d\u003d false) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r21 \u003d r0._nextAfterName()\n  return\n}",
      "B2 {\n  UTF8StreamJsonParser: int _numTypesValid\u003e \u003d 0\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i4 \u003d r0._skipWSOrEnd()\n  i5 \u003d $i4\n  if ($i4 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  $r20 \u003d r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  UTF8StreamJsonParser: byte[] _binaryValue\u003e \u003d null\n  if ($i4 !\u003d 93) goto B7 else B8\n}",
      "B7 {\n  r0._closeArrayScope()\n  $r18 \u003d JsonToken END_ARRAY\u003e\n  $r19 \u003d r0._updateToken($r18)\n  return\n}",
      "B8 {\n  if ($i4 !\u003d 125) goto B9 else B10\n}",
      "B9 {\n  r0._closeObjectScope()\n  $r16 \u003d JsonToken END_OBJECT\u003e\n  $r17 \u003d r0._updateToken($r16)\n  return\n}",
      "B10 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B11 else B17\n}",
      "B11 {\n  if ($i4 \u003d\u003d 44) goto B12 else B13\n}",
      "B12 {\n  $r13 \u003d JsonReadContext _parsingContext\u003e\n  $r14 \u003d $r13.typeDesc()\n  $r15 \u003d dynInvoke makeConcatWithConstants($r14)\n  r0._reportUnexpectedChar($i4, $r15)\n}",
      "B13 {\n  $i3 \u003d r0._skipWS()\n  i5 \u003d $i3\n  $i1 \u003d UTF8StreamJsonParser: int _features\u003e\n  $i0 \u003d UTF8StreamJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i2 \u003d $i1 \u0026 $i0\n  if ($i2 \u003d\u003d false) goto B14 else B17\n}",
      "B14 {\n  if ($i3 \u003d\u003d 93) goto B15 else B16\n}",
      "B15 {\n  if ($i3 !\u003d 125) goto B16 else B17\n}",
      "B16 {\n  $r12 \u003d r0._closeScope($i3)\n  return\n}",
      "B17 {\n  $r22 \u003d JsonReadContext _parsingContext\u003e\n  $z3 \u003d $r22.inObject()\n  if ($z3 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  r0._updateLocation()\n  $r11 \u003d r0._nextTokenNotInObject(i5)\n  return\n}",
      "B19 {\n  r0._updateNameLocation()\n  r4 \u003d r0._parseName(i5)\n  $r5 \u003d JsonReadContext _parsingContext\u003e\n  $r5.setCurrentName(r4)\n  $r6 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r6)\n  i6 \u003d r0._skipColon()\n  r0._updateLocation()\n  if (i6 !\u003d 34) goto B20 else B21\n}",
      "B20 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  $r10 \u003d JsonToken _currToken\u003e\n  return\n}",
      "B21 {\n  JsonToken _handleUnexpectedValue(int)\u003e(i6); }\n}",
      "B22 {\n  r23 \u003d r0._parseSignedNumber(1)\n  goto B34\n}",
      "B23 {\n  $r7 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r8 \u003d $r7.mappedFeature()\n  $z2 \u003d r0.isEnabled($r8)\n  if ($z2 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  r23 \u003d r0._parseSignedNumber(0)\n  goto B34\n}",
      "B25 {\n  r23 \u003d r0._handleUnexpectedValue(i6)\n  goto B34\n}",
      "B26 {\n  r23 \u003d r0._parseFloatThatStartsWithPeriod(0, 0)\n  goto B34\n}",
      "B27 {\n  r23 \u003d r0._parseUnsignedNumber(i6)\n  goto B34\n}",
      "B28 {\n  r0._matchFalse()\n  r23 \u003d JsonToken VALUE_FALSE\u003e\n  goto B34\n}",
      "B29 {\n  r0._matchNull()\n  r23 \u003d JsonToken VALUE_NULL\u003e\n  goto B34\n}",
      "B30 {\n  r0._matchTrue()\n  r23 \u003d JsonToken VALUE_TRUE\u003e\n  goto B34\n}",
      "B31 {\n  r23 \u003d JsonToken START_ARRAY\u003e\n  goto B34\n}",
      "B32 {\n  r23 \u003d JsonToken START_OBJECT\u003e\n  goto B34\n}",
      "B33 {\n  r23 \u003d r0._handleUnexpectedValue(i6)\n}",
      "B34 {\n  JsonToken _nextToken\u003e \u003d r23\n  $r24 \u003d JsonToken _currToken\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B23",
      "B21 --\u003e B22",
      "B21 --\u003e B26",
      "B21 --\u003e B27",
      "B21 --\u003e B31",
      "B21 --\u003e B28",
      "B21 --\u003e B29",
      "B21 --\u003e B30",
      "B21 --\u003e B32",
      "B21 --\u003e B33",
      "B22 --\u003e B34",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B34",
      "B25 --\u003e B34",
      "B26 --\u003e B34",
      "B27 --\u003e B34",
      "B28 --\u003e B34",
      "B29 --\u003e B34",
      "B30 --\u003e B34",
      "B31 --\u003e B34",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_parseName(...1)",
        "body": "{\r\n    if (i !\u003d INT_QUOTE) {\r\n        return _handleOddName(i);\r\n    }\r\n    // First: can we optimize out bounds checks?\r\n    if ((_inputPtr + 13) \u003e _inputEnd) {\r\n        // Need up to 12 chars, plus one trailing (quote)\r\n        return slowParseName();\r\n    }\r\n    // If so, can also unroll loops nicely\r\n    /* 25-Nov-2008, tatu: This may seem weird, but here we do\r\n         *   NOT want to worry about UTF-8 decoding. Rather, we\u0027ll\r\n         *   assume that part is ok (if not it will get caught\r\n         *   later on), and just handle quotes and backslashes here.\r\n         */\r\n    final byte[] input \u003d _inputBuffer;\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    int q \u003d input[_inputPtr++] \u0026 0xFF;\r\n    if (codes[q] \u003d\u003d 0) {\r\n        i \u003d input[_inputPtr++] \u0026 0xFF;\r\n        if (codes[i] \u003d\u003d 0) {\r\n            q \u003d (q \u003c\u003c 8) | i;\r\n            i \u003d input[_inputPtr++] \u0026 0xFF;\r\n            if (codes[i] \u003d\u003d 0) {\r\n                q \u003d (q \u003c\u003c 8) | i;\r\n                i \u003d input[_inputPtr++] \u0026 0xFF;\r\n                if (codes[i] \u003d\u003d 0) {\r\n                    q \u003d (q \u003c\u003c 8) | i;\r\n                    i \u003d input[_inputPtr++] \u0026 0xFF;\r\n                    if (codes[i] \u003d\u003d 0) {\r\n                        _quad1 \u003d q;\r\n                        return parseMediumName(i);\r\n                    }\r\n                    if (i \u003d\u003d INT_QUOTE) {\r\n                        // 4 byte/char case or broken\r\n                        return findName(q, 4);\r\n                    }\r\n                    return parseName(q, i, 4);\r\n                }\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    // 3 byte/char case or broken\r\n                    return findName(q, 3);\r\n                }\r\n                return parseName(q, i, 3);\r\n            }\r\n            if (i \u003d\u003d INT_QUOTE) {\r\n                // 2 byte/char case or broken\r\n                return findName(q, 2);\r\n            }\r\n            return parseName(q, i, 2);\r\n        }\r\n        if (i \u003d\u003d INT_QUOTE) {\r\n            // one byte/char case or broken\r\n            return findName(q, 1);\r\n        }\r\n        return parseName(q, i, 1);\r\n    }\r\n    if (q \u003d\u003d INT_QUOTE) {\r\n        // special case, \"\"\r\n        return \"\";\r\n    }\r\n    // quoting or invalid char\r\n    return parseName(0, q, 0);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_matchFalse(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 4) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027a\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027s\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027e\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"false\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_matchTrue(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027r\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027u\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027e\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"true\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseSignedNumber(true));\r\n        case \u0027+\u0027:\r\n            if (!isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                return _updateToken(_handleUnexpectedValue(i));\r\n            }\r\n            return _updateToken(_parseSignedNumber(false));\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false, false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n    }\r\n    return _updateToken(_handleUnexpectedValue(i));\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_closeArrayScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inArray()) {\r\n        _reportMismatchedEndMarker(\u0027]\u0027, \u0027}\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    _nameStartRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseSignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    if (negative) {\r\n        // Need to prepend sign?\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    // Must have something after sign too\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n    }\r\n    int c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n    // Note: must be followed by a digit\r\n    if (c \u003c\u003d INT_0) {\r\n        // One special case: if first char is 0, must not be followed by a digit\r\n        if (c !\u003d INT_0) {\r\n            if (c \u003d\u003d INT_PERIOD) {\r\n                return _parseFloatThatStartsWithPeriod(negative, true);\r\n            }\r\n            return _handleInvalidNumberStart(c, negative, true);\r\n        }\r\n        c \u003d _verifyNoLeadingZeroes();\r\n    } else if (c \u003e INT_9) {\r\n        return _handleInvalidNumberStart(c, negative, true);\r\n    }\r\n    // Ok: we can first just add digit we saw first:\r\n    outBuf[outPtr++] \u003d (char) c;\r\n    int intLen \u003d 1;\r\n    // And then figure out how far we can read without further checks\r\n    // for either input or output\r\n    final int end \u003d Math.min(_inputEnd, _inputPtr + outBuf.length - outPtr);\r\n    // With this, we have a nice and tight loop:\r\n    while (true) {\r\n        if (_inputPtr \u003e\u003d end) {\r\n            // Long enough to be split across boundary, so:\r\n            return _parseNumber2(outBuf, outPtr, negative, intLen);\r\n        }\r\n        c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (c \u003c INT_0 || c \u003e INT_9) {\r\n            break;\r\n        }\r\n        ++intLen;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    if (c \u003d\u003d INT_PERIOD || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\r\n    }\r\n    // to push back trailing char (comma etc)\r\n    --_inputPtr;\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(c);\r\n    }\r\n    // And there we have it!\r\n    return resetInt(negative, intLen);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateLocation(...0)",
        "body": "{\r\n    _tokenInputRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    // One special case: if first char is 0, must not be followed by a digit\r\n    if (c \u003d\u003d INT_0) {\r\n        c \u003d _verifyNoLeadingZeroes();\r\n    }\r\n    // Ok: we can first just add digit we saw first:\r\n    outBuf[0] \u003d (char) c;\r\n    int intLen \u003d 1;\r\n    int outPtr \u003d 1;\r\n    // And then figure out how far we can read without further checks\r\n    // for either input or output\r\n    // 1 \u003d\u003d outPtr\r\n    final int end \u003d Math.min(_inputEnd, _inputPtr + outBuf.length - 1);\r\n    // With this, we have a nice and tight loop:\r\n    while (true) {\r\n        if (_inputPtr \u003e\u003d end) {\r\n            // split across boundary, offline\r\n            return _parseNumber2(outBuf, outPtr, false, intLen);\r\n        }\r\n        c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (c \u003c INT_0 || c \u003e INT_9) {\r\n            break;\r\n        }\r\n        ++intLen;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    if (c \u003d\u003d INT_PERIOD || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, false, intLen);\r\n    }\r\n    // to push back trailing char (comma etc)\r\n    --_inputPtr;\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(c);\r\n    }\r\n    // And there we have it!\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_matchNull(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027u\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"null\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWS(...0)",
        "body": "{\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWS2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWS2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    _closeArrayScope();\r\n    return _updateToken(JsonToken.END_ARRAY);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseFloatThatStartsWithPeriod(...2)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleUnexpectedValue(INT_PERIOD);\r\n    }\r\n    final char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    if (neg) {\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    // Need to be fully UTF-8 aware here:\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    main_loop: while (true) {\r\n        int c;\r\n        ascii_loop: while (true) {\r\n            int ptr \u003d _inputPtr;\r\n            int max \u003d _inputEnd;\r\n            if (ptr \u003e\u003d max) {\r\n                _loadMoreGuaranteed();\r\n                ptr \u003d _inputPtr;\r\n                max \u003d _inputEnd;\r\n            }\r\n            while (ptr \u003c max) {\r\n                c \u003d inputBuffer[ptr++] \u0026 0xFF;\r\n                if (codes[c] !\u003d 0) {\r\n                    _inputPtr \u003d ptr;\r\n                    break ascii_loop;\r\n                }\r\n            }\r\n            _inputPtr \u003d ptr;\r\n        }\r\n        // Ok: end marker, escape or multi-byte?\r\n        if (c \u003d\u003d INT_QUOTE) {\r\n            break main_loop;\r\n        }\r\n        switch(codes[c]) {\r\n            case // backslash\r\n            1:\r\n                _decodeEscaped();\r\n                break;\r\n            case // 2-byte UTF\r\n            2:\r\n                _skipUtf8_2();\r\n                break;\r\n            case // 3-byte UTF\r\n            3:\r\n                _skipUtf8_3();\r\n                break;\r\n            case // 4-byte UTF\r\n            4:\r\n                _skipUtf8_4(c);\r\n                break;\r\n            default:\r\n                if (c \u003c INT_SPACE) {\r\n                    _throwUnquotedSpace(c, \"string value\");\r\n                } else {\r\n                    // Is this good enough error message?\r\n                    _reportInvalidChar(c);\r\n                }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeObjectScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inObject()) {\r\n        _reportMismatchedEndMarker(\u0027}\u0027, \u0027]\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_handleUnexpectedValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(c) {\r\n        /* This check proceeds only if `Feature.ALLOW_MISSING_VALUES` is enabled;\r\n         * it is for missing values. In case of missing values in an array the next token\r\n         * will be either \u0027,\u0027 or \u0027]\u0027. This case, decrements the already incremented _inputPtr\r\n         * in the buffer in case of comma (`,`) so that the existing flow goes back to checking\r\n         * the next token which will be comma again and  it parsing continues.\r\n         * Also the case returns NULL as current token in case of \u0027,\u0027 or \u0027]\u0027.\r\n         */\r\n        case \u0027]\u0027:\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\r\n            //   we may allow \"missing values\", that is, encountering a trailing\r\n            //   comma or closing marker where value would be expected\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n        // fall through\r\n        case \u0027}\u0027:\r\n            // Error: neither is valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(c, \"expected a value\");\r\n        case \u0027\\\u0027\u0027:\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                if (!_loadMore()) {\r\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\r\n                }\r\n            }\r\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] \u0026 0xFF, false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(c)) {\r\n        _reportInvalidToken(\"\" + ((char) c), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(c, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipColon(...0)",
        "body": "{\r\n    if ((_inputPtr + 4) \u003e\u003d _inputEnd) {\r\n        return _skipColon2(false);\r\n    }\r\n    // Fast path: colon with optional single-space/tab before and/or after:\r\n    int i \u003d _inputBuffer[_inputPtr];\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n    }\r\n    if (i \u003d\u003d INT_COLON) {\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(true);\r\n    }\r\n    return _skipColon2(false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "finishToken",
    "signature": "void finishToken()",
    "visibility": "public",
    "body": "{\r\n    if (_tokenIncomplete) {\r\n        _tokenIncomplete \u003d false;\r\n        // only strings can be incomplete\r\n        _finishString();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  r0._finishString()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_finishString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                _textBuffer.setCurrentLength(outPtr);\r\n                return;\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextFieldName",
    "signature": "boolean nextFieldName(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    // // // Note: most of code below is copied from nextToken()\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // can\u0027t have name right after name\r\n        _nextAfterName();\r\n        return false;\r\n    }\r\n    if (_tokenIncomplete) {\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        close();\r\n        _updateTokenToNull();\r\n        return false;\r\n    }\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n        return false;\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n        return false;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                _closeScope(i);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        _nextTokenNotInObject(i);\r\n        return false;\r\n    }\r\n    // // // This part differs, name parsing\r\n    _updateNameLocation();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        // when doing literal match, must consider escaping:\r\n        byte[] nameBytes \u003d str.asQuotedUTF8();\r\n        final int len \u003d nameBytes.length;\r\n        // 22-May-2014, tatu: Actually, let\u0027s require 4 more bytes for faster skipping\r\n        //    of colon that follows name\r\n        if ((_inputPtr + len + 4) \u003c _inputEnd) {\r\n            // maybe...\r\n            // first check length match by\r\n            final int end \u003d _inputPtr + len;\r\n            if (_inputBuffer[end] \u003d\u003d INT_QUOTE) {\r\n                int offset \u003d 0;\r\n                int ptr \u003d _inputPtr;\r\n                while (true) {\r\n                    if (ptr \u003d\u003d end) {\r\n                        // yes, match!\r\n                        _parsingContext.setCurrentName(str.getValue());\r\n                        i \u003d _skipColonFast(ptr + 1);\r\n                        _isNextTokenNameYes(i);\r\n                        return true;\r\n                    }\r\n                    if (nameBytes[offset] !\u003d _inputBuffer[ptr]) {\r\n                        break;\r\n                    }\r\n                    ++offset;\r\n                    ++ptr;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _isNextTokenNameMaybe(i, str);\r\n}",
    "nodes": 29,
    "edges": 37,
    "cc": 10,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i15 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i15 !\u003d 93) → B7 | else → B8",
      "B8 : If($i15 !\u003d 125) → B9 | else → B10",
      "B10 : If($z1 \u003d\u003d false) → B11 | else → B17",
      "B11 : If($i15 \u003d\u003d 44) → B12 | else → B13",
      "B13 : If($i13 \u003d\u003d false) → B14 | else → B17",
      "B14 : If($i14 \u003d\u003d 93) → B15 | else → B16",
      "B15 : If($i14 !\u003d 125) → B16 | else → B17",
      "B17 : If($z2 !\u003d 0) → B18 | else → B19",
      "B19 : If(i16 !\u003d 34) → B20 | else → B28",
      "B20 : If($i4 \u003e\u003d $i3) → B21 | else → B28",
      "B21 : If($i20 !\u003d 34) → B22 | else → B28",
      "B23 : If(i18 !\u003d i6) → B24 | else → B25",
      "B25 : If($i21 \u003d\u003d $i22) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  SerializableString\n  UTF8StreamJsonParser: int _numTypesValid\u003e \u003d 0\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0._nextAfterName()\n  return\n}",
      "B2 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i15 \u003d r0._skipWSOrEnd()\n  i16 \u003d $i15\n  if ($i15 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  UTF8StreamJsonParser: byte[] _binaryValue\u003e \u003d null\n  if ($i15 !\u003d 93) goto B7 else B8\n}",
      "B7 {\n  r0._closeArrayScope()\n  $r14 \u003d JsonToken END_ARRAY\u003e\n  r0._updateToken($r14)\n  return\n}",
      "B8 {\n  if ($i15 !\u003d 125) goto B9 else B10\n}",
      "B9 {\n  r0._closeObjectScope()\n  $r13 \u003d JsonToken END_OBJECT\u003e\n  r0._updateToken($r13)\n  return\n}",
      "B10 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B11 else B17\n}",
      "B11 {\n  if ($i15 \u003d\u003d 44) goto B12 else B13\n}",
      "B12 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $r11 \u003d $r10.typeDesc()\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportUnexpectedChar($i15, $r12)\n}",
      "B13 {\n  $i14 \u003d r0._skipWS()\n  i16 \u003d $i14\n  $i12 \u003d UTF8StreamJsonParser: int _features\u003e\n  $i11 \u003d UTF8StreamJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i13 \u003d $i12 \u0026 $i11\n  if ($i13 \u003d\u003d false) goto B14 else B17\n}",
      "B14 {\n  if ($i14 \u003d\u003d 93) goto B15 else B16\n}",
      "B15 {\n  if ($i14 !\u003d 125) goto B16 else B17\n}",
      "B16 {\n  r0._closeScope($i14)\n  return\n}",
      "B17 {\n  $r15 \u003d JsonReadContext _parsingContext\u003e\n  $z2 \u003d $r15.inObject()\n  if ($z2 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  r0._updateLocation()\n  r0._nextTokenNotInObject(i16)\n  return\n}",
      "B19 {\n  r0._updateNameLocation()\n  if (i16 !\u003d 34) goto B20 else B28\n}",
      "B20 {\n  r5 \u003d r4.asQuotedUTF8()\n  i0 \u003d lengthof r5\n  $i1 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n  $i2 \u003d $i1 + i0\n  $i4 \u003d $i2 + 4\n  $i3 \u003d UTF8StreamJsonParser: int _inputEnd\u003e\n  if ($i4 \u003e\u003d $i3) goto B21 else B28\n}",
      "B21 {\n  $i5 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n  i6 \u003d $i5 + i0\n  $r6 \u003d UTF8StreamJsonParser: byte[] _inputBuffer\u003e\n  $b7 \u003d $r6[i6]\n  $i20 \u003d (int) $b7\n  if ($i20 !\u003d 34) goto B22 else B28\n}",
      "B22 {\n  i17 \u003d 0\n  i18 \u003d UTF8StreamJsonParser: int _inputPtr\u003e\n}",
      "B23 {\n  if (i18 !\u003d i6) goto B24 else B25\n}",
      "B24 {\n  $r8 \u003d JsonReadContext _parsingContext\u003e\n  $r9 \u003d r4.getValue()\n  $r8.setCurrentName($r9)\n  $i10 \u003d i18 + 1\n  i19 \u003d r0._skipColonFast($i10)\n  r0._isNextTokenNameYes(i19)\n  return\n}",
      "B25 {\n  $b9 \u003d r5[i17]\n  $r7 \u003d UTF8StreamJsonParser: byte[] _inputBuffer\u003e\n  $b8 \u003d $r7[i18]\n  $i21 \u003d (int) $b9\n  $i22 \u003d (int) $b8\n  if ($i21 \u003d\u003d $i22) goto B26 else B27\n}",
      "B26 {\n  goto B28\n}",
      "B27 {\n  i17 \u003d i17 + 1\n  i18 \u003d i18 + 1\n  goto B23\n}",
      "B28 {\n  $z3 \u003d r0._isNextTokenNameMaybe(i16, r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B28",
      "B21 --\u003e B22",
      "B21 --\u003e B28",
      "B22 --\u003e B23",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B28",
      "B27 --\u003e B23",
      "B28 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_skipColonFast(...1)",
        "body": "{\r\n    int i \u003d _inputBuffer[ptr++];\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputBuffer[ptr++];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                _inputPtr \u003d ptr;\r\n                return i;\r\n            }\r\n        } else if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[ptr++];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                    _inputPtr \u003d ptr;\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        _inputPtr \u003d ptr - 1;\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputBuffer[ptr++];\r\n    }\r\n    if (i \u003d\u003d INT_COLON) {\r\n        i \u003d _inputBuffer[ptr++];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                _inputPtr \u003d ptr;\r\n                return i;\r\n            }\r\n        } else if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[ptr++];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i !\u003d INT_SLASH \u0026\u0026 i !\u003d INT_HASH) {\r\n                    _inputPtr \u003d ptr;\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        _inputPtr \u003d ptr - 1;\r\n        return _skipColon2(true);\r\n    }\r\n    _inputPtr \u003d ptr - 1;\r\n    return _skipColon2(false);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseSignedNumber(true));\r\n        case \u0027+\u0027:\r\n            if (!isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                return _updateToken(_handleUnexpectedValue(i));\r\n            }\r\n            return _updateToken(_parseSignedNumber(false));\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false, false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n    }\r\n    return _updateToken(_handleUnexpectedValue(i));\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_closeArrayScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inArray()) {\r\n        _reportMismatchedEndMarker(\u0027]\u0027, \u0027}\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    _nameStartRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_isNextTokenNameMaybe(...2)",
        "body": "{\r\n    // // // and this is back to standard nextToken()\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    final boolean match \u003d n.equals(str.getValue());\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return match;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return match;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateLocation(...0)",
        "body": "{\r\n    _tokenInputRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWS(...0)",
        "body": "{\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWS2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWS2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    _closeArrayScope();\r\n    return _updateToken(JsonToken.END_ARRAY);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_isNextTokenNameYes(...1)",
        "body": "{\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    _updateLocation();\r\n    switch(i) {\r\n        case \u0027\"\u0027:\r\n            _tokenIncomplete \u003d true;\r\n            _nextToken \u003d JsonToken.VALUE_STRING;\r\n            return;\r\n        case \u0027[\u0027:\r\n            _nextToken \u003d JsonToken.START_ARRAY;\r\n            return;\r\n        case \u0027{\u0027:\r\n            _nextToken \u003d JsonToken.START_OBJECT;\r\n            return;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            _nextToken \u003d JsonToken.VALUE_TRUE;\r\n            return;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            _nextToken \u003d JsonToken.VALUE_FALSE;\r\n            return;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            _nextToken \u003d JsonToken.VALUE_NULL;\r\n            return;\r\n        case \u0027-\u0027:\r\n            _nextToken \u003d _parseSignedNumber(true);\r\n            return;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                _nextToken \u003d _parseSignedNumber(false);\r\n            } else {\r\n                _nextToken \u003d _handleUnexpectedValue(i);\r\n            }\r\n            return;\r\n        case // [core#611]\r\n        \u0027.\u0027:\r\n            _nextToken \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            return;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            _nextToken \u003d _parseUnsignedNumber(i);\r\n            return;\r\n    }\r\n    _nextToken \u003d _handleUnexpectedValue(i);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    // Need to be fully UTF-8 aware here:\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    main_loop: while (true) {\r\n        int c;\r\n        ascii_loop: while (true) {\r\n            int ptr \u003d _inputPtr;\r\n            int max \u003d _inputEnd;\r\n            if (ptr \u003e\u003d max) {\r\n                _loadMoreGuaranteed();\r\n                ptr \u003d _inputPtr;\r\n                max \u003d _inputEnd;\r\n            }\r\n            while (ptr \u003c max) {\r\n                c \u003d inputBuffer[ptr++] \u0026 0xFF;\r\n                if (codes[c] !\u003d 0) {\r\n                    _inputPtr \u003d ptr;\r\n                    break ascii_loop;\r\n                }\r\n            }\r\n            _inputPtr \u003d ptr;\r\n        }\r\n        // Ok: end marker, escape or multi-byte?\r\n        if (c \u003d\u003d INT_QUOTE) {\r\n            break main_loop;\r\n        }\r\n        switch(codes[c]) {\r\n            case // backslash\r\n            1:\r\n                _decodeEscaped();\r\n                break;\r\n            case // 2-byte UTF\r\n            2:\r\n                _skipUtf8_2();\r\n                break;\r\n            case // 3-byte UTF\r\n            3:\r\n                _skipUtf8_3();\r\n                break;\r\n            case // 4-byte UTF\r\n            4:\r\n                _skipUtf8_4(c);\r\n                break;\r\n            default:\r\n                if (c \u003c INT_SPACE) {\r\n                    _throwUnquotedSpace(c, \"string value\");\r\n                } else {\r\n                    // Is this good enough error message?\r\n                    _reportInvalidChar(c);\r\n                }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeObjectScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inObject()) {\r\n        _reportMismatchedEndMarker(\u0027}\u0027, \u0027]\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextFieldName",
    "signature": "java.lang.String nextFieldName()",
    "visibility": "public",
    "body": "{\r\n    // // // Note: this is almost a verbatim copy of nextToken()\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        _nextAfterName();\r\n        return null;\r\n    }\r\n    if (_tokenIncomplete) {\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        close();\r\n        _updateTokenToNull();\r\n        return null;\r\n    }\r\n    _binaryValue \u003d null;\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        _updateToken(JsonToken.END_ARRAY);\r\n        return null;\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        _updateToken(JsonToken.END_OBJECT);\r\n        return null;\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                _closeScope(i);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        _nextTokenNotInObject(i);\r\n        return null;\r\n    }\r\n    _updateNameLocation();\r\n    final String nameStr \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(nameStr);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return nameStr;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return nameStr;\r\n}",
    "nodes": 35,
    "edges": 49,
    "cc": 16,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($i4 \u003e\u003d 0) → B5 | else → B6",
      "B6 : If($i4 !\u003d 93) → B7 | else → B8",
      "B8 : If($i4 !\u003d 125) → B9 | else → B10",
      "B10 : If($z1 \u003d\u003d false) → B11 | else → B17",
      "B11 : If($i4 \u003d\u003d 44) → B12 | else → B13",
      "B13 : If($i2 \u003d\u003d false) → B14 | else → B17",
      "B14 : If($i3 \u003d\u003d 93) → B15 | else → B16",
      "B15 : If($i3 !\u003d 125) → B16 | else → B17",
      "B17 : If($z3 !\u003d 0) → B18 | else → B19",
      "B19 : If(i6 !\u003d 34) → B20 | else → B21",
      "B21 : If(switch-on i6) → B23 | else → B22",
      "B23 : If($z2 \u003d\u003d false) → B24 | else → B25"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  UTF8StreamJsonParser: int _numTypesValid\u003e \u003d 0\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0._nextAfterName()\n  return\n}",
      "B2 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._skipString()\n}",
      "B4 {\n  $i4 \u003d r0._skipWSOrEnd()\n  i5 \u003d $i4\n  if ($i4 \u003e\u003d 0) goto B5 else B6\n}",
      "B5 {\n  r0.close()\n  r0._updateTokenToNull()\n  return\n}",
      "B6 {\n  UTF8StreamJsonParser: byte[] _binaryValue\u003e \u003d null\n  if ($i4 !\u003d 93) goto B7 else B8\n}",
      "B7 {\n  r0._closeArrayScope()\n  $r14 \u003d JsonToken END_ARRAY\u003e\n  r0._updateToken($r14)\n  return\n}",
      "B8 {\n  if ($i4 !\u003d 125) goto B9 else B10\n}",
      "B9 {\n  r0._closeObjectScope()\n  $r13 \u003d JsonToken END_OBJECT\u003e\n  r0._updateToken($r13)\n  return\n}",
      "B10 {\n  $r3 \u003d JsonReadContext _parsingContext\u003e\n  $z1 \u003d $r3.expectComma()\n  if ($z1 \u003d\u003d false) goto B11 else B17\n}",
      "B11 {\n  if ($i4 \u003d\u003d 44) goto B12 else B13\n}",
      "B12 {\n  $r10 \u003d JsonReadContext _parsingContext\u003e\n  $r11 \u003d $r10.typeDesc()\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11)\n  r0._reportUnexpectedChar($i4, $r12)\n}",
      "B13 {\n  $i3 \u003d r0._skipWS()\n  i5 \u003d $i3\n  $i1 \u003d UTF8StreamJsonParser: int _features\u003e\n  $i0 \u003d UTF8StreamJsonParser: int FEAT_MASK_TRAILING_COMMA\u003e\n  $i2 \u003d $i1 \u0026 $i0\n  if ($i2 \u003d\u003d false) goto B14 else B17\n}",
      "B14 {\n  if ($i3 \u003d\u003d 93) goto B15 else B16\n}",
      "B15 {\n  if ($i3 !\u003d 125) goto B16 else B17\n}",
      "B16 {\n  r0._closeScope($i3)\n  return\n}",
      "B17 {\n  $r15 \u003d JsonReadContext _parsingContext\u003e\n  $z3 \u003d $r15.inObject()\n  if ($z3 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  r0._updateLocation()\n  r0._nextTokenNotInObject(i5)\n  return\n}",
      "B19 {\n  r0._updateNameLocation()\n  r4 \u003d r0._parseName(i5)\n  $r5 \u003d JsonReadContext _parsingContext\u003e\n  $r5.setCurrentName(r4)\n  $r6 \u003d JsonToken FIELD_NAME\u003e\n  r0._updateToken($r6)\n  i6 \u003d r0._skipColon()\n  r0._updateLocation()\n  if (i6 !\u003d 34) goto B20 else B21\n}",
      "B20 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 1\n  $r9 \u003d JsonToken VALUE_STRING\u003e\n  JsonToken _nextToken\u003e \u003d $r9\n  return\n}",
      "B21 {\n  JsonToken _handleUnexpectedValue(int)\u003e(i6); }\n}",
      "B22 {\n  r16 \u003d r0._parseSignedNumber(1)\n  goto B34\n}",
      "B23 {\n  $r7 \u003d JsonReadFeature ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS\u003e\n  $r8 \u003d $r7.mappedFeature()\n  $z2 \u003d r0.isEnabled($r8)\n  if ($z2 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  r16 \u003d r0._parseSignedNumber(0)\n  goto B34\n}",
      "B25 {\n  r16 \u003d r0._handleUnexpectedValue(i6)\n  goto B34\n}",
      "B26 {\n  r16 \u003d r0._parseFloatThatStartsWithPeriod(0, 0)\n  goto B34\n}",
      "B27 {\n  r16 \u003d r0._parseUnsignedNumber(i6)\n  goto B34\n}",
      "B28 {\n  r0._matchFalse()\n  r16 \u003d JsonToken VALUE_FALSE\u003e\n  goto B34\n}",
      "B29 {\n  r0._matchNull()\n  r16 \u003d JsonToken VALUE_NULL\u003e\n  goto B34\n}",
      "B30 {\n  r0._matchTrue()\n  r16 \u003d JsonToken VALUE_TRUE\u003e\n  goto B34\n}",
      "B31 {\n  r16 \u003d JsonToken START_ARRAY\u003e\n  goto B34\n}",
      "B32 {\n  r16 \u003d JsonToken START_OBJECT\u003e\n  goto B34\n}",
      "B33 {\n  r16 \u003d r0._handleUnexpectedValue(i6)\n}",
      "B34 {\n  JsonToken _nextToken\u003e \u003d r16\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B17",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B23",
      "B21 --\u003e B22",
      "B21 --\u003e B26",
      "B21 --\u003e B27",
      "B21 --\u003e B31",
      "B21 --\u003e B28",
      "B21 --\u003e B29",
      "B21 --\u003e B30",
      "B21 --\u003e B32",
      "B21 --\u003e B33",
      "B22 --\u003e B34",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B34",
      "B25 --\u003e B34",
      "B26 --\u003e B34",
      "B27 --\u003e B34",
      "B28 --\u003e B34",
      "B29 --\u003e B34",
      "B30 --\u003e B34",
      "B31 --\u003e B34",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_parseName(...1)",
        "body": "{\r\n    if (i !\u003d INT_QUOTE) {\r\n        return _handleOddName(i);\r\n    }\r\n    // First: can we optimize out bounds checks?\r\n    if ((_inputPtr + 13) \u003e _inputEnd) {\r\n        // Need up to 12 chars, plus one trailing (quote)\r\n        return slowParseName();\r\n    }\r\n    // If so, can also unroll loops nicely\r\n    /* 25-Nov-2008, tatu: This may seem weird, but here we do\r\n         *   NOT want to worry about UTF-8 decoding. Rather, we\u0027ll\r\n         *   assume that part is ok (if not it will get caught\r\n         *   later on), and just handle quotes and backslashes here.\r\n         */\r\n    final byte[] input \u003d _inputBuffer;\r\n    final int[] codes \u003d INPUT_CODES_LATIN1;\r\n    int q \u003d input[_inputPtr++] \u0026 0xFF;\r\n    if (codes[q] \u003d\u003d 0) {\r\n        i \u003d input[_inputPtr++] \u0026 0xFF;\r\n        if (codes[i] \u003d\u003d 0) {\r\n            q \u003d (q \u003c\u003c 8) | i;\r\n            i \u003d input[_inputPtr++] \u0026 0xFF;\r\n            if (codes[i] \u003d\u003d 0) {\r\n                q \u003d (q \u003c\u003c 8) | i;\r\n                i \u003d input[_inputPtr++] \u0026 0xFF;\r\n                if (codes[i] \u003d\u003d 0) {\r\n                    q \u003d (q \u003c\u003c 8) | i;\r\n                    i \u003d input[_inputPtr++] \u0026 0xFF;\r\n                    if (codes[i] \u003d\u003d 0) {\r\n                        _quad1 \u003d q;\r\n                        return parseMediumName(i);\r\n                    }\r\n                    if (i \u003d\u003d INT_QUOTE) {\r\n                        // 4 byte/char case or broken\r\n                        return findName(q, 4);\r\n                    }\r\n                    return parseName(q, i, 4);\r\n                }\r\n                if (i \u003d\u003d INT_QUOTE) {\r\n                    // 3 byte/char case or broken\r\n                    return findName(q, 3);\r\n                }\r\n                return parseName(q, i, 3);\r\n            }\r\n            if (i \u003d\u003d INT_QUOTE) {\r\n                // 2 byte/char case or broken\r\n                return findName(q, 2);\r\n            }\r\n            return parseName(q, i, 2);\r\n        }\r\n        if (i \u003d\u003d INT_QUOTE) {\r\n            // one byte/char case or broken\r\n            return findName(q, 1);\r\n        }\r\n        return parseName(q, i, 1);\r\n    }\r\n    if (q \u003d\u003d INT_QUOTE) {\r\n        // special case, \"\"\r\n        return \"\";\r\n    }\r\n    // quoting or invalid char\r\n    return parseName(0, q, 0);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_nextAfterName(...0)",
        "body": "{\r\n    // need to invalidate if it was copied\r\n    _nameCopied \u003d false;\r\n    JsonToken t \u003d _nextToken;\r\n    _nextToken \u003d null;\r\n    // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\r\n    // Also: may need to start new context?\r\n    if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n        createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n    } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n        createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n    }\r\n    return _updateToken(t);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWSOrEnd(...0)",
        "body": "{\r\n    // Let\u0027s handle first character separately since it is likely that\r\n    // it is either non-whitespace; or we have longer run of white space\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        if (!_loadMore()) {\r\n            return _eofAsNextChar();\r\n        }\r\n    }\r\n    int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n    if (i \u003e INT_SPACE) {\r\n        if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n            --_inputPtr;\r\n            return _skipWSOrEnd2();\r\n        }\r\n        return i;\r\n    }\r\n    if (i !\u003d INT_SPACE) {\r\n        if (i \u003d\u003d INT_LF) {\r\n            ++_currInputRow;\r\n            _currInputRowStart \u003d _inputPtr;\r\n        } else if (i \u003d\u003d INT_CR) {\r\n            _skipCR();\r\n        } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n            _throwInvalidSpace(i);\r\n        }\r\n    }\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWSOrEnd2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB \u0026\u0026 !_isAllowedCtrlCharRS(i)) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWSOrEnd2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_matchFalse(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 4) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027a\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027s\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027e\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"false\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#close(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_matchTrue(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027r\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027u\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027e\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"true\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_nextTokenNotInObject(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        return _updateToken(JsonToken.VALUE_STRING);\r\n    }\r\n    switch(i) {\r\n        case \u0027[\u0027:\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_ARRAY);\r\n        case \u0027{\u0027:\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n            return _updateToken(JsonToken.START_OBJECT);\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            return _updateToken(JsonToken.VALUE_TRUE);\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            return _updateToken(JsonToken.VALUE_FALSE);\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            return _updateToken(JsonToken.VALUE_NULL);\r\n        case \u0027-\u0027:\r\n            return _updateToken(_parseSignedNumber(true));\r\n        case \u0027+\u0027:\r\n            if (!isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                return _updateToken(_handleUnexpectedValue(i));\r\n            }\r\n            return _updateToken(_parseSignedNumber(false));\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            return _updateToken(_parseFloatThatStartsWithPeriod(false, false));\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            return _updateToken(_parseUnsignedNumber(i));\r\n    }\r\n    return _updateToken(_handleUnexpectedValue(i));\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_closeArrayScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inArray()) {\r\n        _reportMismatchedEndMarker(\u0027]\u0027, \u0027}\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateNameLocation(...0)",
        "body": "{\r\n    _nameStartRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _nameStartOffset \u003d ptr;\r\n    _nameStartCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseSignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    if (negative) {\r\n        // Need to prepend sign?\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    // Must have something after sign too\r\n    if (_inputPtr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n    }\r\n    int c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n    // Note: must be followed by a digit\r\n    if (c \u003c\u003d INT_0) {\r\n        // One special case: if first char is 0, must not be followed by a digit\r\n        if (c !\u003d INT_0) {\r\n            if (c \u003d\u003d INT_PERIOD) {\r\n                return _parseFloatThatStartsWithPeriod(negative, true);\r\n            }\r\n            return _handleInvalidNumberStart(c, negative, true);\r\n        }\r\n        c \u003d _verifyNoLeadingZeroes();\r\n    } else if (c \u003e INT_9) {\r\n        return _handleInvalidNumberStart(c, negative, true);\r\n    }\r\n    // Ok: we can first just add digit we saw first:\r\n    outBuf[outPtr++] \u003d (char) c;\r\n    int intLen \u003d 1;\r\n    // And then figure out how far we can read without further checks\r\n    // for either input or output\r\n    final int end \u003d Math.min(_inputEnd, _inputPtr + outBuf.length - outPtr);\r\n    // With this, we have a nice and tight loop:\r\n    while (true) {\r\n        if (_inputPtr \u003e\u003d end) {\r\n            // Long enough to be split across boundary, so:\r\n            return _parseNumber2(outBuf, outPtr, negative, intLen);\r\n        }\r\n        c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (c \u003c INT_0 || c \u003e INT_9) {\r\n            break;\r\n        }\r\n        ++intLen;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    if (c \u003d\u003d INT_PERIOD || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\r\n    }\r\n    // to push back trailing char (comma etc)\r\n    --_inputPtr;\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(c);\r\n    }\r\n    // And there we have it!\r\n    return resetInt(negative, intLen);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateLocation(...0)",
        "body": "{\r\n    _tokenInputRow \u003d _currInputRow;\r\n    final int ptr \u003d _inputPtr;\r\n    _tokenInputTotal \u003d _currInputProcessed + ptr;\r\n    _tokenInputCol \u003d ptr - _currInputRowStart;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseUnsignedNumber(...1)",
        "body": "{\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    // One special case: if first char is 0, must not be followed by a digit\r\n    if (c \u003d\u003d INT_0) {\r\n        c \u003d _verifyNoLeadingZeroes();\r\n    }\r\n    // Ok: we can first just add digit we saw first:\r\n    outBuf[0] \u003d (char) c;\r\n    int intLen \u003d 1;\r\n    int outPtr \u003d 1;\r\n    // And then figure out how far we can read without further checks\r\n    // for either input or output\r\n    // 1 \u003d\u003d outPtr\r\n    final int end \u003d Math.min(_inputEnd, _inputPtr + outBuf.length - 1);\r\n    // With this, we have a nice and tight loop:\r\n    while (true) {\r\n        if (_inputPtr \u003e\u003d end) {\r\n            // split across boundary, offline\r\n            return _parseNumber2(outBuf, outPtr, false, intLen);\r\n        }\r\n        c \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (c \u003c INT_0 || c \u003e INT_9) {\r\n            break;\r\n        }\r\n        ++intLen;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    if (c \u003d\u003d INT_PERIOD || (c | 0x20) \u003d\u003d INT_e) {\r\n        // ~ \u0027.eE\u0027\r\n        return _parseFloat(outBuf, outPtr, c, false, intLen);\r\n    }\r\n    // to push back trailing char (comma etc)\r\n    --_inputPtr;\r\n    _textBuffer.setCurrentLength(outPtr);\r\n    // As per #105, need separating space between root values; check here\r\n    if (_parsingContext.inRoot()) {\r\n        _verifyRootSpace(c);\r\n    }\r\n    // And there we have it!\r\n    return resetInt(false, intLen);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_matchNull(...0)",
        "body": "{\r\n    int ptr \u003d _inputPtr;\r\n    if ((ptr + 3) \u003c _inputEnd) {\r\n        byte[] buf \u003d _inputBuffer;\r\n        if ((buf[ptr++] \u003d\u003d \u0027u\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027) \u0026\u0026 (buf[ptr++] \u003d\u003d \u0027l\u0027)) {\r\n            int ch \u003d buf[ptr] \u0026 0xFF;\r\n            if (ch \u003c INT_0 || (ch | 0x20) \u003d\u003d INT_RCURLY) {\r\n                //  \u003c \u00270\u0027 || ~ \u0027}]\u0027 expected/allowed chars\r\n                _inputPtr \u003d ptr;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _matchToken2(\"null\", 1);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_reportUnexpectedChar(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_skipWS(...0)",
        "body": "{\r\n    while (_inputPtr \u003c _inputEnd) {\r\n        int i \u003d _inputBuffer[_inputPtr++] \u0026 0xFF;\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                --_inputPtr;\r\n                return _skipWS2();\r\n            }\r\n            return i;\r\n        }\r\n        if (i !\u003d INT_SPACE) {\r\n            if (i \u003d\u003d INT_LF) {\r\n                ++_currInputRow;\r\n                _currInputRowStart \u003d _inputPtr;\r\n            } else if (i \u003d\u003d INT_CR) {\r\n                _skipCR();\r\n            } else if (i !\u003d INT_TAB) {\r\n                _throwInvalidSpace(i);\r\n            }\r\n        }\r\n    }\r\n    return _skipWS2();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateTokenToNull(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeScope(...1)",
        "body": "{\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    _closeArrayScope();\r\n    return _updateToken(JsonToken.END_ARRAY);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_parseFloatThatStartsWithPeriod(...2)",
        "body": "{\r\n    // [core#611]: allow optionally leading decimal point\r\n    if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS.mappedFeature())) {\r\n        return _handleUnexpectedValue(INT_PERIOD);\r\n    }\r\n    final char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    int outPtr \u003d 0;\r\n    // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\r\n    if (neg) {\r\n        outBuf[outPtr++] \u003d \u0027-\u0027;\r\n    }\r\n    return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipString(...0)",
        "body": "{\r\n    _tokenIncomplete \u003d false;\r\n    // Need to be fully UTF-8 aware here:\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    main_loop: while (true) {\r\n        int c;\r\n        ascii_loop: while (true) {\r\n            int ptr \u003d _inputPtr;\r\n            int max \u003d _inputEnd;\r\n            if (ptr \u003e\u003d max) {\r\n                _loadMoreGuaranteed();\r\n                ptr \u003d _inputPtr;\r\n                max \u003d _inputEnd;\r\n            }\r\n            while (ptr \u003c max) {\r\n                c \u003d inputBuffer[ptr++] \u0026 0xFF;\r\n                if (codes[c] !\u003d 0) {\r\n                    _inputPtr \u003d ptr;\r\n                    break ascii_loop;\r\n                }\r\n            }\r\n            _inputPtr \u003d ptr;\r\n        }\r\n        // Ok: end marker, escape or multi-byte?\r\n        if (c \u003d\u003d INT_QUOTE) {\r\n            break main_loop;\r\n        }\r\n        switch(codes[c]) {\r\n            case // backslash\r\n            1:\r\n                _decodeEscaped();\r\n                break;\r\n            case // 2-byte UTF\r\n            2:\r\n                _skipUtf8_2();\r\n                break;\r\n            case // 3-byte UTF\r\n            3:\r\n                _skipUtf8_3();\r\n                break;\r\n            case // 4-byte UTF\r\n            4:\r\n                _skipUtf8_4(c);\r\n                break;\r\n            default:\r\n                if (c \u003c INT_SPACE) {\r\n                    _throwUnquotedSpace(c, \"string value\");\r\n                } else {\r\n                    // Is this good enough error message?\r\n                    _reportInvalidChar(c);\r\n                }\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#_closeObjectScope(...0)",
        "body": "{\r\n    _updateLocation();\r\n    if (!_parsingContext.inObject()) {\r\n        _reportMismatchedEndMarker(\u0027}\u0027, \u0027]\u0027);\r\n    }\r\n    _parsingContext \u003d _parsingContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_handleUnexpectedValue(...1)",
        "body": "{\r\n    // Most likely an error, unless we are to allow single-quote-strings\r\n    switch(c) {\r\n        /* This check proceeds only if `Feature.ALLOW_MISSING_VALUES` is enabled;\r\n         * it is for missing values. In case of missing values in an array the next token\r\n         * will be either \u0027,\u0027 or \u0027]\u0027. This case, decrements the already incremented _inputPtr\r\n         * in the buffer in case of comma (`,`) so that the existing flow goes back to checking\r\n         * the next token which will be comma again and  it parsing continues.\r\n         * Also the case returns NULL as current token in case of \u0027,\u0027 or \u0027]\u0027.\r\n         */\r\n        case \u0027]\u0027:\r\n            if (!_parsingContext.inArray()) {\r\n                break;\r\n            }\r\n        // fall through\r\n        case \u0027,\u0027:\r\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\r\n            //   we may allow \"missing values\", that is, encountering a trailing\r\n            //   comma or closing marker where value would be expected\r\n            // 11-May-2020, tatu: [core#616] No commas in root level\r\n            if (!_parsingContext.inRoot()) {\r\n                if ((_features \u0026 FEAT_MASK_ALLOW_MISSING) !\u003d 0) {\r\n                    --_inputPtr;\r\n                    return JsonToken.VALUE_NULL;\r\n                }\r\n            }\r\n        // fall through\r\n        case \u0027}\u0027:\r\n            // Error: neither is valid at this point; valid closers have\r\n            // been handled earlier\r\n            _reportUnexpectedChar(c, \"expected a value\");\r\n        case \u0027\\\u0027\u0027:\r\n            if ((_features \u0026 FEAT_MASK_ALLOW_SINGLE_QUOTES) !\u003d 0) {\r\n                return _handleApos();\r\n            }\r\n            break;\r\n        case \u0027N\u0027:\r\n            _matchToken(\"NaN\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"NaN\", Double.NaN);\r\n            }\r\n            _reportError(\"Non-standard token \u0027NaN\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case \u0027I\u0027:\r\n            _matchToken(\"Infinity\", 1);\r\n            if ((_features \u0026 FEAT_MASK_NON_NUM_NUMBERS) !\u003d 0) {\r\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\r\n            }\r\n            _reportError(\"Non-standard token \u0027Infinity\u0027: enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow\");\r\n            break;\r\n        case // note: \u0027-\u0027 is taken as number\r\n        \u0027+\u0027:\r\n            if (_inputPtr \u003e\u003d _inputEnd) {\r\n                if (!_loadMore()) {\r\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\r\n                }\r\n            }\r\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] \u0026 0xFF, false, true);\r\n    }\r\n    // [core#77] Try to decode most likely token\r\n    if (Character.isJavaIdentifierStart(c)) {\r\n        _reportInvalidToken(\"\" + ((char) c), _validJsonTokenList());\r\n    }\r\n    // but if it doesn\u0027t look like a token:\r\n    _reportUnexpectedChar(c, \"expected a valid value \" + _validJsonValueList());\r\n    return null;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_skipColon(...0)",
        "body": "{\r\n    if ((_inputPtr + 4) \u003e\u003d _inputEnd) {\r\n        return _skipColon2(false);\r\n    }\r\n    // Fast path: colon with optional single-space/tab before and/or after:\r\n    int i \u003d _inputBuffer[_inputPtr];\r\n    if (i \u003d\u003d INT_COLON) {\r\n        // common case, no leading space\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            // nor trailing\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        // true -\u003e skipped colon\r\n        return _skipColon2(true);\r\n    }\r\n    if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n    }\r\n    if (i \u003d\u003d INT_COLON) {\r\n        i \u003d _inputBuffer[++_inputPtr];\r\n        if (i \u003e INT_SPACE) {\r\n            if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                return _skipColon2(true);\r\n            }\r\n            ++_inputPtr;\r\n            return i;\r\n        }\r\n        if (i \u003d\u003d INT_SPACE || i \u003d\u003d INT_TAB) {\r\n            i \u003d _inputBuffer[++_inputPtr];\r\n            if (i \u003e INT_SPACE) {\r\n                if (i \u003d\u003d INT_SLASH || i \u003d\u003d INT_HASH) {\r\n                    return _skipColon2(true);\r\n                }\r\n                ++_inputPtr;\r\n                return i;\r\n            }\r\n        }\r\n        return _skipColon2(true);\r\n    }\r\n    return _skipColon2(false);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextTextValue",
    "signature": "java.lang.String nextTextValue()",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_STRING) {\r\n            if (_tokenIncomplete) {\r\n                _tokenIncomplete \u003d false;\r\n                return _finishAndReturnString();\r\n            }\r\n            return _textBuffer.contentsAsString();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_STRING) ? getText() : null;\r\n}",
    "nodes": 14,
    "edges": 16,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(r5 !\u003d $r7) → B6 | else → B7",
      "B7 : If(r5 !\u003d $r8) → B8 | else → B9",
      "B10 : If($r4 !\u003d $r3) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  UTF8StreamJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_STRING\u003e\n  if (r5 !\u003d $r6) goto B2 else B5\n}",
      "B2 {\n  $z0 \u003d UTF8StreamJsonParser: boolean _tokenIncomplete\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  UTF8StreamJsonParser: boolean _tokenIncomplete\u003e \u003d 0\n  $r11 \u003d r0._finishAndReturnString()\n  return\n}",
      "B4 {\n  $r9 \u003d TextBuffer _textBuffer\u003e\n  $r10 \u003d $r9.contentsAsString()\n  return\n}",
      "B5 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i2 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i3, $i2)\n  goto B9\n}",
      "B7 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i0 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i1, $i0)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_STRING\u003e\n  if ($r4 !\u003d $r3) goto B11 else B12\n}",
      "B11 {\n  $r12 \u003d r0.getText()\n  goto B13\n}",
      "B12 {\n  $r12 \u003d null\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        return _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                return _closeScope(i);\r\n            }\r\n        }\r\n    }\r\n    // And should we now have a name? Always true for Object contexts\r\n    // since the intermediate \u0027expect-value\u0027 state is never retained.\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    _updateNameLocation();\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_finishAndReturnString(...0)",
        "body": "{\r\n    // First, single tight loop for ASCII content, not split across input buffer boundary:\r\n    int ptr \u003d _inputPtr;\r\n    if (ptr \u003e\u003d _inputEnd) {\r\n        _loadMoreGuaranteed();\r\n        ptr \u003d _inputPtr;\r\n    }\r\n    int outPtr \u003d 0;\r\n    char[] outBuf \u003d _textBuffer.emptyAndGetCurrentSegment();\r\n    final int[] codes \u003d INPUT_CODES_UTF8;\r\n    final int max \u003d Math.min(_inputEnd, (ptr + outBuf.length));\r\n    final byte[] inputBuffer \u003d _inputBuffer;\r\n    while (ptr \u003c max) {\r\n        int c \u003d inputBuffer[ptr] \u0026 0xFF;\r\n        if (codes[c] !\u003d 0) {\r\n            if (c \u003d\u003d INT_QUOTE) {\r\n                _inputPtr \u003d ptr + 1;\r\n                return _textBuffer.setCurrentAndReturn(outPtr);\r\n            }\r\n            break;\r\n        }\r\n        ++ptr;\r\n        outBuf[outPtr++] \u003d (char) c;\r\n    }\r\n    _inputPtr \u003d ptr;\r\n    _finishString2(outBuf, outPtr);\r\n    return _textBuffer.contentsAsString();\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#getText(...0)",
        "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.VALUE_STRING) {\r\n        if (_tokenIncomplete) {\r\n            _tokenIncomplete \u003d false;\r\n            // only strings can be incomplete\r\n            return _finishAndReturnString();\r\n        }\r\n        return _textBuffer.contentsAsString();\r\n    }\r\n    return _getText2(_currToken);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextIntValue",
    "signature": "int nextIntValue(int)",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getIntValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  i0 :\u003d @parameter0: int\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  UTF8StreamJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $i5 \u003d r0.getIntValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $i6 \u003d r0.getIntValue()\n  goto B11\n}",
      "B10 {\n  $i6 \u003d i0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#getIntValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        return _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                return _closeScope(i);\r\n            }\r\n        }\r\n    }\r\n    // And should we now have a name? Always true for Object contexts\r\n    // since the intermediate \u0027expect-value\u0027 state is never retained.\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    _updateNameLocation();\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextLongValue",
    "signature": "long nextLongValue(long)",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_NUMBER_INT) {\r\n            return getLongValue();\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return defaultValue;\r\n    }\r\n    // !!! TODO: optimize this case as well\r\n    return (nextToken() \u003d\u003d JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B8",
      "B1 : If(r5 !\u003d $r6) → B2 | else → B3",
      "B3 : If(r5 !\u003d $r7) → B4 | else → B5",
      "B5 : If(r5 !\u003d $r8) → B6 | else → B7",
      "B8 : If($r4 !\u003d $r3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  l0 :\u003d @parameter0: long\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B8\n}",
      "B1 {\n  UTF8StreamJsonParser: boolean _nameCopied\u003e \u003d 0\n  r5 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r5)\n  $r6 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if (r5 !\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $l5 \u003d r0.getLongValue()\n  return\n}",
      "B3 {\n  $r7 \u003d JsonToken START_ARRAY\u003e\n  if (r5 !\u003d $r7) goto B4 else B5\n}",
      "B4 {\n  $i4 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i3 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i4, $i3)\n  goto B7\n}",
      "B5 {\n  $r8 \u003d JsonToken START_OBJECT\u003e\n  if (r5 !\u003d $r8) goto B6 else B7\n}",
      "B6 {\n  $i2 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i2, $i1)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r4 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_NUMBER_INT\u003e\n  if ($r4 !\u003d $r3) goto B9 else B10\n}",
      "B9 {\n  $l6 \u003d r0.getLongValue()\n  goto B11\n}",
      "B10 {\n  $l6 \u003d l0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B8",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#getLongValue(...0)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        return _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                return _closeScope(i);\r\n            }\r\n        }\r\n    }\r\n    // And should we now have a name? Always true for Object contexts\r\n    // since the intermediate \u0027expect-value\u0027 state is never retained.\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    _updateNameLocation();\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "nextBooleanValue",
    "signature": "java.lang.Boolean nextBooleanValue()",
    "visibility": "public",
    "body": "{\r\n    // two distinct cases; either got name and we know next type, or \u0027other\u0027\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        // mostly copied from \u0027_nextAfterName\u0027\r\n        _nameCopied \u003d false;\r\n        JsonToken t \u003d _nextToken;\r\n        _nextToken \u003d null;\r\n        _updateToken(t);\r\n        if (t \u003d\u003d JsonToken.VALUE_TRUE) {\r\n            return Boolean.TRUE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.VALUE_FALSE) {\r\n            return Boolean.FALSE;\r\n        }\r\n        if (t \u003d\u003d JsonToken.START_ARRAY) {\r\n            createChildArrayContext(_tokenInputRow, _tokenInputCol);\r\n        } else if (t \u003d\u003d JsonToken.START_OBJECT) {\r\n            createChildObjectContext(_tokenInputRow, _tokenInputCol);\r\n        }\r\n        return null;\r\n    }\r\n    JsonToken t \u003d nextToken();\r\n    if (t \u003d\u003d JsonToken.VALUE_TRUE) {\r\n        return Boolean.TRUE;\r\n    }\r\n    if (t \u003d\u003d JsonToken.VALUE_FALSE) {\r\n        return Boolean.FALSE;\r\n    }\r\n    return null;\r\n}",
    "nodes": 15,
    "edges": 16,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B10",
      "B1 : If(r13 !\u003d $r7) → B2 | else → B3",
      "B3 : If(r13 !\u003d $r8) → B4 | else → B5",
      "B5 : If(r13 !\u003d $r9) → B6 | else → B7",
      "B7 : If(r13 !\u003d $r10) → B8 | else → B9",
      "B10 : If(r14 !\u003d $r3) → B11 | else → B12",
      "B12 : If(r14 !\u003d $r4) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B10\n}",
      "B1 {\n  UTF8StreamJsonParser: boolean _nameCopied\u003e \u003d 0\n  r13 \u003d JsonToken _nextToken\u003e\n  JsonToken _nextToken\u003e \u003d null\n  r0._updateToken(r13)\n  $r7 \u003d JsonToken VALUE_TRUE\u003e\n  if (r13 !\u003d $r7) goto B2 else B3\n}",
      "B2 {\n  $r12 \u003d Boolean TRUE\u003e\n  return\n}",
      "B3 {\n  $r8 \u003d JsonToken VALUE_FALSE\u003e\n  if (r13 !\u003d $r8) goto B4 else B5\n}",
      "B4 {\n  $r11 \u003d Boolean FALSE\u003e\n  return\n}",
      "B5 {\n  $r9 \u003d JsonToken START_ARRAY\u003e\n  if (r13 !\u003d $r9) goto B6 else B7\n}",
      "B6 {\n  $i3 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i2 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildArrayContext($i3, $i2)\n  goto B9\n}",
      "B7 {\n  $r10 \u003d JsonToken START_OBJECT\u003e\n  if (r13 !\u003d $r10) goto B8 else B9\n}",
      "B8 {\n  $i1 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i0 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  r0.createChildObjectContext($i1, $i0)\n}",
      "B9 {\n  return\n}",
      "B10 {\n  r14 \u003d r0.nextToken()\n  $r3 \u003d JsonToken VALUE_TRUE\u003e\n  if (r14 !\u003d $r3) goto B11 else B12\n}",
      "B11 {\n  $r6 \u003d Boolean TRUE\u003e\n  return\n}",
      "B12 {\n  $r4 \u003d JsonToken VALUE_FALSE\u003e\n  if (r14 !\u003d $r4) goto B13 else B14\n}",
      "B13 {\n  $r5 \u003d Boolean FALSE\u003e\n  return\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B10",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#createChildObjectContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#createChildArrayContext(...2)",
        "body": "(source not found)"
      },
      {
        "name": "UTF8StreamJsonParser#nextToken(...0)",
        "body": "{\r\n    /* First: field names are special -- we will always tokenize\r\n         * (part of) value along with field name to simplify\r\n         * state handling. If so, can and need to use secondary token:\r\n         */\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        return _nextAfterName();\r\n    }\r\n    // But if we didn\u0027t already have a name, and (partially?) decode number,\r\n    // need to ensure no numeric information is leaked\r\n    _numTypesValid \u003d NR_UNKNOWN;\r\n    if (_tokenIncomplete) {\r\n        // only strings can be partial\r\n        _skipString();\r\n    }\r\n    int i \u003d _skipWSOrEnd();\r\n    if (i \u003c 0) {\r\n        // end-of-input\r\n        // Close/release things like input source, symbol table and recyclable buffers\r\n        close();\r\n        return _updateTokenToNull();\r\n    }\r\n    // clear any data retained so far\r\n    _binaryValue \u003d null;\r\n    // Closing scope?\r\n    if (i \u003d\u003d INT_RBRACKET) {\r\n        _closeArrayScope();\r\n        return _updateToken(JsonToken.END_ARRAY);\r\n    }\r\n    if (i \u003d\u003d INT_RCURLY) {\r\n        _closeObjectScope();\r\n        return _updateToken(JsonToken.END_OBJECT);\r\n    }\r\n    // Nope: do we then expect a comma?\r\n    if (_parsingContext.expectComma()) {\r\n        if (i !\u003d INT_COMMA) {\r\n            _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.typeDesc() + \" entries\");\r\n        }\r\n        i \u003d _skipWS();\r\n        // Was that a trailing comma?\r\n        if ((_features \u0026 FEAT_MASK_TRAILING_COMMA) !\u003d 0) {\r\n            if ((i \u003d\u003d INT_RBRACKET) || (i \u003d\u003d INT_RCURLY)) {\r\n                return _closeScope(i);\r\n            }\r\n        }\r\n    }\r\n    // And should we now have a name? Always true for Object contexts\r\n    // since the intermediate \u0027expect-value\u0027 state is never retained.\r\n    if (!_parsingContext.inObject()) {\r\n        _updateLocation();\r\n        return _nextTokenNotInObject(i);\r\n    }\r\n    // So first parse the field name itself:\r\n    _updateNameLocation();\r\n    String n \u003d _parseName(i);\r\n    _parsingContext.setCurrentName(n);\r\n    _updateToken(JsonToken.FIELD_NAME);\r\n    i \u003d _skipColon();\r\n    _updateLocation();\r\n    // Ok: we must have a value... what is it? Strings are very common, check first:\r\n    if (i \u003d\u003d INT_QUOTE) {\r\n        _tokenIncomplete \u003d true;\r\n        _nextToken \u003d JsonToken.VALUE_STRING;\r\n        return _currToken;\r\n    }\r\n    JsonToken t;\r\n    switch(i) {\r\n        case \u0027-\u0027:\r\n            t \u003d _parseSignedNumber(true);\r\n            break;\r\n        case \u0027+\u0027:\r\n            if (isEnabled(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS.mappedFeature())) {\r\n                t \u003d _parseSignedNumber(false);\r\n            } else {\r\n                t \u003d _handleUnexpectedValue(i);\r\n            }\r\n            break;\r\n        case // [core#611]:\r\n        \u0027.\u0027:\r\n            t \u003d _parseFloatThatStartsWithPeriod(false, false);\r\n            break;\r\n        case \u00270\u0027:\r\n        case \u00271\u0027:\r\n        case \u00272\u0027:\r\n        case \u00273\u0027:\r\n        case \u00274\u0027:\r\n        case \u00275\u0027:\r\n        case \u00276\u0027:\r\n        case \u00277\u0027:\r\n        case \u00278\u0027:\r\n        case \u00279\u0027:\r\n            t \u003d _parseUnsignedNumber(i);\r\n            break;\r\n        case \u0027f\u0027:\r\n            _matchFalse();\r\n            t \u003d JsonToken.VALUE_FALSE;\r\n            break;\r\n        case \u0027n\u0027:\r\n            _matchNull();\r\n            t \u003d JsonToken.VALUE_NULL;\r\n            break;\r\n        case \u0027t\u0027:\r\n            _matchTrue();\r\n            t \u003d JsonToken.VALUE_TRUE;\r\n            break;\r\n        case \u0027[\u0027:\r\n            t \u003d JsonToken.START_ARRAY;\r\n            break;\r\n        case \u0027{\u0027:\r\n            t \u003d JsonToken.START_OBJECT;\r\n            break;\r\n        default:\r\n            t \u003d _handleUnexpectedValue(i);\r\n    }\r\n    _nextToken \u003d t;\r\n    return _currToken;\r\n}"
      },
      {
        "name": "UTF8StreamJsonParser#_updateToken(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser",
    "methodName": "currentTokenLocation",
    "signature": "com.fasterxml.jackson.core.JsonLocation currentTokenLocation()",
    "visibility": "public",
    "body": "{\r\n    if (_currToken \u003d\u003d JsonToken.FIELD_NAME) {\r\n        long total \u003d _currInputProcessed + (_nameStartOffset - 1);\r\n        return new JsonLocation(_contentReference(), total, -1L, _nameStartRow, _nameStartCol);\r\n    }\r\n    return new JsonLocation(_contentReference(), _tokenInputTotal - 1, -1L, _tokenInputRow, _tokenInputCol);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  UTF8StreamJsonParser\n  $r2 \u003d JsonToken _currToken\u003e\n  $r1 \u003d JsonToken FIELD_NAME\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $l7 \u003d UTF8StreamJsonParser: long _currInputProcessed\u003e\n  $i4 \u003d UTF8StreamJsonParser: int _nameStartOffset\u003e\n  $i5 \u003d $i4 - 1\n  $l6 \u003d (long) $i5\n  l8 \u003d $l7 + $l6\n  $r5 \u003d JsonLocation\n  $r6 \u003d r0._contentReference()\n  $i10 \u003d UTF8StreamJsonParser: int _nameStartRow\u003e\n  $i9 \u003d UTF8StreamJsonParser: int _nameStartCol\u003e\n  new JsonLocation($r6, l8, -1L, $i10, $i9)\n  return\n}",
      "B2 {\n  $r3 \u003d JsonLocation\n  $r4 \u003d r0._contentReference()\n  $l0 \u003d UTF8StreamJsonParser: long _tokenInputTotal\u003e\n  $l3 \u003d $l0 - 1L\n  $i2 \u003d UTF8StreamJsonParser: int _tokenInputRow\u003e\n  $i1 \u003d UTF8StreamJsonParser: int _tokenInputCol\u003e\n  new JsonLocation($r4, $l3, -1L, $i2, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "UTF8StreamJsonParser#_contentReference(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    int status \u003d _writeContext.writeFieldName(name);\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    _writeFieldName(name, (status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA));\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 4) → B1 | else → B2",
      "B2 : If(i0 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  String\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  i0 \u003d $r2.writeFieldName(r1)\n  if (i0 !\u003d 4) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B2 {\n  if (i0 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  r0._writeFieldName(r1, $z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeFieldName(...2)",
        "body": "{\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _writePPFieldName(name, commaBefore);\r\n        return;\r\n    }\r\n    // for fast+std case, need to output up to 2 chars, comma, dquote\r\n    if ((_outputTail + 1) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    if (commaBefore) {\r\n        _outputBuffer[_outputTail++] \u003d \u0027,\u0027;\r\n    }\r\n    // Alternate mode, in which quoting of field names disabled?\r\n    if (_cfgUnqNames) {\r\n        _writeString(name);\r\n        return;\r\n    }\r\n    // we know there\u0027s room for at least one more char\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // The beef:\r\n    _writeString(name);\r\n    // and closing quotes; need room for one more char:\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeFieldName",
    "signature": "void writeFieldName(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    // Object is a value, need to verify it\u0027s allowed\r\n    int status \u003d _writeContext.writeFieldName(name.getValue());\r\n    if (status \u003d\u003d JsonWriteContext.STATUS_EXPECT_VALUE) {\r\n        _reportError(\"Can not write a field name, expecting a value\");\r\n    }\r\n    _writeFieldName(name, (status \u003d\u003d JsonWriteContext.STATUS_OK_AFTER_COMMA));\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 4) → B1 | else → B2",
      "B2 : If(i0 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  SerializableString\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d r1.getValue()\n  i0 \u003d $r2.writeFieldName($r3)\n  if (i0 !\u003d 4) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"Can not write a field name, expecting a value\")\n}",
      "B2 {\n  if (i0 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  r0._writeFieldName(r1, $z0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeFieldName(...2)",
        "body": "{\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _writePPFieldName(name, commaBefore);\r\n        return;\r\n    }\r\n    // for fast+std case, need to output up to 2 chars, comma, dquote\r\n    if ((_outputTail + 1) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    if (commaBefore) {\r\n        _outputBuffer[_outputTail++] \u003d \u0027,\u0027;\r\n    }\r\n    // Alternate mode, in which quoting of field names disabled?\r\n    if (_cfgUnqNames) {\r\n        _writeString(name);\r\n        return;\r\n    }\r\n    // we know there\u0027s room for at least one more char\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    // The beef:\r\n    _writeString(name);\r\n    // and closing quotes; need room for one more char:\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027[\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r0._verifyValueWrite(\"start an array\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildArrayContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r7.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r6 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $r6[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext(currentValue);\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027[\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Object\n  r0._verifyValueWrite(\"start an array\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d $r2.createChildArrayContext(r1)\n  JsonWriteContext _writeContext\u003e \u003d $r3\n  $r5 \u003d r0.streamWriteConstraints()\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getNestingDepth()\n  $r5.validateNestingDepth($i0)\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r8.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r7 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $r7[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(java.lang.Object,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an array\");\r\n    _writeContext \u003d _writeContext.createChildArrayContext(currentValue);\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartArray(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027[\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Object\n  i5 :\u003d @parameter1: int\n  r0._verifyValueWrite(\"start an array\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  $r3 \u003d $r2.createChildArrayContext(r1)\n  JsonWriteContext _writeContext\u003e \u003d $r3\n  $r5 \u003d r0.streamWriteConstraints()\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getNestingDepth()\n  $r5.validateNestingDepth($i0)\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r8.writeStartArray(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r7 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $r7[$i3] \u003d 91\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeEndArray",
    "signature": "void writeEndArray()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027]\u0027;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i1 \u003c $i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inArray()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d JsonWriteContext _writeContext\u003e\n  $r7 \u003d $r6.typeDesc()\n  $r8 \u003d dynInvoke makeConcatWithConstants($r7)\n  r0._reportError($r8)\n}",
      "B2 {\n  $r2 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i4 \u003d $r4.getEntryCount()\n  $r5.writeEndArray(r0, $i4)\n  goto B7\n}",
      "B4 {\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $r3[$i2] \u003d 93\n}",
      "B7 {\n  $r9 \u003d JsonWriteContext _writeContext\u003e\n  $r10 \u003d $r9.clearAndGetParent()\n  JsonWriteContext _writeContext\u003e \u003d $r10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject()",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an object\");\r\n    _writeContext \u003d _writeContext.createChildObjectContext();\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartObject(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027{\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r5 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r0._verifyValueWrite(\"start an object\")\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $r2 \u003d $r1.createChildObjectContext()\n  JsonWriteContext _writeContext\u003e \u003d $r2\n  $r4 \u003d r0.streamWriteConstraints()\n  $r3 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r3.getNestingDepth()\n  $r4.validateNestingDepth($i0)\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r5 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r7.writeStartObject(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r6 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $r6[$i3] \u003d 123\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(\"start an object\");\r\n    JsonWriteContext ctxt \u003d _writeContext.createChildObjectContext(forValue);\r\n    streamWriteConstraints().validateNestingDepth(_writeContext.getNestingDepth());\r\n    _writeContext \u003d ctxt;\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeStartObject(this);\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027{\u0027;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Object\n  r0._verifyValueWrite(\"start an object\")\n  $r2 \u003d JsonWriteContext _writeContext\u003e\n  r3 \u003d $r2.createChildObjectContext(r1)\n  $r5 \u003d r0.streamWriteConstraints()\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i0 \u003d $r4.getNestingDepth()\n  $r5.validateNestingDepth($i0)\n  JsonWriteContext _writeContext\u003e \u003d r3\n  $r6 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r8.writeStartObject(r0)\n  goto B5\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r7 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $r7[$i3] \u003d 123\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#streamWriteConstraints(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject()",
    "visibility": "public",
    "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027}\u0027;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i1 \u003c $i0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  $r1 \u003d JsonWriteContext _writeContext\u003e\n  $z0 \u003d $r1.inObject()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d JsonWriteContext _writeContext\u003e\n  $r7 \u003d $r6.typeDesc()\n  $r8 \u003d dynInvoke makeConcatWithConstants($r7)\n  r0._reportError($r8)\n}",
      "B2 {\n  $r2 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d PrettyPrinter _cfgPrettyPrinter\u003e\n  $r4 \u003d JsonWriteContext _writeContext\u003e\n  $i4 \u003d $r4.getEntryCount()\n  $r5.writeEndObject(r0, $i4)\n  goto B7\n}",
      "B4 {\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $r3[$i2] \u003d 125\n}",
      "B7 {\n  $r9 \u003d JsonWriteContext _writeContext\u003e\n  $r10 \u003d $r9.clearAndGetParent()\n  JsonWriteContext _writeContext\u003e \u003d $r10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeString(text);\r\n    // And finally, closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($i1 \u003c $i0) → B3 | else → B4",
      "B4 : If($i6 \u003c $i5) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  String\n  r0._verifyValueWrite(\"write a string\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  return\n}",
      "B2 {\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r2 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $c4 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r2[$i2] \u003d $c4\n  r0._writeString(r1)\n  $i6 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i5 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i6 \u003c $i5) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i7 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i8 \u003d $i7 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i8\n  $c9 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r3[$i7] \u003d $c9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeString(...1)",
        "body": "{\r\n    /* One check first: if String won\u0027t fit in the buffer, let\u0027s\r\n         * segment writes. No point in extending buffer to huge sizes\r\n         * (like if someone wants to include multi-megabyte base64\r\n         * encoded stuff or such)\r\n         */\r\n    final int len \u003d text.length();\r\n    if (len \u003e _outputEnd) {\r\n        // Let\u0027s reserve space for entity at begin/end\r\n        _writeLongString(text);\r\n        return;\r\n    }\r\n    // Ok: we know String will fit in buffer ok\r\n    // But do we need to flush first?\r\n    if ((_outputTail + len) \u003e _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    text.getChars(0, len, _outputBuffer, _outputTail);\r\n    if (_characterEscapes !\u003d null) {\r\n        _writeStringCustom(len);\r\n    } else if (_maximumNonEscapedChar !\u003d 0) {\r\n        _writeStringASCII(len, _maximumNonEscapedChar);\r\n    } else {\r\n        _writeString2(len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    int ptr \u003d _outputTail;\r\n    char[] buf \u003d _outputBuffer;\r\n    buf[ptr] \u003d \u0027n\u0027;\r\n    buf[++ptr] \u003d \u0027u\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    _outputTail \u003d ptr + 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(java.io.Reader,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (reader \u003d\u003d null) {\r\n        _reportError(\"null reader\");\r\n        // just to block warnings by lgtm.com\r\n        return;\r\n    }\r\n    int toRead \u003d (len \u003e\u003d 0) ? len : Integer.MAX_VALUE;\r\n    // Add leading quote\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    final char[] buf \u003d _allocateCopyBuffer();\r\n    while (toRead \u003e 0) {\r\n        int toReadNow \u003d Math.min(toRead, buf.length);\r\n        int numRead \u003d reader.read(buf, 0, toReadNow);\r\n        if (numRead \u003c\u003d 0) {\r\n            break;\r\n        }\r\n        _writeString(buf, 0, numRead);\r\n        toRead -\u003d numRead;\r\n    }\r\n    // Add trailing quote\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    if (toRead \u003e 0 \u0026\u0026 len \u003e\u003d 0) {\r\n        _reportError(\"Didn\u0027t read enough from reader\");\r\n    }\r\n}",
    "nodes": 18,
    "edges": 24,
    "cc": 8,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If(i0 \u003c 0) → B3 | else → B4",
      "B5 : If($i2 \u003c $i1) → B6 | else → B7",
      "B8 : If(i15 \u003c\u003d 0) → B9 | else → B12",
      "B9 : If(i13 \u003e 0) → B10 | else → B11",
      "B12 : If($i7 \u003c $i6) → B13 | else → B14",
      "B14 : If(i15 \u003c\u003d 0) → B15 | else → B17",
      "B15 : If(i0 \u003c 0) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Reader\n  i0 :\u003d @parameter1: int\n  r0._verifyValueWrite(\"write a string\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._reportError(\"null reader\")\n  return\n}",
      "B2 {\n  if (i0 \u003c 0) goto B3 else B4\n}",
      "B3 {\n  $i14 \u003d i0\n  goto B5\n}",
      "B4 {\n  $i14 \u003d 2147483647\n}",
      "B5 {\n  i15 \u003d $i14\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B6 else B7\n}",
      "B6 {\n  r0._flushBuffer()\n}",
      "B7 {\n  $r2 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i4 \u003d $i3 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i4\n  $c5 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r2[$i3] \u003d $c5\n  $r4 \u003d r0._allocateCopyBuffer()\n}",
      "B8 {\n  if (i15 \u003c\u003d 0) goto B9 else B12\n}",
      "B9 {\n  $i11 \u003d lengthof $r4\n  i12 \u003d Math.min(i15, $i11)\n  i13 \u003d r1.read($r4, 0, i12)\n  if (i13 \u003e 0) goto B10 else B11\n}",
      "B10 {\n  goto B12\n}",
      "B11 {\n  r0._writeString($r4, 0, i13)\n  i15 \u003d i15 - i13\n  goto B8\n}",
      "B12 {\n  $i7 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i6 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i7 \u003c $i6) goto B13 else B14\n}",
      "B13 {\n  r0._flushBuffer()\n}",
      "B14 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i8 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i9 \u003d $i8 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i9\n  $c10 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r3[$i8] \u003d $c10\n  if (i15 \u003c\u003d 0) goto B15 else B17\n}",
      "B15 {\n  if (i0 \u003c 0) goto B16 else B17\n}",
      "B16 {\n  r0._reportError(\"Didn\\\u0027t read enough from reader\")\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B8",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeString(...3)",
        "body": "{\r\n    if (_characterEscapes !\u003d null) {\r\n        _writeStringCustom(text, offset, len);\r\n        return;\r\n    }\r\n    if (_maximumNonEscapedChar !\u003d 0) {\r\n        _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\r\n        return;\r\n    }\r\n    // Let\u0027s just find longest spans of non-escapable content, and for\r\n    // each see if it makes sense to copy them, or write through\r\n    // -\u003e len marks the end from now on\r\n    len +\u003d offset;\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    final int escLen \u003d escCodes.length;\r\n    while (offset \u003c len) {\r\n        int start \u003d offset;\r\n        while (true) {\r\n            char c \u003d text[offset];\r\n            if (c \u003c escLen \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break;\r\n            }\r\n            if (++offset \u003e\u003d len) {\r\n                break;\r\n            }\r\n        }\r\n        // Short span? Better just copy it to buffer first:\r\n        int newAmount \u003d offset - start;\r\n        if (newAmount \u003c SHORT_WRITE) {\r\n            // Note: let\u0027s reserve room for escaped char (up to 6 chars)\r\n            if ((_outputTail + newAmount) \u003e _outputEnd) {\r\n                _flushBuffer();\r\n            }\r\n            if (newAmount \u003e 0) {\r\n                System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\r\n                _outputTail +\u003d newAmount;\r\n            }\r\n        } else {\r\n            // Nope: better just write through\r\n            _flushBuffer();\r\n            _writer.write(text, start, newAmount);\r\n        }\r\n        // Was this the end?\r\n        if (offset \u003e\u003d len) {\r\n            // yup\r\n            break;\r\n        }\r\n        // Nope, need to escape the char.\r\n        char c \u003d text[offset++];\r\n        _appendCharacterEscape(c, escCodes[c]);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#_allocateCopyBuffer(...0)",
        "body": "{\r\n    if (_copyBuffer \u003d\u003d null) {\r\n        _copyBuffer \u003d _ioContext.allocNameCopyBuffer(2000);\r\n    }\r\n    return _copyBuffer;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeString(text, offset, len);\r\n    // And finally, closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If($i8 \u003c $i7) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r2 :\u003d @parameter0: char[]\n  i5 :\u003d @parameter1: int\n  i6 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a string\")\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $c4 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r1[$i2] \u003d $c4\n  r0._writeString(r2, i5, i6)\n  $i8 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i7 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i8 \u003c $i7) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i9 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i10\n  $c11 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r3[$i9] \u003d $c11\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeString(...3)",
        "body": "{\r\n    if (_characterEscapes !\u003d null) {\r\n        _writeStringCustom(text, offset, len);\r\n        return;\r\n    }\r\n    if (_maximumNonEscapedChar !\u003d 0) {\r\n        _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\r\n        return;\r\n    }\r\n    // Let\u0027s just find longest spans of non-escapable content, and for\r\n    // each see if it makes sense to copy them, or write through\r\n    // -\u003e len marks the end from now on\r\n    len +\u003d offset;\r\n    final int[] escCodes \u003d _outputEscapes;\r\n    final int escLen \u003d escCodes.length;\r\n    while (offset \u003c len) {\r\n        int start \u003d offset;\r\n        while (true) {\r\n            char c \u003d text[offset];\r\n            if (c \u003c escLen \u0026\u0026 escCodes[c] !\u003d 0) {\r\n                break;\r\n            }\r\n            if (++offset \u003e\u003d len) {\r\n                break;\r\n            }\r\n        }\r\n        // Short span? Better just copy it to buffer first:\r\n        int newAmount \u003d offset - start;\r\n        if (newAmount \u003c SHORT_WRITE) {\r\n            // Note: let\u0027s reserve room for escaped char (up to 6 chars)\r\n            if ((_outputTail + newAmount) \u003e _outputEnd) {\r\n                _flushBuffer();\r\n            }\r\n            if (newAmount \u003e 0) {\r\n                System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\r\n                _outputTail +\u003d newAmount;\r\n            }\r\n        } else {\r\n            // Nope: better just write through\r\n            _flushBuffer();\r\n            _writer.write(text, start, newAmount);\r\n        }\r\n        // Was this the end?\r\n        if (offset \u003e\u003d len) {\r\n            // yup\r\n            break;\r\n        }\r\n        // Nope, need to escape the char.\r\n        char c \u003d text[offset++];\r\n        _appendCharacterEscape(c, escCodes[c]);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeString",
    "signature": "void writeString(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    int len \u003d sstr.appendQuoted(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        _writeString2(sstr);\r\n        return;\r\n    }\r\n    _outputTail +\u003d len;\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If($i13 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If($i9 \u003c $i8) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  SerializableString\n  r0._verifyValueWrite(\"write a string\")\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $c4 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r1[$i2] \u003d $c4\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i5 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i13 \u003d r2.appendQuoted($r3, $i5)\n  if ($i13 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  r0._writeString2(r2)\n  return\n}",
      "B4 {\n  $i6 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i7 \u003d $i6 + $i13\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i7\n  $i9 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i8 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B5 else B6\n}",
      "B5 {\n  r0._flushBuffer()\n}",
      "B6 {\n  $r4 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i10 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i11\n  $c12 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r4[$i10] \u003d $c12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeString2(...1)",
        "body": "{\r\n    // Note: copied from writeRaw:\r\n    char[] text \u003d sstr.asQuotedChars();\r\n    final int len \u003d text.length;\r\n    if (len \u003c SHORT_WRITE) {\r\n        int room \u003d _outputEnd - _outputTail;\r\n        if (len \u003e room) {\r\n            _flushBuffer();\r\n        }\r\n        System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        _flushBuffer();\r\n        _writer.write(text, 0, len);\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i8 !\u003d 0) → B1 | else → B2",
      "B2 : If(i8 \u003c i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  String\n  i0 \u003d r0.length()\n  $i2 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i8 \u003d $i2 - $i1\n  if (i8 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r1._flushBuffer()\n  $i7 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  $i6 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i8 \u003d $i7 - $i6\n}",
      "B2 {\n  if (i8 \u003c i0) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  r0.getChars(0, i0, $r2, $i3)\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + i0\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i5\n  goto B5\n}",
      "B4 {\n  r1.writeRawLong(r0)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeRawLong(...1)",
        "body": "{\r\n    int room \u003d _outputEnd - _outputTail;\r\n    // If not, need to do it by looping\r\n    text.getChars(0, room, _outputBuffer, _outputTail);\r\n    _outputTail +\u003d room;\r\n    _flushBuffer();\r\n    int offset \u003d room;\r\n    int len \u003d text.length() - room;\r\n    while (len \u003e _outputEnd) {\r\n        int amount \u003d _outputEnd;\r\n        text.getChars(offset, offset + amount, _outputBuffer, 0);\r\n        _outputHead \u003d 0;\r\n        _outputTail \u003d amount;\r\n        _flushBuffer();\r\n        offset +\u003d amount;\r\n        len -\u003d amount;\r\n    }\r\n    // And last piece (at most length of buffer)\r\n    text.getChars(offset, offset + len, _outputBuffer, 0);\r\n    _outputHead \u003d 0;\r\n    _outputTail \u003d len;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    // Nothing to check, can just output as is\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003c len) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(offset, offset + len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text.substring(offset, offset + len));\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i11 \u003e\u003d i1) → B1 | else → B2",
      "B2 : If(i11 \u003c i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForString(r1, i0, i1)\n  $i3 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i11 \u003d $i3 - $i2\n  if (i11 \u003e\u003d i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n  $i10 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  $i9 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i11 \u003d $i10 - $i9\n}",
      "B2 {\n  if (i11 \u003c i1) goto B3 else B4\n}",
      "B3 {\n  $i6 \u003d i0 + i1\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i5 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  r1.getChars(i0, $i6, $r3, $i5)\n  $i7 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i8 \u003d $i7 + i1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i8\n  goto B5\n}",
      "B4 {\n  $i4 \u003d i0 + i1\n  $r2 \u003d r1.substring(i0, $i4)\n  r0.writeRawLong($r2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeRawLong(...1)",
        "body": "{\r\n    int room \u003d _outputEnd - _outputTail;\r\n    // If not, need to do it by looping\r\n    text.getChars(0, room, _outputBuffer, _outputTail);\r\n    _outputTail +\u003d room;\r\n    _flushBuffer();\r\n    int offset \u003d room;\r\n    int len \u003d text.length() - room;\r\n    while (len \u003e _outputEnd) {\r\n        int amount \u003d _outputEnd;\r\n        text.getChars(offset, offset + amount, _outputBuffer, 0);\r\n        _outputHead \u003d 0;\r\n        _outputTail \u003d amount;\r\n        _flushBuffer();\r\n        offset +\u003d amount;\r\n        len -\u003d amount;\r\n    }\r\n    // And last piece (at most length of buffer)\r\n    text.getChars(offset, offset + len, _outputBuffer, 0);\r\n    _outputHead \u003d 0;\r\n    _outputTail \u003d len;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_checkRangeBoundsForString(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    int len \u003d text.appendUnquoted(_outputBuffer, _outputTail);\r\n    if (len \u003c 0) {\r\n        writeRaw(text.getValue());\r\n        return;\r\n    }\r\n    _outputTail +\u003d len;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  SerializableString\n  $r2 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i1 \u003d r0.appendUnquoted($r2, $i0)\n  if (i1 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.getValue()\n  r1.writeRaw($r3)\n  return\n}",
      "B2 {\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + i1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForCharArray(cbuf, offset, len);\r\n    // Only worth buffering if it\u0027s a short write?\r\n    if (len \u003c SHORT_WRITE) {\r\n        int room \u003d _outputEnd - _outputTail;\r\n        if (len \u003e room) {\r\n            _flushBuffer();\r\n        }\r\n        System.arraycopy(cbuf, offset, _outputBuffer, _outputTail, len);\r\n        _outputTail +\u003d len;\r\n        return;\r\n    }\r\n    // Otherwise, better just pass through:\r\n    _flushBuffer();\r\n    _writer.write(cbuf, offset, len);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i1 \u003e\u003d 32) → B1 | else → B4",
      "B1 : If(i1 \u003c\u003d i4) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForCharArray(r1, i0, i1)\n  if (i1 \u003e\u003d 32) goto B1 else B4\n}",
      "B1 {\n  $i3 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  i4 \u003d $i3 - $i2\n  if (i1 \u003c\u003d i4) goto B2 else B3\n}",
      "B2 {\n  r0._flushBuffer()\n}",
      "B3 {\n  $r3 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i5 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  System.arraycopy(r1, i0, $r3, $i5, i1)\n  $i6 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i7 \u003d $i6 + i1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i7\n  return\n}",
      "B4 {\n  r0._flushBuffer()\n  $r2 \u003d Writer _writer\u003e\n  $r2.write(r1, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_checkRangeBoundsForCharArray(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeRaw",
    "signature": "void writeRaw(char)",
    "visibility": "public",
    "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  c4 :\u003d @parameter0: char\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $r1[$i2] \u003d c4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeBinary",
    "signature": "void writeBinary(com.fasterxml.jackson.core.Base64Variant,byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForByteArray(data, offset, len);\r\n    _verifyValueWrite(WRITE_BINARY);\r\n    // Starting quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeBinary(b64variant, data, offset, offset + len);\r\n    // and closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i3 \u003c $i2) → B1 | else → B2",
      "B2 : If($i9 \u003c $i8) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Base64Variant\n  r1 :\u003d @parameter1: byte[]\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  r0._checkRangeBoundsForByteArray(r1, i0, i1)\n  r0._verifyValueWrite(\"write a binary value\")\n  $i3 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i3 \u003c $i2) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r2 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i5 \u003d $i4 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i5\n  $c6 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r2[$i4] \u003d $c6\n  $i7 \u003d i0 + i1\n  r0._writeBinary(r3, r1, i0, $i7)\n  $i9 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i8 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i9 \u003c $i8) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r4 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i10 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i11 \u003d $i10 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i11\n  $c12 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r4[$i10] \u003d $c12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_checkRangeBoundsForByteArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeBinary(...4)",
        "body": "{\r\n    // Encoding is by chunks of 3 input, 4 output chars, so:\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    // Let\u0027s also reserve room for possible (and quoted) lf char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            // note: must quote in JSON value\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    // 0, 1 or 2\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeBinary",
    "signature": "int writeBinary(com.fasterxml.jackson.core.Base64Variant,java.io.InputStream,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_BINARY);\r\n    // Starting quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    byte[] encodingBuffer \u003d _ioContext.allocBase64Buffer();\r\n    int bytes;\r\n    try {\r\n        if (dataLength \u003c 0) {\r\n            // length unknown\r\n            bytes \u003d _writeBinary(b64variant, data, encodingBuffer);\r\n        } else {\r\n            int missing \u003d _writeBinary(b64variant, data, encodingBuffer, dataLength);\r\n            if (missing \u003e 0) {\r\n                _reportError(\"Too few bytes available: missing \" + missing + \" bytes (out of \" + dataLength + \")\");\r\n            }\r\n            bytes \u003d dataLength;\r\n        }\r\n    } finally {\r\n        _ioContext.releaseBase64Buffer(encodingBuffer);\r\n    }\r\n    // and closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    return bytes;\r\n}",
    "nodes": 12,
    "edges": 14,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2",
      "B2 : If(i5 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If(i6 \u003c\u003d 0) → B5 | else → B6",
      "B9 : If($i8 \u003c $i7) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  Base64Variant\n  InputStream\n  i5 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a binary value\")\n  $i1 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i0 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i2 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i3 \u003d $i2 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  $c4 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r1[$i2] \u003d $c4\n  $r2 \u003d IOContext _ioContext\u003e\n  $r7 \u003d $r2.allocBase64Buffer()\n  if (i5 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  i12 \u003d r0._writeBinary(r3, r4, $r7)\n  goto B7\n}",
      "B4 {\n  i6 \u003d r0._writeBinary(r3, r4, $r7, i5)\n  if (i6 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $r6 \u003d dynInvoke makeConcatWithConstants(i6, i5)\n  r0._reportError($r6)\n}",
      "B6 {\n  i12 \u003d i5\n}",
      "B7 {\n  $r10 \u003d IOContext _ioContext\u003e\n  $r10.releaseBase64Buffer($r7)\n  goto B9\n}",
      "B8 {\n  $r8 :\u003d @caughtexception\n  $r9 \u003d IOContext _ioContext\u003e\n  $r9.releaseBase64Buffer($r7)\n  throw $r8\n}",
      "B9 {\n  $i8 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i7 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i8 \u003c $i7) goto B10 else B11\n}",
      "B10 {\n  r0._flushBuffer()\n}",
      "B11 {\n  $r5 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i9 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i10 \u003d $i9 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i10\n  $c11 \u003d WriterBasedJsonGenerator: char _quoteChar\u003e\n  $r5[$i9] \u003d $c11\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeBinary(...4)",
        "body": "{\r\n    // Encoding is by chunks of 3 input, 4 output chars, so:\r\n    int safeInputEnd \u003d inputEnd - 3;\r\n    // Let\u0027s also reserve room for possible (and quoted) lf char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (inputPtr \u003c\u003d safeInputEnd) {\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (input[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((input[inputPtr++]) \u0026 0xFF);\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            // note: must quote in JSON value\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    // 0, 1 or 2\r\n    int inputLeft \u003d inputEnd - inputPtr;\r\n    if (inputLeft \u003e 0) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (input[inputPtr++]) \u003c\u003c 16;\r\n        if (inputLeft \u003d\u003d 2) {\r\n            b24 |\u003d ((input[inputPtr++]) \u0026 0xFF) \u003c\u003c 8;\r\n        }\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeBinary(...3)",
        "body": "{\r\n    int inputPtr \u003d 0;\r\n    int inputEnd \u003d 0;\r\n    int lastFullOffset \u003d -3;\r\n    int bytesDone \u003d 0;\r\n    // Let\u0027s also reserve room for possible (and quoted) LF char each round\r\n    int safeOutputEnd \u003d _outputEnd - 6;\r\n    int chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n    // Ok, first we loop through all full triplets of data:\r\n    while (true) {\r\n        if (inputPtr \u003e lastFullOffset) {\r\n            // need to load more\r\n            inputEnd \u003d _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\r\n            inputPtr \u003d 0;\r\n            if (inputEnd \u003c 3) {\r\n                // required to try to read to have at least 3 bytes\r\n                break;\r\n            }\r\n            lastFullOffset \u003d inputEnd - 3;\r\n        }\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // need to flush\r\n            _flushBuffer();\r\n        }\r\n        // First, mash 3 bytes into lsb of 32-bit int\r\n        int b24 \u003d (readBuffer[inputPtr++]) \u003c\u003c 8;\r\n        b24 |\u003d (readBuffer[inputPtr++]) \u0026 0xFF;\r\n        b24 \u003d (b24 \u003c\u003c 8) | ((readBuffer[inputPtr++]) \u0026 0xFF);\r\n        bytesDone +\u003d 3;\r\n        _outputTail \u003d b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\r\n        if (--chunksBeforeLF \u003c\u003d 0) {\r\n            _outputBuffer[_outputTail++] \u003d \u0027\\\\\u0027;\r\n            _outputBuffer[_outputTail++] \u003d \u0027n\u0027;\r\n            chunksBeforeLF \u003d b64variant.getMaxLineLength() \u003e\u003e 2;\r\n        }\r\n    }\r\n    // And then we may have 1 or 2 leftover bytes to encode\r\n    if (inputPtr \u003c inputEnd) {\r\n        // yes, but do we have room for output?\r\n        if (_outputTail \u003e safeOutputEnd) {\r\n            // don\u0027t really need 6 bytes but...\r\n            _flushBuffer();\r\n        }\r\n        int b24 \u003d (readBuffer[inputPtr++]) \u003c\u003c 16;\r\n        int amount \u003d 1;\r\n        if (inputPtr \u003c inputEnd) {\r\n            b24 |\u003d ((readBuffer[inputPtr]) \u0026 0xFF) \u003c\u003c 8;\r\n            amount \u003d 2;\r\n        }\r\n        bytesDone +\u003d amount;\r\n        _outputTail \u003d b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\r\n    }\r\n    return bytesDone;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_reportError(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(short)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedShort(s);\r\n        return;\r\n    }\r\n    // up to 5 digits and possible minus sign\r\n    if ((_outputTail + 6) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputTail \u003d NumberOutput.outputInt(s, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  s3 :\u003d @parameter0: short\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedShort(s3)\n  return\n}",
      "B2 {\n  $i0 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 6\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i6 \u003d (int) s3\n  $i5 \u003d NumberOutput.outputInt($i6, $r1, $i4)\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedShort(...1)",
        "body": "{\r\n    if ((_outputTail + 8) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputInt(s, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedInt(i);\r\n        return;\r\n    }\r\n    // up to 10 digits and possible minus sign\r\n    if ((_outputTail + 11) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputTail \u003d NumberOutput.outputInt(i, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  i3 :\u003d @parameter0: int\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedInt(i3)\n  return\n}",
      "B2 {\n  $i0 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 11\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i5 \u003d NumberOutput.outputInt(i3, $r1, $i4)\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedInt(...1)",
        "body": "{\r\n    if ((_outputTail + 13) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputInt(i, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(long)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedLong(l);\r\n        return;\r\n    }\r\n    if ((_outputTail + 21) \u003e\u003d _outputEnd) {\r\n        // up to 20 digits, minus sign\r\n        _flushBuffer();\r\n    }\r\n    _outputTail \u003d NumberOutput.outputLong(l, _outputBuffer, _outputTail);\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  l3 :\u003d @parameter0: long\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedLong(l3)\n  return\n}",
      "B2 {\n  $i0 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 21\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0._flushBuffer()\n}",
      "B4 {\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i5 \u003d NumberOutput.outputLong(l3, $r1, $i4)\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedLong(...1)",
        "body": "{\r\n    if ((_outputTail + 23) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _outputTail \u003d NumberOutput.outputLong(l, _outputBuffer, _outputTail);\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigInteger)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (value \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(value.toString());\r\n    } else {\r\n        writeRaw(value.toString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  BigInteger\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r1.toString()\n  r0._writeQuotedRaw($r3)\n  goto B5\n}",
      "B4 {\n  $r2 \u003d r1.toString()\n  r0.writeRaw($r2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    int ptr \u003d _outputTail;\r\n    char[] buf \u003d _outputBuffer;\r\n    buf[ptr] \u003d \u0027n\u0027;\r\n    buf[++ptr] \u003d \u0027u\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    _outputTail \u003d ptr + 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(double)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgNumbersAsStrings || (NumberOutput.notFinite(d) \u0026\u0026 isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS))) {\r\n        writeString(NumberOutput.toString(d, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n        return;\r\n    }\r\n    // What is the max length for doubles? 40 chars?\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    writeRaw(NumberOutput.toString(d, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z2 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  d0 :\u003d @parameter0: double\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z2 \u003d NumberOutput.notFinite(d0)\n  if ($z2 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r5 \u003d JsonGenerator$Feature QUOTE_NON_NUMERIC_NUMBERS\u003e\n  $z4 \u003d r0.isEnabled($r5)\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z1 \u003d r0.isEnabled($r1)\n  $r2 \u003d NumberOutput.toString(d0, $z1)\n  r0.writeString($r2)\n  return\n}",
      "B4 {\n  r0._verifyValueWrite(\"write a number\")\n  $r3 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z3 \u003d r0.isEnabled($r3)\n  $r4 \u003d NumberOutput.toString(d0, $z3)\n  r0.writeRaw($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeString(...1)",
        "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeString(text);\r\n    // And finally, closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(float)",
    "visibility": "public",
    "body": "{\r\n    if (_cfgNumbersAsStrings || (NumberOutput.notFinite(f) \u0026\u0026 isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS))) {\r\n        writeString(NumberOutput.toString(f, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n        return;\r\n    }\r\n    // What is the max length for floats?\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    writeRaw(NumberOutput.toString(f, isEnabled(Feature.USE_FAST_DOUBLE_WRITER)));\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z2 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  f0 :\u003d @parameter0: float\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z2 \u003d NumberOutput.notFinite(f0)\n  if ($z2 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r5 \u003d JsonGenerator$Feature QUOTE_NON_NUMERIC_NUMBERS\u003e\n  $z4 \u003d r0.isEnabled($r5)\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z1 \u003d r0.isEnabled($r1)\n  $r2 \u003d NumberOutput.toString(f0, $z1)\n  r0.writeString($r2)\n  return\n}",
      "B4 {\n  r0._verifyValueWrite(\"write a number\")\n  $r3 \u003d JsonGenerator$Feature USE_FAST_DOUBLE_WRITER\u003e\n  $z3 \u003d r0.isEnabled($r3)\n  $r4 \u003d NumberOutput.toString(f0, $z3)\n  r0.writeRaw($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeString(...1)",
        "body": "{\r\n    _verifyValueWrite(WRITE_STRING);\r\n    if (text \u003d\u003d null) {\r\n        _writeNull();\r\n        return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    _writeString(text);\r\n    // And finally, closing quotes\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.math.BigDecimal)",
    "visibility": "public",
    "body": "{\r\n    // Don\u0027t really know max length for big decimal, no point checking\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (value \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(_asString(value));\r\n    } else {\r\n        writeRaw(_asString(value));\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  BigDecimal\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0._asString(r1)\n  r0._writeQuotedRaw($r3)\n  goto B5\n}",
      "B4 {\n  $r2 \u003d r0._asString(r1)\n  r0.writeRaw($r2)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_asString(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    int ptr \u003d _outputTail;\r\n    char[] buf \u003d _outputBuffer;\r\n    buf[ptr] \u003d \u0027n\u0027;\r\n    buf[++ptr] \u003d \u0027u\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    _outputTail \u003d ptr + 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (encodedValue \u003d\u003d null) {\r\n        _writeNull();\r\n    } else if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(encodedValue);\r\n    } else {\r\n        writeRaw(encodedValue);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  String\n  r0._verifyValueWrite(\"write a number\")\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r0._writeNull()\n  goto B5\n}",
      "B2 {\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0._writeQuotedRaw(r1)\n  goto B5\n}",
      "B4 {\n  r0.writeRaw(r1)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...1)",
        "body": "{\r\n    // Nothing to check, can just output as is\r\n    int len \u003d text.length();\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003d\u003d 0) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(0, len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedRaw(...1)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(value);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_writeNull(...0)",
        "body": "{\r\n    if ((_outputTail + 4) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    int ptr \u003d _outputTail;\r\n    char[] buf \u003d _outputBuffer;\r\n    buf[ptr] \u003d \u0027n\u0027;\r\n    buf[++ptr] \u003d \u0027u\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    buf[++ptr] \u003d \u0027l\u0027;\r\n    _outputTail \u003d ptr + 1;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeNumber",
    "signature": "void writeNumber(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_NUMBER);\r\n    if (_cfgNumbersAsStrings) {\r\n        _writeQuotedRaw(encodedValueBuffer, offset, length);\r\n    } else {\r\n        writeRaw(encodedValueBuffer, offset, length);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._verifyValueWrite(\"write a number\")\n  $z0 \u003d WriterBasedJsonGenerator: boolean _cfgNumbersAsStrings\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0._writeQuotedRaw(r1, i0, i1)\n  goto B3\n}",
      "B2 {\n  r0.writeRaw(r1, i0, i1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_writeQuotedRaw(...3)",
        "body": "{\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n    writeRaw(text, offset, length);\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d _quoteChar;\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#writeRaw(...3)",
        "body": "{\r\n    _checkRangeBoundsForString(text, offset, len);\r\n    // Nothing to check, can just output as is\r\n    int room \u003d _outputEnd - _outputTail;\r\n    if (room \u003c len) {\r\n        _flushBuffer();\r\n        room \u003d _outputEnd - _outputTail;\r\n    }\r\n    // But would it nicely fit in? If yes, it\u0027s easy\r\n    if (room \u003e\u003d len) {\r\n        text.getChars(offset, offset + len, _outputBuffer, _outputTail);\r\n        _outputTail +\u003d len;\r\n    } else {\r\n        writeRawLong(text.substring(offset, offset + len));\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "writeBoolean",
    "signature": "void writeBoolean(boolean)",
    "visibility": "public",
    "body": "{\r\n    _verifyValueWrite(WRITE_BOOLEAN);\r\n    if ((_outputTail + 5) \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    int ptr \u003d _outputTail;\r\n    char[] buf \u003d _outputBuffer;\r\n    if (state) {\r\n        buf[ptr] \u003d \u0027t\u0027;\r\n        buf[++ptr] \u003d \u0027r\u0027;\r\n        buf[++ptr] \u003d \u0027u\u0027;\r\n        buf[++ptr] \u003d \u0027e\u0027;\r\n    } else {\r\n        buf[ptr] \u003d \u0027f\u0027;\r\n        buf[++ptr] \u003d \u0027a\u0027;\r\n        buf[++ptr] \u003d \u0027l\u0027;\r\n        buf[++ptr] \u003d \u0027s\u0027;\r\n        buf[++ptr] \u003d \u0027e\u0027;\r\n    }\r\n    _outputTail \u003d ptr + 1;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i2 \u003c $i1) → B1 | else → B2",
      "B2 : If(z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  z0 :\u003d @parameter0: boolean\n  r0._verifyValueWrite(\"write a boolean value\")\n  $i0 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $i2 \u003d $i0 + 5\n  $i1 \u003d WriterBasedJsonGenerator: int _outputEnd\u003e\n  if ($i2 \u003c $i1) goto B1 else B2\n}",
      "B1 {\n  r0._flushBuffer()\n}",
      "B2 {\n  $i4 \u003d WriterBasedJsonGenerator: int _outputTail\u003e\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  if (z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1[$i4] \u003d 116\n  i5 \u003d $i4 + 1\n  $r1[i5] \u003d 114\n  i6 \u003d i5 + 1\n  $r1[i6] \u003d 117\n  i7 \u003d i6 + 1\n  $r1[i7] \u003d 101\n  goto B5\n}",
      "B4 {\n  $r1[$i4] \u003d 102\n  i8 \u003d $i4 + 1\n  $r1[i8] \u003d 97\n  i9 \u003d i8 + 1\n  $r1[i9] \u003d 108\n  i10 \u003d i9 + 1\n  $r1[i10] \u003d 115\n  i7 \u003d i10 + 1\n  $r1[i7] \u003d 101\n}",
      "B5 {\n  $i3 \u003d i7 + 1\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_verifyValueWrite(...1)",
        "body": "{\r\n    final int status \u003d _writeContext.writeValue();\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        // Otherwise, pretty printer knows what to do...\r\n        _verifyPrettyValueWrite(typeMsg, status);\r\n        return;\r\n    }\r\n    char c;\r\n    switch(status) {\r\n        case JsonWriteContext.STATUS_OK_AS_IS:\r\n        default:\r\n            return;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\r\n            c \u003d \u0027,\u0027;\r\n            break;\r\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\r\n            c \u003d \u0027:\u0027;\r\n            break;\r\n        case // root-value separator\r\n        JsonWriteContext.STATUS_OK_AFTER_SPACE:\r\n            if (_rootValueSeparator !\u003d null) {\r\n                writeRaw(_rootValueSeparator.getValue());\r\n            }\r\n            return;\r\n        case JsonWriteContext.STATUS_EXPECT_NAME:\r\n            _reportCantWriteValueExpectName(typeMsg);\r\n            return;\r\n    }\r\n    if (_outputTail \u003e\u003d _outputEnd) {\r\n        _flushBuffer();\r\n    }\r\n    _outputBuffer[_outputTail++] \u003d c;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    _flushBuffer();\r\n    if (_writer !\u003d null) {\r\n        if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\r\n            _writer.flush();\r\n        }\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r0._flushBuffer()\n  $r1 \u003d Writer _writer\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d JsonGenerator$Feature FLUSH_PASSED_TO_STREAM\u003e\n  $z0 \u003d r0.isEnabled($r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d Writer _writer\u003e\n  $r3.flush()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    super.close();\r\n    // 05-Dec-2008, tatu: To add [JACKSON-27], need to close open scopes\r\n    // First: let\u0027s see that we still have buffers...\r\n    IOException flushFail \u003d null;\r\n    try {\r\n        if ((_outputBuffer !\u003d null) \u0026\u0026 isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\r\n            while (true) {\r\n                JsonStreamContext ctxt \u003d getOutputContext();\r\n                if (ctxt.inArray()) {\r\n                    writeEndArray();\r\n                } else if (ctxt.inObject()) {\r\n                    writeEndObject();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        _flushBuffer();\r\n    } catch (IOException e) {\r\n        // 10-Jun-2022, tatu: [core#764] Need to avoid failing here; may\r\n        //    still need to close the underlying output stream\r\n        flushFail \u003d e;\r\n    }\r\n    _outputHead \u003d 0;\r\n    _outputTail \u003d 0;\r\n    /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\r\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\r\n         *   feature is enabled.\r\n         *   One downside: when using UTF8Writer, underlying buffer(s)\r\n         *   may not be properly recycled if we don\u0027t close the writer.\r\n         */\r\n    if (_writer !\u003d null) {\r\n        try {\r\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\r\n                _writer.close();\r\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\r\n                // If we can\u0027t close it, we should at least flush\r\n                _writer.flush();\r\n            }\r\n        } catch (IOException | RuntimeException e) {\r\n            if (flushFail !\u003d null) {\r\n                e.addSuppressed(flushFail);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    // Internal buffer(s) generator has can now be released as well\r\n    _releaseBuffers();\r\n    if (flushFail !\u003d null) {\r\n        throw flushFail;\r\n    }\r\n}",
    "nodes": 22,
    "edges": 29,
    "cc": 9,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B7",
      "B1 : If($z3 \u003d\u003d false) → B2 | else → B7",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z5 \u003d\u003d false) → B5 | else → B7",
      "B9 : If($r2 \u003d\u003d null) → B10 | else → B19",
      "B10 : If($z0 !\u003d 0) → B11 | else → B12",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z2 \u003d\u003d false) → B14 | else → B15",
      "B16 : If(r12 \u003d\u003d null) → B17 | else → B18",
      "B19 : If(r12 \u003d\u003d null) → B20 | else → B21"
    ],
    "blockList": [
      "B0 {\n  WriterBasedJsonGenerator\n  r0.close()\n  r12 \u003d null\n  $r1 \u003d WriterBasedJsonGenerator: char[] _outputBuffer\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B7\n}",
      "B1 {\n  $r8 \u003d JsonGenerator$Feature AUTO_CLOSE_JSON_CONTENT\u003e\n  $z3 \u003d r0.isEnabled($r8)\n  if ($z3 \u003d\u003d false) goto B2 else B7\n}",
      "B2 {\n  $r9 \u003d r0.getOutputContext()\n  $z4 \u003d $r9.inArray()\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r0.writeEndArray()\n  goto B6\n}",
      "B4 {\n  $z5 \u003d $r9.inObject()\n  if ($z5 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  r0.writeEndObject()\n}",
      "B6 {\n  goto B2\n}",
      "B7 {\n  r0._flushBuffer()\n  goto B9\n}",
      "B8 {\n  $r11 :\u003d @caughtexception\n  r12 \u003d $r11\n}",
      "B9 {\n  WriterBasedJsonGenerator: int _outputHead\u003e \u003d 0\n  WriterBasedJsonGenerator: int _outputTail\u003e \u003d 0\n  $r2 \u003d Writer _writer\u003e\n  if ($r2 \u003d\u003d null) goto B10 else B19\n}",
      "B10 {\n  $r3 \u003d IOContext _ioContext\u003e\n  $z0 \u003d $r3.isResourceManaged()\n  if ($z0 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  $r5 \u003d JsonGenerator$Feature AUTO_CLOSE_TARGET\u003e\n  $z1 \u003d r0.isEnabled($r5)\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r4 \u003d Writer _writer\u003e\n  $r4.close()\n  goto B15\n}",
      "B13 {\n  $r6 \u003d JsonGenerator$Feature FLUSH_PASSED_TO_STREAM\u003e\n  $z2 \u003d r0.isEnabled($r6)\n  if ($z2 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r7 \u003d Writer _writer\u003e\n  $r7.flush()\n}",
      "B15 {\n  goto B19\n}",
      "B16 {\n  $r10 :\u003d @caughtexception\n  if (r12 \u003d\u003d null) goto B17 else B18\n}",
      "B17 {\n  $r10.addSuppressed(r12)\n}",
      "B18 {\n  throw $r10\n}",
      "B19 {\n  r0._releaseBuffers()\n  if (r12 \u003d\u003d null) goto B20 else B21\n}",
      "B20 {\n  throw r12\n}",
      "B21 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B6 --\u003e B2",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B19",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B15",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e B19",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "WriterBasedJsonGenerator#isEnabled(...1)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#writeEndArray(...0)",
        "body": "{\r\n    if (!_writeContext.inArray()) {\r\n        _reportError(\"Current context not Array but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027]\u0027;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#getOutputContext(...0)",
        "body": "(source not found)"
      },
      {
        "name": "WriterBasedJsonGenerator#_flushBuffer(...0)",
        "body": "{\r\n    int len \u003d _outputTail - _outputHead;\r\n    if (len \u003e 0) {\r\n        int offset \u003d _outputHead;\r\n        _outputTail \u003d _outputHead \u003d 0;\r\n        _writer.write(_outputBuffer, offset, len);\r\n    }\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#writeEndObject(...0)",
        "body": "{\r\n    if (!_writeContext.inObject()) {\r\n        _reportError(\"Current context not Object but \" + _writeContext.typeDesc());\r\n    }\r\n    if (_cfgPrettyPrinter !\u003d null) {\r\n        _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\r\n    } else {\r\n        if (_outputTail \u003e\u003d _outputEnd) {\r\n            _flushBuffer();\r\n        }\r\n        _outputBuffer[_outputTail++] \u003d \u0027}\u0027;\r\n    }\r\n    _writeContext \u003d _writeContext.clearAndGetParent();\r\n}"
      },
      {
        "name": "WriterBasedJsonGenerator#_releaseBuffers(...0)",
        "body": "{\r\n    char[] buf \u003d _outputBuffer;\r\n    if (buf !\u003d null) {\r\n        _outputBuffer \u003d null;\r\n        _ioContext.releaseConcatBuffer(buf);\r\n    }\r\n    buf \u003d _copyBuffer;\r\n    if (buf !\u003d null) {\r\n        _copyBuffer \u003d null;\r\n        _ioContext.releaseNameCopyBuffer(buf);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "canUseSchema",
    "signature": "boolean canUseSchema(com.fasterxml.jackson.core.FormatSchema)",
    "visibility": "public",
    "body": "{\r\n    if (schema \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    String ourFormat \u003d getFormatName();\r\n    return (ourFormat !\u003d null) \u0026\u0026 ourFormat.equals(schema.getSchemaType());\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r2 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  FormatSchema\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r2 \u003d r1.getFormatName()\n  if (r2 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r3 \u003d r0.getSchemaType()\n  $z0 \u003d r2.equals($r3)\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z1 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z1 \u003d 0\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#getFormatName(...0)",
        "body": "{\r\n    /* Somewhat nasty check: since we can\u0027t make this abstract\r\n         * (due to backwards compatibility concerns), need to prevent\r\n         * format name \"leakage\"\r\n         */\r\n    if (getClass() \u003d\u003d JsonFactory.class) {\r\n        return FORMAT_NAME_JSON;\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "getFormatName",
    "signature": "java.lang.String getFormatName()",
    "visibility": "public",
    "body": "{\r\n    /* Somewhat nasty check: since we can\u0027t make this abstract\r\n         * (due to backwards compatibility concerns), need to prevent\r\n         * format name \"leakage\"\r\n         */\r\n    if (getClass() \u003d\u003d JsonFactory.class) {\r\n        return FORMAT_NAME_JSON;\r\n    }\r\n    return null;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d class \"Lcom/fasterxml/jackson/core/JsonFactory;\") → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  $r1 \u003d r0.getClass()\n  if ($r1 !\u003d class \"Lcom/fasterxml/jackson/core/JsonFactory;\") goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "hasFormat",
    "signature": "com.fasterxml.jackson.core.format.MatchStrength hasFormat(com.fasterxml.jackson.core.format.InputAccessor)",
    "visibility": "public",
    "body": "{\r\n    // since we can\u0027t keep this abstract, only implement for \"vanilla\" instance\r\n    if (getClass() \u003d\u003d JsonFactory.class) {\r\n        return hasJSONFormat(acc);\r\n    }\r\n    return null;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d class \"Lcom/fasterxml/jackson/core/JsonFactory;\") → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  InputAccessor\n  $r1 \u003d r0.getClass()\n  if ($r1 !\u003d class \"Lcom/fasterxml/jackson/core/JsonFactory;\") goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0.hasJSONFormat(r2)\n  return\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#hasJSONFormat(...1)",
        "body": "{\r\n    return ByteSourceJsonBootstrapper.hasJSONFormat(acc);\r\n}"
      },
      {
        "name": "JsonFactory#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.core.JsonFactory configure(com.fasterxml.jackson.core.JsonFactory$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonFactory$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.JsonFactory$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonFactory$Feature\n  $i0 \u003d JsonFactory: int _factoryFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "setStreamReadConstraints",
    "signature": "com.fasterxml.jackson.core.JsonFactory setStreamReadConstraints(com.fasterxml.jackson.core.StreamReadConstraints)",
    "visibility": "public",
    "body": "{\r\n    final int maxNameLen \u003d _streamReadConstraints.getMaxNameLength();\r\n    _streamReadConstraints \u003d Objects.requireNonNull(src);\r\n    // 30-Jan-2024, tatu: [core#1207] Need to recreate if max-name-length\r\n    //    setting changes\r\n    if (_streamReadConstraints.getMaxNameLength() !\u003d maxNameLen) {\r\n        _rootCharSymbols \u003d CharsToNameCanonicalizer.createRoot(this);\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003d\u003d i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  StreamReadConstraints\n  $r1 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  i0 \u003d $r1.getMaxNameLength()\n  $r3 \u003d Objects.requireNonNull(r2)\n  $r4 \u003d StreamReadConstraints) $r3\n  StreamReadConstraints _streamReadConstraints\u003e \u003d $r4\n  $r5 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  $i1 \u003d $r5.getMaxNameLength()\n  if ($i1 \u003d\u003d i0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d CharsToNameCanonicalizer.createRoot(r0)\n  CharsToNameCanonicalizer _rootCharSymbols\u003e \u003d $r6\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.core.JsonFactory configure(com.fasterxml.jackson.core.JsonParser$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonParser$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.JsonParser$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonParser$Feature\n  $i0 \u003d JsonFactory: int _parserFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.StreamReadFeature)",
    "visibility": "public",
    "body": "{\r\n    return (_parserFeatures \u0026 f.mappedFeature().getMask()) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  StreamReadFeature\n  $i0 \u003d JsonFactory: int _parserFeatures\u003e\n  $r2 \u003d r1.mappedFeature()\n  $i1 \u003d $r2.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.core.JsonFactory configure(com.fasterxml.jackson.core.JsonGenerator$Feature,boolean)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonGenerator$Feature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.JsonGenerator$Feature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  JsonGenerator$Feature\n  $i0 \u003d JsonFactory: int _generatorFeatures\u003e\n  $i1 \u003d r1.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.StreamWriteFeature)",
    "visibility": "public",
    "body": "{\r\n    return (_generatorFeatures \u0026 f.mappedFeature().getMask()) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  StreamWriteFeature\n  $i0 \u003d JsonFactory: int _generatorFeatures\u003e\n  $r2 \u003d r1.mappedFeature()\n  $i1 \u003d $r2.getMask()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "setRootValueSeparator",
    "signature": "com.fasterxml.jackson.core.JsonFactory setRootValueSeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _rootValueSeparator \u003d (sep \u003d\u003d null) ? null : new SerializedString(sep);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  String\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d SerializedString\n  new SerializedString(r1)\n}",
      "B3 {\n  SerializableString _rootValueSeparator\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "getRootValueSeparator",
    "signature": "java.lang.String getRootValueSeparator()",
    "visibility": "public",
    "body": "{\r\n    return (_rootValueSeparator \u003d\u003d null) ? null : _rootValueSeparator.getValue();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  $r1 \u003d SerializableString _rootValueSeparator\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d SerializableString _rootValueSeparator\u003e\n  $r3 \u003d $r2.getValue()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.core.JsonParser createParser(byte[])",
    "visibility": "public",
    "body": "{\r\n    IOContext ctxt \u003d _createContext(_createContentReference(data), true);\r\n    if (_inputDecorator !\u003d null) {\r\n        InputStream in \u003d _inputDecorator.decorate(ctxt, data, 0, data.length);\r\n        if (in !\u003d null) {\r\n            return _createParser(in, ctxt);\r\n        }\r\n    }\r\n    return _createParser(data, 0, data.length, ctxt);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r4 \u003d\u003d null) → B1 | else → B3",
      "B1 : If(r7 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  r1 :\u003d @parameter0: byte[]\n  $r2 \u003d r0._createContentReference(r1)\n  r3 \u003d r0._createContext($r2, 1)\n  $r4 \u003d InputDecorator _inputDecorator\u003e\n  if ($r4 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r6 \u003d InputDecorator _inputDecorator\u003e\n  $i1 \u003d lengthof r1\n  r7 \u003d $r6.decorate(r3, r1, 0, $i1)\n  if (r7 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d r0._createParser(r7, r3)\n  return\n}",
      "B3 {\n  $i0 \u003d lengthof r1\n  $r5 \u003d r0._createParser(r1, 0, $i0, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createParser(...2)",
        "body": "{\r\n    try {\r\n        return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures, _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\r\n    } catch (IOException | RuntimeException e) {\r\n        // 10-Jun-2022, tatu: For [core#763] may need to close InputStream here\r\n        if (ctxt.isResourceManaged()) {\r\n            try {\r\n                in.close();\r\n            } catch (Exception e2) {\r\n                e.addSuppressed(e2);\r\n            }\r\n        }\r\n        ctxt.close();\r\n        throw e;\r\n    }\r\n}"
      },
      {
        "name": "JsonFactory#_createParser(...4)",
        "body": "{\r\n    return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures, _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...1)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, _errorReportConfiguration);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.core.JsonParser createParser(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForByteArray(data, offset, len);\r\n    IOContext ctxt \u003d _createContext(_createContentReference(data, offset, len), true);\r\n    // [JACKSON-512]: allow wrapping with InputDecorator\r\n    if (_inputDecorator !\u003d null) {\r\n        InputStream in \u003d _inputDecorator.decorate(ctxt, data, offset, len);\r\n        if (in !\u003d null) {\r\n            return _createParser(in, ctxt);\r\n        }\r\n    }\r\n    return _createParser(data, offset, len, ctxt);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r4 \u003d\u003d null) → B1 | else → B3",
      "B1 : If(r7 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  r1 :\u003d @parameter0: byte[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForByteArray(r1, i0, i1)\n  $r2 \u003d r0._createContentReference(r1, i0, i1)\n  r3 \u003d r0._createContext($r2, 1)\n  $r4 \u003d InputDecorator _inputDecorator\u003e\n  if ($r4 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r6 \u003d InputDecorator _inputDecorator\u003e\n  r7 \u003d $r6.decorate(r3, r1, i0, i1)\n  if (r7 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d r0._createParser(r7, r3)\n  return\n}",
      "B3 {\n  $r5 \u003d r0._createParser(r1, i0, i1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#_checkRangeBoundsForByteArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createParser(...2)",
        "body": "{\r\n    try {\r\n        return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures, _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\r\n    } catch (IOException | RuntimeException e) {\r\n        // 10-Jun-2022, tatu: For [core#763] may need to close InputStream here\r\n        if (ctxt.isResourceManaged()) {\r\n            try {\r\n                in.close();\r\n            } catch (Exception e2) {\r\n                e.addSuppressed(e2);\r\n            }\r\n        }\r\n        ctxt.close();\r\n        throw e;\r\n    }\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...3)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, offset, length, _errorReportConfiguration);\r\n}"
      },
      {
        "name": "JsonFactory#_createParser(...4)",
        "body": "{\r\n    return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures, _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.core.JsonParser createParser(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int strLen \u003d content.length();\r\n    // Actually, let\u0027s use this for medium-sized content, up to 64kB chunk (32kb char)\r\n    if ((_inputDecorator !\u003d null) || (strLen \u003e 0x8000) || !canUseCharArrays()) {\r\n        // easier to just wrap in a Reader than extend InputDecorator; or, if content\r\n        // is too long for us to copy it over\r\n        return createParser(new StringReader(content));\r\n    }\r\n    IOContext ctxt \u003d _createContext(_createContentReference(content), true);\r\n    char[] buf \u003d ctxt.allocTokenBuffer(strLen);\r\n    content.getChars(0, strLen, buf, 0);\r\n    return _createParser(buf, 0, strLen, ctxt, true);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 !\u003d null) → B1 | else → B3",
      "B1 : If(i0 \u003e $i2) → B2 | else → B3",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  String\n  i0 \u003d r0.length()\n  $r2 \u003d InputDecorator _inputDecorator\u003e\n  if ($r2 !\u003d null) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d (int) 32768\n  if (i0 \u003e $i2) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d r1.canUseCharArrays()\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r9 \u003d StringReader\n  new StringReader(r0)\n  $r8 \u003d r1.createParser($r9)\n  return\n}",
      "B4 {\n  $r3 \u003d r1._createContentReference(r0)\n  r4 \u003d r1._createContext($r3, 1)\n  r5 \u003d r4.allocTokenBuffer(i0)\n  r0.getChars(0, i0, r5, 0)\n  $r6 \u003d r1._createParser(r5, 0, i0, r4, 1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#canUseCharArrays(...0)",
        "body": "{\r\n    return true;\r\n}"
      },
      {
        "name": "JsonFactory#createParser(...1)",
        "body": "{\r\n    // true, since we create InputStream from File\r\n    IOContext ctxt \u003d _createContext(_createContentReference(f), true);\r\n    InputStream in \u003d _fileInputStream(f);\r\n    return _createParser(_decorate(in, ctxt), ctxt);\r\n}"
      },
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...1)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, _errorReportConfiguration);\r\n}"
      },
      {
        "name": "JsonFactory#_createParser(...5)",
        "body": "{\r\n    return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec, _rootCharSymbols.makeChild(), data, offset, offset + len, recyclable);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createParser",
    "signature": "com.fasterxml.jackson.core.JsonParser createParser(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _checkRangeBoundsForCharArray(content, offset, len);\r\n    if (_inputDecorator !\u003d null) {\r\n        // easier to just wrap in a Reader than extend InputDecorator\r\n        return createParser(new CharArrayReader(content, offset, len));\r\n    }\r\n    return _createParser(content, offset, len, _createContext(_createContentReference(content, offset, len), true), // important: buffer is NOT recyclable, as it\u0027s from caller\r\n    false);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._checkRangeBoundsForCharArray(r1, i0, i1)\n  $r2 \u003d InputDecorator _inputDecorator\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d CharArrayReader\n  new CharArrayReader(r1, i0, i1)\n  $r7 \u003d r0.createParser($r6)\n  return\n}",
      "B2 {\n  $r3 \u003d r0._createContentReference(r1, i0, i1)\n  $r4 \u003d r0._createContext($r3, 1)\n  $r5 \u003d r0._createParser(r1, i0, i1, $r4, 0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#createParser(...1)",
        "body": "{\r\n    // true, since we create InputStream from File\r\n    IOContext ctxt \u003d _createContext(_createContentReference(f), true);\r\n    InputStream in \u003d _fileInputStream(f);\r\n    return _createParser(_decorate(in, ctxt), ctxt);\r\n}"
      },
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...3)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, offset, length, _errorReportConfiguration);\r\n}"
      },
      {
        "name": "JsonFactory#_checkRangeBoundsForCharArray(...3)",
        "body": "(source not found)"
      },
      {
        "name": "JsonFactory#_createParser(...5)",
        "body": "{\r\n    return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec, _rootCharSymbols.makeChild(), data, offset, offset + len, recyclable);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createGenerator",
    "signature": "com.fasterxml.jackson.core.JsonGenerator createGenerator(java.io.OutputStream,com.fasterxml.jackson.core.JsonEncoding)",
    "visibility": "public",
    "body": "{\r\n    // false -\u003e we won\u0027t manage the stream unless explicitly directed to\r\n    IOContext ctxt \u003d _createContext(_createContentReference(out), false);\r\n    ctxt.setEncoding(enc);\r\n    if (enc \u003d\u003d JsonEncoding.UTF8) {\r\n        return _createUTF8Generator(_decorate(out, ctxt), ctxt);\r\n    }\r\n    Writer w \u003d _createWriter(out, enc, ctxt);\r\n    return _createGenerator(_decorate(w, ctxt), ctxt);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r4 !\u003d $r5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  OutputStream\n  JsonEncoding\n  $r2 \u003d r0._createContentReference(r1)\n  r3 \u003d r0._createContext($r2, 0)\n  r3.setEncoding(r4)\n  $r5 \u003d JsonEncoding UTF8\u003e\n  if (r4 !\u003d $r5) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d r0._decorate(r1, r3)\n  $r10 \u003d r0._createUTF8Generator($r9, r3)\n  return\n}",
      "B2 {\n  r6 \u003d r0._createWriter(r1, r4, r3)\n  $r7 \u003d r0._decorate(r6, r3)\n  $r8 \u003d r0._createGenerator($r7, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createWriter(...3)",
        "body": "{\r\n    // note: this should not get called any more (caller checks, dispatches)\r\n    if (enc \u003d\u003d JsonEncoding.UTF8) {\r\n        // We have optimized writer for UTF-8\r\n        return new UTF8Writer(ctxt, out);\r\n    }\r\n    // not optimal, but should do unless we really care about UTF-16/32 encoding speed\r\n    return new OutputStreamWriter(out, enc.getJavaName());\r\n}"
      },
      {
        "name": "JsonFactory#_createUTF8Generator(...2)",
        "body": "{\r\n    UTF8JsonGenerator gen \u003d new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _quoteChar);\r\n    if (_maximumNonEscapedChar \u003e 0) {\r\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\r\n    }\r\n    if (_characterEscapes !\u003d null) {\r\n        gen.setCharacterEscapes(_characterEscapes);\r\n    }\r\n    SerializableString rootSep \u003d _rootValueSeparator;\r\n    if (rootSep !\u003d DEFAULT_ROOT_VALUE_SEPARATOR) {\r\n        gen.setRootValueSeparator(rootSep);\r\n    }\r\n    return _decorate(gen);\r\n}"
      },
      {
        "name": "JsonFactory#_createGenerator(...2)",
        "body": "{\r\n    WriterBasedJsonGenerator gen \u003d new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _quoteChar);\r\n    if (_maximumNonEscapedChar \u003e 0) {\r\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\r\n    }\r\n    if (_characterEscapes !\u003d null) {\r\n        gen.setCharacterEscapes(_characterEscapes);\r\n    }\r\n    SerializableString rootSep \u003d _rootValueSeparator;\r\n    if (rootSep !\u003d DEFAULT_ROOT_VALUE_SEPARATOR) {\r\n        gen.setRootValueSeparator(rootSep);\r\n    }\r\n    return _decorate(gen);\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...1)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, _errorReportConfiguration);\r\n}"
      },
      {
        "name": "JsonFactory#_decorate(...2)",
        "body": "{\r\n    if (_inputDecorator !\u003d null) {\r\n        InputStream in2 \u003d _inputDecorator.decorate(ctxt, in);\r\n        if (in2 !\u003d null) {\r\n            return in2;\r\n        }\r\n    }\r\n    return in;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "createGenerator",
    "signature": "com.fasterxml.jackson.core.JsonGenerator createGenerator(java.io.File,com.fasterxml.jackson.core.JsonEncoding)",
    "visibility": "public",
    "body": "{\r\n    OutputStream out \u003d _fileOutputStream(f);\r\n    // true -\u003e yes, we have to manage the stream since we created it\r\n    IOContext ctxt \u003d _createContext(_createContentReference(out), true);\r\n    ctxt.setEncoding(enc);\r\n    if (enc \u003d\u003d JsonEncoding.UTF8) {\r\n        return _createUTF8Generator(_decorate(out, ctxt), ctxt);\r\n    }\r\n    Writer w \u003d _createWriter(out, enc, ctxt);\r\n    return _createGenerator(_decorate(w, ctxt), ctxt);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r5 !\u003d $r6) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  File\n  JsonEncoding\n  r2 \u003d r0._fileOutputStream(r1)\n  $r3 \u003d r0._createContentReference(r2)\n  r4 \u003d r0._createContext($r3, 1)\n  r4.setEncoding(r5)\n  $r6 \u003d JsonEncoding UTF8\u003e\n  if (r5 !\u003d $r6) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d r0._decorate(r2, r4)\n  $r11 \u003d r0._createUTF8Generator($r10, r4)\n  return\n}",
      "B2 {\n  r7 \u003d r0._createWriter(r2, r5, r4)\n  $r8 \u003d r0._decorate(r7, r4)\n  $r9 \u003d r0._createGenerator($r8, r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactory#_fileOutputStream(...1)",
        "body": "(source not found)"
      },
      {
        "name": "JsonFactory#_createContext(...2)",
        "body": "{\r\n    BufferRecycler br \u003d null;\r\n    boolean recyclerExternal \u003d false;\r\n    if (contentRef \u003d\u003d null) {\r\n        contentRef \u003d ContentReference.unknown();\r\n    } else {\r\n        Object content \u003d contentRef.getRawContent();\r\n        // 18-Jan-2024, tatu: [core#1195] Let\u0027s see if we can reuse already allocated recycler\r\n        //   (is the case when SegmentedStringWriter / ByteArrayBuilder passed)\r\n        if (content instanceof BufferRecycler.Gettable) {\r\n            br \u003d ((BufferRecycler.Gettable) content).bufferRecycler();\r\n            recyclerExternal \u003d (br !\u003d null);\r\n        }\r\n    }\r\n    if (br \u003d\u003d null) {\r\n        br \u003d _getBufferRecycler();\r\n    }\r\n    IOContext ctxt \u003d new IOContext(_streamReadConstraints, _streamWriteConstraints, _errorReportConfiguration, br, contentRef, resourceManaged);\r\n    if (recyclerExternal) {\r\n        ctxt.markBufferRecyclerReleased();\r\n    }\r\n    return ctxt;\r\n}"
      },
      {
        "name": "JsonFactory#_createWriter(...3)",
        "body": "{\r\n    // note: this should not get called any more (caller checks, dispatches)\r\n    if (enc \u003d\u003d JsonEncoding.UTF8) {\r\n        // We have optimized writer for UTF-8\r\n        return new UTF8Writer(ctxt, out);\r\n    }\r\n    // not optimal, but should do unless we really care about UTF-16/32 encoding speed\r\n    return new OutputStreamWriter(out, enc.getJavaName());\r\n}"
      },
      {
        "name": "JsonFactory#_createUTF8Generator(...2)",
        "body": "{\r\n    UTF8JsonGenerator gen \u003d new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _quoteChar);\r\n    if (_maximumNonEscapedChar \u003e 0) {\r\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\r\n    }\r\n    if (_characterEscapes !\u003d null) {\r\n        gen.setCharacterEscapes(_characterEscapes);\r\n    }\r\n    SerializableString rootSep \u003d _rootValueSeparator;\r\n    if (rootSep !\u003d DEFAULT_ROOT_VALUE_SEPARATOR) {\r\n        gen.setRootValueSeparator(rootSep);\r\n    }\r\n    return _decorate(gen);\r\n}"
      },
      {
        "name": "JsonFactory#_createGenerator(...2)",
        "body": "{\r\n    WriterBasedJsonGenerator gen \u003d new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _quoteChar);\r\n    if (_maximumNonEscapedChar \u003e 0) {\r\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\r\n    }\r\n    if (_characterEscapes !\u003d null) {\r\n        gen.setCharacterEscapes(_characterEscapes);\r\n    }\r\n    SerializableString rootSep \u003d _rootValueSeparator;\r\n    if (rootSep !\u003d DEFAULT_ROOT_VALUE_SEPARATOR) {\r\n        gen.setRootValueSeparator(rootSep);\r\n    }\r\n    return _decorate(gen);\r\n}"
      },
      {
        "name": "JsonFactory#_createContentReference(...1)",
        "body": "{\r\n    // 21-Mar-2021, tatu: For now assume \"canHandleBinaryNatively()\" is reliable\r\n    //    indicator of textual vs binary format:\r\n    return ContentReference.construct(!canHandleBinaryNatively(), contentAccessor, _errorReportConfiguration);\r\n}"
      },
      {
        "name": "JsonFactory#_decorate(...2)",
        "body": "{\r\n    if (_inputDecorator !\u003d null) {\r\n        InputStream in2 \u003d _inputDecorator.decorate(ctxt, in);\r\n        if (in2 !\u003d null) {\r\n            return in2;\r\n        }\r\n    }\r\n    return in;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactory",
    "methodName": "_getRecyclerPool",
    "signature": "com.fasterxml.jackson.core.util.RecyclerPool _getRecyclerPool()",
    "visibility": "public",
    "body": "{\r\n    // 23-Apr-2015, tatu: Let\u0027s allow disabling of buffer recycling\r\n    //   scheme, for cases where it is considered harmful (possibly\r\n    //   on Android, for example)\r\n    if (!Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING.enabledIn(_factoryFeatures)) {\r\n        return JsonRecyclerPools.nonRecyclingPool();\r\n    }\r\n    return _recyclerPool;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactory\n  $r1 \u003d JsonFactory$Feature USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING\u003e\n  $i0 \u003d JsonFactory: int _factoryFeatures\u003e\n  $z0 \u003d $r1.enabledIn($i0)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonRecyclerPools.nonRecyclingPool()\n  return\n}",
      "B2 {\n  $r2 \u003d RecyclerPool _recyclerPool\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "enable",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder enable(com.fasterxml.jackson.core.json.JsonReadFeature,com.fasterxml.jackson.core.json.JsonReadFeature[])",
    "visibility": "public",
    "body": "{\r\n    _legacyEnable(first.mappedFeature());\r\n    enable(first);\r\n    for (JsonReadFeature f : other) {\r\n        _legacyEnable(f.mappedFeature());\r\n    }\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonReadFeature\n  JsonReadFeature[]\n  $r2 \u003d r1.mappedFeature()\n  r0._legacyEnable($r2)\n  r0.enable(r1)\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r4 \u003d r3[i1]\n  $r5 \u003d r4.mappedFeature()\n  r0._legacyEnable($r5)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#enable(...1)",
        "body": "{\r\n    _legacyEnable(f.mappedFeature());\r\n    return this;\r\n}"
      },
      {
        "name": "JsonFactoryBuilder#_legacyEnable(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "disable",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder disable(com.fasterxml.jackson.core.json.JsonReadFeature,com.fasterxml.jackson.core.json.JsonReadFeature[])",
    "visibility": "public",
    "body": "{\r\n    _legacyDisable(first.mappedFeature());\r\n    for (JsonReadFeature f : other) {\r\n        _legacyEnable(f.mappedFeature());\r\n    }\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonReadFeature\n  JsonReadFeature[]\n  $r2 \u003d r1.mappedFeature()\n  r0._legacyDisable($r2)\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r4 \u003d r3[i1]\n  $r5 \u003d r4.mappedFeature()\n  r0._legacyEnable($r5)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#_legacyDisable(...1)",
        "body": "(source not found)"
      },
      {
        "name": "JsonFactoryBuilder#_legacyEnable(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder configure(com.fasterxml.jackson.core.json.JsonReadFeature,boolean)",
    "visibility": "public",
    "body": "{\r\n    return state ? enable(f) : disable(f);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonReadFeature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#enable(...1)",
        "body": "{\r\n    _legacyEnable(f.mappedFeature());\r\n    return this;\r\n}"
      },
      {
        "name": "JsonFactoryBuilder#disable(...1)",
        "body": "{\r\n    _legacyDisable(f.mappedFeature());\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "enable",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder enable(com.fasterxml.jackson.core.json.JsonWriteFeature)",
    "visibility": "public",
    "body": "{\r\n    JsonGenerator.Feature old \u003d f.mappedFeature();\r\n    if (old !\u003d null) {\r\n        _legacyEnable(old);\r\n    }\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonWriteFeature\n  r1 \u003d r0.mappedFeature()\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r2._legacyEnable(r1)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#_legacyEnable(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "enable",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder enable(com.fasterxml.jackson.core.json.JsonWriteFeature,com.fasterxml.jackson.core.json.JsonWriteFeature[])",
    "visibility": "public",
    "body": "{\r\n    _legacyEnable(first.mappedFeature());\r\n    for (JsonWriteFeature f : other) {\r\n        _legacyEnable(f.mappedFeature());\r\n    }\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonWriteFeature\n  JsonWriteFeature[]\n  $r2 \u003d r1.mappedFeature()\n  r0._legacyEnable($r2)\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r4 \u003d r3[i1]\n  $r5 \u003d r4.mappedFeature()\n  r0._legacyEnable($r5)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#_legacyEnable(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "disable",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder disable(com.fasterxml.jackson.core.json.JsonWriteFeature,com.fasterxml.jackson.core.json.JsonWriteFeature[])",
    "visibility": "public",
    "body": "{\r\n    _legacyDisable(first.mappedFeature());\r\n    for (JsonWriteFeature f : other) {\r\n        _legacyDisable(f.mappedFeature());\r\n    }\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonWriteFeature\n  JsonWriteFeature[]\n  $r2 \u003d r1.mappedFeature()\n  r0._legacyDisable($r2)\n  i0 \u003d lengthof r3\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r4 \u003d r3[i1]\n  $r5 \u003d r4.mappedFeature()\n  r0._legacyDisable($r5)\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#_legacyDisable(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "configure",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder configure(com.fasterxml.jackson.core.json.JsonWriteFeature,boolean)",
    "visibility": "public",
    "body": "{\r\n    return state ? enable(f) : disable(f);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  JsonWriteFeature\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.enable(r1)\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.disable(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonFactoryBuilder#enable(...1)",
        "body": "{\r\n    _legacyEnable(f.mappedFeature());\r\n    return this;\r\n}"
      },
      {
        "name": "JsonFactoryBuilder#disable(...1)",
        "body": "{\r\n    _legacyDisable(f.mappedFeature());\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "rootValueSeparator",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder rootValueSeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _rootValueSeparator \u003d (sep \u003d\u003d null) ? null : new SerializedString(sep);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  String\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d SerializedString\n  new SerializedString(r1)\n}",
      "B3 {\n  SerializableString _rootValueSeparator\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "highestNonEscapedChar",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder highestNonEscapedChar(int)",
    "visibility": "public",
    "body": "{\r\n    _maximumNonEscapedChar \u003d (maxNonEscaped \u003c\u003d 0) ? 0 : Math.max(127, maxNonEscaped);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e 0) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d 0\n  goto B3\n}",
      "B2 {\n  $i1 \u003d Math.max(127, i0)\n}",
      "B3 {\n  JsonFactoryBuilder: int _maximumNonEscapedChar\u003e \u003d $i1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonFactoryBuilder",
    "methodName": "quoteChar",
    "signature": "com.fasterxml.jackson.core.JsonFactoryBuilder quoteChar(char)",
    "visibility": "public",
    "body": "{\r\n    // 12-Aug-2019, tatu: Due to implementation details, escaping characters beyond\r\n    //    7-bit ASCII set has deep overhead so let\u0027s limit set. If we absolutely\r\n    //    must it is possible of course, but leads to problems combining with\r\n    //    custom escaping aspects.\r\n    if (ch \u003e 0x7F) {\r\n        throw new IllegalArgumentException(\"Can only use Unicode characters up to 0x7F as quote characters\");\r\n    }\r\n    _quoteChar \u003d ch;\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i1 \u003c\u003d 127) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonFactoryBuilder\n  c0 :\u003d @parameter0: char\n  $i1 \u003d (int) c0\n  if ($i1 \u003c\u003d 127) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Can only use Unicode characters up to 0x7F as quote characters\")\n  throw $r2\n}",
      "B2 {\n  JsonFactoryBuilder: char _quoteChar\u003e \u003d c0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonLocation",
    "methodName": "sourceDescription",
    "signature": "java.lang.String sourceDescription()",
    "visibility": "public",
    "body": "{\r\n    // 04-Apr-2021, tatu: Construct lazily but retain\r\n    if (_sourceDescription \u003d\u003d null) {\r\n        _sourceDescription \u003d _contentReference.buildSourceDescription();\r\n    }\r\n    return _sourceDescription;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonLocation\n  $r1 \u003d String _sourceDescription\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d ContentReference _contentReference\u003e\n  $r4 \u003d $r3.buildSourceDescription()\n  String _sourceDescription\u003e \u003d $r4\n}",
      "B2 {\n  $r2 \u003d String _sourceDescription\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonLocation",
    "methodName": "appendOffsetDescription",
    "signature": "java.lang.StringBuilder appendOffsetDescription(java.lang.StringBuilder)",
    "visibility": "public",
    "body": "{\r\n    // 04-Apr-2021, tatu: [core#694] For binary content, we have no line\r\n    //    number or column position indicators; try using what we do have\r\n    //    (if anything)\r\n    if (_contentReference.hasTextualContent()) {\r\n        sb.append(\"line: \");\r\n        // should be 1-based, but consider -1 to be canonical \"got none\"\r\n        if (_lineNr \u003e\u003d 0) {\r\n            sb.append(_lineNr);\r\n        } else {\r\n            sb.append(\"UNKNOWN\");\r\n        }\r\n        sb.append(\", column: \");\r\n        if (_columnNr \u003e\u003d 0) {\r\n            // same here\r\n            sb.append(_columnNr);\r\n        } else {\r\n            sb.append(\"UNKNOWN\");\r\n        }\r\n    } else {\r\n        // 04-Apr-2021, tatu: Ideally byte formats would not need line/column\r\n        //    info, but for backwards-compatibility purposes (Jackson 2.x),\r\n        //    will leave logic here\r\n        if (_lineNr \u003e 0) {\r\n            // yes, require 1-based in case of allegedly binary content\r\n            sb.append(\"line: \").append(_lineNr);\r\n            if (_columnNr \u003e 0) {\r\n                sb.append(\", column: \");\r\n                sb.append(_columnNr);\r\n            }\r\n        } else {\r\n            sb.append(\"byte offset: #\");\r\n            // For binary formats, total bytes should be the canonical offset\r\n            // for token/current location\r\n            if (_totalBytes \u003e\u003d 0) {\r\n                sb.append(_totalBytes);\r\n            } else {\r\n                sb.append(\"UNKNOWN\");\r\n            }\r\n        }\r\n    }\r\n    return sb;\r\n}",
    "nodes": 14,
    "edges": 19,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B7",
      "B1 : If($i7 \u003c 0) → B2 | else → B3",
      "B4 : If($i8 \u003c 0) → B5 | else → B6",
      "B7 : If($i0 \u003c\u003d 0) → B8 | else → B10",
      "B8 : If($i5 \u003c\u003d 0) → B9 | else → B13",
      "B10 : If($i11 \u003c 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  JsonLocation\n  StringBuilder\n  $r1 \u003d ContentReference _contentReference\u003e\n  $z0 \u003d $r1.hasTextualContent()\n  if ($z0 \u003d\u003d false) goto B1 else B7\n}",
      "B1 {\n  r2.append(\"line: \")\n  $i7 \u003d JsonLocation: int _lineNr\u003e\n  if ($i7 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $i10 \u003d JsonLocation: int _lineNr\u003e\n  r2.append($i10)\n  goto B4\n}",
      "B3 {\n  r2.append(\"UNKNOWN\")\n}",
      "B4 {\n  r2.append(\", column: \")\n  $i8 \u003d JsonLocation: int _columnNr\u003e\n  if ($i8 \u003c 0) goto B5 else B6\n}",
      "B5 {\n  $i9 \u003d JsonLocation: int _columnNr\u003e\n  r2.append($i9)\n  goto B13\n}",
      "B6 {\n  r2.append(\"UNKNOWN\")\n  goto B13\n}",
      "B7 {\n  $i0 \u003d JsonLocation: int _lineNr\u003e\n  if ($i0 \u003c\u003d 0) goto B8 else B10\n}",
      "B8 {\n  $r3 \u003d r2.append(\"line: \")\n  $i4 \u003d JsonLocation: int _lineNr\u003e\n  $r3.append($i4)\n  $i5 \u003d JsonLocation: int _columnNr\u003e\n  if ($i5 \u003c\u003d 0) goto B9 else B13\n}",
      "B9 {\n  r2.append(\", column: \")\n  $i6 \u003d JsonLocation: int _columnNr\u003e\n  r2.append($i6)\n  goto B13\n}",
      "B10 {\n  r2.append(\"byte offset: #\")\n  $l1 \u003d JsonLocation: long _totalBytes\u003e\n  $b2 \u003d $l1 cmp 0L\n  $i11 \u003d (int) $b2\n  if ($i11 \u003c 0) goto B11 else B12\n}",
      "B11 {\n  $l3 \u003d JsonLocation: long _totalBytes\u003e\n  r2.append($l3)\n  goto B13\n}",
      "B12 {\n  r2.append(\"UNKNOWN\")\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B7",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B13",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonLocation",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    int hash \u003d (_contentReference \u003d\u003d null) ? 1 : 2;\r\n    hash ^\u003d _lineNr;\r\n    hash +\u003d _columnNr;\r\n    hash ^\u003d (int) _totalChars;\r\n    hash +\u003d (int) _totalBytes;\r\n    return hash;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonLocation\n  $r1 \u003d ContentReference _contentReference\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $b10 \u003d 1\n  goto B3\n}",
      "B2 {\n  $b10 \u003d 2\n}",
      "B3 {\n  $i0 \u003d JsonLocation: int _lineNr\u003e\n  $i6 \u003d $b10 ^ $i0\n  $i1 \u003d JsonLocation: int _columnNr\u003e\n  $i7 \u003d $i6 + $i1\n  $l2 \u003d JsonLocation: long _totalChars\u003e\n  $i3 \u003d (int) $l2\n  $i8 \u003d $i7 ^ $i3\n  $l4 \u003d JsonLocation: long _totalBytes\u003e\n  $i5 \u003d (int) $l4\n  $i9 \u003d $i8 + $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonLocation",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d this)\r\n        return true;\r\n    if (other \u003d\u003d null)\r\n        return false;\r\n    if (!(other instanceof JsonLocation))\r\n        return false;\r\n    JsonLocation otherLoc \u003d (JsonLocation) other;\r\n    if (_contentReference \u003d\u003d null) {\r\n        if (otherLoc._contentReference !\u003d null)\r\n            return false;\r\n    } else if (!_contentReference.equals(otherLoc._contentReference)) {\r\n        return false;\r\n    }\r\n    return (_lineNr \u003d\u003d otherLoc._lineNr) \u0026\u0026 (_columnNr \u003d\u003d otherLoc._columnNr) \u0026\u0026 (_totalChars \u003d\u003d otherLoc._totalChars) \u0026\u0026 (_totalBytes \u003d\u003d otherLoc._totalBytes);\r\n}",
    "nodes": 18,
    "edges": 22,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6",
      "B6 : If($r3 !\u003d null) → B7 | else → B9",
      "B7 : If($r6 \u003d\u003d null) → B8 | else → B11",
      "B9 : If($z1 !\u003d 0) → B10 | else → B11",
      "B11 : If($i1 !\u003d $i0) → B12 | else → B16",
      "B12 : If($i3 !\u003d $i2) → B13 | else → B16",
      "B13 : If($b6 !\u003d 0) → B14 | else → B16",
      "B14 : If($b9 !\u003d 0) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  JsonLocation\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z0 \u003d JsonLocation\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r2 \u003d JsonLocation) r0\n  $r3 \u003d ContentReference _contentReference\u003e\n  if ($r3 !\u003d null) goto B7 else B9\n}",
      "B7 {\n  $r6 \u003d ContentReference _contentReference\u003e\n  if ($r6 \u003d\u003d null) goto B8 else B11\n}",
      "B8 {\n  return\n}",
      "B9 {\n  $r5 \u003d ContentReference _contentReference\u003e\n  $r4 \u003d ContentReference _contentReference\u003e\n  $z1 \u003d $r5.equals($r4)\n  if ($z1 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $i1 \u003d JsonLocation: int _lineNr\u003e\n  $i0 \u003d JsonLocation: int _lineNr\u003e\n  if ($i1 !\u003d $i0) goto B12 else B16\n}",
      "B12 {\n  $i3 \u003d JsonLocation: int _columnNr\u003e\n  $i2 \u003d JsonLocation: int _columnNr\u003e\n  if ($i3 !\u003d $i2) goto B13 else B16\n}",
      "B13 {\n  $l5 \u003d JsonLocation: long _totalChars\u003e\n  $l4 \u003d JsonLocation: long _totalChars\u003e\n  $b6 \u003d $l5 cmp $l4\n  if ($b6 !\u003d 0) goto B14 else B16\n}",
      "B14 {\n  $l8 \u003d JsonLocation: long _totalBytes\u003e\n  $l7 \u003d JsonLocation: long _totalBytes\u003e\n  $b9 \u003d $l8 cmp $l7\n  if ($b9 !\u003d 0) goto B15 else B16\n}",
      "B15 {\n  $z2 \u003d 1\n  goto B17\n}",
      "B16 {\n  $z2 \u003d 0\n}",
      "B17 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonpCharacterEscapes",
    "methodName": "getEscapeSequence",
    "signature": "com.fasterxml.jackson.core.SerializableString getEscapeSequence(int)",
    "visibility": "public",
    "body": "{\r\n    switch(ch) {\r\n        case 0x2028:\r\n            return escapeFor2028;\r\n        case 0x2029:\r\n            return escapeFor2029;\r\n        default:\r\n            return null;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonpCharacterEscapes\n  i0 :\u003d @parameter0: int\n  SerializedString escapeFor2029\u003e;     default: goto return null; }\n}",
      "B1 {\n  $r1 \u003d SerializedString escapeFor2028\u003e\n  return\n}",
      "B2 {\n  $r0 \u003d SerializedString escapeFor2029\u003e\n  return\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "compile",
    "signature": "com.fasterxml.jackson.core.JsonPointer compile(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    // First quick checks for well-known \u0027empty\u0027 pointer\r\n    if ((expr \u003d\u003d null) || expr.length() \u003d\u003d 0) {\r\n        return EMPTY;\r\n    }\r\n    // And then quick validity check:\r\n    if (expr.charAt(0) !\u003d SEPARATOR) {\r\n        throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with \u0027/\u0027: \" + \"\\\"\" + expr + \"\\\"\");\r\n    }\r\n    return _parseTail(expr);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i0 !\u003d 0) → B2 | else → B3",
      "B3 : If($i2 \u003d\u003d 47) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  String\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d r0.length()\n  if ($i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d JsonPointer EMPTY\u003e\n  return\n}",
      "B3 {\n  $c1 \u003d r0.charAt(0)\n  $i2 \u003d (int) $c1\n  if ($i2 \u003d\u003d 47) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(r0)\n  new IllegalArgumentException($r4)\n  throw $r5\n}",
      "B5 {\n  $r2 \u003d JsonPointer._parseTail(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#_parseTail(...1)",
        "body": "{\r\n    PointerParent parent \u003d null;\r\n    // first char is the contextual slash, skip\r\n    int i \u003d 1;\r\n    final int end \u003d fullPath.length();\r\n    int startOffset \u003d 0;\r\n    while (i \u003c end) {\r\n        char c \u003d fullPath.charAt(i);\r\n        if (c \u003d\u003d SEPARATOR) {\r\n            // common case, got a segment\r\n            parent \u003d new PointerParent(parent, startOffset, fullPath.substring(startOffset + 1, i));\r\n            startOffset \u003d i;\r\n            ++i;\r\n            continue;\r\n        }\r\n        ++i;\r\n        // quoting is different; offline this case\r\n        if (c \u003d\u003d ESC \u0026\u0026 i \u003c end) {\r\n            // possibly, quote\r\n            // 04-Oct-2022, tatu: Let\u0027s decode escaped segment\r\n            //   instead of recursive call\r\n            StringBuilder sb \u003d new StringBuilder(32);\r\n            i \u003d _extractEscapedSegment(fullPath, startOffset + 1, i, sb);\r\n            final String segment \u003d sb.toString();\r\n            if (i \u003c 0) {\r\n                // end!\r\n                return _buildPath(fullPath, startOffset, segment, parent);\r\n            }\r\n            parent \u003d new PointerParent(parent, startOffset, segment);\r\n            startOffset \u003d i;\r\n            ++i;\r\n            continue;\r\n        }\r\n        // otherwise, loop on\r\n    }\r\n    // end of the road, no escapes\r\n    return _buildPath(fullPath, startOffset, fullPath.substring(startOffset + 1), parent);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "forPath",
    "signature": "com.fasterxml.jackson.core.JsonPointer forPath(com.fasterxml.jackson.core.JsonStreamContext,boolean)",
    "visibility": "public",
    "body": "{\r\n    // First things first: last segment may be for START_ARRAY/START_OBJECT,\r\n    // in which case it does not yet point to anything, and should be skipped\r\n    if (context \u003d\u003d null) {\r\n        return EMPTY;\r\n    }\r\n    // Otherwise if context was just created but is not advanced -- like,\r\n    // opening START_ARRAY/START_OBJECT returned -- drop the empty context.\r\n    if (!context.hasPathSegment()) {\r\n        // Except one special case: do not prune root if we need it\r\n        if (!(includeRoot \u0026\u0026 context.inRoot() \u0026\u0026 context.hasCurrentIndex())) {\r\n            context \u003d context.getParent();\r\n        }\r\n    }\r\n    PointerSegment next \u003d null;\r\n    int approxLength \u003d 0;\r\n    for (; context !\u003d null; context \u003d context.getParent()) {\r\n        if (context.inObject()) {\r\n            String propName \u003d context.getCurrentName();\r\n            if (propName \u003d\u003d null) {\r\n                // is this legal?\r\n                propName \u003d \"\";\r\n            }\r\n            approxLength +\u003d 2 + propName.length();\r\n            next \u003d new PointerSegment(next, propName, -1);\r\n        } else if (context.inArray() || includeRoot) {\r\n            int ix \u003d context.getCurrentIndex();\r\n            approxLength +\u003d 6;\r\n            next \u003d new PointerSegment(next, null, ix);\r\n        }\r\n        // NOTE: this effectively drops ROOT node(s); should have 1 such node,\r\n        // as the last one, but we don\u0027t have to care (probably some paths have\r\n        // no root, for example)\r\n    }\r\n    if (next \u003d\u003d null) {\r\n        return EMPTY;\r\n    }\r\n    // And here the fun starts! We have the head, need to traverse\r\n    // to compose full path String\r\n    StringBuilder pathBuilder \u003d new StringBuilder(approxLength);\r\n    PointerSegment last \u003d null;\r\n    for (; next !\u003d null; next \u003d next.next) {\r\n        // Let\u0027s find the last segment as well, for reverse traversal\r\n        last \u003d next;\r\n        next.pathOffset \u003d pathBuilder.length();\r\n        pathBuilder.append(SEPARATOR);\r\n        if (next.property !\u003d null) {\r\n            _appendEscaped(pathBuilder, next.property);\r\n        } else {\r\n            pathBuilder.append(next.index);\r\n        }\r\n    }\r\n    final String fullPath \u003d pathBuilder.toString();\r\n    // and then iteratively construct JsonPointer chain in reverse direction\r\n    // (from innermost back to outermost)\r\n    PointerSegment currSegment \u003d last;\r\n    JsonPointer currPtr \u003d EMPTY;\r\n    for (; currSegment !\u003d null; currSegment \u003d currSegment.prev) {\r\n        if (currSegment.property !\u003d null) {\r\n            currPtr \u003d new JsonPointer(fullPath, currSegment.pathOffset, currSegment.property, currPtr);\r\n        } else {\r\n            int index \u003d currSegment.index;\r\n            currPtr \u003d new JsonPointer(fullPath, currSegment.pathOffset, String.valueOf(index), index, currPtr);\r\n        }\r\n    }\r\n    return currPtr;\r\n}",
    "nodes": 32,
    "edges": 44,
    "cc": 14,
    "flowSummary": [
      "B0 : If(r13 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B7",
      "B3 : If(z3 \u003d\u003d false) → B4 | else → B6",
      "B4 : If($z4 \u003d\u003d false) → B5 | else → B6",
      "B5 : If($z5 !\u003d 0) → B6 | else → B7",
      "B8 : If(r13 \u003d\u003d null) → B9 | else → B17",
      "B9 : If($z1 \u003d\u003d false) → B10 | else → B13",
      "B10 : If(r15 !\u003d null) → B11 | else → B12",
      "B13 : If($z2 !\u003d 0) → B14 | else → B15",
      "B14 : If(z3 \u003d\u003d false) → B15 | else → B16",
      "B17 : If(r14 !\u003d null) → B18 | else → B19",
      "B20 : If(r14 \u003d\u003d null) → B21 | else → B25",
      "B21 : If($r7 \u003d\u003d null) → B22 | else → B23",
      "B26 : If(r17 \u003d\u003d null) → B27 | else → B31",
      "B27 : If($r2 \u003d\u003d null) → B28 | else → B29"
    ],
    "blockList": [
      "B0 {\n  JsonStreamContext\n  z3 :\u003d @parameter1: boolean\n  if (r13 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d JsonPointer EMPTY\u003e\n  return\n}",
      "B2 {\n  $z0 \u003d r13.hasPathSegment()\n  if ($z0 !\u003d 0) goto B3 else B7\n}",
      "B3 {\n  if (z3 \u003d\u003d false) goto B4 else B6\n}",
      "B4 {\n  $z4 \u003d r13.inRoot()\n  if ($z4 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $z5 \u003d r13.hasCurrentIndex()\n  if ($z5 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  r13 \u003d r13.getParent()\n}",
      "B7 {\n  r14 \u003d null\n  i8 \u003d 0\n}",
      "B8 {\n  if (r13 \u003d\u003d null) goto B9 else B17\n}",
      "B9 {\n  $z1 \u003d r13.inObject()\n  if ($z1 \u003d\u003d false) goto B10 else B13\n}",
      "B10 {\n  r15 \u003d r13.getCurrentName()\n  if (r15 !\u003d null) goto B11 else B12\n}",
      "B11 {\n  r15 \u003d \"\"\n}",
      "B12 {\n  $i6 \u003d r15.length()\n  $i7 \u003d 2 + $i6\n  i8 \u003d i8 + $i7\n  $r19 \u003d JsonPointer$PointerSegment\n  $i10 \u003d (int) -1\n  new JsonPointer$PointerSegment(r14, r15, $i10)\n  r14 \u003d $r19\n  goto B16\n}",
      "B13 {\n  $z2 \u003d r13.inArray()\n  if ($z2 !\u003d 0) goto B14 else B15\n}",
      "B14 {\n  if (z3 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $i5 \u003d r13.getCurrentIndex()\n  i8 \u003d i8 + 6\n  $r20 \u003d JsonPointer$PointerSegment\n  new JsonPointer$PointerSegment(r14, null, $i5)\n  r14 \u003d $r20\n}",
      "B16 {\n  r13 \u003d r13.getParent()\n  goto B8\n}",
      "B17 {\n  if (r14 !\u003d null) goto B18 else B19\n}",
      "B18 {\n  $r9 \u003d JsonPointer EMPTY\u003e\n  return\n}",
      "B19 {\n  $r21 \u003d StringBuilder\n  new StringBuilder(i8)\n  r16 \u003d null\n}",
      "B20 {\n  if (r14 \u003d\u003d null) goto B21 else B25\n}",
      "B21 {\n  r16 \u003d r14\n  $i3 \u003d $r21.length()\n  JsonPointer$PointerSegment: int pathOffset\u003e \u003d $i3\n  $r21.append(47)\n  $r7 \u003d String property\u003e\n  if ($r7 \u003d\u003d null) goto B22 else B23\n}",
      "B22 {\n  $r8 \u003d String property\u003e\n  JsonPointer._appendEscaped($r21, $r8)\n  goto B24\n}",
      "B23 {\n  $i4 \u003d JsonPointer$PointerSegment: int index\u003e\n  $r21.append($i4)\n}",
      "B24 {\n  r14 \u003d JsonPointer$PointerSegment next\u003e\n  goto B20\n}",
      "B25 {\n  r1 \u003d $r21.toString()\n  r17 \u003d r16\n  r18 \u003d JsonPointer EMPTY\u003e\n}",
      "B26 {\n  if (r17 \u003d\u003d null) goto B27 else B31\n}",
      "B27 {\n  $r2 \u003d String property\u003e\n  if ($r2 \u003d\u003d null) goto B28 else B29\n}",
      "B28 {\n  $r22 \u003d JsonPointer\n  $i2 \u003d JsonPointer$PointerSegment: int pathOffset\u003e\n  $r6 \u003d String property\u003e\n  new JsonPointer(r1, $i2, $r6, r18)\n  r18 \u003d $r22\n  goto B30\n}",
      "B29 {\n  i0 \u003d JsonPointer$PointerSegment: int index\u003e\n  $r23 \u003d JsonPointer\n  $i1 \u003d JsonPointer$PointerSegment: int pathOffset\u003e\n  $r4 \u003d String.valueOf(i0)\n  new JsonPointer(r1, $i1, $r4, i0, r18)\n  r18 \u003d $r23\n}",
      "B30 {\n  r17 \u003d JsonPointer$PointerSegment prev\u003e\n  goto B26\n}",
      "B31 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B17",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B8",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B25",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B20",
      "B25 --\u003e B26",
      "B26 --\u003e B27",
      "B26 --\u003e B31",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B30",
      "B29 --\u003e B30",
      "B30 --\u003e B26",
      "B31 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#_appendEscaped(...2)",
        "body": "{\r\n    for (int i \u003d 0, end \u003d segment.length(); i \u003c end; ++i) {\r\n        char c \u003d segment.charAt(i);\r\n        if (c \u003d\u003d SEPARATOR) {\r\n            sb.append(ESC_SLASH);\r\n            continue;\r\n        }\r\n        if (c \u003d\u003d ESC) {\r\n            sb.append(ESC_TILDE);\r\n            continue;\r\n        }\r\n        sb.append(c);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "matches",
    "signature": "boolean matches()",
    "visibility": "public",
    "body": "{\r\n    return _nextSegment \u003d\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  $r1 \u003d JsonPointer _nextSegment\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "mayMatchProperty",
    "signature": "boolean mayMatchProperty()",
    "visibility": "public",
    "body": "{\r\n    return _matchingPropertyName !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  $r1 \u003d String _matchingPropertyName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "mayMatchElement",
    "signature": "boolean mayMatchElement()",
    "visibility": "public",
    "body": "{\r\n    return _matchingElementIndex \u003e\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  $i0 \u003d JsonPointer: int _matchingElementIndex\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "last",
    "signature": "com.fasterxml.jackson.core.JsonPointer last()",
    "visibility": "public",
    "body": "{\r\n    JsonPointer current \u003d this;\r\n    if (current \u003d\u003d EMPTY) {\r\n        return null;\r\n    }\r\n    JsonPointer next;\r\n    while ((next \u003d current._nextSegment) !\u003d JsonPointer.EMPTY) {\r\n        current \u003d next;\r\n    }\r\n    return current;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d $r3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  r4 \u003d r0\n  $r1 \u003d JsonPointer EMPTY\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d JsonPointer _nextSegment\u003e\n  $r3 \u003d JsonPointer EMPTY\u003e\n  if ($r2 \u003d\u003d $r3) goto B3 else B4\n}",
      "B3 {\n  r4 \u003d $r2\n  goto B2\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "append",
    "signature": "com.fasterxml.jackson.core.JsonPointer append(com.fasterxml.jackson.core.JsonPointer)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d EMPTY) {\r\n        return tail;\r\n    }\r\n    if (tail \u003d\u003d EMPTY) {\r\n        return this;\r\n    }\r\n    // 21-Mar-2017, tatu: Not superbly efficient; could probably improve by not concatenating,\r\n    //    re-decoding -- by stitching together segments -- but for now should be fine.\r\n    String currentJsonPointer \u003d toString();\r\n    // 14-Dec-2023, tatu: Pre-2.17 had special handling which makes no sense:\r\n    /*\r\n        if (currentJsonPointer.endsWith(\"/\")) {\r\n            //removes final slash\r\n            currentJsonPointer \u003d currentJsonPointer.substring(0, currentJsonPointer.length()-1);\r\n        }\r\n        */\r\n    return compile(currentJsonPointer + tail.toString());\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2",
      "B2 : If(r2 !\u003d $r3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  JsonPointer\n  $r1 \u003d JsonPointer EMPTY\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d JsonPointer EMPTY\u003e\n  if (r2 !\u003d $r3) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  r4 \u003d r0.toString()\n  $r5 \u003d r2.toString()\n  $r6 \u003d dynInvoke makeConcatWithConstants(r4, $r5)\n  $r7 \u003d JsonPointer.compile($r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#toString(...0)",
        "body": "{\r\n    if (_asStringOffset \u003c\u003d 0) {\r\n        return _asString;\r\n    }\r\n    return _asString.substring(_asStringOffset);\r\n}"
      },
      {
        "name": "JsonPointer#compile(...1)",
        "body": "{\r\n    // First quick checks for well-known \u0027empty\u0027 pointer\r\n    if ((expr \u003d\u003d null) || expr.length() \u003d\u003d 0) {\r\n        return EMPTY;\r\n    }\r\n    // And then quick validity check:\r\n    if (expr.charAt(0) !\u003d SEPARATOR) {\r\n        throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with \u0027/\u0027: \" + \"\\\"\" + expr + \"\\\"\");\r\n    }\r\n    return _parseTail(expr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "appendProperty",
    "signature": "com.fasterxml.jackson.core.JsonPointer appendProperty(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (property \u003d\u003d null) {\r\n        return this;\r\n    }\r\n    // 14-Dec-2023, tatu: [core#1145] Must escape `property`; accept empty String\r\n    //    as valid segment to match as well\r\n    StringBuilder sb \u003d toStringBuilder(property.length() + 2).append(SEPARATOR);\r\n    _appendEscaped(sb, property);\r\n    return compile(sb.toString());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.length()\n  $i1 \u003d $i0 + 2\n  $r2 \u003d r1.toStringBuilder($i1)\n  r3 \u003d $r2.append(47)\n  JsonPointer._appendEscaped(r3, r0)\n  $r4 \u003d r3.toString()\n  $r5 \u003d JsonPointer.compile($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#toStringBuilder(...1)",
        "body": "{\r\n    if (_asStringOffset \u003c\u003d 0) {\r\n        return new StringBuilder(_asString);\r\n    }\r\n    final int len \u003d _asString.length();\r\n    StringBuilder sb \u003d new StringBuilder(len - _asStringOffset + slack);\r\n    sb.append(_asString, _asStringOffset, len);\r\n    return sb;\r\n}"
      },
      {
        "name": "JsonPointer#_appendEscaped(...2)",
        "body": "{\r\n    for (int i \u003d 0, end \u003d segment.length(); i \u003c end; ++i) {\r\n        char c \u003d segment.charAt(i);\r\n        if (c \u003d\u003d SEPARATOR) {\r\n            sb.append(ESC_SLASH);\r\n            continue;\r\n        }\r\n        if (c \u003d\u003d ESC) {\r\n            sb.append(ESC_TILDE);\r\n            continue;\r\n        }\r\n        sb.append(c);\r\n    }\r\n}"
      },
      {
        "name": "JsonPointer#compile(...1)",
        "body": "{\r\n    // First quick checks for well-known \u0027empty\u0027 pointer\r\n    if ((expr \u003d\u003d null) || expr.length() \u003d\u003d 0) {\r\n        return EMPTY;\r\n    }\r\n    // And then quick validity check:\r\n    if (expr.charAt(0) !\u003d SEPARATOR) {\r\n        throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with \u0027/\u0027: \" + \"\\\"\" + expr + \"\\\"\");\r\n    }\r\n    return _parseTail(expr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "appendIndex",
    "signature": "com.fasterxml.jackson.core.JsonPointer appendIndex(int)",
    "visibility": "public",
    "body": "{\r\n    if (index \u003c 0) {\r\n        throw new IllegalArgumentException(\"Negative index cannot be appended\");\r\n    }\r\n    // 14-Dec-2024, tatu: Used to have odd logic for removing \"trailing\" slash;\r\n    //    removed from 2.17\r\n    return compile(toStringBuilder(8).append(SEPARATOR).append(index).toString());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  i0 :\u003d @parameter0: int\n  if (i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"Negative index cannot be appended\")\n  throw $r6\n}",
      "B2 {\n  $r1 \u003d r0.toStringBuilder(8)\n  $r2 \u003d $r1.append(47)\n  $r3 \u003d $r2.append(i0)\n  $r4 \u003d $r3.toString()\n  $r5 \u003d JsonPointer.compile($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#toStringBuilder(...1)",
        "body": "{\r\n    if (_asStringOffset \u003c\u003d 0) {\r\n        return new StringBuilder(_asString);\r\n    }\r\n    final int len \u003d _asString.length();\r\n    StringBuilder sb \u003d new StringBuilder(len - _asStringOffset + slack);\r\n    sb.append(_asString, _asStringOffset, len);\r\n    return sb;\r\n}"
      },
      {
        "name": "JsonPointer#compile(...1)",
        "body": "{\r\n    // First quick checks for well-known \u0027empty\u0027 pointer\r\n    if ((expr \u003d\u003d null) || expr.length() \u003d\u003d 0) {\r\n        return EMPTY;\r\n    }\r\n    // And then quick validity check:\r\n    if (expr.charAt(0) !\u003d SEPARATOR) {\r\n        throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with \u0027/\u0027: \" + \"\\\"\" + expr + \"\\\"\");\r\n    }\r\n    return _parseTail(expr);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "matchesProperty",
    "signature": "boolean matchesProperty(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return (_nextSegment !\u003d null) \u0026\u0026 _matchingPropertyName.equals(name);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  String\n  $r1 \u003d JsonPointer _nextSegment\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d String _matchingPropertyName\u003e\n  $z0 \u003d $r3.equals(r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "matchProperty",
    "signature": "com.fasterxml.jackson.core.JsonPointer matchProperty(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if ((_nextSegment !\u003d null) \u0026\u0026 _matchingPropertyName.equals(name)) {\r\n        return _nextSegment;\r\n    }\r\n    return null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  String\n  $r1 \u003d JsonPointer _nextSegment\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r3 \u003d String _matchingPropertyName\u003e\n  $z0 \u003d $r3.equals(r2)\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d JsonPointer _nextSegment\u003e\n  return\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "matchesElement",
    "signature": "boolean matchesElement(int)",
    "visibility": "public",
    "body": "{\r\n    return (index \u003d\u003d _matchingElementIndex) \u0026\u0026 (index \u003e\u003d 0);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B3",
      "B1 : If(i0 \u003c 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  i0 :\u003d @parameter0: int\n  $i1 \u003d JsonPointer: int _matchingElementIndex\u003e\n  if (i0 !\u003d $i1) goto B1 else B3\n}",
      "B1 {\n  if (i0 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "matchElement",
    "signature": "com.fasterxml.jackson.core.JsonPointer matchElement(int)",
    "visibility": "public",
    "body": "{\r\n    if ((index !\u003d _matchingElementIndex) || (index \u003c 0)) {\r\n        return null;\r\n    }\r\n    return _nextSegment;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B2",
      "B1 : If(i0 \u003e\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  i0 :\u003d @parameter0: int\n  $i1 \u003d JsonPointer: int _matchingElementIndex\u003e\n  if (i0 !\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  if (i0 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r1 \u003d JsonPointer _nextSegment\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "head",
    "signature": "com.fasterxml.jackson.core.JsonPointer head()",
    "visibility": "public",
    "body": "{\r\n    JsonPointer h \u003d _head;\r\n    if (h \u003d\u003d null) {\r\n        if (this !\u003d EMPTY) {\r\n            h \u003d _constructHead();\r\n        }\r\n        _head \u003d h;\r\n    }\r\n    return h;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B4",
      "B1 : If(r0 \u003d\u003d $r1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  r2 \u003d JsonPointer _head\u003e\n  if (r2 !\u003d null) goto B1 else B4\n}",
      "B1 {\n  $r1 \u003d JsonPointer EMPTY\u003e\n  if (r0 \u003d\u003d $r1) goto B2 else B3\n}",
      "B2 {\n  r2 \u003d r0._constructHead()\n}",
      "B3 {\n  JsonPointer _head\u003e \u003d r2\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#_constructHead(...0)",
        "body": "{\r\n    // ok; find out the segment we are to drop\r\n    JsonPointer last \u003d last();\r\n    if (last \u003d\u003d this) {\r\n        return EMPTY;\r\n    }\r\n    // Initialize a list to store intermediate JsonPointers in reverse\r\n    ArrayList\u003cJsonPointer\u003e pointers \u003d new ArrayList\u003c\u003e();\r\n    JsonPointer current \u003d this;\r\n    String origFullString \u003d toString();\r\n    // Make sure to share the new full string for path segments\r\n    String fullString \u003d origFullString.substring(0, origFullString.length() - last.length());\r\n    // Also: if there was an offset, must compensate (new String starts at 0)\r\n    final int offsetDiff \u003d -_asStringOffset;\r\n    while (current !\u003d last) {\r\n        // NOTE: since we drop from the end we can simply reuse offset (w/ possible modification)\r\n        JsonPointer nextSegment \u003d new JsonPointer(current, fullString, current._asStringOffset + offsetDiff);\r\n        pointers.add(nextSegment);\r\n        current \u003d current._nextSegment;\r\n    }\r\n    // Iteratively build the JsonPointer chain from the list in reverse\r\n    JsonPointer head \u003d EMPTY;\r\n    for (int i \u003d pointers.size() - 1; i \u003e\u003d 0; i--) {\r\n        head \u003d new JsonPointer(pointers.get(i), head);\r\n    }\r\n    return head;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    if (_asStringOffset \u003c\u003d 0) {\r\n        return _asString;\r\n    }\r\n    return _asString.substring(_asStringOffset);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 \u003e 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  $i0 \u003d JsonPointer: int _asStringOffset\u003e\n  if ($i0 \u003e 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d String _asString\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d String _asString\u003e\n  $i1 \u003d JsonPointer: int _asStringOffset\u003e\n  $r2 \u003d $r1.substring($i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    int h \u003d _hashCode;\r\n    if (h \u003d\u003d 0) {\r\n        // Alas, this is bit wasteful, creating temporary String, but\r\n        // without JDK exposing hash code calculation for a sub-string\r\n        // can\u0027t do much\r\n        h \u003d toString().hashCode();\r\n        if (h \u003d\u003d 0) {\r\n            h \u003d -1;\r\n        }\r\n        _hashCode \u003d h;\r\n    }\r\n    return h;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B4",
      "B1 : If(i0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  i0 \u003d JsonPointer: int _hashCode\u003e\n  if (i0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $r1 \u003d r0.toString()\n  i0 \u003d $r1.hashCode()\n  if (i0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d (int) -1\n  i0 \u003d $i2\n}",
      "B3 {\n  JsonPointer: int _hashCode\u003e \u003d i0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#toString(...0)",
        "body": "{\r\n    if (_asStringOffset \u003c\u003d 0) {\r\n        return _asString;\r\n    }\r\n    return _asString.substring(_asStringOffset);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonPointer",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o \u003d\u003d this)\r\n        return true;\r\n    if (o \u003d\u003d null)\r\n        return false;\r\n    if (!(o instanceof JsonPointer))\r\n        return false;\r\n    JsonPointer other \u003d (JsonPointer) o;\r\n    // 07-Oct-2022, tatu: Ugh.... this gets way more complicated as we MUST\r\n    //   compare logical representation so cannot simply compare offset\r\n    //   and String\r\n    return _compare(_asString, _asStringOffset, other._asString, other._asStringOffset);\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d null) → B3 | else → B4",
      "B4 : If($z0 !\u003d 0) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonPointer\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $z0 \u003d JsonPointer\n  if ($z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r2 \u003d JsonPointer) r0\n  $r4 \u003d String _asString\u003e\n  $i1 \u003d JsonPointer: int _asStringOffset\u003e\n  $r3 \u003d String _asString\u003e\n  $i0 \u003d JsonPointer: int _asStringOffset\u003e\n  $z1 \u003d r1._compare($r4, $i1, $r3, $i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPointer#_compare(...4)",
        "body": "{\r\n    final int end1 \u003d str1.length();\r\n    // Different lengths? Not equal\r\n    if ((end1 - offset1) !\u003d (str2.length() - offset2)) {\r\n        return false;\r\n    }\r\n    for (; offset1 \u003c end1; ) {\r\n        if (str1.charAt(offset1++) !\u003d str2.charAt(offset2++)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonProcessingException",
    "methodName": "getMessage",
    "signature": "java.lang.String getMessage()",
    "visibility": "public",
    "body": "{\r\n    String msg \u003d super.getMessage();\r\n    if (msg \u003d\u003d null) {\r\n        msg \u003d \"N/A\";\r\n    }\r\n    JsonLocation loc \u003d getLocation();\r\n    String suffix \u003d getMessageSuffix();\r\n    // mild optimization, if nothing extra is needed:\r\n    if (loc !\u003d null || suffix !\u003d null) {\r\n        StringBuilder sb \u003d new StringBuilder(100);\r\n        sb.append(msg);\r\n        if (suffix !\u003d null) {\r\n            sb.append(suffix);\r\n        }\r\n        if (loc !\u003d null) {\r\n            sb.append(\u0027\\n\u0027);\r\n            sb.append(\" at \");\r\n            sb.append(loc.toString());\r\n        }\r\n        msg \u003d sb.toString();\r\n    }\r\n    return msg;\r\n}",
    "nodes": 10,
    "edges": 14,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r5 !\u003d null) → B1 | else → B2",
      "B2 : If($r3 !\u003d null) → B3 | else → B4",
      "B3 : If($r4 \u003d\u003d null) → B4 | else → B9",
      "B4 : If($r4 \u003d\u003d null) → B5 | else → B6",
      "B6 : If($r3 \u003d\u003d null) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  JsonProcessingException\n  r5 \u003d r0.getMessage()\n  if (r5 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r5 \u003d \"N/A\"\n}",
      "B2 {\n  $r3 \u003d r0.getLocation()\n  $r4 \u003d r0.getMessageSuffix()\n  if ($r3 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  if ($r4 \u003d\u003d null) goto B4 else B9\n}",
      "B4 {\n  $r1 \u003d StringBuilder\n  new StringBuilder(100)\n  $r1.append(r5)\n  if ($r4 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r1.append($r4)\n}",
      "B6 {\n  if ($r3 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $r1.append(10)\n  $r1.append(\" at \")\n  $r2 \u003d $r3.toString()\n  $r1.append($r2)\n}",
      "B8 {\n  r5 \u003d $r1.toString()\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonProcessingException#getMessageSuffix(...0)",
        "body": "{\r\n    return null;\r\n}"
      },
      {
        "name": "JsonProcessingException#getLocation(...0)",
        "body": "{\r\n    return _location;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.JsonToken",
    "methodName": "valueDescFor",
    "signature": "java.lang.String valueDescFor(com.fasterxml.jackson.core.JsonToken)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 12,
    "edges": 11,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(switch-on $i0) → B11 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonToken\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.ordinal()\n  tableswitch($i0) {     case 0: goto return \"[Unavailable value]\";     case 1: goto return \"Object value\";     case 2: goto return \"Object value\";     case 3: goto return \"Array value\";     case 4: goto return \"Array value\";     case 5: goto return \"Object value\";     case 6: goto return \"Embedded Object value\";     case 7: goto return \"String value\";     case 8: goto return \"Integer value\";     case 9: goto return \"Floating-point value\";     case 10: goto return \"Boolean value\";     case 11: goto return \"Boolean value\";     case 12: goto return \"Null value\";     default: goto return \"[Unavailable value]\"; }\n}",
      "B3 {\n  return\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}",
      "B6 {\n  return\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}",
      "B9 {\n  return\n}",
      "B10 {\n  return\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B11",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B6",
      "B2 --\u003e B9",
      "B2 --\u003e B8",
      "B2 --\u003e B7",
      "B2 --\u003e B5",
      "B2 --\u003e B10",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadCapability",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadCapability\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadCapability: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "overrideDefaultStreamReadConstraints",
    "signature": "void overrideDefaultStreamReadConstraints(com.fasterxml.jackson.core.StreamReadConstraints)",
    "visibility": "public",
    "body": "{\r\n    if (streamReadConstraints \u003d\u003d null) {\r\n        DEFAULT \u003d new StreamReadConstraints(DEFAULT_MAX_DEPTH, DEFAULT_MAX_DOC_LEN, DEFAULT_MAX_NUM_LEN, DEFAULT_MAX_STRING_LEN);\r\n    } else {\r\n        DEFAULT \u003d streamReadConstraints;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d StreamReadConstraints\n  new StreamReadConstraints(1000, -1L, 1000, 20000000)\n  StreamReadConstraints DEFAULT\u003e \u003d $r1\n  goto B3\n}",
      "B2 {\n  StreamReadConstraints DEFAULT\u003e \u003d r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "hasMaxDocumentLength",
    "signature": "boolean hasMaxDocumentLength()",
    "visibility": "public",
    "body": "{\r\n    return _maxDocLen \u003e 0L;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  $l0 \u003d StreamReadConstraints: long _maxDocLen\u003e\n  $b1 \u003d $l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "hasMaxTokenCount",
    "signature": "boolean hasMaxTokenCount()",
    "visibility": "public",
    "body": "{\r\n    return _maxTokenCount \u003e 0L;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  $l0 \u003d StreamReadConstraints: long _maxTokenCount\u003e\n  $b1 \u003d $l0 cmp 0L\n  $i2 \u003d (int) $b1\n  if ($i2 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateNestingDepth",
    "signature": "void validateNestingDepth(int)",
    "visibility": "public",
    "body": "{\r\n    if (depth \u003e _maxNestingDepth) {\r\n        throw _constructException(\"Document nesting depth (%d) exceeds the maximum allowed (%d, from %s)\", depth, _maxNestingDepth, _constrainRef(\"getMaxNestingDepth\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadConstraints: int _maxNestingDepth\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamReadConstraints: int _maxNestingDepth\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxNestingDepth\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Document nesting depth (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateDocumentLength",
    "signature": "void validateDocumentLength(long)",
    "visibility": "public",
    "body": "{\r\n    if ((len \u003e _maxDocLen) \u0026\u0026 // Note: -1L used as marker for \"unlimited\"\r\n    (_maxDocLen \u003e 0L)) {\r\n        throw _constructException(\"Document length (%d) exceeds the maximum allowed (%d, from %s)\", len, _maxDocLen, _constrainRef(\"getMaxDocumentLength\"));\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i6 \u003c\u003d 0) → B1 | else → B3",
      "B1 : If($i7 \u003c\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  l0 :\u003d @parameter0: long\n  $l1 \u003d StreamReadConstraints: long _maxDocLen\u003e\n  $b2 \u003d l0 cmp $l1\n  $i6 \u003d (int) $b2\n  if ($i6 \u003c\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $l3 \u003d StreamReadConstraints: long _maxDocLen\u003e\n  $b4 \u003d $l3 cmp 0L\n  $i7 \u003d (int) $b4\n  if ($i7 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Long.valueOf(l0)\n  $r1[0] \u003d $r2\n  $l5 \u003d StreamReadConstraints: long _maxDocLen\u003e\n  $r3 \u003d Long.valueOf($l5)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxDocumentLength\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Document length (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateTokenCount",
    "signature": "void validateTokenCount(long)",
    "visibility": "public",
    "body": "{\r\n    // for performance reasons, it is assumed that users check hasMaxTokenCount()\r\n    // before calling this method - this method will not work properly if hasMaxTokenCount() is false\r\n    if (count \u003e _maxTokenCount) {\r\n        throw _constructException(\"Token count (%d) exceeds the maximum allowed (%d, from %s)\", count, _maxTokenCount, _constrainRef(\"getMaxTokenCount\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i4 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  l0 :\u003d @parameter0: long\n  $l1 \u003d StreamReadConstraints: long _maxTokenCount\u003e\n  $b2 \u003d l0 cmp $l1\n  $i4 \u003d (int) $b2\n  if ($i4 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Long.valueOf(l0)\n  $r1[0] \u003d $r2\n  $l3 \u003d StreamReadConstraints: long _maxTokenCount\u003e\n  $r3 \u003d Long.valueOf($l3)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxTokenCount\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Token count (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateFPLength",
    "signature": "void validateFPLength(int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003e _maxNumLen) {\r\n        throw _constructException(\"Number value length (%d) exceeds the maximum allowed (%d, from %s)\", length, _maxNumLen, _constrainRef(\"getMaxNumberLength\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadConstraints: int _maxNumLen\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamReadConstraints: int _maxNumLen\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxNumberLength\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Number value length (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateIntegerLength",
    "signature": "void validateIntegerLength(int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003e _maxNumLen) {\r\n        throw _constructException(\"Number value length (%d) exceeds the maximum allowed (%d, from %s)\", length, _maxNumLen, _constrainRef(\"getMaxNumberLength\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadConstraints: int _maxNumLen\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamReadConstraints: int _maxNumLen\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxNumberLength\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Number value length (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateStringLength",
    "signature": "void validateStringLength(int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003e _maxStringLen) {\r\n        throw _constructException(\"String value length (%d) exceeds the maximum allowed (%d, from %s)\", length, _maxStringLen, _constrainRef(\"getMaxStringLength\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadConstraints: int _maxStringLen\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamReadConstraints: int _maxStringLen\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxStringLength\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"String value length (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateNameLength",
    "signature": "void validateNameLength(int)",
    "visibility": "public",
    "body": "{\r\n    if (length \u003e _maxNameLen) {\r\n        throw _constructException(\"Name length (%d) exceeds the maximum allowed (%d, from %s)\", length, _maxNameLen, _constrainRef(\"getMaxNameLength\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadConstraints: int _maxNameLen\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamReadConstraints: int _maxNameLen\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxNameLength\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Name length (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamReadConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamReadConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadConstraints",
    "methodName": "validateBigIntegerScale",
    "signature": "void validateBigIntegerScale(int)",
    "visibility": "public",
    "body": "{\r\n    final int absScale \u003d Math.abs(scale);\r\n    final int limit \u003d MAX_BIGINT_SCALE_MAGNITUDE;\r\n    if (absScale \u003e limit) {\r\n        throw _constructException(\"BigDecimal scale (%d) magnitude exceeds the maximum allowed (%d)\", scale, limit);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i1 \u003c\u003d 100000) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadConstraints\n  i0 :\u003d @parameter0: int\n  i1 \u003d Math.abs(i0)\n  if (i1 \u003c\u003d 100000) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[2]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $r3 \u003d Integer.valueOf(100000)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constructException(\"BigDecimal scale (%d) magnitude exceeds the maximum allowed (%d)\", $r1)\n  throw $r4\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamReadConstraints#_constructException(...3)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadFeature",
    "methodName": "collectDefaults",
    "signature": "int collectDefaults()",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  i2 \u003d 0\n  r0 \u003d StreamReadFeature.values()\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r1 \u003d r0[i3]\n  $z0 \u003d r1.enabledByDefault()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i1 \u003d r1.getMask()\n  i2 \u003d i2 | $i1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamReadFeature",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamReadFeature\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamReadFeature: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamWriteCapability",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamWriteCapability\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamWriteCapability: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamWriteConstraints",
    "methodName": "overrideDefaultStreamWriteConstraints",
    "signature": "void overrideDefaultStreamWriteConstraints(com.fasterxml.jackson.core.StreamWriteConstraints)",
    "visibility": "public",
    "body": "{\r\n    if (streamWriteConstraints \u003d\u003d null) {\r\n        DEFAULT \u003d new StreamWriteConstraints(DEFAULT_MAX_DEPTH);\r\n    } else {\r\n        DEFAULT \u003d streamWriteConstraints;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamWriteConstraints\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d StreamWriteConstraints\n  new StreamWriteConstraints(1000)\n  StreamWriteConstraints DEFAULT\u003e \u003d $r1\n  goto B3\n}",
      "B2 {\n  StreamWriteConstraints DEFAULT\u003e \u003d r0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamWriteConstraints",
    "methodName": "validateNestingDepth",
    "signature": "void validateNestingDepth(int)",
    "visibility": "public",
    "body": "{\r\n    if (depth \u003e _maxNestingDepth) {\r\n        throw _constructException(\"Document nesting depth (%d) exceeds the maximum allowed (%d, from %s)\", depth, _maxNestingDepth, _constrainRef(\"getMaxNestingDepth\"));\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(i0 \u003c\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamWriteConstraints\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamWriteConstraints: int _maxNestingDepth\u003e\n  if (i0 \u003c\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Object)[3]\n  $r2 \u003d Integer.valueOf(i0)\n  $r1[0] \u003d $r2\n  $i2 \u003d StreamWriteConstraints: int _maxNestingDepth\u003e\n  $r3 \u003d Integer.valueOf($i2)\n  $r1[1] \u003d $r3\n  $r4 \u003d r0._constrainRef(\"getMaxNestingDepth\")\n  $r1[2] \u003d $r4\n  $r5 \u003d r0._constructException(\"Document nesting depth (%d) exceeds the maximum allowed (%d, from %s)\", $r1)\n  throw $r5\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "StreamWriteConstraints#_constructException(...4)",
        "body": "(source not found)"
      },
      {
        "name": "StreamWriteConstraints#_constrainRef(...1)",
        "body": "{\r\n    return \"`StreamWriteConstraints.\" + method + \"()`\";\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamWriteFeature",
    "methodName": "collectDefaults",
    "signature": "int collectDefaults()",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  i2 \u003d 0\n  r0 \u003d StreamWriteFeature.values()\n  i0 \u003d lengthof r0\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r1 \u003d r0[i3]\n  $z0 \u003d r1.enabledByDefault()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $i1 \u003d r1.getMask()\n  i2 \u003d i2 | $i1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.StreamWriteFeature",
    "methodName": "enabledIn",
    "signature": "boolean enabledIn(int)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  StreamWriteFeature\n  i0 :\u003d @parameter0: int\n  $i1 \u003d StreamWriteFeature: int _mask\u003e\n  $i2 \u003d i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "makeChildOrPlaceholder",
    "signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer makeChildOrPlaceholder(int)",
    "visibility": "public",
    "body": "{\r\n    if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags)) {\r\n        // inlined \"makeChild()\"\r\n        return new ByteQuadsCanonicalizer(this, _seed, _tableInfo.get(), JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags), JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags));\r\n    }\r\n    return new ByteQuadsCanonicalizer(_tableInfo.get());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i0 :\u003d @parameter0: int\n  $r0 \u003d JsonFactory$Feature CANONICALIZE_FIELD_NAMES\u003e\n  $z0 \u003d $r0.enabledIn(i0)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ByteQuadsCanonicalizer\n  $i1 \u003d ByteQuadsCanonicalizer: int _seed\u003e\n  $r7 \u003d AtomicReference _tableInfo\u003e\n  $r8 \u003d $r7.get()\n  $r11 \u003d ByteQuadsCanonicalizer$TableInfo) $r8\n  $r9 \u003d JsonFactory$Feature INTERN_FIELD_NAMES\u003e\n  $z2 \u003d $r9.enabledIn(i0)\n  $r10 \u003d JsonFactory$Feature FAIL_ON_SYMBOL_HASH_OVERFLOW\u003e\n  $z1 \u003d $r10.enabledIn(i0)\n  new ByteQuadsCanonicalizer(r2, $i1, $r11, $z2, $z1)\n  return\n}",
      "B2 {\n  $r1 \u003d ByteQuadsCanonicalizer\n  $r3 \u003d AtomicReference _tableInfo\u003e\n  $r4 \u003d $r3.get()\n  $r5 \u003d ByteQuadsCanonicalizer$TableInfo) $r4\n  new ByteQuadsCanonicalizer($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "release",
    "signature": "void release()",
    "visibility": "public",
    "body": "{\r\n    // we will try to merge if child table has new entries\r\n    // 28-Jul-2019, tatu: From [core#548]: do not share if immediate rehash needed\r\n    if ((_parent !\u003d null) \u0026\u0026 maybeDirty()) {\r\n        _parent.mergeChild(new TableInfo(this));\r\n        // Let\u0027s also mark this instance as dirty, so that just in\r\n        // case release was too early, there\u0027s no corruption of possibly shared data.\r\n        _hashShared \u003d true;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  $r1 \u003d ByteQuadsCanonicalizer _parent\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $z0 \u003d r0.maybeDirty()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d ByteQuadsCanonicalizer _parent\u003e\n  $r2 \u003d ByteQuadsCanonicalizer$TableInfo\n  new ByteQuadsCanonicalizer$TableInfo(r0)\n  $r3.mergeChild($r2)\n  ByteQuadsCanonicalizer: boolean _hashShared\u003e \u003d 1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#maybeDirty(...0)",
        "body": "{\r\n    return !_hashShared;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "size",
    "signature": "int size()",
    "visibility": "public",
    "body": "{\r\n    if (_tableInfo !\u003d null) {\r\n        // root table\r\n        return _tableInfo.get().count;\r\n    }\r\n    // nope, child table\r\n    return _count;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  $r1 \u003d AtomicReference _tableInfo\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d AtomicReference _tableInfo\u003e\n  $r3 \u003d $r2.get()\n  $r4 \u003d ByteQuadsCanonicalizer$TableInfo) $r3\n  $i1 \u003d ByteQuadsCanonicalizer$TableInfo: int count\u003e\n  return\n}",
      "B2 {\n  $i0 \u003d ByteQuadsCanonicalizer: int _count\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "maybeDirty",
    "signature": "boolean maybeDirty()",
    "visibility": "public",
    "body": "{\r\n    return !_hashShared;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  $z0 \u003d ByteQuadsCanonicalizer: boolean _hashShared\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "isCanonicalizing",
    "signature": "boolean isCanonicalizing()",
    "visibility": "public",
    "body": "{\r\n    // couple of options, but for now missing parent linkage simplest:\r\n    return _parent !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  $r1 \u003d ByteQuadsCanonicalizer _parent\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "primaryCount",
    "signature": "int primaryCount()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (int offset \u003d 3, end \u003d _secondaryStart; offset \u003c end; offset +\u003d 4) {\r\n        if (_hashArea[offset] !\u003d 0) {\r\n            ++count;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If($i1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i2 \u003d 0\n  i3 \u003d 3\n  i0 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i1 \u003d $r1[i3]\n  if ($i1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i2 \u003d i2 + 1\n}",
      "B4 {\n  i3 \u003d i3 + 4\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "secondaryCount",
    "signature": "int secondaryCount()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    int offset \u003d _secondaryStart + 3;\r\n    for (int end \u003d _tertiaryStart; offset \u003c end; offset +\u003d 4) {\r\n        if (_hashArea[offset] !\u003d 0) {\r\n            ++count;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i1) → B2 | else → B5",
      "B2 : If($i2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i3 \u003d 0\n  $i0 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n  i4 \u003d $i0 + 3\n  i1 \u003d ByteQuadsCanonicalizer: int _tertiaryStart\u003e\n}",
      "B1 {\n  if (i4 \u003e\u003d i1) goto B2 else B5\n}",
      "B2 {\n  $r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i2 \u003d $r1[i4]\n  if ($i2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i3 \u003d i3 + 1\n}",
      "B4 {\n  i4 \u003d i4 + 4\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "tertiaryCount",
    "signature": "int tertiaryCount()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    // to 1.5x, starting point of tertiary\r\n    int offset \u003d _tertiaryStart + 3;\r\n    for (int end \u003d offset + _hashSize; offset \u003c end; offset +\u003d 4) {\r\n        if (_hashArea[offset] !\u003d 0) {\r\n            ++count;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i5 \u003e\u003d i2) → B2 | else → B5",
      "B2 : If($i3 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i4 \u003d 0\n  $i0 \u003d ByteQuadsCanonicalizer: int _tertiaryStart\u003e\n  i5 \u003d $i0 + 3\n  $i1 \u003d ByteQuadsCanonicalizer: int _hashSize\u003e\n  i2 \u003d i5 + $i1\n}",
      "B1 {\n  if (i5 \u003e\u003d i2) goto B2 else B5\n}",
      "B2 {\n  $r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i3 \u003d $r1[i5]\n  if ($i3 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i4 \u003d i4 + 1\n}",
      "B4 {\n  i5 \u003d i5 + 4\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "totalCount",
    "signature": "int totalCount()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (int offset \u003d 3, end \u003d (_hashSize \u003c\u003c 3); offset \u003c end; offset +\u003d 4) {\r\n        if (_hashArea[offset] !\u003d 0) {\r\n            ++count;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i1) → B2 | else → B5",
      "B2 : If($i2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i3 \u003d 0\n  i4 \u003d 3\n  $i0 \u003d ByteQuadsCanonicalizer: int _hashSize\u003e\n  i1 \u003d $i0 \u003c\u003c 3\n}",
      "B1 {\n  if (i4 \u003e\u003d i1) goto B2 else B5\n}",
      "B2 {\n  $r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i2 \u003d $r1[i4]\n  if ($i2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i3 \u003d i3 + 1\n}",
      "B4 {\n  i4 \u003d i4 + 4\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "findName",
    "signature": "java.lang.String findName(int)",
    "visibility": "public",
    "body": "{\r\n    int offset \u003d _calcOffset(calcHash(q1));\r\n    // first: primary match?\r\n    final int[] hashArea \u003d _hashArea;\r\n    int len \u003d hashArea[offset + 3];\r\n    if (len \u003d\u003d 1) {\r\n        if (hashArea[offset] \u003d\u003d q1) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot; unlikely but avoid further lookups if so\r\n        return null;\r\n    }\r\n    // secondary? single slot shared by N/2 primaries\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    len \u003d hashArea[offset2 + 3];\r\n    if (len \u003d\u003d 1) {\r\n        if (hashArea[offset2] \u003d\u003d q1) {\r\n            return _names[offset2 \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot; unlikely but avoid further lookups if so\r\n        return null;\r\n    }\r\n    // tertiary lookup \u0026 spillovers best to offline\r\n    return _findSecondary(offset, q1);\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i14 !\u003d 1) → B1 | else → B3",
      "B1 : If($i10 !\u003d i0) → B2 | else → B5",
      "B3 : If(i14 !\u003d 0) → B4 | else → B5",
      "B5 : If($i12 !\u003d 1) → B6 | else → B8",
      "B6 : If($i8 !\u003d i0) → B7 | else → B10",
      "B8 : If($i12 !\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i0 :\u003d @parameter0: int\n  $i1 \u003d r0.calcHash(i0)\n  i2 \u003d r0._calcOffset($i1)\n  r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i3 \u003d i2 + 3\n  i14 \u003d r1[$i3]\n  if (i14 !\u003d 1) goto B1 else B3\n}",
      "B1 {\n  $i10 \u003d r1[i2]\n  if ($i10 !\u003d i0) goto B2 else B5\n}",
      "B2 {\n  $r5 \u003d String[] _names\u003e\n  $i13 \u003d i2 \u003e\u003e 2\n  $r6 \u003d $r5[$i13]\n  return\n}",
      "B3 {\n  if (i14 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $i6 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n  $i4 \u003d i2 \u003e\u003e 3\n  $i5 \u003d $i4 \u003c\u003c 2\n  $i11 \u003d $i6 + $i5\n  $i7 \u003d $i11 + 3\n  $i12 \u003d r1[$i7]\n  if ($i12 !\u003d 1) goto B6 else B8\n}",
      "B6 {\n  $i8 \u003d r1[$i11]\n  if ($i8 !\u003d i0) goto B7 else B10\n}",
      "B7 {\n  $r3 \u003d String[] _names\u003e\n  $i9 \u003d $i11 \u003e\u003e 2\n  $r4 \u003d $r3[$i9]\n  return\n}",
      "B8 {\n  if ($i12 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r2 \u003d r0._findSecondary(i2, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...1)",
        "body": "{\r\n    int hash \u003d q1 ^ _seed;\r\n    /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\r\n         *    except for one specific problem case: numbers. So needed to make sure\r\n         *    that all 4 least-significant bits participate in hash. Couple of ways\r\n         *    to work it out, but this is the simplest, fast and seems to do ok.\r\n         */\r\n    // to xor hi- and low- 16-bits\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    // shuffle back a bit\r\n    hash ^\u003d (hash \u003c\u003c 3);\r\n    // and bit more\r\n    hash +\u003d (hash \u003e\u003e\u003e 12);\r\n    return hash;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_calcOffset(...1)",
        "body": "{\r\n    // NOTE: simple for initial impl, but we may want to interleave it a bit\r\n    // in near future\r\n    // So: first, hash into primary hash index\r\n    int ix \u003d hash \u0026 (_hashSize - 1);\r\n    // keeping in mind we have 4 ints per entry\r\n    return (ix \u003c\u003c 2);\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_findSecondary(...2)",
        "body": "{\r\n    // tertiary area division is dynamic. First; its size is N/4 compared to\r\n    // primary hash size; and offsets are for 4 int slots. So to get to logical\r\n    // index would shift by 4. But! Tertiary area is further split into buckets,\r\n    // determined by shift value. And finally, from bucket back into physical offsets\r\n    int offset \u003d _tertiaryStart + ((origOffset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int[] hashArea \u003d _hashArea;\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset + bucketSize; offset \u003c end; offset +\u003d 4) {\r\n        int len \u003d hashArea[offset + 3];\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (1 \u003d\u003d len)) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n        if (len \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n    }\r\n    // but if tertiary full, check out spill-over area as last resort\r\n    // shared spillover starts at 7/8 of the main hash area\r\n    // (which is sized at 2 * _hashSize), so:\r\n    for (offset \u003d _spilloverStart(); offset \u003c _spilloverEnd; offset +\u003d 4) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (1 \u003d\u003d hashArea[offset + 3])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "findName",
    "signature": "java.lang.String findName(int,int)",
    "visibility": "public",
    "body": "{\r\n    int offset \u003d _calcOffset(calcHash(q1, q2));\r\n    final int[] hashArea \u003d _hashArea;\r\n    int len \u003d hashArea[offset + 3];\r\n    if (len \u003d\u003d 2) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot; unlikely but avoid further lookups if so\r\n        return null;\r\n    }\r\n    // secondary?\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    len \u003d hashArea[offset2 + 3];\r\n    if (len \u003d\u003d 2) {\r\n        if ((q1 \u003d\u003d hashArea[offset2]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset2 + 1])) {\r\n            return _names[offset2 \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot? Short-circuit if no more spillovers\r\n        return null;\r\n    }\r\n    return _findSecondary(offset, q1, q2);\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i13 !\u003d 2) → B1 | else → B4",
      "B1 : If(i0 !\u003d $i9) → B2 | else → B6",
      "B2 : If(i1 !\u003d $i11) → B3 | else → B6",
      "B4 : If(i13 !\u003d 0) → B5 | else → B6",
      "B6 : If($i19 !\u003d 2) → B7 | else → B10",
      "B7 : If(i0 !\u003d $i5) → B8 | else → B12",
      "B8 : If(i1 !\u003d $i7) → B9 | else → B12",
      "B10 : If($i19 !\u003d 0) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  $i2 \u003d r0.calcHash(i0, i1)\n  i3 \u003d r0._calcOffset($i2)\n  r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i4 \u003d i3 + 3\n  i13 \u003d r1[$i4]\n  if (i13 !\u003d 2) goto B1 else B4\n}",
      "B1 {\n  $i9 \u003d r1[i3]\n  if (i0 !\u003d $i9) goto B2 else B6\n}",
      "B2 {\n  $i10 \u003d i3 + 1\n  $i11 \u003d r1[$i10]\n  if (i1 !\u003d $i11) goto B3 else B6\n}",
      "B3 {\n  $r4 \u003d String[] _names\u003e\n  $i12 \u003d i3 \u003e\u003e 2\n  $r5 \u003d $r4[$i12]\n  return\n}",
      "B4 {\n  if (i13 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $i14 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n  $i15 \u003d i3 \u003e\u003e 3\n  $i16 \u003d $i15 \u003c\u003c 2\n  $i17 \u003d $i14 + $i16\n  $i18 \u003d $i17 + 3\n  $i19 \u003d r1[$i18]\n  if ($i19 !\u003d 2) goto B7 else B10\n}",
      "B7 {\n  $i5 \u003d r1[$i17]\n  if (i0 !\u003d $i5) goto B8 else B12\n}",
      "B8 {\n  $i6 \u003d $i17 + 1\n  $i7 \u003d r1[$i6]\n  if (i1 !\u003d $i7) goto B9 else B12\n}",
      "B9 {\n  $r2 \u003d String[] _names\u003e\n  $i8 \u003d $i17 \u003e\u003e 2\n  $r3 \u003d $r2[$i8]\n  return\n}",
      "B10 {\n  if ($i19 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  $r6 \u003d r0._findSecondary(i3, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findSecondary(...3)",
        "body": "{\r\n    int offset \u003d _tertiaryStart + ((origOffset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int[] hashArea \u003d _hashArea;\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset + bucketSize; offset \u003c end; offset +\u003d 4) {\r\n        int len \u003d hashArea[offset + 3];\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (2 \u003d\u003d len)) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n        if (len \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n    }\r\n    for (offset \u003d _spilloverStart(); offset \u003c _spilloverEnd; offset +\u003d 4) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (2 \u003d\u003d hashArea[offset + 3])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_calcOffset(...1)",
        "body": "{\r\n    // NOTE: simple for initial impl, but we may want to interleave it a bit\r\n    // in near future\r\n    // So: first, hash into primary hash index\r\n    int ix \u003d hash \u0026 (_hashSize - 1);\r\n    // keeping in mind we have 4 ints per entry\r\n    return (ix \u003c\u003c 2);\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...2)",
        "body": "{\r\n    // For two quads, let\u0027s change algorithm a bit, to spice\r\n    // things up (can do bit more processing anyway)\r\n    int hash \u003d q1;\r\n    // try mixing first and second byte pairs first\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    // as well as lowest 2 bytes\r\n    hash ^\u003d (hash \u003e\u003e\u003e 9);\r\n    // then add second quad\r\n    hash +\u003d (q2 * MULT);\r\n    hash ^\u003d _seed;\r\n    // and shuffle some more\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    hash ^\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003c\u003c 3);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "findName",
    "signature": "java.lang.String findName(int,int,int)",
    "visibility": "public",
    "body": "{\r\n    int offset \u003d _calcOffset(calcHash(q1, q2, q3));\r\n    final int[] hashArea \u003d _hashArea;\r\n    int len \u003d hashArea[offset + 3];\r\n    if (len \u003d\u003d 3) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (hashArea[offset + 1] \u003d\u003d q2) \u0026\u0026 (hashArea[offset + 2] \u003d\u003d q3)) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot; unlikely but avoid further lookups if so\r\n        return null;\r\n    }\r\n    // secondary?\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    len \u003d hashArea[offset2 + 3];\r\n    if (len \u003d\u003d 3) {\r\n        if ((q1 \u003d\u003d hashArea[offset2]) \u0026\u0026 (hashArea[offset2 + 1] \u003d\u003d q2) \u0026\u0026 (hashArea[offset2 + 2] \u003d\u003d q3)) {\r\n            return _names[offset2 \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot? Short-circuit if no more spillovers\r\n        return null;\r\n    }\r\n    return _findSecondary(offset, q1, q2, q3);\r\n}",
    "nodes": 15,
    "edges": 20,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i18 !\u003d 3) → B1 | else → B5",
      "B1 : If(i0 !\u003d $i12) → B2 | else → B7",
      "B2 : If($i14 !\u003d i1) → B3 | else → B7",
      "B3 : If($i16 !\u003d i2) → B4 | else → B7",
      "B5 : If(i18 !\u003d 0) → B6 | else → B7",
      "B7 : If($i24 !\u003d 3) → B8 | else → B12",
      "B8 : If(i0 !\u003d $i6) → B9 | else → B14",
      "B9 : If($i8 !\u003d i1) → B10 | else → B14",
      "B10 : If($i10 !\u003d i2) → B11 | else → B14",
      "B12 : If($i24 !\u003d 0) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  i0 :\u003d @parameter0: int\n  i1 :\u003d @parameter1: int\n  i2 :\u003d @parameter2: int\n  $i3 \u003d r0.calcHash(i0, i1, i2)\n  i4 \u003d r0._calcOffset($i3)\n  r1 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i5 \u003d i4 + 3\n  i18 \u003d r1[$i5]\n  if (i18 !\u003d 3) goto B1 else B5\n}",
      "B1 {\n  $i12 \u003d r1[i4]\n  if (i0 !\u003d $i12) goto B2 else B7\n}",
      "B2 {\n  $i13 \u003d i4 + 1\n  $i14 \u003d r1[$i13]\n  if ($i14 !\u003d i1) goto B3 else B7\n}",
      "B3 {\n  $i15 \u003d i4 + 2\n  $i16 \u003d r1[$i15]\n  if ($i16 !\u003d i2) goto B4 else B7\n}",
      "B4 {\n  $r4 \u003d String[] _names\u003e\n  $i17 \u003d i4 \u003e\u003e 2\n  $r5 \u003d $r4[$i17]\n  return\n}",
      "B5 {\n  if (i18 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  $i19 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n  $i20 \u003d i4 \u003e\u003e 3\n  $i21 \u003d $i20 \u003c\u003c 2\n  $i22 \u003d $i19 + $i21\n  $i23 \u003d $i22 + 3\n  $i24 \u003d r1[$i23]\n  if ($i24 !\u003d 3) goto B8 else B12\n}",
      "B8 {\n  $i6 \u003d r1[$i22]\n  if (i0 !\u003d $i6) goto B9 else B14\n}",
      "B9 {\n  $i7 \u003d $i22 + 1\n  $i8 \u003d r1[$i7]\n  if ($i8 !\u003d i1) goto B10 else B14\n}",
      "B10 {\n  $i9 \u003d $i22 + 2\n  $i10 \u003d r1[$i9]\n  if ($i10 !\u003d i2) goto B11 else B14\n}",
      "B11 {\n  $r2 \u003d String[] _names\u003e\n  $i11 \u003d $i22 \u003e\u003e 2\n  $r3 \u003d $r2[$i11]\n  return\n}",
      "B12 {\n  if ($i24 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $r6 \u003d r0._findSecondary(i4, i0, i1, i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findSecondary(...4)",
        "body": "{\r\n    int offset \u003d _tertiaryStart + ((origOffset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int[] hashArea \u003d _hashArea;\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset + bucketSize; offset \u003c end; offset +\u003d 4) {\r\n        int len \u003d hashArea[offset + 3];\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (q3 \u003d\u003d hashArea[offset + 2]) \u0026\u0026 (3 \u003d\u003d len)) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n        if (len \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n    }\r\n    for (offset \u003d _spilloverStart(); offset \u003c _spilloverEnd; offset +\u003d 4) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (q3 \u003d\u003d hashArea[offset + 2]) \u0026\u0026 (3 \u003d\u003d hashArea[offset + 3])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_calcOffset(...1)",
        "body": "{\r\n    // NOTE: simple for initial impl, but we may want to interleave it a bit\r\n    // in near future\r\n    // So: first, hash into primary hash index\r\n    int ix \u003d hash \u0026 (_hashSize - 1);\r\n    // keeping in mind we have 4 ints per entry\r\n    return (ix \u003c\u003c 2);\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...3)",
        "body": "{\r\n    // use same algorithm as multi-byte, tested to work well\r\n    int hash \u003d q1 ^ _seed;\r\n    hash +\u003d (hash \u003e\u003e\u003e 9);\r\n    hash *\u003d MULT3;\r\n    hash +\u003d q2;\r\n    hash *\u003d MULT;\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    hash ^\u003d q3;\r\n    // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\r\n    hash +\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    hash ^\u003d (hash \u003c\u003c 9);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "findName",
    "signature": "java.lang.String findName(int[],int)",
    "visibility": "public",
    "body": "{\r\n    int offset \u003d _calcOffset(calcHash(q1, q2));\r\n    final int[] hashArea \u003d _hashArea;\r\n    int len \u003d hashArea[offset + 3];\r\n    if (len \u003d\u003d 2) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot; unlikely but avoid further lookups if so\r\n        return null;\r\n    }\r\n    // secondary?\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    len \u003d hashArea[offset2 + 3];\r\n    if (len \u003d\u003d 2) {\r\n        if ((q1 \u003d\u003d hashArea[offset2]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset2 + 1])) {\r\n            return _names[offset2 \u003e\u003e 2];\r\n        }\r\n    } else if (len \u003d\u003d 0) {\r\n        // empty slot? Short-circuit if no more spillovers\r\n        return null;\r\n    }\r\n    return _findSecondary(offset, q1, q2);\r\n}",
    "nodes": 17,
    "edges": 20,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 4) → B1 | else → B6",
      "B1 : If(switch-on i0) → B4 | else → B3",
      "B6 : If(i1 !\u003d $i5) → B7 | else → B10",
      "B7 : If(i4 !\u003d i0) → B8 | else → B10",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B10",
      "B10 : If(i4 !\u003d 0) → B11 | else → B12",
      "B12 : If(i1 !\u003d $i12) → B13 | else → B16",
      "B13 : If(i11 !\u003d i0) → B14 | else → B16",
      "B14 : If($z0 \u003d\u003d false) → B15 | else → B16"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  r1 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003e\u003d 4) goto B1 else B6\n}",
      "B1 {\n  tableswitch(i0) {     case 1: goto $i24 \u003d r1[0];     case 2: goto $i23 \u003d r1[0];     case 3: goto $i21 \u003d r1[0];     default: goto return \"\"; }\n}",
      "B2 {\n  $i21 \u003d r1[0]\n  $i20 \u003d r1[1]\n  $i19 \u003d r1[2]\n  $r7 \u003d r0.findName($i21, $i20, $i19)\n  return\n}",
      "B3 {\n  $i23 \u003d r1[0]\n  $i22 \u003d r1[1]\n  $r8 \u003d r0.findName($i23, $i22)\n  return\n}",
      "B4 {\n  $i24 \u003d r1[0]\n  $r9 \u003d r0.findName($i24)\n  return\n}",
      "B5 {\n  return\n}",
      "B6 {\n  i1 \u003d r0.calcHash(r1, i0)\n  i2 \u003d r0._calcOffset(i1)\n  r2 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i3 \u003d i2 + 3\n  i4 \u003d r2[$i3]\n  $i5 \u003d r2[i2]\n  if (i1 !\u003d $i5) goto B7 else B10\n}",
      "B7 {\n  if (i4 !\u003d i0) goto B8 else B10\n}",
      "B8 {\n  $i16 \u003d i2 + 1\n  $i17 \u003d r2[$i16]\n  $z1 \u003d r0._verifyLongName(r1, i0, $i17)\n  if ($z1 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r5 \u003d String[] _names\u003e\n  $i18 \u003d i2 \u003e\u003e 2\n  $r6 \u003d $r5[$i18]\n  return\n}",
      "B10 {\n  if (i4 !\u003d 0) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  $i8 \u003d ByteQuadsCanonicalizer: int _secondaryStart\u003e\n  $i6 \u003d i2 \u003e\u003e 3\n  $i7 \u003d $i6 \u003c\u003c 2\n  i9 \u003d $i8 + $i7\n  $i10 \u003d i9 + 3\n  i11 \u003d r2[$i10]\n  $i12 \u003d r2[i9]\n  if (i1 !\u003d $i12) goto B13 else B16\n}",
      "B13 {\n  if (i11 !\u003d i0) goto B14 else B16\n}",
      "B14 {\n  $i13 \u003d i9 + 1\n  $i14 \u003d r2[$i13]\n  $z0 \u003d r0._verifyLongName(r1, i0, $i14)\n  if ($z0 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $r3 \u003d String[] _names\u003e\n  $i15 \u003d i9 \u003e\u003e 2\n  $r4 \u003d $r3[$i15]\n  return\n}",
      "B16 {\n  $r10 \u003d r0._findSecondary(i2, i1, r1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B6",
      "B1 --\u003e B4",
      "B1 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B10",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findSecondary(...3)",
        "body": "{\r\n    int offset \u003d _tertiaryStart + ((origOffset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int[] hashArea \u003d _hashArea;\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset + bucketSize; offset \u003c end; offset +\u003d 4) {\r\n        int len \u003d hashArea[offset + 3];\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (2 \u003d\u003d len)) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n        if (len \u003d\u003d 0) {\r\n            return null;\r\n        }\r\n    }\r\n    for (offset \u003d _spilloverStart(); offset \u003c _spilloverEnd; offset +\u003d 4) {\r\n        if ((q1 \u003d\u003d hashArea[offset]) \u0026\u0026 (q2 \u003d\u003d hashArea[offset + 1]) \u0026\u0026 (2 \u003d\u003d hashArea[offset + 3])) {\r\n            return _names[offset \u003e\u003e 2];\r\n        }\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_calcOffset(...1)",
        "body": "{\r\n    // NOTE: simple for initial impl, but we may want to interleave it a bit\r\n    // in near future\r\n    // So: first, hash into primary hash index\r\n    int ix \u003d hash \u0026 (_hashSize - 1);\r\n    // keeping in mind we have 4 ints per entry\r\n    return (ix \u003c\u003c 2);\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...2)",
        "body": "{\r\n    // For two quads, let\u0027s change algorithm a bit, to spice\r\n    // things up (can do bit more processing anyway)\r\n    int hash \u003d q1;\r\n    // try mixing first and second byte pairs first\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    // as well as lowest 2 bytes\r\n    hash ^\u003d (hash \u003e\u003e\u003e 9);\r\n    // then add second quad\r\n    hash +\u003d (q2 * MULT);\r\n    hash ^\u003d _seed;\r\n    // and shuffle some more\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    hash ^\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003c\u003c 3);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "addName",
    "signature": "java.lang.String addName(java.lang.String,int)",
    "visibility": "public",
    "body": "{\r\n    _verifySharing();\r\n    if (_interner !\u003d null) {\r\n        name \u003d _interner.intern(name);\r\n    }\r\n    int offset \u003d _findOffsetForAdd(calcHash(q1));\r\n    _hashArea[offset] \u003d q1;\r\n    _hashArea[offset + 3] \u003d 1;\r\n    _names[offset \u003e\u003e 2] \u003d name;\r\n    ++_count;\r\n    return name;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  String\n  i0 :\u003d @parameter1: int\n  r0._verifySharing()\n  $r1 \u003d InternCache _interner\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d InternCache _interner\u003e\n  r6 \u003d $r5.intern(r6)\n}",
      "B2 {\n  $i1 \u003d r0.calcHash(i0)\n  $i6 \u003d r0._findOffsetForAdd($i1)\n  $r2 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $r2[$i6] \u003d i0\n  $r3 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i2 \u003d $i6 + 3\n  $r3[$i2] \u003d 1\n  $r4 \u003d String[] _names\u003e\n  $i3 \u003d $i6 \u003e\u003e 2\n  $r4[$i3] \u003d r6\n  $i4 \u003d ByteQuadsCanonicalizer: int _count\u003e\n  $i5 \u003d $i4 + 1\n  ByteQuadsCanonicalizer: int _count\u003e \u003d $i5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findOffsetForAdd(...1)",
        "body": "{\r\n    // first, check the primary: if slot found, no need for resize\r\n    int offset \u003d _calcOffset(hash);\r\n    final int[] hashArea \u003d _hashArea;\r\n    if (hashArea[offset + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset\u003e\u003e2), hash \u0026 0x7F);\r\n        return offset;\r\n    }\r\n    // Otherwise let\u0027s see if we are due resize():\r\n    if (_checkNeedForRehash()) {\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    // If not, proceed with secondary slot\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset \u003e\u003e 3), _secondaryStart, (hash \u0026 0x7F));\r\n        return offset2;\r\n    }\r\n    // if not, tertiary?\r\n    offset2 \u003d _tertiaryStart + ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset2 + bucketSize; offset2 \u003c end; offset2 +\u003d 4) {\r\n        if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n            //System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift), _tertiaryStart, (hash \u0026 0x7F));\r\n            return offset2;\r\n        }\r\n    }\r\n    // and if even tertiary full, append at the end of spill area\r\n    offset \u003d _spilloverEnd;\r\n    _spilloverEnd +\u003d 4;\r\n    //System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash \u0026 0x7F));\r\n    // one caveat: in the unlikely event if spill-over filling up,\r\n    // check if that could be considered a DoS attack; handle appropriately\r\n    // (NOTE: approximate for now; we could verify details if that becomes necessary)\r\n    /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\r\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\r\n         */\r\n    final int end \u003d (_hashSize \u003c\u003c 3);\r\n    if (_spilloverEnd \u003e\u003d end) {\r\n        if (_failOnDoS) {\r\n            _reportTooManyCollisions();\r\n        }\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    return offset;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...1)",
        "body": "{\r\n    int hash \u003d q1 ^ _seed;\r\n    /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\r\n         *    except for one specific problem case: numbers. So needed to make sure\r\n         *    that all 4 least-significant bits participate in hash. Couple of ways\r\n         *    to work it out, but this is the simplest, fast and seems to do ok.\r\n         */\r\n    // to xor hi- and low- 16-bits\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    // shuffle back a bit\r\n    hash ^\u003d (hash \u003c\u003c 3);\r\n    // and bit more\r\n    hash +\u003d (hash \u003e\u003e\u003e 12);\r\n    return hash;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_verifySharing(...0)",
        "body": "{\r\n    if (_hashShared) {\r\n        // 12-Mar-2021, tatu: prevent modifying of \"placeholder\" and\r\n        //   parent tables\r\n        if (_parent \u003d\u003d null) {\r\n            if (_count \u003d\u003d 0) {\r\n                // root\r\n                throw new IllegalStateException(\"Internal error: Cannot add names to Root symbol table\");\r\n            }\r\n            throw new IllegalStateException(\"Internal error: Cannot add names to Placeholder symbol table\");\r\n        }\r\n        _hashArea \u003d Arrays.copyOf(_hashArea, _hashArea.length);\r\n        _names \u003d Arrays.copyOf(_names, _names.length);\r\n        _hashShared \u003d false;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "addName",
    "signature": "java.lang.String addName(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifySharing();\r\n    if (_interner !\u003d null) {\r\n        name \u003d _interner.intern(name);\r\n    }\r\n    // 20-Mar-2021, tatu: For some reason, pre-2.13 there was logic\r\n    //    to support \"only one quad\" case. Not sure why, does not make sense;\r\n    //    removed from 2.13.0.\r\n    //        int hash \u003d (q2 \u003d\u003d 0) ? calcHash(q1) : calcHash(q1, q2);\r\n    final int hash \u003d calcHash(q1, q2);\r\n    final int offset \u003d _findOffsetForAdd(hash);\r\n    _hashArea[offset] \u003d q1;\r\n    _hashArea[offset + 1] \u003d q2;\r\n    _hashArea[offset + 3] \u003d 2;\r\n    _names[offset \u003e\u003e 2] \u003d name;\r\n    ++_count;\r\n    return name;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  r0._verifySharing()\n  $r1 \u003d InternCache _interner\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d InternCache _interner\u003e\n  r7 \u003d $r6.intern(r7)\n}",
      "B2 {\n  $i7 \u003d r0.calcHash(i0, i1)\n  $i8 \u003d r0._findOffsetForAdd($i7)\n  $r2 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $r2[$i8] \u003d i0\n  $r3 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i2 \u003d $i8 + 1\n  $r3[$i2] \u003d i1\n  $r4 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i3 \u003d $i8 + 3\n  $r4[$i3] \u003d 2\n  $r5 \u003d String[] _names\u003e\n  $i4 \u003d $i8 \u003e\u003e 2\n  $r5[$i4] \u003d r7\n  $i5 \u003d ByteQuadsCanonicalizer: int _count\u003e\n  $i6 \u003d $i5 + 1\n  ByteQuadsCanonicalizer: int _count\u003e \u003d $i6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findOffsetForAdd(...1)",
        "body": "{\r\n    // first, check the primary: if slot found, no need for resize\r\n    int offset \u003d _calcOffset(hash);\r\n    final int[] hashArea \u003d _hashArea;\r\n    if (hashArea[offset + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset\u003e\u003e2), hash \u0026 0x7F);\r\n        return offset;\r\n    }\r\n    // Otherwise let\u0027s see if we are due resize():\r\n    if (_checkNeedForRehash()) {\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    // If not, proceed with secondary slot\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset \u003e\u003e 3), _secondaryStart, (hash \u0026 0x7F));\r\n        return offset2;\r\n    }\r\n    // if not, tertiary?\r\n    offset2 \u003d _tertiaryStart + ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset2 + bucketSize; offset2 \u003c end; offset2 +\u003d 4) {\r\n        if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n            //System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift), _tertiaryStart, (hash \u0026 0x7F));\r\n            return offset2;\r\n        }\r\n    }\r\n    // and if even tertiary full, append at the end of spill area\r\n    offset \u003d _spilloverEnd;\r\n    _spilloverEnd +\u003d 4;\r\n    //System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash \u0026 0x7F));\r\n    // one caveat: in the unlikely event if spill-over filling up,\r\n    // check if that could be considered a DoS attack; handle appropriately\r\n    // (NOTE: approximate for now; we could verify details if that becomes necessary)\r\n    /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\r\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\r\n         */\r\n    final int end \u003d (_hashSize \u003c\u003c 3);\r\n    if (_spilloverEnd \u003e\u003d end) {\r\n        if (_failOnDoS) {\r\n            _reportTooManyCollisions();\r\n        }\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    return offset;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_verifySharing(...0)",
        "body": "{\r\n    if (_hashShared) {\r\n        // 12-Mar-2021, tatu: prevent modifying of \"placeholder\" and\r\n        //   parent tables\r\n        if (_parent \u003d\u003d null) {\r\n            if (_count \u003d\u003d 0) {\r\n                // root\r\n                throw new IllegalStateException(\"Internal error: Cannot add names to Root symbol table\");\r\n            }\r\n            throw new IllegalStateException(\"Internal error: Cannot add names to Placeholder symbol table\");\r\n        }\r\n        _hashArea \u003d Arrays.copyOf(_hashArea, _hashArea.length);\r\n        _names \u003d Arrays.copyOf(_names, _names.length);\r\n        _hashShared \u003d false;\r\n    }\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...2)",
        "body": "{\r\n    // For two quads, let\u0027s change algorithm a bit, to spice\r\n    // things up (can do bit more processing anyway)\r\n    int hash \u003d q1;\r\n    // try mixing first and second byte pairs first\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    // as well as lowest 2 bytes\r\n    hash ^\u003d (hash \u003e\u003e\u003e 9);\r\n    // then add second quad\r\n    hash +\u003d (q2 * MULT);\r\n    hash ^\u003d _seed;\r\n    // and shuffle some more\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    hash ^\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003c\u003c 3);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "addName",
    "signature": "java.lang.String addName(java.lang.String,int,int,int)",
    "visibility": "public",
    "body": "{\r\n    _verifySharing();\r\n    if (_interner !\u003d null) {\r\n        name \u003d _interner.intern(name);\r\n    }\r\n    int offset \u003d _findOffsetForAdd(calcHash(q1, q2, q3));\r\n    _hashArea[offset] \u003d q1;\r\n    _hashArea[offset + 1] \u003d q2;\r\n    _hashArea[offset + 2] \u003d q3;\r\n    _hashArea[offset + 3] \u003d 3;\r\n    _names[offset \u003e\u003e 2] \u003d name;\r\n    ++_count;\r\n    return name;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  i2 :\u003d @parameter3: int\n  r0._verifySharing()\n  $r1 \u003d InternCache _interner\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d InternCache _interner\u003e\n  r8 \u003d $r7.intern(r8)\n}",
      "B2 {\n  $i3 \u003d r0.calcHash(i0, i1, i2)\n  $i10 \u003d r0._findOffsetForAdd($i3)\n  $r2 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $r2[$i10] \u003d i0\n  $r3 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i4 \u003d $i10 + 1\n  $r3[$i4] \u003d i1\n  $r4 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i5 \u003d $i10 + 2\n  $r4[$i5] \u003d i2\n  $r5 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i6 \u003d $i10 + 3\n  $r5[$i6] \u003d 3\n  $r6 \u003d String[] _names\u003e\n  $i7 \u003d $i10 \u003e\u003e 2\n  $r6[$i7] \u003d r8\n  $i8 \u003d ByteQuadsCanonicalizer: int _count\u003e\n  $i9 \u003d $i8 + 1\n  ByteQuadsCanonicalizer: int _count\u003e \u003d $i9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findOffsetForAdd(...1)",
        "body": "{\r\n    // first, check the primary: if slot found, no need for resize\r\n    int offset \u003d _calcOffset(hash);\r\n    final int[] hashArea \u003d _hashArea;\r\n    if (hashArea[offset + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset\u003e\u003e2), hash \u0026 0x7F);\r\n        return offset;\r\n    }\r\n    // Otherwise let\u0027s see if we are due resize():\r\n    if (_checkNeedForRehash()) {\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    // If not, proceed with secondary slot\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset \u003e\u003e 3), _secondaryStart, (hash \u0026 0x7F));\r\n        return offset2;\r\n    }\r\n    // if not, tertiary?\r\n    offset2 \u003d _tertiaryStart + ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset2 + bucketSize; offset2 \u003c end; offset2 +\u003d 4) {\r\n        if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n            //System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift), _tertiaryStart, (hash \u0026 0x7F));\r\n            return offset2;\r\n        }\r\n    }\r\n    // and if even tertiary full, append at the end of spill area\r\n    offset \u003d _spilloverEnd;\r\n    _spilloverEnd +\u003d 4;\r\n    //System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash \u0026 0x7F));\r\n    // one caveat: in the unlikely event if spill-over filling up,\r\n    // check if that could be considered a DoS attack; handle appropriately\r\n    // (NOTE: approximate for now; we could verify details if that becomes necessary)\r\n    /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\r\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\r\n         */\r\n    final int end \u003d (_hashSize \u003c\u003c 3);\r\n    if (_spilloverEnd \u003e\u003d end) {\r\n        if (_failOnDoS) {\r\n            _reportTooManyCollisions();\r\n        }\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    return offset;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_verifySharing(...0)",
        "body": "{\r\n    if (_hashShared) {\r\n        // 12-Mar-2021, tatu: prevent modifying of \"placeholder\" and\r\n        //   parent tables\r\n        if (_parent \u003d\u003d null) {\r\n            if (_count \u003d\u003d 0) {\r\n                // root\r\n                throw new IllegalStateException(\"Internal error: Cannot add names to Root symbol table\");\r\n            }\r\n            throw new IllegalStateException(\"Internal error: Cannot add names to Placeholder symbol table\");\r\n        }\r\n        _hashArea \u003d Arrays.copyOf(_hashArea, _hashArea.length);\r\n        _names \u003d Arrays.copyOf(_names, _names.length);\r\n        _hashShared \u003d false;\r\n    }\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...3)",
        "body": "{\r\n    // use same algorithm as multi-byte, tested to work well\r\n    int hash \u003d q1 ^ _seed;\r\n    hash +\u003d (hash \u003e\u003e\u003e 9);\r\n    hash *\u003d MULT3;\r\n    hash +\u003d q2;\r\n    hash *\u003d MULT;\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    hash ^\u003d q3;\r\n    // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\r\n    hash +\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    hash ^\u003d (hash \u003c\u003c 9);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "addName",
    "signature": "java.lang.String addName(java.lang.String,int[],int)",
    "visibility": "public",
    "body": "{\r\n    _verifySharing();\r\n    if (_interner !\u003d null) {\r\n        name \u003d _interner.intern(name);\r\n    }\r\n    // 20-Mar-2021, tatu: For some reason, pre-2.13 there was logic\r\n    //    to support \"only one quad\" case. Not sure why, does not make sense;\r\n    //    removed from 2.13.0.\r\n    //        int hash \u003d (q2 \u003d\u003d 0) ? calcHash(q1) : calcHash(q1, q2);\r\n    final int hash \u003d calcHash(q1, q2);\r\n    final int offset \u003d _findOffsetForAdd(hash);\r\n    _hashArea[offset] \u003d q1;\r\n    _hashArea[offset + 1] \u003d q2;\r\n    _hashArea[offset + 3] \u003d 2;\r\n    _names[offset \u003e\u003e 2] \u003d name;\r\n    ++_count;\r\n    return name;\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(switch-on i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  String\n  r2 :\u003d @parameter1: int[]\n  i0 :\u003d @parameter2: int\n  r0._verifySharing()\n  $r1 \u003d InternCache _interner\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r15 \u003d InternCache _interner\u003e\n  r16 \u003d $r15.intern(r16)\n}",
      "B2 {\n  ByteQuadsCanonicalizer: int calcHash(int[],int)\u003e(r2, i0); }\n}",
      "B3 {\n  $i18 \u003d r2[0]\n  $i19 \u003d r0.calcHash($i18)\n  i26 \u003d r0._findOffsetForAdd($i19)\n  $r10 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i20 \u003d r2[0]\n  $r10[i26] \u003d $i20\n  $r11 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i21 \u003d i26 + 3\n  $r11[$i21] \u003d 1\n  goto B7\n}",
      "B4 {\n  $i12 \u003d r2[0]\n  $i11 \u003d r2[1]\n  $i13 \u003d r0.calcHash($i12, $i11)\n  i26 \u003d r0._findOffsetForAdd($i13)\n  $r7 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i14 \u003d r2[0]\n  $r7[i26] \u003d $i14\n  $r8 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i16 \u003d i26 + 1\n  $i15 \u003d r2[1]\n  $r8[$i16] \u003d $i15\n  $r9 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i17 \u003d i26 + 3\n  $r9[$i17] \u003d 2\n  goto B7\n}",
      "B5 {\n  $i3 \u003d r2[0]\n  $i2 \u003d r2[1]\n  $i1 \u003d r2[2]\n  $i4 \u003d r0.calcHash($i3, $i2, $i1)\n  i26 \u003d r0._findOffsetForAdd($i4)\n  $r3 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i5 \u003d r2[0]\n  $r3[i26] \u003d $i5\n  $r4 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i7 \u003d i26 + 1\n  $i6 \u003d r2[1]\n  $r4[$i7] \u003d $i6\n  $r5 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i9 \u003d i26 + 2\n  $i8 \u003d r2[2]\n  $r5[$i9] \u003d $i8\n  $r6 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i10 \u003d i26 + 3\n  $r6[$i10] \u003d 3\n  goto B7\n}",
      "B6 {\n  i22 \u003d r0.calcHash(r2, i0)\n  i26 \u003d r0._findOffsetForAdd(i22)\n  $r12 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $r12[i26] \u003d i22\n  i23 \u003d r0._appendLongName(r2, i0)\n  $r13 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i24 \u003d i26 + 1\n  $r13[$i24] \u003d i23\n  $r14 \u003d ByteQuadsCanonicalizer: int[] _hashArea\u003e\n  $i25 \u003d i26 + 3\n  $r14[$i25] \u003d i0\n}",
      "B7 {\n  $r17 \u003d String[] _names\u003e\n  $i27 \u003d i26 \u003e\u003e 2\n  $r17[$i27] \u003d r16\n  $i28 \u003d ByteQuadsCanonicalizer: int _count\u003e\n  $i29 \u003d $i28 + 1\n  ByteQuadsCanonicalizer: int _count\u003e \u003d $i29\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B2 --\u003e B6",
      "B3 --\u003e B7",
      "B4 --\u003e B7",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteQuadsCanonicalizer#_findOffsetForAdd(...1)",
        "body": "{\r\n    // first, check the primary: if slot found, no need for resize\r\n    int offset \u003d _calcOffset(hash);\r\n    final int[] hashArea \u003d _hashArea;\r\n    if (hashArea[offset + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset\u003e\u003e2), hash \u0026 0x7F);\r\n        return offset;\r\n    }\r\n    // Otherwise let\u0027s see if we are due resize():\r\n    if (_checkNeedForRehash()) {\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    // If not, proceed with secondary slot\r\n    int offset2 \u003d _secondaryStart + ((offset \u003e\u003e 3) \u003c\u003c 2);\r\n    if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n        //System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset \u003e\u003e 3), _secondaryStart, (hash \u0026 0x7F));\r\n        return offset2;\r\n    }\r\n    // if not, tertiary?\r\n    offset2 \u003d _tertiaryStart + ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift);\r\n    final int bucketSize \u003d (1 \u003c\u003c _tertiaryShift);\r\n    for (int end \u003d offset2 + bucketSize; offset2 \u003c end; offset2 +\u003d 4) {\r\n        if (hashArea[offset2 + 3] \u003d\u003d 0) {\r\n            //System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset \u003e\u003e (_tertiaryShift + 2)) \u003c\u003c _tertiaryShift), _tertiaryStart, (hash \u0026 0x7F));\r\n            return offset2;\r\n        }\r\n    }\r\n    // and if even tertiary full, append at the end of spill area\r\n    offset \u003d _spilloverEnd;\r\n    _spilloverEnd +\u003d 4;\r\n    //System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash \u0026 0x7F));\r\n    // one caveat: in the unlikely event if spill-over filling up,\r\n    // check if that could be considered a DoS attack; handle appropriately\r\n    // (NOTE: approximate for now; we could verify details if that becomes necessary)\r\n    /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\r\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\r\n         */\r\n    final int end \u003d (_hashSize \u003c\u003c 3);\r\n    if (_spilloverEnd \u003e\u003d end) {\r\n        if (_failOnDoS) {\r\n            _reportTooManyCollisions();\r\n        }\r\n        return _resizeAndFindOffsetForAdd(hash);\r\n    }\r\n    return offset;\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#_verifySharing(...0)",
        "body": "{\r\n    if (_hashShared) {\r\n        // 12-Mar-2021, tatu: prevent modifying of \"placeholder\" and\r\n        //   parent tables\r\n        if (_parent \u003d\u003d null) {\r\n            if (_count \u003d\u003d 0) {\r\n                // root\r\n                throw new IllegalStateException(\"Internal error: Cannot add names to Root symbol table\");\r\n            }\r\n            throw new IllegalStateException(\"Internal error: Cannot add names to Placeholder symbol table\");\r\n        }\r\n        _hashArea \u003d Arrays.copyOf(_hashArea, _hashArea.length);\r\n        _names \u003d Arrays.copyOf(_names, _names.length);\r\n        _hashShared \u003d false;\r\n    }\r\n}"
      },
      {
        "name": "ByteQuadsCanonicalizer#calcHash(...2)",
        "body": "{\r\n    // For two quads, let\u0027s change algorithm a bit, to spice\r\n    // things up (can do bit more processing anyway)\r\n    int hash \u003d q1;\r\n    // try mixing first and second byte pairs first\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    // as well as lowest 2 bytes\r\n    hash ^\u003d (hash \u003e\u003e\u003e 9);\r\n    // then add second quad\r\n    hash +\u003d (q2 * MULT);\r\n    hash ^\u003d _seed;\r\n    // and shuffle some more\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    hash ^\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003c\u003c 3);\r\n    return hash;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
    "methodName": "calcHash",
    "signature": "int calcHash(int[],int)",
    "visibility": "public",
    "body": "{\r\n    // For two quads, let\u0027s change algorithm a bit, to spice\r\n    // things up (can do bit more processing anyway)\r\n    int hash \u003d q1;\r\n    // try mixing first and second byte pairs first\r\n    hash +\u003d (hash \u003e\u003e\u003e 15);\r\n    // as well as lowest 2 bytes\r\n    hash ^\u003d (hash \u003e\u003e\u003e 9);\r\n    // then add second quad\r\n    hash +\u003d (q2 * MULT);\r\n    hash ^\u003d _seed;\r\n    // and shuffle some more\r\n    hash +\u003d (hash \u003e\u003e\u003e 16);\r\n    hash ^\u003d (hash \u003e\u003e\u003e 4);\r\n    hash +\u003d (hash \u003c\u003c 3);\r\n    return hash;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 4) → B1 | else → B2",
      "B3 : If(i18 \u003e\u003d i0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ByteQuadsCanonicalizer\n  r0 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  if (i0 \u003e\u003d 4) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"qlen is too short, needs to be at least 4\")\n  throw $r2\n}",
      "B2 {\n  $i2 \u003d r0[0]\n  $i1 \u003d ByteQuadsCanonicalizer: int _seed\u003e\n  i11 \u003d $i2 ^ $i1\n  $i3 \u003d i11 \u003e\u003e\u003e 9\n  i12 \u003d i11 + $i3\n  $i4 \u003d r0[1]\n  i13 \u003d i12 + $i4\n  $i5 \u003d i13 \u003e\u003e\u003e 15\n  i14 \u003d i13 + $i5\n  i15 \u003d i14 * 33\n  $i6 \u003d r0[2]\n  i16 \u003d i15 ^ $i6\n  $i7 \u003d i16 \u003e\u003e\u003e 4\n  i17 \u003d i16 + $i7\n  i18 \u003d 3\n}",
      "B3 {\n  if (i18 \u003e\u003d i0) goto B4 else B5\n}",
      "B4 {\n  i19 \u003d r0[i18]\n  $i10 \u003d i19 \u003e\u003e 21\n  i20 \u003d i19 ^ $i10\n  i17 \u003d i17 + i20\n  i18 \u003d i18 + 1\n  goto B3\n}",
      "B5 {\n  i21 \u003d i17 * 65599\n  $i8 \u003d i21 \u003e\u003e\u003e 19\n  i22 \u003d i21 + $i8\n  $i9 \u003d i22 \u003c\u003c 5\n  i23 \u003d i22 ^ $i9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "createRoot",
    "signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer createRoot(com.fasterxml.jackson.core.TokenStreamFactory,int)",
    "visibility": "public",
    "body": "{\r\n    // Need to use a variable seed, to thwart hash-collision based attacks.\r\n    // 14-Feb-2017, tatu: not sure it actually helps, at all, since it won\u0027t\r\n    //   change mixing or any of the steps. Should likely just remove in future.\r\n    if (seed \u003d\u003d 0) {\r\n        // 23-Aug-2023, tatu: Changed to use identity hash code instead of current time\r\n        seed \u003d System.identityHashCode(owner);\r\n    }\r\n    StreamReadConstraints src;\r\n    int factoryFeatures;\r\n    if (owner \u003d\u003d null) {\r\n        src \u003d StreamReadConstraints.defaults();\r\n        factoryFeatures \u003d 0;\r\n    } else {\r\n        src \u003d owner.streamReadConstraints();\r\n        factoryFeatures \u003d owner.getFactoryFeatures();\r\n    }\r\n    return new CharsToNameCanonicalizer(src, factoryFeatures, seed);\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(r0 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TokenStreamFactory\n  i0 :\u003d @parameter1: int\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i0 \u003d System.identityHashCode(r0)\n}",
      "B2 {\n  if (r0 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r2 \u003d StreamReadConstraints.defaults()\n  i1 \u003d 0\n  goto B5\n}",
      "B4 {\n  r2 \u003d r0.streamReadConstraints()\n  i1 \u003d r0.getFactoryFeatures()\n}",
      "B5 {\n  $r1 \u003d CharsToNameCanonicalizer\n  new CharsToNameCanonicalizer(r2, i1, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "release",
    "signature": "void release()",
    "visibility": "public",
    "body": "{\r\n    // If nothing has been added, nothing to do\r\n    if (!maybeDirty()) {\r\n        return;\r\n    }\r\n    // we will try to merge if child table has new entries\r\n    if (_parent !\u003d null \u0026\u0026 _canonicalize) {\r\n        // canonicalize set to false if max size was reached\r\n        _parent.mergeChild(new TableInfo(this));\r\n        // Let\u0027s also mark this instance as dirty, so that just in\r\n        // case release was too early, there\u0027s no corruption of possibly shared data.\r\n        _hashShared \u003d true;\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  $z0 \u003d r0.maybeDirty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d CharsToNameCanonicalizer _parent\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $z1 \u003d CharsToNameCanonicalizer: boolean _canonicalize\u003e\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r3 \u003d CharsToNameCanonicalizer _parent\u003e\n  $r2 \u003d CharsToNameCanonicalizer$TableInfo\n  new CharsToNameCanonicalizer$TableInfo(r0)\n  $r3.mergeChild($r2)\n  CharsToNameCanonicalizer: boolean _hashShared\u003e \u003d 1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CharsToNameCanonicalizer#maybeDirty(...0)",
        "body": "{\r\n    return !_hashShared;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "size",
    "signature": "int size()",
    "visibility": "public",
    "body": "{\r\n    if (_tableInfo !\u003d null) {\r\n        // root table\r\n        return _tableInfo.get().size;\r\n    }\r\n    // nope, child table\r\n    return _size;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  $r1 \u003d AtomicReference _tableInfo\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d AtomicReference _tableInfo\u003e\n  $r3 \u003d $r2.get()\n  $r4 \u003d CharsToNameCanonicalizer$TableInfo) $r3\n  $i1 \u003d CharsToNameCanonicalizer$TableInfo: int size\u003e\n  return\n}",
      "B2 {\n  $i0 \u003d CharsToNameCanonicalizer: int _size\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "maybeDirty",
    "signature": "boolean maybeDirty()",
    "visibility": "public",
    "body": "{\r\n    return !_hashShared;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  $z0 \u003d CharsToNameCanonicalizer: boolean _hashShared\u003e\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z1 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "collisionCount",
    "signature": "int collisionCount()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    for (Bucket bucket : _buckets) {\r\n        if (bucket !\u003d null) {\r\n            count +\u003d bucket.length;\r\n        }\r\n    }\r\n    return count;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i3 \u003e\u003d i0) → B2 | else → B5",
      "B2 : If(r2 \u003d\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  i2 \u003d 0\n  r1 \u003d CharsToNameCanonicalizer$Bucket[] _buckets\u003e\n  i0 \u003d lengthof r1\n  i3 \u003d 0\n}",
      "B1 {\n  if (i3 \u003e\u003d i0) goto B2 else B5\n}",
      "B2 {\n  r2 \u003d r1[i3]\n  if (r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $i1 \u003d CharsToNameCanonicalizer$Bucket: int length\u003e\n  i2 \u003d i2 + $i1\n}",
      "B4 {\n  i3 \u003d i3 + 1\n  goto B1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "findSymbol",
    "signature": "java.lang.String findSymbol(char[],int,int,int)",
    "visibility": "public",
    "body": "{\r\n    if (len \u003c 1) {\r\n        // empty Strings are simplest to handle up front\r\n        return \"\";\r\n    }\r\n    if (!_canonicalize) {\r\n        // [JACKSON-259]\r\n        _streamReadConstraints.validateNameLength(len);\r\n        return new String(buffer, start, len);\r\n    }\r\n    /* Related to problems with sub-standard hashing (somewhat\r\n         * relevant for collision attacks too), let\u0027s try little\r\n         * bit of shuffling to improve hash codes.\r\n         * (note, however, that this can\u0027t help with full collisions)\r\n         */\r\n    int index \u003d _hashToIndex(h);\r\n    String sym \u003d _symbols[index];\r\n    // Optimal case; checking existing primary symbol for hash index:\r\n    if (sym !\u003d null) {\r\n        // Let\u0027s inline primary String equality checking:\r\n        if (sym.length() \u003d\u003d len) {\r\n            int i \u003d 0;\r\n            while (sym.charAt(i) \u003d\u003d buffer[start + i]) {\r\n                // Optimal case; primary match found\r\n                if (++i \u003d\u003d len) {\r\n                    return sym;\r\n                }\r\n            }\r\n        }\r\n        Bucket b \u003d _buckets[index \u003e\u003e 1];\r\n        if (b !\u003d null) {\r\n            sym \u003d b.has(buffer, start, len);\r\n            if (sym !\u003d null) {\r\n                return sym;\r\n            }\r\n            sym \u003d _findSymbol2(buffer, start, len, b.next);\r\n            if (sym !\u003d null) {\r\n                return sym;\r\n            }\r\n        }\r\n    }\r\n    _streamReadConstraints.validateNameLength(len);\r\n    return _addSymbol(buffer, start, len, h, index);\r\n}",
    "nodes": 16,
    "edges": 19,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 1) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B4",
      "B4 : If(r8 \u003d\u003d null) → B5 | else → B15",
      "B5 : If($i4 !\u003d i0) → B6 | else → B10",
      "B7 : If($i10 !\u003d $i11) → B8 | else → B10",
      "B8 : If(i9 !\u003d i0) → B9 | else → B7",
      "B10 : If($r5 \u003d\u003d null) → B11 | else → B15",
      "B11 : If(r9 \u003d\u003d null) → B12 | else → B13",
      "B13 : If(r10 \u003d\u003d null) → B14 | else → B15"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  r2 :\u003d @parameter0: char[]\n  i3 :\u003d @parameter1: int\n  i0 :\u003d @parameter2: int\n  i1 :\u003d @parameter3: int\n  if (i0 \u003e\u003d 1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d CharsToNameCanonicalizer: boolean _canonicalize\u003e\n  if ($z0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  $r6.validateNameLength(i0)\n  $r13 \u003d String\n  new String(r2, i3, i0)\n  return\n}",
      "B4 {\n  i2 \u003d r0._hashToIndex(i1)\n  $r1 \u003d String[] _symbols\u003e\n  r8 \u003d $r1[i2]\n  if (r8 \u003d\u003d null) goto B5 else B15\n}",
      "B5 {\n  $i4 \u003d r8.length()\n  if ($i4 !\u003d i0) goto B6 else B10\n}",
      "B6 {\n  i9 \u003d 0\n}",
      "B7 {\n  $c8 \u003d r8.charAt(i9)\n  $i6 \u003d i3 + i9\n  $c7 \u003d r2[$i6]\n  $i10 \u003d (int) $c8\n  $i11 \u003d (int) $c7\n  if ($i10 !\u003d $i11) goto B8 else B10\n}",
      "B8 {\n  i9 \u003d i9 + 1\n  if (i9 !\u003d i0) goto B9 else B7\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r3 \u003d CharsToNameCanonicalizer$Bucket[] _buckets\u003e\n  $i5 \u003d i2 \u003e\u003e 1\n  $r5 \u003d $r3[$i5]\n  if ($r5 \u003d\u003d null) goto B11 else B15\n}",
      "B11 {\n  r9 \u003d $r5.has(r2, i3, i0)\n  if (r9 \u003d\u003d null) goto B12 else B13\n}",
      "B12 {\n  return\n}",
      "B13 {\n  $r4 \u003d CharsToNameCanonicalizer$Bucket next\u003e\n  r10 \u003d r0._findSymbol2(r2, i3, i0, $r4)\n  if (r10 \u003d\u003d null) goto B14 else B15\n}",
      "B14 {\n  return\n}",
      "B15 {\n  $r11 \u003d StreamReadConstraints _streamReadConstraints\u003e\n  $r11.validateNameLength(i0)\n  $r12 \u003d r0._addSymbol(r2, i3, i0, i1, i2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B15",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B15",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "CharsToNameCanonicalizer#_findSymbol2(...4)",
        "body": "{\r\n    while (b !\u003d null) {\r\n        String sym \u003d b.has(buffer, start, len);\r\n        if (sym !\u003d null) {\r\n            return sym;\r\n        }\r\n        b \u003d b.next;\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "CharsToNameCanonicalizer#_hashToIndex(...1)",
        "body": "{\r\n    // doing these seems to help a bit\r\n    rawHash +\u003d (rawHash \u003e\u003e\u003e 15);\r\n    rawHash ^\u003d (rawHash \u003c\u003c 7);\r\n    rawHash +\u003d (rawHash \u003e\u003e\u003e 3);\r\n    return (rawHash \u0026 _indexMask);\r\n}"
      },
      {
        "name": "CharsToNameCanonicalizer#_addSymbol(...5)",
        "body": "{\r\n    if (_hashShared) {\r\n        //need to do copy-on-write?\r\n        copyArrays();\r\n        _hashShared \u003d false;\r\n    } else if (_size \u003e\u003d _sizeThreshold) {\r\n        // Need to expand?\r\n        rehash();\r\n        // Need to recalc hash; rare occurrence (index mask has been\r\n        // recalculated as part of rehash)\r\n        index \u003d _hashToIndex(calcHash(buffer, start, len));\r\n    }\r\n    String newSymbol \u003d new String(buffer, start, len);\r\n    if (JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(_factoryFeatures)) {\r\n        newSymbol \u003d InternCache.instance.intern(newSymbol);\r\n    }\r\n    ++_size;\r\n    // Ok; do we need to add primary entry, or a bucket?\r\n    if (_symbols[index] \u003d\u003d null) {\r\n        _symbols[index] \u003d newSymbol;\r\n    } else {\r\n        final int bix \u003d (index \u003e\u003e 1);\r\n        Bucket newB \u003d new Bucket(newSymbol, _buckets[bix]);\r\n        int collLen \u003d newB.length;\r\n        if (collLen \u003e MAX_COLL_CHAIN_LENGTH) {\r\n            // 23-May-2014, tatu: Instead of throwing an exception right away,\r\n            //    let\u0027s handle in bit smarter way.\r\n            _handleSpillOverflow(bix, newB, index);\r\n        } else {\r\n            _buckets[bix] \u003d newB;\r\n            _longestCollisionList \u003d Math.max(collLen, _longestCollisionList);\r\n        }\r\n    }\r\n    return newSymbol;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "calcHash",
    "signature": "int calcHash(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    int hash \u003d _seed;\r\n    for (int i \u003d start, end \u003d start + len; i \u003c end; ++i) {\r\n        hash \u003d (hash * HASH_MULT) + buffer[i];\r\n    }\r\n    // NOTE: shuffling, if any, is done in \u0027findSymbol()\u0027, not here:\r\n    return (hash \u003d\u003d 0) ? 1 : hash;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i6 \u003e\u003d i2) → B2 | else → B3",
      "B3 : If(i5 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  i5 \u003d CharsToNameCanonicalizer: int _seed\u003e\n  i6 \u003d i0\n  i2 \u003d i0 + i1\n}",
      "B1 {\n  if (i6 \u003e\u003d i2) goto B2 else B3\n}",
      "B2 {\n  $i4 \u003d i5 * 33\n  $c3 \u003d r1[i6]\n  $i8 \u003d (int) $c3\n  i5 \u003d $i4 + $i8\n  i6 \u003d i6 + 1\n  goto B1\n}",
      "B3 {\n  if (i5 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i7 \u003d 1\n  goto B6\n}",
      "B5 {\n  $i7 \u003d i5\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer",
    "methodName": "calcHash",
    "signature": "int calcHash(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    final int len \u003d key.length();\r\n    int hash \u003d _seed;\r\n    for (int i \u003d 0; i \u003c len; ++i) {\r\n        hash \u003d (hash * HASH_MULT) + key.charAt(i);\r\n    }\r\n    // NOTE: shuffling, if any, is done in \u0027findSymbol()\u0027, not here:\r\n    return (hash \u003d\u003d 0) ? 1 : hash;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i0) → B2 | else → B3",
      "B3 : If(i3 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  CharsToNameCanonicalizer\n  String\n  i0 \u003d r0.length()\n  i3 \u003d CharsToNameCanonicalizer: int _seed\u003e\n  i4 \u003d 0\n}",
      "B1 {\n  if (i4 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  $i2 \u003d i3 * 33\n  $c1 \u003d r0.charAt(i4)\n  $i6 \u003d (int) $c1\n  i3 \u003d $i2 + $i6\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B3 {\n  if (i3 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $i5 \u003d 1\n  goto B6\n}",
      "B5 {\n  $i5 \u003d i3\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name1",
    "methodName": "equals",
    "signature": "boolean equals(int)",
    "visibility": "public",
    "body": "{\r\n    return (quad \u003d\u003d q);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Name1\n  i0 :\u003d @parameter0: int\n  $i1 \u003d Name1: int q\u003e\n  if (i0 !\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name1",
    "methodName": "equals",
    "signature": "boolean equals(int,int)",
    "visibility": "public",
    "body": "{\r\n    return (quad1 \u003d\u003d q) \u0026\u0026 (quad2 \u003d\u003d 0);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B3",
      "B1 : If(i2 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Name1\n  i0 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  $i1 \u003d Name1: int q\u003e\n  if (i0 !\u003d $i1) goto B1 else B3\n}",
      "B1 {\n  if (i2 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name1",
    "methodName": "equals",
    "signature": "boolean equals(int[],int)",
    "visibility": "public",
    "body": "{\r\n    return (quad1 \u003d\u003d q) \u0026\u0026 (quad2 \u003d\u003d 0);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d 1) → B1 | else → B3",
      "B1 : If($i2 !\u003d $i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Name1\n  r0 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  if (i0 !\u003d 1) goto B1 else B3\n}",
      "B1 {\n  $i2 \u003d r0[0]\n  $i1 \u003d Name1: int q\u003e\n  if ($i2 !\u003d $i1) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name2",
    "methodName": "equals",
    "signature": "boolean equals(int,int)",
    "visibility": "public",
    "body": "{\r\n    return (quad1 \u003d\u003d q1) \u0026\u0026 (quad2 \u003d\u003d q2);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 !\u003d $i1) → B1 | else → B3",
      "B1 : If(i2 !\u003d $i3) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Name2\n  i0 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  $i1 \u003d Name2: int q1\u003e\n  if (i0 !\u003d $i1) goto B1 else B3\n}",
      "B1 {\n  $i3 \u003d Name2: int q2\u003e\n  if (i2 !\u003d $i3) goto B2 else B3\n}",
      "B2 {\n  $z0 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z0 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name2",
    "methodName": "equals",
    "signature": "boolean equals(int[],int)",
    "visibility": "public",
    "body": "{\r\n    return (quad1 \u003d\u003d q1) \u0026\u0026 (quad2 \u003d\u003d q2);\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 !\u003d 2) → B1 | else → B4",
      "B1 : If($i2 !\u003d $i1) → B2 | else → B4",
      "B2 : If($i4 !\u003d $i3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Name2\n  r0 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  if (i0 !\u003d 2) goto B1 else B4\n}",
      "B1 {\n  $i2 \u003d r0[0]\n  $i1 \u003d Name2: int q1\u003e\n  if ($i2 !\u003d $i1) goto B2 else B4\n}",
      "B2 {\n  $i4 \u003d r0[1]\n  $i3 \u003d Name2: int q2\u003e\n  if ($i4 !\u003d $i3) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name3",
    "methodName": "equals",
    "signature": "boolean equals(int,int,int)",
    "visibility": "public",
    "body": "{\r\n    return (q1 \u003d\u003d quad1) \u0026\u0026 (q2 \u003d\u003d quad2) \u0026\u0026 (q3 \u003d\u003d quad3);\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i1 !\u003d i0) → B1 | else → B4",
      "B1 : If($i3 !\u003d i2) → B2 | else → B4",
      "B2 : If($i5 !\u003d i4) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Name3\n  i0 :\u003d @parameter0: int\n  i2 :\u003d @parameter1: int\n  i4 :\u003d @parameter2: int\n  $i1 \u003d Name3: int q1\u003e\n  if ($i1 !\u003d i0) goto B1 else B4\n}",
      "B1 {\n  $i3 \u003d Name3: int q2\u003e\n  if ($i3 !\u003d i2) goto B2 else B4\n}",
      "B2 {\n  $i5 \u003d Name3: int q3\u003e\n  if ($i5 !\u003d i4) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.Name3",
    "methodName": "equals",
    "signature": "boolean equals(int[],int)",
    "visibility": "public",
    "body": "{\r\n    return false;\r\n}",
    "nodes": 7,
    "edges": 10,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 !\u003d 3) → B1 | else → B5",
      "B1 : If($i2 !\u003d $i1) → B2 | else → B5",
      "B2 : If($i4 !\u003d $i3) → B3 | else → B5",
      "B3 : If($i6 !\u003d $i5) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Name3\n  r0 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  if (i0 !\u003d 3) goto B1 else B5\n}",
      "B1 {\n  $i2 \u003d r0[0]\n  $i1 \u003d Name3: int q1\u003e\n  if ($i2 !\u003d $i1) goto B2 else B5\n}",
      "B2 {\n  $i4 \u003d r0[1]\n  $i3 \u003d Name3: int q2\u003e\n  if ($i4 !\u003d $i3) goto B3 else B5\n}",
      "B3 {\n  $i6 \u003d r0[2]\n  $i5 \u003d Name3: int q3\u003e\n  if ($i6 !\u003d $i5) goto B4 else B5\n}",
      "B4 {\n  $z0 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z0 \u003d 0\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.NameN",
    "methodName": "construct",
    "signature": "com.fasterxml.jackson.core.sym.NameN construct(java.lang.String,int,int[],int)",
    "visibility": "public",
    "body": "{\r\n    /* We have specialized implementations for shorter\r\n         * names, so let\u0027s not allow runt instances here\r\n         */\r\n    if (qlen \u003c 4) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    int q1 \u003d q[0];\r\n    int q2 \u003d q[1];\r\n    int q3 \u003d q[2];\r\n    int q4 \u003d q[3];\r\n    int rem \u003d qlen - 4;\r\n    int[] buf;\r\n    if (rem \u003e 0) {\r\n        buf \u003d Arrays.copyOfRange(q, 4, qlen);\r\n    } else {\r\n        buf \u003d null;\r\n    }\r\n    return new NameN(name, hash, q1, q2, q3, q4, buf, qlen);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 \u003e\u003d 4) → B1 | else → B2",
      "B2 : If(i5 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  String\n  i6 :\u003d @parameter1: int\n  r0 :\u003d @parameter2: int[]\n  i0 :\u003d @parameter3: int\n  if (i0 \u003e\u003d 4) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalArgumentException\n  new IllegalArgumentException()\n  throw $r3\n}",
      "B2 {\n  i1 \u003d r0[0]\n  i2 \u003d r0[1]\n  i3 \u003d r0[2]\n  i4 \u003d r0[3]\n  i5 \u003d i0 - 4\n  if (i5 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  r4 \u003d Arrays.copyOfRange(r0, 4, i0)\n  goto B5\n}",
      "B4 {\n  r4 \u003d null\n}",
      "B5 {\n  $r1 \u003d NameN\n  new NameN(r2, i6, i1, i2, i3, i4, r4, i0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.sym.NameN",
    "methodName": "equals",
    "signature": "boolean equals(int[],int)",
    "visibility": "public",
    "body": "{\r\n    return false;\r\n}",
    "nodes": 21,
    "edges": 24,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 \u003d\u003d $i1) → B1 | else → B2",
      "B2 : If($i3 \u003d\u003d $i2) → B3 | else → B4",
      "B4 : If($i5 \u003d\u003d $i4) → B5 | else → B6",
      "B6 : If($i7 \u003d\u003d $i6) → B7 | else → B8",
      "B8 : If($i9 \u003d\u003d $i8) → B9 | else → B10",
      "B10 : If(switch-on i0) → B20 | else → B18",
      "B12 : If($i11 \u003d\u003d $i10) → B13 | else → B14",
      "B14 : If($i13 \u003d\u003d $i12) → B15 | else → B16",
      "B16 : If($i15 \u003d\u003d $i14) → B17 | else → B18",
      "B18 : If($i17 \u003d\u003d $i16) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  NameN\n  r1 :\u003d @parameter0: int[]\n  i0 :\u003d @parameter1: int\n  $i1 \u003d NameN: int qlen\u003e\n  if (i0 \u003d\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i3 \u003d r1[0]\n  $i2 \u003d NameN: int q1\u003e\n  if ($i3 \u003d\u003d $i2) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $i5 \u003d r1[1]\n  $i4 \u003d NameN: int q2\u003e\n  if ($i5 \u003d\u003d $i4) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $i7 \u003d r1[2]\n  $i6 \u003d NameN: int q3\u003e\n  if ($i7 \u003d\u003d $i6) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $i9 \u003d r1[3]\n  $i8 \u003d NameN: int q4\u003e\n  if ($i9 \u003d\u003d $i8) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  NameN: boolean _equals2(int[])\u003e(r1); }\n}",
      "B11 {\n  $z0 \u003d r0._equals2(r1)\n  return\n}",
      "B12 {\n  $i11 \u003d r1[7]\n  $r2 \u003d NameN: int[] q\u003e\n  $i10 \u003d $r2[3]\n  if ($i11 \u003d\u003d $i10) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $i13 \u003d r1[6]\n  $r3 \u003d NameN: int[] q\u003e\n  $i12 \u003d $r3[2]\n  if ($i13 \u003d\u003d $i12) goto B15 else B16\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $i15 \u003d r1[5]\n  $r4 \u003d NameN: int[] q\u003e\n  $i14 \u003d $r4[1]\n  if ($i15 \u003d\u003d $i14) goto B17 else B18\n}",
      "B17 {\n  return\n}",
      "B18 {\n  $i17 \u003d r1[4]\n  $r5 \u003d NameN: int[] q\u003e\n  $i16 \u003d $r5[0]\n  if ($i17 \u003d\u003d $i16) goto B19 else B20\n}",
      "B19 {\n  return\n}",
      "B20 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B20",
      "B10 --\u003e B18",
      "B10 --\u003e B16",
      "B10 --\u003e B14",
      "B10 --\u003e B12",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "isLinkedWithPool",
    "signature": "boolean isLinkedWithPool()",
    "visibility": "public",
    "body": "{\r\n    return _pool !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  $r1 \u003d RecyclerPool _pool\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "allocByteBuffer",
    "signature": "byte[] allocByteBuffer(int,int)",
    "visibility": "public",
    "body": "{\r\n    final int DEF_SIZE \u003d byteBufferLength(ix);\r\n    if (minSize \u003c DEF_SIZE) {\r\n        minSize \u003d DEF_SIZE;\r\n    }\r\n    byte[] buffer \u003d _byteBuffers.getAndSet(ix, null);\r\n    if (buffer \u003d\u003d null || buffer.length \u003c minSize) {\r\n        buffer \u003d balloc(minSize);\r\n    }\r\n    return buffer;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i3 \u003e\u003d i1) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($i2 \u003e\u003d i3) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  i0 :\u003d @parameter0: int\n  i3 :\u003d @parameter1: int\n  i1 \u003d r0.byteBufferLength(i0)\n  if (i3 \u003e\u003d i1) goto B1 else B2\n}",
      "B1 {\n  i3 \u003d i1\n}",
      "B2 {\n  $r1 \u003d AtomicReferenceArray _byteBuffers\u003e\n  $r2 \u003d $r1.getAndSet(i0, null)\n  $r3 \u003d (byte[]) $r2\n  r4 \u003d $r3\n  if ($r3 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $i2 \u003d lengthof $r3\n  if ($i2 \u003e\u003d i3) goto B4 else B5\n}",
      "B4 {\n  r4 \u003d r0.balloc(i3)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BufferRecycler#balloc(...1)",
        "body": "{\r\n    return new byte[size];\r\n}"
      },
      {
        "name": "BufferRecycler#byteBufferLength(...1)",
        "body": "{\r\n    return BYTE_BUFFER_LENGTHS[ix];\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "releaseByteBuffer",
    "signature": "void releaseByteBuffer(int,byte[])",
    "visibility": "public",
    "body": "{\r\n    // 13-Jan-2024, tatu: [core#1186] Replace only if beneficial:\r\n    byte[] oldBuffer \u003d _byteBuffers.get(ix);\r\n    if ((oldBuffer \u003d\u003d null) || buffer.length \u003e oldBuffer.length) {\r\n        // Could use CAS, but should not really matter\r\n        _byteBuffers.set(ix, buffer);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i2 \u003c\u003d $i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  i0 :\u003d @parameter0: int\n  r4 :\u003d @parameter1: byte[]\n  $r1 \u003d AtomicReferenceArray _byteBuffers\u003e\n  $r2 \u003d $r1.get(i0)\n  r3 \u003d (byte[]) $r2\n  if (r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d lengthof r4\n  $i1 \u003d lengthof r3\n  if ($i2 \u003c\u003d $i1) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d AtomicReferenceArray _byteBuffers\u003e\n  $r5.set(i0, r4)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "allocCharBuffer",
    "signature": "char[] allocCharBuffer(int,int)",
    "visibility": "public",
    "body": "{\r\n    final int DEF_SIZE \u003d charBufferLength(ix);\r\n    if (minSize \u003c DEF_SIZE) {\r\n        minSize \u003d DEF_SIZE;\r\n    }\r\n    char[] buffer \u003d _charBuffers.getAndSet(ix, null);\r\n    if (buffer \u003d\u003d null || buffer.length \u003c minSize) {\r\n        buffer \u003d calloc(minSize);\r\n    }\r\n    return buffer;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i3 \u003e\u003d i1) → B1 | else → B2",
      "B2 : If($r3 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($i2 \u003e\u003d i3) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  i0 :\u003d @parameter0: int\n  i3 :\u003d @parameter1: int\n  i1 \u003d r0.charBufferLength(i0)\n  if (i3 \u003e\u003d i1) goto B1 else B2\n}",
      "B1 {\n  i3 \u003d i1\n}",
      "B2 {\n  $r1 \u003d AtomicReferenceArray _charBuffers\u003e\n  $r2 \u003d $r1.getAndSet(i0, null)\n  $r3 \u003d (char[]) $r2\n  r4 \u003d $r3\n  if ($r3 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $i2 \u003d lengthof $r3\n  if ($i2 \u003e\u003d i3) goto B4 else B5\n}",
      "B4 {\n  r4 \u003d r0.calloc(i3)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "BufferRecycler#calloc(...1)",
        "body": "{\r\n    return new char[size];\r\n}"
      },
      {
        "name": "BufferRecycler#charBufferLength(...1)",
        "body": "{\r\n    return CHAR_BUFFER_LENGTHS[ix];\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "releaseCharBuffer",
    "signature": "void releaseCharBuffer(int,char[])",
    "visibility": "public",
    "body": "{\r\n    // 13-Jan-2024, tatu: [core#1186] Replace only if beneficial:\r\n    char[] oldBuffer \u003d _charBuffers.get(ix);\r\n    if ((oldBuffer \u003d\u003d null) || buffer.length \u003e oldBuffer.length) {\r\n        // Could use CAS, but should not really matter\r\n        _charBuffers.set(ix, buffer);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r3 \u003d\u003d null) → B1 | else → B2",
      "B1 : If($i2 \u003c\u003d $i1) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  i0 :\u003d @parameter0: int\n  r4 :\u003d @parameter1: char[]\n  $r1 \u003d AtomicReferenceArray _charBuffers\u003e\n  $r2 \u003d $r1.get(i0)\n  r3 \u003d (char[]) $r2\n  if (r3 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d lengthof r4\n  $i1 \u003d lengthof r3\n  if ($i2 \u003c\u003d $i1) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d AtomicReferenceArray _charBuffers\u003e\n  $r5.set(i0, r4)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "withPool",
    "signature": "com.fasterxml.jackson.core.util.BufferRecycler withPool(com.fasterxml.jackson.core.util.RecyclerPool)",
    "visibility": "public",
    "body": "{\r\n    if (_pool !\u003d null) {\r\n        throw new IllegalStateException(\"BufferRecycler already linked to pool: \" + pool);\r\n    }\r\n    // assign to pool to which this BufferRecycler belongs in order to release it\r\n    // to the same pool when the work will be completed\r\n    _pool \u003d Objects.requireNonNull(pool);\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  RecyclerPool\n  $r1 \u003d RecyclerPool _pool\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d IllegalStateException\n  $r6 \u003d String.valueOf(r2)\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6)\n  new IllegalStateException($r7)\n  throw $r5\n}",
      "B2 {\n  $r3 \u003d Objects.requireNonNull(r2)\n  $r4 \u003d RecyclerPool) $r3\n  RecyclerPool _pool\u003e \u003d $r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecycler",
    "methodName": "releaseToPool",
    "signature": "void releaseToPool()",
    "visibility": "public",
    "body": "{\r\n    if (_pool !\u003d null) {\r\n        RecyclerPool\u003cBufferRecycler\u003e tmpPool \u003d _pool;\r\n        // nullify the reference to the pool in order to avoid the risk of releasing\r\n        // the same BufferRecycler more than once, thus compromising the pool integrity\r\n        _pool \u003d null;\r\n        tmpPool.releasePooled(this);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  BufferRecycler\n  $r1 \u003d RecyclerPool _pool\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  r2 \u003d RecyclerPool _pool\u003e\n  RecyclerPool _pool\u003e \u003d null\n  r2.releasePooled(r0)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecyclers",
    "methodName": "getBufferRecycler",
    "signature": "com.fasterxml.jackson.core.util.BufferRecycler getBufferRecycler()",
    "visibility": "public",
    "body": "{\r\n    SoftReference\u003cBufferRecycler\u003e ref \u003d _recyclerRef.get();\r\n    BufferRecycler br \u003d (ref \u003d\u003d null) ? null : ref.get();\r\n    if (br \u003d\u003d null) {\r\n        br \u003d new BufferRecycler();\r\n        if (_bufferRecyclerTracker !\u003d null) {\r\n            ref \u003d _bufferRecyclerTracker.wrapAndTrack(br);\r\n        } else {\r\n            ref \u003d new SoftReference\u003c\u003e(br);\r\n        }\r\n        _recyclerRef.set(ref);\r\n    }\r\n    return br;\r\n}",
    "nodes": 9,
    "edges": 11,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r8 !\u003d null) → B1 | else → B2",
      "B3 : If($r9 !\u003d null) → B4 | else → B8",
      "B4 : If($r4 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d ThreadLocal _recyclerRef\u003e\n  $r1 \u003d $r0.get()\n  r8 \u003d SoftReference) $r1\n  if (r8 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d null\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r8.get()\n  $r9 \u003d BufferRecycler) $r2\n}",
      "B3 {\n  r10 \u003d $r9\n  if ($r9 !\u003d null) goto B4 else B8\n}",
      "B4 {\n  $r3 \u003d BufferRecycler\n  new BufferRecycler()\n  r10 \u003d $r3\n  $r4 \u003d ThreadLocalBufferManager _bufferRecyclerTracker\u003e\n  if ($r4 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d ThreadLocalBufferManager _bufferRecyclerTracker\u003e\n  r11 \u003d $r7.wrapAndTrack($r3)\n  goto B7\n}",
      "B6 {\n  $r5 \u003d SoftReference\n  new SoftReference($r3)\n  r11 \u003d $r5\n}",
      "B7 {\n  $r6 \u003d ThreadLocal _recyclerRef\u003e\n  $r6.set(r11)\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.BufferRecyclers",
    "methodName": "releaseBuffers",
    "signature": "int releaseBuffers()",
    "visibility": "public",
    "body": "{\r\n    if (_bufferRecyclerTracker !\u003d null) {\r\n        return _bufferRecyclerTracker.releaseBuffers();\r\n    }\r\n    return -1;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $r0 \u003d ThreadLocalBufferManager _bufferRecyclerTracker\u003e\n  if ($r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d ThreadLocalBufferManager _bufferRecyclerTracker\u003e\n  $i0 \u003d $r1.releaseBuffers()\n  return\n}",
      "B2 {\n  $i2 \u003d (int) -1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "reset",
    "signature": "void reset()",
    "visibility": "public",
    "body": "{\r\n    _pastLen \u003d 0;\r\n    _currBlockPtr \u003d 0;\r\n    if (!_pastBlocks.isEmpty()) {\r\n        _pastBlocks.clear();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  ByteArrayBuilder: int _pastLen\u003e \u003d 0\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d 0\n  $r1 \u003d LinkedList _pastBlocks\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d LinkedList _pastBlocks\u003e\n  $r2.clear()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "release",
    "signature": "void release()",
    "visibility": "public",
    "body": "{\r\n    reset();\r\n    if (_bufferRecycler !\u003d null \u0026\u0026 _currBlock !\u003d null) {\r\n        _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_CONCAT_BUFFER, _currBlock);\r\n        _currBlock \u003d null;\r\n    }\r\n}",
    "nodes": 4,
    "edges": 5,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($r2 \u003d\u003d null) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  r0.reset()\n  $r1 \u003d BufferRecycler _bufferRecycler\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  if ($r2 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r4 \u003d BufferRecycler _bufferRecycler\u003e\n  $r3 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $r4.releaseByteBuffer(2, $r3)\n  ByteArrayBuilder: byte[] _currBlock\u003e \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#reset(...0)",
        "body": "{\r\n    _pastLen \u003d 0;\r\n    _currBlockPtr \u003d 0;\r\n    if (!_pastBlocks.isEmpty()) {\r\n        _pastBlocks.clear();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "append",
    "signature": "void append(int)",
    "visibility": "public",
    "body": "{\r\n    if (_currBlockPtr \u003e\u003d _currBlock.length) {\r\n        _allocMore();\r\n    }\r\n    _currBlock[_currBlockPtr++] \u003d (byte) i;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003c $i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  i4 :\u003d @parameter0: int\n  $i1 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $r1 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i0 \u003d lengthof $r1\n  if ($i1 \u003c $i0) goto B1 else B2\n}",
      "B1 {\n  r0._allocMore()\n}",
      "B2 {\n  $r2 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i2 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i3 \u003d $i2 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i3\n  $b5 \u003d (byte) i4\n  $r2[$i2] \u003d $b5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#_allocMore(...0)",
        "body": "{\r\n    final int newPastLen \u003d _pastLen + _currBlock.length;\r\n    // 13-Feb-2016, tatu: As per [core#351] let\u0027s try to catch problem earlier;\r\n    //     for now we are strongly limited by 2GB limit of Java arrays\r\n    if (newPastLen \u003c 0) {\r\n        throw new IllegalStateException(\"Maximum Java array size (2GB) exceeded by `ByteArrayBuilder`\");\r\n    }\r\n    _pastLen \u003d newPastLen;\r\n    /* Let\u0027s allocate block that\u0027s half the total size, except\r\n         * never smaller than twice the initial block size.\r\n         * The idea is just to grow with reasonable rate, to optimize\r\n         * between minimal number of chunks and minimal amount of\r\n         * wasted space.\r\n         */\r\n    int newSize \u003d Math.max((_pastLen \u003e\u003e 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE));\r\n    // plus not to exceed max we define...\r\n    if (newSize \u003e MAX_BLOCK_SIZE) {\r\n        newSize \u003d MAX_BLOCK_SIZE;\r\n    }\r\n    _pastBlocks.add(_currBlock);\r\n    _currBlock \u003d new byte[newSize];\r\n    _currBlockPtr \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "appendTwoBytes",
    "signature": "void appendTwoBytes(int)",
    "visibility": "public",
    "body": "{\r\n    if ((_currBlockPtr + 1) \u003c _currBlock.length) {\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b16 \u003e\u003e 8);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) b16;\r\n    } else {\r\n        append(b16 \u003e\u003e 8);\r\n        append(b16);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  i3 :\u003d @parameter0: int\n  $i0 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i2 \u003d $i0 + 1\n  $r1 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i1 \u003d lengthof $r1\n  if ($i2 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i5 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i6 \u003d $i5 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i6\n  $i7 \u003d i3 \u003e\u003e 8\n  $b8 \u003d (byte) $i7\n  $r2[$i5] \u003d $b8\n  $r3 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i9 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i10 \u003d $i9 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i10\n  $b11 \u003d (byte) i3\n  $r3[$i9] \u003d $b11\n  goto B3\n}",
      "B2 {\n  $i4 \u003d i3 \u003e\u003e 8\n  r0.append($i4)\n  r0.append(i3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#append(...1)",
        "body": "{\r\n    if (_currBlockPtr \u003e\u003d _currBlock.length) {\r\n        _allocMore();\r\n    }\r\n    _currBlock[_currBlockPtr++] \u003d (byte) i;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "appendThreeBytes",
    "signature": "void appendThreeBytes(int)",
    "visibility": "public",
    "body": "{\r\n    if ((_currBlockPtr + 2) \u003c _currBlock.length) {\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b24 \u003e\u003e 16);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b24 \u003e\u003e 8);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) b24;\r\n    } else {\r\n        append(b24 \u003e\u003e 16);\r\n        append(b24 \u003e\u003e 8);\r\n        append(b24);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  i3 :\u003d @parameter0: int\n  $i0 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i2 \u003d $i0 + 2\n  $r1 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i1 \u003d lengthof $r1\n  if ($i2 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i6 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i7 \u003d $i6 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i7\n  $i8 \u003d i3 \u003e\u003e 16\n  $b9 \u003d (byte) $i8\n  $r2[$i6] \u003d $b9\n  $r3 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i10 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i11 \u003d $i10 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i11\n  $i12 \u003d i3 \u003e\u003e 8\n  $b13 \u003d (byte) $i12\n  $r3[$i10] \u003d $b13\n  $r4 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i14 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i15 \u003d $i14 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i15\n  $b16 \u003d (byte) i3\n  $r4[$i14] \u003d $b16\n  goto B3\n}",
      "B2 {\n  $i4 \u003d i3 \u003e\u003e 16\n  r0.append($i4)\n  $i5 \u003d i3 \u003e\u003e 8\n  r0.append($i5)\n  r0.append(i3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#append(...1)",
        "body": "{\r\n    if (_currBlockPtr \u003e\u003d _currBlock.length) {\r\n        _allocMore();\r\n    }\r\n    _currBlock[_currBlockPtr++] \u003d (byte) i;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "appendFourBytes",
    "signature": "void appendFourBytes(int)",
    "visibility": "public",
    "body": "{\r\n    if ((_currBlockPtr + 3) \u003c _currBlock.length) {\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b32 \u003e\u003e 24);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b32 \u003e\u003e 16);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) (b32 \u003e\u003e 8);\r\n        _currBlock[_currBlockPtr++] \u003d (byte) b32;\r\n    } else {\r\n        append(b32 \u003e\u003e 24);\r\n        append(b32 \u003e\u003e 16);\r\n        append(b32 \u003e\u003e 8);\r\n        append(b32);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003e\u003d $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  i3 :\u003d @parameter0: int\n  $i0 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i2 \u003d $i0 + 3\n  $r1 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i1 \u003d lengthof $r1\n  if ($i2 \u003e\u003d $i1) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i7 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i8 \u003d $i7 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i8\n  $i9 \u003d i3 \u003e\u003e 24\n  $b10 \u003d (byte) $i9\n  $r2[$i7] \u003d $b10\n  $r3 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i11 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i12 \u003d $i11 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i12\n  $i13 \u003d i3 \u003e\u003e 16\n  $b14 \u003d (byte) $i13\n  $r3[$i11] \u003d $b14\n  $r4 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i15 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i16 \u003d $i15 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i16\n  $i17 \u003d i3 \u003e\u003e 8\n  $b18 \u003d (byte) $i17\n  $r4[$i15] \u003d $b18\n  $r5 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i19 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i20 \u003d $i19 + 1\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i20\n  $b21 \u003d (byte) i3\n  $r5[$i19] \u003d $b21\n  goto B3\n}",
      "B2 {\n  $i4 \u003d i3 \u003e\u003e 24\n  r0.append($i4)\n  $i5 \u003d i3 \u003e\u003e 16\n  r0.append($i5)\n  $i6 \u003d i3 \u003e\u003e 8\n  r0.append($i6)\n  r0.append(i3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#append(...1)",
        "body": "{\r\n    if (_currBlockPtr \u003e\u003d _currBlock.length) {\r\n        _allocMore();\r\n    }\r\n    _currBlock[_currBlockPtr++] \u003d (byte) i;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "toByteArray",
    "signature": "byte[] toByteArray()",
    "visibility": "public",
    "body": "{\r\n    int totalLen \u003d _pastLen + _currBlockPtr;\r\n    if (totalLen \u003d\u003d 0) {\r\n        // quick check: nothing aggregated?\r\n        return NO_BYTES;\r\n    }\r\n    byte[] result \u003d new byte[totalLen];\r\n    int offset \u003d 0;\r\n    for (byte[] block : _pastBlocks) {\r\n        int len \u003d block.length;\r\n        System.arraycopy(block, 0, result, offset, len);\r\n        offset +\u003d len;\r\n    }\r\n    System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr);\r\n    offset +\u003d _currBlockPtr;\r\n    if (offset !\u003d totalLen) {\r\n        // just a sanity check\r\n        throw new RuntimeException(\"Internal error: total len assumed to be \" + totalLen + \", copied \" + offset + \" bytes\");\r\n    }\r\n    // Let\u0027s only reset if there\u0027s sizable use, otherwise will get reset later on\r\n    if (!_pastBlocks.isEmpty()) {\r\n        reset();\r\n    }\r\n    return result;\r\n}",
    "nodes": 10,
    "edges": 11,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i2 !\u003d 0) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If(i7 \u003d\u003d i2) → B6 | else → B7",
      "B7 : If($z1 !\u003d 0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  $i1 \u003d ByteArrayBuilder: int _pastLen\u003e\n  $i0 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  i2 \u003d $i1 + $i0\n  if (i2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r10 \u003d ByteArrayBuilder: byte[] NO_BYTES\u003e\n  return\n}",
      "B2 {\n  r1 \u003d newarray (byte)[i2]\n  i6 \u003d 0\n  $r2 \u003d LinkedList _pastBlocks\u003e\n  r3 \u003d $r2.iterator()\n}",
      "B3 {\n  $z0 \u003d r3.hasNext()\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d r3.next()\n  r9 \u003d (byte[]) $r8\n  i5 \u003d lengthof r9\n  System.arraycopy(r9, 0, r1, i6, i5)\n  i6 \u003d i6 + i5\n  goto B3\n}",
      "B5 {\n  $r4 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i3 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  System.arraycopy($r4, 0, r1, i6, $i3)\n  $i4 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  i7 \u003d i6 + $i4\n  if (i7 \u003d\u003d i2) goto B6 else B7\n}",
      "B6 {\n  $r6 \u003d RuntimeException\n  $r7 \u003d dynInvoke makeConcatWithConstants(i2, i7)\n  new RuntimeException($r7)\n  throw $r6\n}",
      "B7 {\n  $r5 \u003d LinkedList _pastBlocks\u003e\n  $z1 \u003d $r5.isEmpty()\n  if ($z1 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  r0.reset()\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#reset(...0)",
        "body": "{\r\n    _pastLen \u003d 0;\r\n    _currBlockPtr \u003d 0;\r\n    if (!_pastBlocks.isEmpty()) {\r\n        _pastBlocks.clear();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.ByteArrayBuilder",
    "methodName": "write",
    "signature": "void write(byte[],int,int)",
    "visibility": "public",
    "body": "{\r\n    while (true) {\r\n        int max \u003d _currBlock.length - _currBlockPtr;\r\n        int toCopy \u003d Math.min(max, len);\r\n        if (toCopy \u003e 0) {\r\n            System.arraycopy(b, off, _currBlock, _currBlockPtr, toCopy);\r\n            off +\u003d toCopy;\r\n            _currBlockPtr +\u003d toCopy;\r\n            len -\u003d toCopy;\r\n        }\r\n        if (len \u003c\u003d 0)\r\n            break;\r\n        _allocMore();\r\n    }\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B1 : If($i3 \u003c\u003d 0) → B2 | else → B3",
      "B3 : If(i8 \u003e 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ByteArrayBuilder\n  r2 :\u003d @parameter0: byte[]\n  i7 :\u003d @parameter1: int\n  i8 :\u003d @parameter2: int\n}",
      "B1 {\n  $r1 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i1 \u003d lengthof $r1\n  $i0 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i2 \u003d $i1 - $i0\n  $i3 \u003d Math.min($i2, i8)\n  if ($i3 \u003c\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d ByteArrayBuilder: byte[] _currBlock\u003e\n  $i4 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  System.arraycopy(r2, i7, $r3, $i4, $i3)\n  i7 \u003d i7 + $i3\n  $i5 \u003d ByteArrayBuilder: int _currBlockPtr\u003e\n  $i6 \u003d $i5 + $i3\n  ByteArrayBuilder: int _currBlockPtr\u003e \u003d $i6\n  i8 \u003d i8 - $i3\n}",
      "B3 {\n  if (i8 \u003e 0) goto B4 else B5\n}",
      "B4 {\n  goto B6\n}",
      "B5 {\n  r0._allocMore()\n  goto B1\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B1",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ByteArrayBuilder#_allocMore(...0)",
        "body": "{\r\n    final int newPastLen \u003d _pastLen + _currBlock.length;\r\n    // 13-Feb-2016, tatu: As per [core#351] let\u0027s try to catch problem earlier;\r\n    //     for now we are strongly limited by 2GB limit of Java arrays\r\n    if (newPastLen \u003c 0) {\r\n        throw new IllegalStateException(\"Maximum Java array size (2GB) exceeded by `ByteArrayBuilder`\");\r\n    }\r\n    _pastLen \u003d newPastLen;\r\n    /* Let\u0027s allocate block that\u0027s half the total size, except\r\n         * never smaller than twice the initial block size.\r\n         * The idea is just to grow with reasonable rate, to optimize\r\n         * between minimal number of chunks and minimal amount of\r\n         * wasted space.\r\n         */\r\n    int newSize \u003d Math.max((_pastLen \u003e\u003e 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE));\r\n    // plus not to exceed max we define...\r\n    if (newSize \u003e MAX_BLOCK_SIZE) {\r\n        newSize \u003d MAX_BLOCK_SIZE;\r\n    }\r\n    _pastBlocks.add(_currBlock);\r\n    _currBlock \u003d new byte[newSize];\r\n    _currBlockPtr \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultIndenter",
    "methodName": "withLinefeed",
    "signature": "com.fasterxml.jackson.core.util.DefaultIndenter withLinefeed(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (lf.equals(eol)) {\r\n        return this;\r\n    }\r\n    return new DefaultIndenter(getIndent(), lf);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultIndenter\n  String\n  $r2 \u003d String eol\u003e\n  $z0 \u003d r0.equals($r2)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DefaultIndenter\n  $r4 \u003d r1.getIndent()\n  new DefaultIndenter($r4, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultIndenter#getIndent(...0)",
        "body": "{\r\n    return new String(indents, 0, charsPerLevel);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultIndenter",
    "methodName": "withIndent",
    "signature": "com.fasterxml.jackson.core.util.DefaultIndenter withIndent(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (indent.equals(getIndent())) {\r\n        return this;\r\n    }\r\n    return new DefaultIndenter(indent, eol);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultIndenter\n  String\n  $r2 \u003d r1.getIndent()\n  $z0 \u003d r0.equals($r2)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d DefaultIndenter\n  $r4 \u003d String eol\u003e\n  new DefaultIndenter(r0, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultIndenter#getIndent(...0)",
        "body": "{\r\n    return new String(indents, 0, charsPerLevel);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultIndenter",
    "methodName": "writeIndentation",
    "signature": "void writeIndentation(com.fasterxml.jackson.core.JsonGenerator,int)",
    "visibility": "public",
    "body": "{\r\n    jg.writeRaw(eol);\r\n    if (level \u003e 0) {\r\n        // should we err on negative values (as there\u0027s some flaw?)\r\n        level *\u003d charsPerLevel;\r\n        while (level \u003e indents.length) {\r\n            // unlike to happen but just in case\r\n            jg.writeRaw(indents, 0, indents.length);\r\n            level -\u003d indents.length;\r\n        }\r\n        jg.writeRaw(indents, 0, level);\r\n    }\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i4 \u003c\u003d 0) → B1 | else → B5",
      "B2 : If(i5 \u003c\u003d $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultIndenter\n  JsonGenerator\n  i4 :\u003d @parameter1: int\n  $r2 \u003d String eol\u003e\n  r0.writeRaw($r2)\n  if (i4 \u003c\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $i0 \u003d DefaultIndenter: int charsPerLevel\u003e\n  i5 \u003d i4 * $i0\n}",
      "B2 {\n  $r3 \u003d DefaultIndenter: char[] indents\u003e\n  $i1 \u003d lengthof $r3\n  if (i5 \u003c\u003d $i1) goto B3 else B4\n}",
      "B3 {\n  $r6 \u003d DefaultIndenter: char[] indents\u003e\n  $r5 \u003d DefaultIndenter: char[] indents\u003e\n  $i2 \u003d lengthof $r5\n  r0.writeRaw($r6, 0, $i2)\n  $r7 \u003d DefaultIndenter: char[] indents\u003e\n  $i3 \u003d lengthof $r7\n  i5 \u003d i5 - $i3\n  goto B2\n}",
      "B4 {\n  $r4 \u003d DefaultIndenter: char[] indents\u003e\n  r0.writeRaw($r4, 0, i5)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "withRootSeparator",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter withRootSeparator(com.fasterxml.jackson.core.SerializableString)",
    "visibility": "public",
    "body": "{\r\n    if (_rootSeparator \u003d\u003d rootSeparator || (rootSeparator !\u003d null \u0026\u0026 rootSeparator.equals(_rootSeparator))) {\r\n        return this;\r\n    }\r\n    Separators separators \u003d _separators.withRootSeparator(rootSeparator \u003d\u003d null ? null : rootSeparator.getValue());\r\n    return new DefaultPrettyPrinter(this).withSeparators(separators);\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d r1) → B1 | else → B3",
      "B1 : If(r1 \u003d\u003d null) → B2 | else → B4",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(r1 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  SerializableString\n  $r2 \u003d SerializableString _rootSeparator\u003e\n  if ($r2 \u003d\u003d r1) goto B1 else B3\n}",
      "B1 {\n  if (r1 \u003d\u003d null) goto B2 else B4\n}",
      "B2 {\n  $r7 \u003d SerializableString _rootSeparator\u003e\n  $z0 \u003d r1.equals($r7)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d Separators _separators\u003e\n  if (r1 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r8 \u003d null\n  goto B7\n}",
      "B6 {\n  $r8 \u003d r1.getValue()\n}",
      "B7 {\n  $r6 \u003d $r3.withRootSeparator($r8)\n  $r4 \u003d DefaultPrettyPrinter\n  new DefaultPrettyPrinter(r0)\n  $r5 \u003d $r4.withSeparators($r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "withRootSeparator",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter withRootSeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return withRootSeparator((rootSeparator \u003d\u003d null) ? null : new SerializedString(rootSeparator));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  String\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d null\n  goto B3\n}",
      "B2 {\n  $r3 \u003d SerializedString\n  new SerializedString(r1)\n}",
      "B3 {\n  $r2 \u003d r0.withRootSeparator($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultPrettyPrinter#withRootSeparator(...1)",
        "body": "{\r\n    if (_rootSeparator \u003d\u003d rootSeparator || (rootSeparator !\u003d null \u0026\u0026 rootSeparator.equals(_rootSeparator))) {\r\n        return this;\r\n    }\r\n    Separators separators \u003d _separators.withRootSeparator(rootSeparator \u003d\u003d null ? null : rootSeparator.getValue());\r\n    return new DefaultPrettyPrinter(this).withSeparators(separators);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "indentArraysWith",
    "signature": "void indentArraysWith(com.fasterxml.jackson.core.util.DefaultPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  DefaultPrettyPrinter$Indenter\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d DefaultPrettyPrinter$NopIndenter instance\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  DefaultPrettyPrinter$Indenter _arrayIndenter\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "indentObjectsWith",
    "signature": "void indentObjectsWith(com.fasterxml.jackson.core.util.DefaultPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  DefaultPrettyPrinter$Indenter\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d DefaultPrettyPrinter$NopIndenter instance\u003e\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r1\n}",
      "B3 {\n  DefaultPrettyPrinter$Indenter _objectIndenter\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "withArrayIndenter",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter withArrayIndenter(com.fasterxml.jackson.core.util.DefaultPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If($r1 !\u003d r3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  DefaultPrettyPrinter$Indenter\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DefaultPrettyPrinter$NopIndenter instance\u003e\n}",
      "B2 {\n  $r1 \u003d DefaultPrettyPrinter$Indenter _arrayIndenter\u003e\n  if ($r1 !\u003d r3) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d DefaultPrettyPrinter\n  new DefaultPrettyPrinter(r0)\n  DefaultPrettyPrinter$Indenter _arrayIndenter\u003e \u003d r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "withObjectIndenter",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter withObjectIndenter(com.fasterxml.jackson.core.util.DefaultPrettyPrinter$Indenter)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2",
      "B2 : If($r1 !\u003d r3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  DefaultPrettyPrinter$Indenter\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r3 \u003d DefaultPrettyPrinter$NopIndenter instance\u003e\n}",
      "B2 {\n  $r1 \u003d DefaultPrettyPrinter$Indenter _objectIndenter\u003e\n  if ($r1 !\u003d r3) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r2 \u003d DefaultPrettyPrinter\n  new DefaultPrettyPrinter(r0)\n  DefaultPrettyPrinter$Indenter _objectIndenter\u003e \u003d r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "withSeparators",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter withSeparators(com.fasterxml.jackson.core.util.Separators)",
    "visibility": "public",
    "body": "{\r\n    DefaultPrettyPrinter result \u003d new DefaultPrettyPrinter(this);\r\n    result._separators \u003d separators;\r\n    result._rootSeparator \u003d separators.getRootSeparator() \u003d\u003d null ? null : new SerializedString(separators.getRootSeparator());\r\n    result._objectFieldValueSeparatorWithSpaces \u003d separators.getObjectFieldValueSpacing().apply(separators.getObjectFieldValueSeparator());\r\n    result._objectEntrySeparator \u003d separators.getObjectEntrySpacing().apply(separators.getObjectEntrySeparator());\r\n    result._objectEmptySeparator \u003d separators.getObjectEmptySeparator();\r\n    result._arrayValueSeparator \u003d separators.getArrayValueSpacing().apply(separators.getArrayValueSeparator());\r\n    result._arrayEmptySeparator \u003d separators.getArrayEmptySeparator();\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r3 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  Separators\n  $r0 \u003d DefaultPrettyPrinter\n  new DefaultPrettyPrinter(r1)\n  Separators _separators\u003e \u003d r2\n  $r3 \u003d r2.getRootSeparator()\n  if ($r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d null\n  goto B3\n}",
      "B2 {\n  $r13 \u003d SerializedString\n  $r4 \u003d r2.getRootSeparator()\n  new SerializedString($r4)\n}",
      "B3 {\n  SerializableString _rootSeparator\u003e \u003d $r13\n  $r5 \u003d r2.getObjectFieldValueSpacing()\n  $c0 \u003d r2.getObjectFieldValueSeparator()\n  $r6 \u003d $r5.apply($c0)\n  String _objectFieldValueSeparatorWithSpaces\u003e \u003d $r6\n  $r7 \u003d r2.getObjectEntrySpacing()\n  $c1 \u003d r2.getObjectEntrySeparator()\n  $r8 \u003d $r7.apply($c1)\n  String _objectEntrySeparator\u003e \u003d $r8\n  $r9 \u003d r2.getObjectEmptySeparator()\n  String _objectEmptySeparator\u003e \u003d $r9\n  $r10 \u003d r2.getArrayValueSpacing()\n  $c2 \u003d r2.getArrayValueSeparator()\n  $r11 \u003d $r10.apply($c2)\n  String _arrayValueSeparator\u003e \u003d $r11\n  $r12 \u003d r2.getArrayEmptySeparator()\n  String _arrayEmptySeparator\u003e \u003d $r12\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "createInstance",
    "signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter createInstance()",
    "visibility": "public",
    "body": "{\r\n    if (getClass() !\u003d DefaultPrettyPrinter.class) {\r\n        // since 2.10\r\n        throw new IllegalStateException(\"Failed `createInstance()`: \" + getClass().getName() + \" does not override method; it has to\");\r\n    }\r\n    return new DefaultPrettyPrinter(this);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d class \"Lcom/fasterxml/jackson/core/util/DefaultPrettyPrinter;\") → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  $r1 \u003d r0.getClass()\n  if ($r1 \u003d\u003d class \"Lcom/fasterxml/jackson/core/util/DefaultPrettyPrinter;\") goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalStateException\n  $r4 \u003d r0.getClass()\n  $r5 \u003d $r4.getName()\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IllegalStateException($r6)\n  throw $r3\n}",
      "B2 {\n  $r2 \u003d DefaultPrettyPrinter\n  new DefaultPrettyPrinter(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultPrettyPrinter#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "writeRootValueSeparator",
    "signature": "void writeRootValueSeparator(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (_rootSeparator !\u003d null) {\r\n        g.writeRaw(_rootSeparator);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  JsonGenerator\n  $r1 \u003d SerializableString _rootSeparator\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d SerializableString _rootSeparator\u003e\n  r2.writeRaw($r3)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "writeStartObject",
    "signature": "void writeStartObject(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    g.writeRaw(\u0027{\u0027);\r\n    if (!_objectIndenter.isInline()) {\r\n        ++_nesting;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  JsonGenerator\n  r0.writeRaw(123)\n  $r2 \u003d DefaultPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r2.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $i1 \u003d $i0 + 1\n  DefaultPrettyPrinter: int _nesting\u003e \u003d $i1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "writeEndObject",
    "signature": "void writeEndObject(com.fasterxml.jackson.core.JsonGenerator,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_objectIndenter.isInline()) {\r\n        --_nesting;\r\n    }\r\n    if (nrOfEntries \u003e 0) {\r\n        _objectIndenter.writeIndentation(g, _nesting);\r\n    } else {\r\n        g.writeRaw(_objectEmptySeparator);\r\n    }\r\n    g.writeRaw(\u0027}\u0027);\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  JsonGenerator\n  i0 :\u003d @parameter1: int\n  $r1 \u003d DefaultPrettyPrinter$Indenter _objectIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $i3 \u003d $i2 - 1\n  DefaultPrettyPrinter: int _nesting\u003e \u003d $i3\n}",
      "B2 {\n  if (i0 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d DefaultPrettyPrinter$Indenter _objectIndenter\u003e\n  $i1 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $r4.writeIndentation(r2, $i1)\n  goto B5\n}",
      "B4 {\n  $r3 \u003d String _objectEmptySeparator\u003e\n  r2.writeRaw($r3)\n}",
      "B5 {\n  r2.writeRaw(125)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "writeStartArray",
    "signature": "void writeStartArray(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (!_arrayIndenter.isInline()) {\r\n        ++_nesting;\r\n    }\r\n    g.writeRaw(\u0027[\u0027);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  JsonGenerator\n  $r1 \u003d DefaultPrettyPrinter$Indenter _arrayIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i0 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $i1 \u003d $i0 + 1\n  DefaultPrettyPrinter: int _nesting\u003e \u003d $i1\n}",
      "B2 {\n  r2.writeRaw(91)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter",
    "methodName": "writeEndArray",
    "signature": "void writeEndArray(com.fasterxml.jackson.core.JsonGenerator,int)",
    "visibility": "public",
    "body": "{\r\n    if (!_arrayIndenter.isInline()) {\r\n        --_nesting;\r\n    }\r\n    if (nrOfValues \u003e 0) {\r\n        _arrayIndenter.writeIndentation(g, _nesting);\r\n    } else {\r\n        g.writeRaw(_arrayEmptySeparator);\r\n    }\r\n    g.writeRaw(\u0027]\u0027);\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003c\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  DefaultPrettyPrinter\n  JsonGenerator\n  i0 :\u003d @parameter1: int\n  $r1 \u003d DefaultPrettyPrinter$Indenter _arrayIndenter\u003e\n  $z0 \u003d $r1.isInline()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $i3 \u003d $i2 - 1\n  DefaultPrettyPrinter: int _nesting\u003e \u003d $i3\n}",
      "B2 {\n  if (i0 \u003c\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d DefaultPrettyPrinter$Indenter _arrayIndenter\u003e\n  $i1 \u003d DefaultPrettyPrinter: int _nesting\u003e\n  $r4.writeIndentation(r2, $i1)\n  goto B5\n}",
      "B4 {\n  $r3 \u003d String _arrayEmptySeparator\u003e\n  r2.writeRaw($r3)\n}",
      "B5 {\n  r2.writeRaw(93)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.InternCache",
    "methodName": "intern",
    "signature": "java.lang.String intern(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    String result \u003d get(input);\r\n    if (result !\u003d null) {\r\n        return result;\r\n    }\r\n    /* 18-Sep-2013, tatu: We used to use LinkedHashMap, which has simple LRU\r\n         *   method. No such functionality exists with CHM; and let\u0027s use simplest\r\n         *   possible limitation: just clear all contents. This because otherwise\r\n         *   we are simply likely to keep on clearing same, commonly used entries.\r\n         */\r\n    if (size() \u003e\u003d DEFAULT_MAX_ENTRIES) {\r\n        /* As of 2.18, the limit is not strictly enforced, but we do try to\r\n             * clear entries if we have reached the limit. We do not expect to\r\n             * go too much over the limit, and if we do, it\u0027s not a huge problem.\r\n             * If some other thread has the lock, we will not clear but the lock should\r\n             * not be held for long, so another thread should be able to clear in the near future.\r\n             */\r\n        if (lock.tryLock()) {\r\n            try {\r\n                if (size() \u003e\u003d DEFAULT_MAX_ENTRIES) {\r\n                    clear();\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n        }\r\n    }\r\n    result \u003d input.intern();\r\n    put(result, result);\r\n    return result;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r7 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i0 \u003c 280) → B3 | else → B8",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B8",
      "B4 : If($i1 \u003c 280) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  InternCache\n  String\n  $r2 \u003d r0.get(r1)\n  r7 \u003d String) $r2\n  if (r7 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $i0 \u003d r0.size()\n  if ($i0 \u003c 280) goto B3 else B8\n}",
      "B3 {\n  $r3 \u003d ReentrantLock lock\u003e\n  $z0 \u003d $r3.tryLock()\n  if ($z0 \u003d\u003d false) goto B4 else B8\n}",
      "B4 {\n  $i1 \u003d r0.size()\n  if ($i1 \u003c 280) goto B5 else B6\n}",
      "B5 {\n  r0.clear()\n}",
      "B6 {\n  $r4 \u003d ReentrantLock lock\u003e\n  $r4.unlock()\n  goto B8\n}",
      "B7 {\n  $r5 :\u003d @caughtexception\n  $r6 \u003d ReentrantLock lock\u003e\n  $r6.unlock()\n  throw $r5\n}",
      "B8 {\n  $r8 \u003d r1.intern()\n  r0.put($r8, $r8)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B8",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "InternCache#put(...2)",
        "body": "(source not found)"
      },
      {
        "name": "InternCache#clear(...0)",
        "body": "(source not found)"
      },
      {
        "name": "InternCache#size(...0)",
        "body": "(source not found)"
      },
      {
        "name": "InternCache#get(...1)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JacksonFeatureSet",
    "methodName": "fromDefaults",
    "signature": "com.fasterxml.jackson.core.util.JacksonFeatureSet fromDefaults(com.fasterxml.jackson.core.util.JacksonFeature[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 8,
    "edges": 9,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 31) → B1 | else → B2",
      "B3 : If(i5 \u003e\u003d i1) → B4 | else → B7",
      "B4 : If($z0 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JacksonFeature[]\n  $i0 \u003d lengthof r0\n  if ($i0 \u003c\u003d 31) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r0[0]\n  $r4 \u003d $r3.getClass()\n  r9 \u003d $r4.getName()\n  $r5 \u003d IllegalArgumentException\n  $r6 \u003d Object)[2]\n  $r6[0] \u003d r9\n  $i3 \u003d lengthof r0\n  $r7 \u003d Integer.valueOf($i3)\n  $r6[1] \u003d $r7\n  $r8 \u003d String.format(\"Can not use type `%s` with JacksonFeatureSet: too many entries (%d \u003e 31)\", $r6)\n  new IllegalArgumentException($r8)\n  throw $r5\n}",
      "B2 {\n  i4 \u003d 0\n  i1 \u003d lengthof r0\n  i5 \u003d 0\n}",
      "B3 {\n  if (i5 \u003e\u003d i1) goto B4 else B7\n}",
      "B4 {\n  r2 \u003d r0[i5]\n  $z0 \u003d r2.enabledByDefault()\n  if ($z0 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $i2 \u003d r2.getMask()\n  i4 \u003d i4 | $i2\n}",
      "B6 {\n  i5 \u003d i5 + 1\n  goto B3\n}",
      "B7 {\n  $r1 \u003d JacksonFeatureSet\n  new JacksonFeatureSet(i4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B3",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JacksonFeatureSet",
    "methodName": "with",
    "signature": "com.fasterxml.jackson.core.util.JacksonFeatureSet \u0027with\u0027(com.fasterxml.jackson.core.util.JacksonFeature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 !\u003d $i3) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JacksonFeatureSet\n  JacksonFeature\n  $i0 \u003d JacksonFeatureSet: int _enabled\u003e\n  $i1 \u003d r1.getMask()\n  i2 \u003d $i0 | $i1\n  $i3 \u003d JacksonFeatureSet: int _enabled\u003e\n  if (i2 !\u003d $i3) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d JacksonFeatureSet\n  new JacksonFeatureSet(i2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JacksonFeatureSet",
    "methodName": "without",
    "signature": "com.fasterxml.jackson.core.util.JacksonFeatureSet without(com.fasterxml.jackson.core.util.JacksonFeature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i3 !\u003d $i4) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JacksonFeatureSet\n  JacksonFeature\n  $i0 \u003d JacksonFeatureSet: int _enabled\u003e\n  $i1 \u003d r1.getMask()\n  $i6 \u003d (int) -1\n  $i2 \u003d $i1 ^ $i6\n  i3 \u003d $i0 \u0026 $i2\n  $i4 \u003d JacksonFeatureSet: int _enabled\u003e\n  if (i3 !\u003d $i4) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r3 \u003d JacksonFeatureSet\n  $r2 \u003d $r3\n  new JacksonFeatureSet(i3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JacksonFeatureSet",
    "methodName": "isEnabled",
    "signature": "boolean isEnabled(com.fasterxml.jackson.core.util.JacksonFeature)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JacksonFeatureSet\n  JacksonFeature\n  $i1 \u003d r0.getMask()\n  $i0 \u003d JacksonFeatureSet: int _enabled\u003e\n  $i2 \u003d $i1 \u0026 $i0\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonGeneratorDelegate",
    "methodName": "writeObject",
    "signature": "void writeObject(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (delegateCopyMethods) {\r\n        delegate.writeObject(pojo);\r\n        return;\r\n    }\r\n    if (pojo \u003d\u003d null) {\r\n        writeNull();\r\n    } else {\r\n        ObjectCodec c \u003d getCodec();\r\n        if (c !\u003d null) {\r\n            c.writeValue(this, pojo);\r\n            return;\r\n        }\r\n        _writeSimpleObject(pojo);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If(r2 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonGeneratorDelegate\n  Object\n  $z0 \u003d JsonGeneratorDelegate: boolean delegateCopyMethods\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonGenerator delegate\u003e\n  $r3.writeObject(r1)\n  return\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.writeNull()\n  goto B7\n}",
      "B4 {\n  r2 \u003d r0.getCodec()\n  if (r2 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  r2.writeValue(r0, r1)\n  return\n}",
      "B6 {\n  r0._writeSimpleObject(r1)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonGeneratorDelegate#getCodec(...0)",
        "body": "{\r\n    return delegate.getCodec();\r\n}"
      },
      {
        "name": "JsonGeneratorDelegate#_writeSimpleObject(...1)",
        "body": "(source not found)"
      },
      {
        "name": "JsonGeneratorDelegate#writeNull(...0)",
        "body": "{\r\n    delegate.writeNull();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonGeneratorDelegate",
    "methodName": "writeTree",
    "signature": "void writeTree(com.fasterxml.jackson.core.TreeNode)",
    "visibility": "public",
    "body": "{\r\n    if (delegateCopyMethods) {\r\n        delegate.writeTree(tree);\r\n        return;\r\n    }\r\n    // As with \u0027writeObject()\u0027, we are not check if write would work\r\n    if (tree \u003d\u003d null) {\r\n        writeNull();\r\n    } else {\r\n        ObjectCodec c \u003d getCodec();\r\n        if (c \u003d\u003d null) {\r\n            throw new IllegalStateException(\"No ObjectCodec defined\");\r\n        }\r\n        c.writeTree(this, tree);\r\n    }\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If(r2 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonGeneratorDelegate\n  TreeNode\n  $z0 \u003d JsonGeneratorDelegate: boolean delegateCopyMethods\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonGenerator delegate\u003e\n  $r4.writeTree(r1)\n  return\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  r0.writeNull()\n  goto B7\n}",
      "B4 {\n  r2 \u003d r0.getCodec()\n  if (r2 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d IllegalStateException\n  new IllegalStateException(\"No ObjectCodec defined\")\n  throw $r3\n}",
      "B6 {\n  r2.writeTree(r0, r1)\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonGeneratorDelegate#getCodec(...0)",
        "body": "{\r\n    return delegate.getCodec();\r\n}"
      },
      {
        "name": "JsonGeneratorDelegate#writeNull(...0)",
        "body": "{\r\n    delegate.writeNull();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonGeneratorDelegate",
    "methodName": "copyCurrentEvent",
    "signature": "void copyCurrentEvent(com.fasterxml.jackson.core.JsonParser)",
    "visibility": "public",
    "body": "{\r\n    if (delegateCopyMethods)\r\n        delegate.copyCurrentEvent(p);\r\n    else\r\n        super.copyCurrentEvent(p);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonGeneratorDelegate\n  JsonParser\n  $z0 \u003d JsonGeneratorDelegate: boolean delegateCopyMethods\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.copyCurrentEvent(r1)\n  goto B3\n}",
      "B2 {\n  r0.copyCurrentEvent(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonGeneratorDelegate",
    "methodName": "copyCurrentStructure",
    "signature": "void copyCurrentStructure(com.fasterxml.jackson.core.JsonParser)",
    "visibility": "public",
    "body": "{\r\n    if (delegateCopyMethods)\r\n        delegate.copyCurrentStructure(p);\r\n    else\r\n        super.copyCurrentStructure(p);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonGeneratorDelegate\n  JsonParser\n  $z0 \u003d JsonGeneratorDelegate: boolean delegateCopyMethods\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonGenerator delegate\u003e\n  $r2.copyCurrentStructure(r1)\n  goto B3\n}",
      "B2 {\n  r0.copyCurrentStructure(r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonParserSequence",
    "methodName": "createFlattened",
    "signature": "com.fasterxml.jackson.core.util.JsonParserSequence createFlattened(boolean,com.fasterxml.jackson.core.JsonParser,com.fasterxml.jackson.core.JsonParser)",
    "visibility": "public",
    "body": "{\r\n    if (!(first instanceof JsonParserSequence || second instanceof JsonParserSequence)) {\r\n        return new JsonParserSequence(checkForExistingToken, new JsonParser[] { first, second });\r\n    }\r\n    ArrayList\u003cJsonParser\u003e p \u003d new ArrayList\u003c\u003e();\r\n    if (first instanceof JsonParserSequence) {\r\n        ((JsonParserSequence) first).addFlattenedActiveParsers(p);\r\n    } else {\r\n        p.add(first);\r\n    }\r\n    if (second instanceof JsonParserSequence) {\r\n        ((JsonParserSequence) second).addFlattenedActiveParsers(p);\r\n    } else {\r\n        p.add(second);\r\n    }\r\n    return new JsonParserSequence(checkForExistingToken, p.toArray(new JsonParser[p.size()]));\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z4 !\u003d 0) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  z3 :\u003d @parameter0: boolean\n  JsonParser\n  JsonParser\n  $z0 \u003d JsonParserSequence\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z4 \u003d JsonParserSequence\n  if ($z4 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r9 \u003d JsonParserSequence\n  $r10 \u003d JsonParser)[2]\n  $r10[0] \u003d r0\n  $r10[1] \u003d r2\n  new JsonParserSequence(z3, $r10)\n  return\n}",
      "B3 {\n  $r1 \u003d ArrayList\n  new ArrayList()\n  $z1 \u003d JsonParserSequence\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r8 \u003d JsonParserSequence) r0\n  $r8.addFlattenedActiveParsers($r1)\n  goto B6\n}",
      "B5 {\n  $r1.add(r0)\n}",
      "B6 {\n  $z2 \u003d JsonParserSequence\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r7 \u003d JsonParserSequence) r2\n  $r7.addFlattenedActiveParsers($r1)\n  goto B9\n}",
      "B8 {\n  $r1.add(r2)\n}",
      "B9 {\n  $r3 \u003d JsonParserSequence\n  $i0 \u003d $r1.size()\n  $r4 \u003d JsonParser)[$i0]\n  $r5 \u003d $r1.toArray($r4)\n  $r6 \u003d JsonParser[]) $r5\n  new JsonParserSequence(z3, $r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonParserSequence",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    do {\r\n        delegate.close();\r\n    } while (switchToNext());\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 !\u003d 0) → B2 | else → B1"
    ],
    "blockList": [
      "B0 {\n  JsonParserSequence\n}",
      "B1 {\n  $r1 \u003d JsonParser delegate\u003e\n  $r1.close()\n  $z0 \u003d r0.switchToNext()\n  if ($z0 !\u003d 0) goto B2 else B1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B1",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonParserSequence#switchToNext(...0)",
        "body": "{\r\n    if (_nextParserIndex \u003c _parsers.length) {\r\n        delegate \u003d _parsers[_nextParserIndex++];\r\n        return true;\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonParserSequence",
    "methodName": "nextToken",
    "signature": "com.fasterxml.jackson.core.JsonToken nextToken()",
    "visibility": "public",
    "body": "{\r\n    if (delegate \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (_hasToken) {\r\n        _hasToken \u003d false;\r\n        return delegate.currentToken();\r\n    }\r\n    JsonToken t \u003d delegate.nextToken();\r\n    if (t \u003d\u003d null) {\r\n        return switchAndReturnNext();\r\n    }\r\n    return t;\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If(r3 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonParserSequence\n  $r1 \u003d JsonParser delegate\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d JsonParserSequence: boolean _hasToken\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  JsonParserSequence: boolean _hasToken\u003e \u003d 0\n  $r5 \u003d JsonParser delegate\u003e\n  $r6 \u003d $r5.currentToken()\n  return\n}",
      "B4 {\n  $r2 \u003d JsonParser delegate\u003e\n  r3 \u003d $r2.nextToken()\n  if (r3 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d r0.switchAndReturnNext()\n  return\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonParserSequence#switchAndReturnNext(...0)",
        "body": "{\r\n    while (_nextParserIndex \u003c _parsers.length) {\r\n        delegate \u003d _parsers[_nextParserIndex++];\r\n        if (_checkForExistingToken \u0026\u0026 delegate.hasCurrentToken()) {\r\n            return delegate.getCurrentToken();\r\n        }\r\n        JsonToken t \u003d delegate.nextToken();\r\n        if (t !\u003d null) {\r\n            return t;\r\n        }\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.JsonParserSequence",
    "methodName": "skipChildren",
    "signature": "com.fasterxml.jackson.core.JsonParser skipChildren()",
    "visibility": "public",
    "body": "{\r\n    if ((delegate.currentToken() !\u003d JsonToken.START_OBJECT) \u0026\u0026 (delegate.currentToken() !\u003d JsonToken.START_ARRAY)) {\r\n        return this;\r\n    }\r\n    int open \u003d 1;\r\n    // Since proper matching of start/end markers is handled\r\n    // by nextToken(), we\u0027ll just count nesting levels here\r\n    while (true) {\r\n        JsonToken t \u003d nextToken();\r\n        if (t \u003d\u003d null) {\r\n            // not ideal but for now, just return\r\n            return this;\r\n        }\r\n        if (t.isStructStart()) {\r\n            ++open;\r\n        } else if (t.isStructEnd()) {\r\n            if (--open \u003d\u003d 0) {\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n}",
    "nodes": 12,
    "edges": 15,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r3 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If($r6 \u003d\u003d $r5) → B2 | else → B3",
      "B4 : If($r7 !\u003d null) → B5 | else → B6",
      "B6 : If($z0 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z1 \u003d\u003d false) → B9 | else → B11",
      "B9 : If(i0 !\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  JsonParserSequence\n  $r1 \u003d JsonParser delegate\u003e\n  $r3 \u003d $r1.currentToken()\n  $r2 \u003d JsonToken START_OBJECT\u003e\n  if ($r3 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  $r4 \u003d JsonParser delegate\u003e\n  $r6 \u003d $r4.currentToken()\n  $r5 \u003d JsonToken START_ARRAY\u003e\n  if ($r6 \u003d\u003d $r5) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  i0 \u003d 1\n}",
      "B4 {\n  $r7 \u003d r0.nextToken()\n  if ($r7 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $z0 \u003d $r7.isStructStart()\n  if ($z0 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  i0 \u003d i0 + 1\n  goto B11\n}",
      "B8 {\n  $z1 \u003d $r7.isStructEnd()\n  if ($z1 \u003d\u003d false) goto B9 else B11\n}",
      "B9 {\n  $i2 \u003d (int) -1\n  i0 \u003d i0 + $i2\n  if (i0 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  goto B4\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B4"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonParserSequence#nextToken(...0)",
        "body": "{\r\n    if (delegate \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    if (_hasToken) {\r\n        _hasToken \u003d false;\r\n        return delegate.currentToken();\r\n    }\r\n    JsonToken t \u003d delegate.nextToken();\r\n    if (t \u003d\u003d null) {\r\n        return switchAndReturnNext();\r\n    }\r\n    return t;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.MinimalPrettyPrinter",
    "methodName": "writeRootValueSeparator",
    "signature": "void writeRootValueSeparator(com.fasterxml.jackson.core.JsonGenerator)",
    "visibility": "public",
    "body": "{\r\n    if (_rootValueSeparator !\u003d null) {\r\n        g.writeRaw(_rootValueSeparator);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MinimalPrettyPrinter\n  JsonGenerator\n  $r1 \u003d String _rootValueSeparator\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d String _rootValueSeparator\u003e\n  r2.writeRaw($r3)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.RequestPayload",
    "methodName": "getRawPayload",
    "signature": "java.lang.Object getRawPayload()",
    "visibility": "public",
    "body": "{\r\n    if (_payloadAsBytes !\u003d null) {\r\n        return _payloadAsBytes;\r\n    }\r\n    return _payloadAsText;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  RequestPayload\n  $r1 \u003d RequestPayload: byte[] _payloadAsBytes\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d RequestPayload: byte[] _payloadAsBytes\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d CharSequence _payloadAsText\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withRootSeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withRootSeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return Objects.equals(rootSeparator, sep) ? this : new Separators(sep, objectFieldValueSeparator, objectFieldValueSpacing, objectEntrySeparator, objectEntrySpacing, objectEmptySeparator, arrayValueSeparator, arrayValueSpacing, arrayEmptySeparator);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  String\n  $r2 \u003d String rootSeparator\u003e\n  $z0 \u003d Objects.equals($r2, r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r7 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r6 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r5 \u003d String objectEmptySeparator\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r4 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r3 \u003d String arrayEmptySeparator\u003e\n  new Separators(r1, $c2, $r7, $c1, $r6, $r5, $c0, $r4, $r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withObjectFieldValueSeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withObjectFieldValueSeparator(char)",
    "visibility": "public",
    "body": "{\r\n    return (objectFieldValueSeparator \u003d\u003d sep) ? this : new Separators(rootSeparator, sep, objectFieldValueSpacing, objectEntrySeparator, objectEntrySpacing, objectEmptySeparator, arrayValueSeparator, arrayValueSpacing, arrayEmptySeparator);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 !\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  c0 :\u003d @parameter0: char\n  $c1 \u003d Separators: char objectFieldValueSeparator\u003e\n  $i4 \u003d (int) $c1\n  $i5 \u003d (int) c0\n  if ($i4 !\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d $r8\n  $r6 \u003d String rootSeparator\u003e\n  $r5 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c3 \u003d Separators: char objectEntrySeparator\u003e\n  $r4 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r3 \u003d String objectEmptySeparator\u003e\n  $c2 \u003d Separators: char arrayValueSeparator\u003e\n  $r2 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r1 \u003d String arrayEmptySeparator\u003e\n  new Separators($r6, c0, $r5, $c3, $r4, $r3, $c2, $r2, $r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withObjectFieldValueSpacing",
    "signature": "com.fasterxml.jackson.core.util.Separators withObjectFieldValueSpacing(com.fasterxml.jackson.core.util.Separators$Spacing)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  Separators$Spacing\n  $r2 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d String rootSeparator\u003e\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r6 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r5 \u003d String objectEmptySeparator\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r4 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r3 \u003d String arrayEmptySeparator\u003e\n  new Separators($r7, $c2, r1, $c1, $r6, $r5, $c0, $r4, $r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withObjectEntrySeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withObjectEntrySeparator(char)",
    "visibility": "public",
    "body": "{\r\n    return (objectEntrySeparator \u003d\u003d sep) ? this : new Separators(rootSeparator, objectFieldValueSeparator, objectFieldValueSpacing, sep, objectEntrySpacing, objectEmptySeparator, arrayValueSeparator, arrayValueSpacing, arrayEmptySeparator);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 !\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  c0 :\u003d @parameter0: char\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $i4 \u003d (int) $c1\n  $i5 \u003d (int) c0\n  if ($i4 !\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d $r8\n  $r6 \u003d String rootSeparator\u003e\n  $c3 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r5 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $r4 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r3 \u003d String objectEmptySeparator\u003e\n  $c2 \u003d Separators: char arrayValueSeparator\u003e\n  $r2 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r1 \u003d String arrayEmptySeparator\u003e\n  new Separators($r6, $c3, $r5, c0, $r4, $r3, $c2, $r2, $r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withObjectEntrySpacing",
    "signature": "com.fasterxml.jackson.core.util.Separators withObjectEntrySpacing(com.fasterxml.jackson.core.util.Separators$Spacing)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  Separators$Spacing\n  $r2 \u003d Separators$Spacing objectEntrySpacing\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d String rootSeparator\u003e\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r6 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r5 \u003d String objectEmptySeparator\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r4 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r3 \u003d String arrayEmptySeparator\u003e\n  new Separators($r7, $c2, $r6, $c1, r1, $r5, $c0, $r4, $r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withObjectEmptySeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withObjectEmptySeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return Objects.equals(objectEmptySeparator, sep) ? this : new Separators(rootSeparator, objectFieldValueSeparator, objectFieldValueSpacing, objectEntrySeparator, objectEntrySpacing, sep, arrayValueSeparator, arrayValueSpacing, arrayEmptySeparator);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  String\n  $r2 \u003d String objectEmptySeparator\u003e\n  $z0 \u003d Objects.equals($r2, r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d String rootSeparator\u003e\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r6 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r5 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r4 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r3 \u003d String arrayEmptySeparator\u003e\n  new Separators($r7, $c2, $r6, $c1, $r5, r1, $c0, $r4, $r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withArrayValueSeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withArrayValueSeparator(char)",
    "visibility": "public",
    "body": "{\r\n    return (arrayValueSeparator \u003d\u003d sep) ? this : new Separators(rootSeparator, objectFieldValueSeparator, objectFieldValueSpacing, objectEntrySeparator, objectEntrySpacing, objectEmptySeparator, sep, arrayValueSpacing, arrayEmptySeparator);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i4 !\u003d $i5) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  c0 :\u003d @parameter0: char\n  $c1 \u003d Separators: char arrayValueSeparator\u003e\n  $i4 \u003d (int) $c1\n  $i5 \u003d (int) c0\n  if ($i4 !\u003d $i5) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d $r8\n  $r6 \u003d String rootSeparator\u003e\n  $c3 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r5 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c2 \u003d Separators: char objectEntrySeparator\u003e\n  $r4 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r3 \u003d String objectEmptySeparator\u003e\n  $r2 \u003d Separators$Spacing arrayValueSpacing\u003e\n  $r1 \u003d String arrayEmptySeparator\u003e\n  new Separators($r6, $c3, $r5, $c2, $r4, $r3, c0, $r2, $r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withArrayValueSpacing",
    "signature": "com.fasterxml.jackson.core.util.Separators withArrayValueSpacing(com.fasterxml.jackson.core.util.Separators$Spacing)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  Separators$Spacing\n  $r2 \u003d Separators$Spacing arrayValueSpacing\u003e\n  if ($r2 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d String rootSeparator\u003e\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r6 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r5 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r4 \u003d String objectEmptySeparator\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r3 \u003d String arrayEmptySeparator\u003e\n  new Separators($r7, $c2, $r6, $c1, $r5, $r4, $c0, r1, $r3)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.Separators",
    "methodName": "withArrayEmptySeparator",
    "signature": "com.fasterxml.jackson.core.util.Separators withArrayEmptySeparator(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    return Objects.equals(arrayEmptySeparator, sep) ? this : new Separators(rootSeparator, objectFieldValueSeparator, objectFieldValueSpacing, objectEntrySeparator, objectEntrySpacing, objectEmptySeparator, arrayValueSeparator, arrayValueSpacing, sep);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Separators\n  String\n  $r2 \u003d String arrayEmptySeparator\u003e\n  $z0 \u003d Objects.equals($r2, r1)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r8 \u003d Separators\n  $r7 \u003d String rootSeparator\u003e\n  $c2 \u003d Separators: char objectFieldValueSeparator\u003e\n  $r6 \u003d Separators$Spacing objectFieldValueSpacing\u003e\n  $c1 \u003d Separators: char objectEntrySeparator\u003e\n  $r5 \u003d Separators$Spacing objectEntrySpacing\u003e\n  $r4 \u003d String objectEmptySeparator\u003e\n  $c0 \u003d Separators: char arrayValueSeparator\u003e\n  $r3 \u003d Separators$Spacing arrayValueSpacing\u003e\n  new Separators($r7, $c2, $r6, $c1, $r5, $r4, $c0, $r3, r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "releaseBuffers",
    "signature": "void releaseBuffers()",
    "visibility": "public",
    "body": "{\r\n    // inlined `resetWithEmpty()` (except leaving `_resultString` as-is\r\n    {\r\n        _inputStart \u003d -1;\r\n        _currentSize \u003d 0;\r\n        _inputLen \u003d 0;\r\n        _inputBuffer \u003d null;\r\n        // note: _resultString retained (see https://github.com/FasterXML/jackson-databind/issues/2635\r\n        // for reason)\r\n        // should this be retained too?\r\n        _resultArray \u003d null;\r\n        if (_hasSegments) {\r\n            clearSegments();\r\n        }\r\n    }\r\n    if (_allocator !\u003d null) {\r\n        if (_currentSegment !\u003d null) {\r\n            // And then return that array\r\n            char[] buf \u003d _currentSegment;\r\n            _currentSegment \u003d null;\r\n            _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\r\n        }\r\n    }\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B5",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i1 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i1\n  TextBuffer: int _currentSize\u003e \u003d 0\n  TextBuffer: int _inputLen\u003e \u003d 0\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n}",
      "B2 {\n  $r1 \u003d BufferRecycler _allocator\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B5\n}",
      "B3 {\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  TextBuffer: char[] _currentSegment\u003e \u003d null\n  $r4 \u003d BufferRecycler _allocator\u003e\n  $r4.releaseCharBuffer(2, r3)\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWithEmpty",
    "signature": "void resetWithEmpty()",
    "visibility": "public",
    "body": "{\r\n    // indicates shared buffer not used\r\n    _inputStart \u003d -1;\r\n    _currentSize \u003d 0;\r\n    _inputLen \u003d 0;\r\n    _inputBuffer \u003d null;\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // And then reset internal input buffers, if necessary:\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i1 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i1\n  TextBuffer: int _currentSize\u003e \u003d 0\n  TextBuffer: int _inputLen\u003e \u003d 0\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWith",
    "signature": "void resetWith(char)",
    "visibility": "public",
    "body": "{\r\n    _inputStart \u003d -1;\r\n    _inputLen \u003d 0;\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    } else if (_currentSegment \u003d\u003d null) {\r\n        _currentSegment \u003d buf(1);\r\n    }\r\n    // lgtm [java/dereferenced-value-may-be-null]\r\n    _currentSegment[0] \u003d ch;\r\n    _currentSize \u003d _segmentSize \u003d 1;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  c0 :\u003d @parameter0: char\n  $i2 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i2\n  TextBuffer: int _inputLen\u003e \u003d 0\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n  goto B4\n}",
      "B2 {\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d r0.buf(1)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r2\n}",
      "B4 {\n  $r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  $r3[0] \u003d c0\n  TextBuffer: int _segmentSize\u003e \u003d 1\n  TextBuffer: int _currentSize\u003e \u003d 1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#buf(...1)",
        "body": "{\r\n    if (_allocator !\u003d null) {\r\n        return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\r\n    }\r\n    return new char[Math.max(needed, MIN_SEGMENT_LEN)];\r\n}"
      },
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWithShared",
    "signature": "void resetWithShared(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // First, let\u0027s clear intermediate values, if any:\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Then let\u0027s mark things we need about input buffer\r\n    _inputBuffer \u003d buf;\r\n    _inputStart \u003d offset;\r\n    _inputLen \u003d len;\r\n    // And then reset internal input buffers, if necessary:\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  r1 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  TextBuffer: char[] _inputBuffer\u003e \u003d r1\n  TextBuffer: int _inputStart\u003e \u003d i0\n  TextBuffer: int _inputLen\u003e \u003d i1\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWithCopy",
    "signature": "void resetWithCopy(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    _inputBuffer \u003d null;\r\n    // indicates shared buffer not used\r\n    _inputStart \u003d -1;\r\n    _inputLen \u003d 0;\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // And then reset internal input buffers, if necessary:\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    } else if (_currentSegment \u003d\u003d null) {\r\n        _currentSegment \u003d buf(len);\r\n    }\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n    append(buf, offset, len);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  r2 :\u003d @parameter0: char[]\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  $i3 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i3\n  TextBuffer: int _inputLen\u003e \u003d 0\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n  goto B4\n}",
      "B2 {\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.buf(i1)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r3\n}",
      "B4 {\n  TextBuffer: int _segmentSize\u003e \u003d 0\n  TextBuffer: int _currentSize\u003e \u003d 0\n  r0.append(r2, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#buf(...1)",
        "body": "{\r\n    if (_allocator !\u003d null) {\r\n        return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\r\n    }\r\n    return new char[Math.max(needed, MIN_SEGMENT_LEN)];\r\n}"
      },
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      },
      {
        "name": "TextBuffer#append(...3)",
        "body": "{\r\n    // Can\u0027t append to shared buf (sanity check)\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(len);\r\n    }\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Room in current segment?\r\n    char[] curr \u003d _currentSegment;\r\n    int max \u003d curr.length - _currentSize;\r\n    if (max \u003e\u003d len) {\r\n        System.arraycopy(c, start, curr, _currentSize, len);\r\n        _currentSize +\u003d len;\r\n        return;\r\n    }\r\n    validateAppend(len);\r\n    // No room for all, need to copy part(s):\r\n    if (max \u003e 0) {\r\n        System.arraycopy(c, start, curr, _currentSize, max);\r\n        start +\u003d max;\r\n        len -\u003d max;\r\n    }\r\n    // And then allocate new segment; we are guaranteed to now\r\n    // have enough room in segment.\r\n    do {\r\n        expand();\r\n        int amount \u003d Math.min(_currentSegment.length, len);\r\n        System.arraycopy(c, start, _currentSegment, 0, amount);\r\n        _currentSize +\u003d amount;\r\n        start +\u003d amount;\r\n        len -\u003d amount;\r\n    } while (len \u003e 0);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWithCopy",
    "signature": "void resetWithCopy(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    _inputBuffer \u003d null;\r\n    _inputStart \u003d -1;\r\n    _inputLen \u003d 0;\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    } else if (_currentSegment \u003d\u003d null) {\r\n        _currentSegment \u003d buf(len);\r\n    }\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n    append(text, start, len);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  String\n  i0 :\u003d @parameter1: int\n  i1 :\u003d @parameter2: int\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  $i3 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i3\n  TextBuffer: int _inputLen\u003e \u003d 0\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n  goto B4\n}",
      "B2 {\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.buf(i1)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r3\n}",
      "B4 {\n  TextBuffer: int _segmentSize\u003e \u003d 0\n  TextBuffer: int _currentSize\u003e \u003d 0\n  r0.append(r2, i0, i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#buf(...1)",
        "body": "{\r\n    if (_allocator !\u003d null) {\r\n        return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\r\n    }\r\n    return new char[Math.max(needed, MIN_SEGMENT_LEN)];\r\n}"
      },
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      },
      {
        "name": "TextBuffer#append(...3)",
        "body": "{\r\n    // Can\u0027t append to shared buf (sanity check)\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(len);\r\n    }\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Room in current segment?\r\n    char[] curr \u003d _currentSegment;\r\n    int max \u003d curr.length - _currentSize;\r\n    if (max \u003e\u003d len) {\r\n        System.arraycopy(c, start, curr, _currentSize, len);\r\n        _currentSize +\u003d len;\r\n        return;\r\n    }\r\n    validateAppend(len);\r\n    // No room for all, need to copy part(s):\r\n    if (max \u003e 0) {\r\n        System.arraycopy(c, start, curr, _currentSize, max);\r\n        start +\u003d max;\r\n        len -\u003d max;\r\n    }\r\n    // And then allocate new segment; we are guaranteed to now\r\n    // have enough room in segment.\r\n    do {\r\n        expand();\r\n        int amount \u003d Math.min(_currentSegment.length, len);\r\n        System.arraycopy(c, start, _currentSegment, 0, amount);\r\n        _currentSize +\u003d amount;\r\n        start +\u003d amount;\r\n        len -\u003d amount;\r\n    } while (len \u003e 0);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "resetWithString",
    "signature": "void resetWithString(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    _inputBuffer \u003d null;\r\n    _inputStart \u003d -1;\r\n    _inputLen \u003d 0;\r\n    validateStringLength(value.length());\r\n    _resultString \u003d value;\r\n    _resultArray \u003d null;\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    }\r\n    _currentSize \u003d 0;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  String\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  $i2 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i2\n  TextBuffer: int _inputLen\u003e \u003d 0\n  $i0 \u003d r1.length()\n  r0.validateStringLength($i0)\n  String _resultString\u003e \u003d r1\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n}",
      "B2 {\n  TextBuffer: int _currentSize\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      },
      {
        "name": "TextBuffer#validateStringLength(...1)",
        "body": "{\r\n    // no-op\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "size",
    "signature": "int size()",
    "visibility": "public",
    "body": "{\r\n    if (_inputStart \u003e\u003d 0) {\r\n        // shared copy from input buf\r\n        return _inputLen;\r\n    }\r\n    if (_resultArray !\u003d null) {\r\n        return _resultArray.length;\r\n    }\r\n    if (_resultString !\u003d null) {\r\n        return _resultString.length();\r\n    }\r\n    // local segmented buffers\r\n    return _segmentSize + _currentSize;\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r2 \u003d\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $i6 \u003d TextBuffer: int _inputLen\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d TextBuffer: char[] _resultArray\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d TextBuffer: char[] _resultArray\u003e\n  $i5 \u003d lengthof $r4\n  return\n}",
      "B4 {\n  $r2 \u003d String _resultString\u003e\n  if ($r2 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d String _resultString\u003e\n  $i4 \u003d $r3.length()\n  return\n}",
      "B6 {\n  $i2 \u003d TextBuffer: int _segmentSize\u003e\n  $i1 \u003d TextBuffer: int _currentSize\u003e\n  $i3 \u003d $i2 + $i1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "getTextOffset",
    "signature": "int getTextOffset()",
    "visibility": "public",
    "body": "{\r\n    /* Only shared input buffer can have non-zero offset; buffer\r\n         * segments start at 0, and if we have to create a combo buffer,\r\n         * that too will start from beginning of the buffer\r\n         */\r\n    return (_inputStart \u003e\u003d 0) ? _inputStart : 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $i1 \u003d TextBuffer: int _inputStart\u003e\n  goto B3\n}",
      "B2 {\n  $i1 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "hasTextAsCharacters",
    "signature": "boolean hasTextAsCharacters()",
    "visibility": "public",
    "body": "{\r\n    // if we have array in some form, sure\r\n    if (_inputStart \u003e\u003d 0 || _resultArray !\u003d null)\r\n        return true;\r\n    // not if we have String as value\r\n    if (_resultString !\u003d null)\r\n        return false;\r\n    return true;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003e\u003d 0) → B1 | else → B2",
      "B1 : If($r1 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($r2 \u003d\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003e\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d TextBuffer: char[] _resultArray\u003e\n  if ($r1 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  return\n}",
      "B3 {\n  $r2 \u003d String _resultString\u003e\n  if ($r2 \u003d\u003d null) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "getTextBuffer",
    "signature": "char[] getTextBuffer()",
    "visibility": "public",
    "body": "{\r\n    // Are we just using shared input buffer?\r\n    if (_inputStart \u003e\u003d 0)\r\n        return _inputBuffer;\r\n    if (_resultArray !\u003d null)\r\n        return _resultArray;\r\n    if (_resultString !\u003d null) {\r\n        return (_resultArray \u003d _resultString.toCharArray());\r\n    }\r\n    // Nope; but does it fit in just one segment?\r\n    if (!_hasSegments) {\r\n        return (_currentSegment \u003d\u003d null) ? NO_CHARS : _currentSegment;\r\n    }\r\n    // Nope, need to have/create a non-segmented array and return it\r\n    return contentsAsArray();\r\n}",
    "nodes": 12,
    "edges": 12,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($r1 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($r2 \u003d\u003d null) → B5 | else → B6",
      "B6 : If($z0 !\u003d 0) → B7 | else → B11",
      "B7 : If($r4 !\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  $r8 \u003d TextBuffer: char[] _inputBuffer\u003e\n  return\n}",
      "B2 {\n  $r1 \u003d TextBuffer: char[] _resultArray\u003e\n  if ($r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d TextBuffer: char[] _resultArray\u003e\n  return\n}",
      "B4 {\n  $r2 \u003d String _resultString\u003e\n  if ($r2 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r5 \u003d String _resultString\u003e\n  $r6 \u003d $r5.toCharArray()\n  TextBuffer: char[] _resultArray\u003e \u003d $r6\n  return\n}",
      "B6 {\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 !\u003d 0) goto B7 else B11\n}",
      "B7 {\n  $r4 \u003d TextBuffer: char[] _currentSegment\u003e\n  if ($r4 !\u003d null) goto B8 else B9\n}",
      "B8 {\n  $r9 \u003d TextBuffer: char[] NO_CHARS\u003e\n  goto B10\n}",
      "B9 {\n  $r9 \u003d TextBuffer: char[] _currentSegment\u003e\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $r3 \u003d r0.contentsAsArray()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B11",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#contentsAsArray(...0)",
        "body": "{\r\n    char[] result \u003d _resultArray;\r\n    if (result \u003d\u003d null) {\r\n        _resultArray \u003d result \u003d resultArray();\r\n    }\r\n    return result;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "contentsAsString",
    "signature": "java.lang.String contentsAsString()",
    "visibility": "public",
    "body": "{\r\n    if (_resultString \u003d\u003d null) {\r\n        // Has array been requested? Can make a shortcut, if so:\r\n        if (_resultArray !\u003d null) {\r\n            // _resultArray length should already be validated, no need to check again\r\n            _resultString \u003d new String(_resultArray);\r\n        } else {\r\n            // Do we use shared array?\r\n            if (_inputStart \u003e\u003d 0) {\r\n                if (_inputLen \u003c 1) {\r\n                    return (_resultString \u003d \"\");\r\n                }\r\n                validateStringLength(_inputLen);\r\n                _resultString \u003d new String(_inputBuffer, _inputStart, _inputLen);\r\n            } else {\r\n                // nope... need to copy\r\n                // But first, let\u0027s see if we have just one buffer\r\n                int segLen \u003d _segmentSize;\r\n                int currLen \u003d _currentSize;\r\n                if (segLen \u003d\u003d 0) {\r\n                    // yup\r\n                    if (currLen \u003d\u003d 0) {\r\n                        _resultString \u003d \"\";\r\n                    } else {\r\n                        validateStringLength(currLen);\r\n                        _resultString \u003d new String(_currentSegment, 0, currLen);\r\n                    }\r\n                } else {\r\n                    // no, need to combine\r\n                    final int builderLen \u003d segLen + currLen;\r\n                    if (builderLen \u003c 0) {\r\n                        _reportBufferOverflow(segLen, currLen);\r\n                    }\r\n                    validateStringLength(builderLen);\r\n                    StringBuilder sb \u003d new StringBuilder(builderLen);\r\n                    // First stored segments\r\n                    if (_segments !\u003d null) {\r\n                        for (int i \u003d 0, len \u003d _segments.size(); i \u003c len; ++i) {\r\n                            char[] curr \u003d _segments.get(i);\r\n                            sb.append(curr, 0, curr.length);\r\n                        }\r\n                    }\r\n                    // And finally, current segment:\r\n                    sb.append(_currentSegment, 0, _currentSize);\r\n                    _resultString \u003d sb.toString();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _resultString;\r\n}",
    "nodes": 19,
    "edges": 26,
    "cc": 9,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B18",
      "B1 : If($r2 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($i0 \u003c 0) → B4 | else → B7",
      "B4 : If($i7 \u003e\u003d 1) → B5 | else → B6",
      "B7 : If(i1 !\u003d 0) → B8 | else → B11",
      "B8 : If(i2 !\u003d 0) → B9 | else → B10",
      "B11 : If(i3 \u003e\u003d 0) → B12 | else → B13",
      "B13 : If($r4 \u003d\u003d null) → B14 | else → B17",
      "B15 : If(i11 \u003e\u003d i5) → B16 | else → B17"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $r1 \u003d String _resultString\u003e\n  if ($r1 !\u003d null) goto B1 else B18\n}",
      "B1 {\n  $r2 \u003d TextBuffer: char[] _resultArray\u003e\n  if ($r2 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r15 \u003d String\n  $r16 \u003d TextBuffer: char[] _resultArray\u003e\n  new String($r16)\n  String _resultString\u003e \u003d $r15\n  goto B18\n}",
      "B3 {\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B4 else B7\n}",
      "B4 {\n  $i7 \u003d TextBuffer: int _inputLen\u003e\n  if ($i7 \u003e\u003d 1) goto B5 else B6\n}",
      "B5 {\n  String _resultString\u003e \u003d \"\"\n  return\n}",
      "B6 {\n  $i8 \u003d TextBuffer: int _inputLen\u003e\n  r0.validateStringLength($i8)\n  $r13 \u003d String\n  $r14 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i10 \u003d TextBuffer: int _inputStart\u003e\n  $i9 \u003d TextBuffer: int _inputLen\u003e\n  new String($r14, $i10, $i9)\n  String _resultString\u003e \u003d $r13\n  goto B18\n}",
      "B7 {\n  i1 \u003d TextBuffer: int _segmentSize\u003e\n  i2 \u003d TextBuffer: int _currentSize\u003e\n  if (i1 !\u003d 0) goto B8 else B11\n}",
      "B8 {\n  if (i2 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  String _resultString\u003e \u003d \"\"\n  goto B18\n}",
      "B10 {\n  r0.validateStringLength(i2)\n  $r11 \u003d String\n  $r12 \u003d TextBuffer: char[] _currentSegment\u003e\n  new String($r12, 0, i2)\n  String _resultString\u003e \u003d $r11\n  goto B18\n}",
      "B11 {\n  i3 \u003d i1 + i2\n  if (i3 \u003e\u003d 0) goto B12 else B13\n}",
      "B12 {\n  r0._reportBufferOverflow(i1, i2)\n}",
      "B13 {\n  r0.validateStringLength(i3)\n  $r3 \u003d StringBuilder\n  new StringBuilder(i3)\n  $r4 \u003d ArrayList _segments\u003e\n  if ($r4 \u003d\u003d null) goto B14 else B17\n}",
      "B14 {\n  i11 \u003d 0\n  $r7 \u003d ArrayList _segments\u003e\n  i5 \u003d $r7.size()\n}",
      "B15 {\n  if (i11 \u003e\u003d i5) goto B16 else B17\n}",
      "B16 {\n  $r8 \u003d ArrayList _segments\u003e\n  $r9 \u003d $r8.get(i11)\n  r10 \u003d (char[]) $r9\n  $i6 \u003d lengthof r10\n  $r3.append(r10, 0, $i6)\n  i11 \u003d i11 + 1\n  goto B15\n}",
      "B17 {\n  $r5 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i4 \u003d TextBuffer: int _currentSize\u003e\n  $r3.append($r5, 0, $i4)\n  $r6 \u003d $r3.toString()\n  String _resultString\u003e \u003d $r6\n}",
      "B18 {\n  $r17 \u003d String _resultString\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B18",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B18",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B18",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B18",
      "B10 --\u003e B18",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B14",
      "B13 --\u003e B17",
      "B14 --\u003e B15",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B15",
      "B17 --\u003e B18",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#validateStringLength(...1)",
        "body": "{\r\n    // no-op\r\n}"
      },
      {
        "name": "TextBuffer#_reportBufferOverflow(...2)",
        "body": "{\r\n    long newSize \u003d (long) prev + (long) curr;\r\n    throw new IllegalStateException(\"TextBuffer overrun: size reached (\" + newSize + \") exceeds maximum of \" + Integer.MAX_VALUE);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "contentsAsArray",
    "signature": "char[] contentsAsArray()",
    "visibility": "public",
    "body": "{\r\n    char[] result \u003d _resultArray;\r\n    if (result \u003d\u003d null) {\r\n        _resultArray \u003d result \u003d resultArray();\r\n    }\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  r2 \u003d TextBuffer: char[] _resultArray\u003e\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d r0.resultArray()\n  r2 \u003d $r1\n  TextBuffer: char[] _resultArray\u003e \u003d $r1\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#resultArray(...0)",
        "body": "{\r\n    if (_resultString !\u003d null) {\r\n        // Can take a shortcut...\r\n        return _resultString.toCharArray();\r\n    }\r\n    // Do we use shared array?\r\n    if (_inputStart \u003e\u003d 0) {\r\n        final int len \u003d _inputLen;\r\n        if (len \u003c 1) {\r\n            return NO_CHARS;\r\n        }\r\n        validateStringLength(len);\r\n        final int start \u003d _inputStart;\r\n        if (start \u003d\u003d 0) {\r\n            return Arrays.copyOf(_inputBuffer, len);\r\n        }\r\n        return Arrays.copyOfRange(_inputBuffer, start, start + len);\r\n    }\r\n    // nope, not shared\r\n    int size \u003d size();\r\n    if (size \u003c 1) {\r\n        if (size \u003c 0) {\r\n            _reportBufferOverflow(_segmentSize, _currentSize);\r\n        }\r\n        return NO_CHARS;\r\n    }\r\n    validateStringLength(size);\r\n    int offset \u003d 0;\r\n    final char[] result \u003d carr(size);\r\n    if (_segments !\u003d null) {\r\n        for (int i \u003d 0, len \u003d _segments.size(); i \u003c len; ++i) {\r\n            char[] curr \u003d _segments.get(i);\r\n            int currLen \u003d curr.length;\r\n            System.arraycopy(curr, 0, result, offset, currLen);\r\n            offset +\u003d currLen;\r\n        }\r\n    }\r\n    System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\r\n    return result;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "contentsAsInt",
    "signature": "int contentsAsInt(boolean)",
    "visibility": "public",
    "body": "{\r\n    if ((_inputStart \u003e\u003d 0) \u0026\u0026 (_inputBuffer !\u003d null)) {\r\n        if (neg) {\r\n            return -NumberInput.parseInt(_inputBuffer, _inputStart + 1, _inputLen - 1);\r\n        }\r\n        return NumberInput.parseInt(_inputBuffer, _inputStart, _inputLen);\r\n    }\r\n    if (neg) {\r\n        return -NumberInput.parseInt(_currentSegment, 1, _currentSize - 1);\r\n    }\r\n    return NumberInput.parseInt(_currentSegment, 0, _currentSize);\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B5",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B5",
      "B2 : If(z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(z0 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  z0 :\u003d @parameter0: boolean\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B5\n}",
      "B1 {\n  $r3 \u003d TextBuffer: char[] _inputBuffer\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B5\n}",
      "B2 {\n  if (z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i10 \u003d TextBuffer: int _inputStart\u003e\n  $i13 \u003d $i10 + 1\n  $i11 \u003d TextBuffer: int _inputLen\u003e\n  $i12 \u003d $i11 - 1\n  $i14 \u003d NumberInput.parseInt($r5, $i13, $i12)\n  $i15 \u003d neg $i14\n  return\n}",
      "B4 {\n  $r4 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i8 \u003d TextBuffer: int _inputStart\u003e\n  $i7 \u003d TextBuffer: int _inputLen\u003e\n  $i9 \u003d NumberInput.parseInt($r4, $i8, $i7)\n  return\n}",
      "B5 {\n  if (z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i3 \u003d TextBuffer: int _currentSize\u003e\n  $i4 \u003d $i3 - 1\n  $i5 \u003d NumberInput.parseInt($r2, 1, $i4)\n  $i6 \u003d neg $i5\n  return\n}",
      "B7 {\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i1 \u003d TextBuffer: int _currentSize\u003e\n  $i2 \u003d NumberInput.parseInt($r1, 0, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "contentsAsLong",
    "signature": "long contentsAsLong(boolean)",
    "visibility": "public",
    "body": "{\r\n    if ((_inputStart \u003e\u003d 0) \u0026\u0026 (_inputBuffer !\u003d null)) {\r\n        if (neg) {\r\n            return -NumberInput.parseLong(_inputBuffer, _inputStart + 1, _inputLen - 1);\r\n        }\r\n        return NumberInput.parseLong(_inputBuffer, _inputStart, _inputLen);\r\n    }\r\n    if (neg) {\r\n        return -NumberInput.parseLong(_currentSegment, 1, _currentSize - 1);\r\n    }\r\n    return NumberInput.parseLong(_currentSegment, 0, _currentSize);\r\n}",
    "nodes": 8,
    "edges": 8,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B5",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B5",
      "B2 : If(z0 \u003d\u003d false) → B3 | else → B4",
      "B5 : If(z0 \u003d\u003d false) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  z0 :\u003d @parameter0: boolean\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B5\n}",
      "B1 {\n  $r3 \u003d TextBuffer: char[] _inputBuffer\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B5\n}",
      "B2 {\n  if (z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i10 \u003d TextBuffer: int _inputStart\u003e\n  $i13 \u003d $i10 + 1\n  $i11 \u003d TextBuffer: int _inputLen\u003e\n  $i12 \u003d $i11 - 1\n  $l14 \u003d NumberInput.parseLong($r5, $i13, $i12)\n  $l15 \u003d neg $l14\n  return\n}",
      "B4 {\n  $r4 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i8 \u003d TextBuffer: int _inputStart\u003e\n  $i7 \u003d TextBuffer: int _inputLen\u003e\n  $l9 \u003d NumberInput.parseLong($r4, $i8, $i7)\n  return\n}",
      "B5 {\n  if (z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i3 \u003d TextBuffer: int _currentSize\u003e\n  $i4 \u003d $i3 - 1\n  $l5 \u003d NumberInput.parseLong($r2, 1, $i4)\n  $l6 \u003d neg $l5\n  return\n}",
      "B7 {\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i1 \u003d TextBuffer: int _currentSize\u003e\n  $l2 \u003d NumberInput.parseLong($r1, 0, $i1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "contentsToWriter",
    "signature": "int contentsToWriter(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    if (_resultArray !\u003d null) {\r\n        w.write(_resultArray);\r\n        return _resultArray.length;\r\n    }\r\n    if (_resultString !\u003d null) {\r\n        // Can take a shortcut...\r\n        w.write(_resultString);\r\n        return _resultString.length();\r\n    }\r\n    // Do we use shared array?\r\n    if (_inputStart \u003e\u003d 0) {\r\n        final int len \u003d _inputLen;\r\n        if (len \u003e 0) {\r\n            w.write(_inputBuffer, _inputStart, len);\r\n        }\r\n        return len;\r\n    }\r\n    // nope, not shared\r\n    int total \u003d 0;\r\n    if (_segments !\u003d null) {\r\n        for (int i \u003d 0, end \u003d _segments.size(); i \u003c end; ++i) {\r\n            char[] curr \u003d _segments.get(i);\r\n            int currLen \u003d curr.length;\r\n            total +\u003d currLen;\r\n            w.write(curr, 0, currLen);\r\n        }\r\n    }\r\n    int len \u003d _currentSize;\r\n    if (len \u003e 0) {\r\n        total +\u003d len;\r\n        w.write(_currentSegment, 0, len);\r\n    }\r\n    return total;\r\n}",
    "nodes": 15,
    "edges": 18,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($r2 \u003d\u003d null) → B3 | else → B4",
      "B4 : If($i0 \u003c 0) → B5 | else → B8",
      "B5 : If(i7 \u003c\u003d 0) → B6 | else → B7",
      "B8 : If($r3 \u003d\u003d null) → B9 | else → B12",
      "B10 : If(i9 \u003e\u003d i1) → B11 | else → B12",
      "B12 : If($i2 \u003c\u003d 0) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  Writer\n  $r1 \u003d TextBuffer: char[] _resultArray\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r13 \u003d TextBuffer: char[] _resultArray\u003e\n  r4.write($r13)\n  $r14 \u003d TextBuffer: char[] _resultArray\u003e\n  $i6 \u003d lengthof $r14\n  return\n}",
      "B2 {\n  $r2 \u003d String _resultString\u003e\n  if ($r2 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r11 \u003d String _resultString\u003e\n  r4.write($r11)\n  $r12 \u003d String _resultString\u003e\n  $i5 \u003d $r12.length()\n  return\n}",
      "B4 {\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B5 else B8\n}",
      "B5 {\n  i7 \u003d TextBuffer: int _inputLen\u003e\n  if (i7 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r10 \u003d TextBuffer: char[] _inputBuffer\u003e\n  $i4 \u003d TextBuffer: int _inputStart\u003e\n  r4.write($r10, $i4, i7)\n}",
      "B7 {\n  return\n}",
      "B8 {\n  i8 \u003d 0\n  $r3 \u003d ArrayList _segments\u003e\n  if ($r3 \u003d\u003d null) goto B9 else B12\n}",
      "B9 {\n  i9 \u003d 0\n  $r6 \u003d ArrayList _segments\u003e\n  i1 \u003d $r6.size()\n}",
      "B10 {\n  if (i9 \u003e\u003d i1) goto B11 else B12\n}",
      "B11 {\n  $r7 \u003d ArrayList _segments\u003e\n  $r8 \u003d $r7.get(i9)\n  r9 \u003d (char[]) $r8\n  i3 \u003d lengthof r9\n  i8 \u003d i8 + i3\n  r4.write(r9, 0, i3)\n  i9 \u003d i9 + 1\n  goto B10\n}",
      "B12 {\n  $i2 \u003d TextBuffer: int _currentSize\u003e\n  if ($i2 \u003c\u003d 0) goto B13 else B14\n}",
      "B13 {\n  i8 \u003d i8 + $i2\n  $r5 \u003d TextBuffer: char[] _currentSegment\u003e\n  r4.write($r5, 0, $i2)\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B8",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B12",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B10",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "ensureNotShared",
    "signature": "void ensureNotShared()",
    "visibility": "public",
    "body": "{\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(16);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.unshare(16)\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#unshare(...1)",
        "body": "{\r\n    int sharedLen \u003d _inputLen;\r\n    _inputLen \u003d 0;\r\n    char[] inputBuf \u003d _inputBuffer;\r\n    _inputBuffer \u003d null;\r\n    int start \u003d _inputStart;\r\n    _inputStart \u003d -1;\r\n    // Is buffer big enough, or do we need to reallocate?\r\n    int needed \u003d sharedLen + needExtra;\r\n    if (_currentSegment \u003d\u003d null || needed \u003e _currentSegment.length) {\r\n        _currentSegment \u003d buf(needed);\r\n    }\r\n    if (sharedLen \u003e 0) {\r\n        System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\r\n    }\r\n    _segmentSize \u003d 0;\r\n    _currentSize \u003d sharedLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "append",
    "signature": "void append(char)",
    "visibility": "public",
    "body": "{\r\n    // Using shared buffer so far?\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(16);\r\n    }\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Room in current segment?\r\n    char[] curr \u003d _currentSegment;\r\n    if (_currentSize \u003e\u003d curr.length) {\r\n        validateAppend(1);\r\n        expand();\r\n        curr \u003d _currentSegment;\r\n    }\r\n    curr[_currentSize++] \u003d c;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($i2 \u003c $i1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  c5 :\u003d @parameter0: char\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.unshare(16)\n}",
      "B2 {\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  r2 \u003d $r1\n  $i2 \u003d TextBuffer: int _currentSize\u003e\n  $i1 \u003d lengthof $r1\n  if ($i2 \u003c $i1) goto B3 else B4\n}",
      "B3 {\n  r0.validateAppend(1)\n  r0.expand()\n  r2 \u003d TextBuffer: char[] _currentSegment\u003e\n}",
      "B4 {\n  $i3 \u003d TextBuffer: int _currentSize\u003e\n  $i4 \u003d $i3 + 1\n  TextBuffer: int _currentSize\u003e \u003d $i4\n  r2[$i3] \u003d c5\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#validateAppend(...1)",
        "body": "{\r\n    int newTotalLength \u003d _segmentSize + _currentSize + toAppend;\r\n    // guard against overflow\r\n    if (newTotalLength \u003c 0) {\r\n        newTotalLength \u003d Integer.MAX_VALUE;\r\n    }\r\n    validateStringLength(newTotalLength);\r\n}"
      },
      {
        "name": "TextBuffer#expand(...0)",
        "body": "{\r\n    // First, let\u0027s move current segment to segment list:\r\n    if (_segments \u003d\u003d null) {\r\n        _segments \u003d new ArrayList\u003c\u003e();\r\n    }\r\n    char[] curr \u003d _currentSegment;\r\n    _hasSegments \u003d true;\r\n    _segments.add(curr);\r\n    _segmentSize +\u003d curr.length;\r\n    if (_segmentSize \u003c 0) {\r\n        _reportBufferOverflow(_segmentSize - curr.length, curr.length);\r\n    }\r\n    _currentSize \u003d 0;\r\n    int oldLen \u003d curr.length;\r\n    // Let\u0027s grow segments by 50% minimum\r\n    int newLen \u003d oldLen + (oldLen \u003e\u003e 1);\r\n    if (newLen \u003c MIN_SEGMENT_LEN) {\r\n        newLen \u003d MIN_SEGMENT_LEN;\r\n    } else if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d MAX_SEGMENT_LEN;\r\n    }\r\n    _currentSegment \u003d carr(newLen);\r\n}"
      },
      {
        "name": "TextBuffer#unshare(...1)",
        "body": "{\r\n    int sharedLen \u003d _inputLen;\r\n    _inputLen \u003d 0;\r\n    char[] inputBuf \u003d _inputBuffer;\r\n    _inputBuffer \u003d null;\r\n    int start \u003d _inputStart;\r\n    _inputStart \u003d -1;\r\n    // Is buffer big enough, or do we need to reallocate?\r\n    int needed \u003d sharedLen + needExtra;\r\n    if (_currentSegment \u003d\u003d null || needed \u003e _currentSegment.length) {\r\n        _currentSegment \u003d buf(needed);\r\n    }\r\n    if (sharedLen \u003e 0) {\r\n        System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\r\n    }\r\n    _segmentSize \u003d 0;\r\n    _currentSize \u003d sharedLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "append",
    "signature": "void append(char[],int,int)",
    "visibility": "public",
    "body": "{\r\n    // Can\u0027t append to shared buf (sanity check)\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(len);\r\n    }\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Room in current segment?\r\n    char[] curr \u003d _currentSegment;\r\n    int max \u003d curr.length - _currentSize;\r\n    if (max \u003e\u003d len) {\r\n        System.arraycopy(c, start, curr, _currentSize, len);\r\n        _currentSize +\u003d len;\r\n        return;\r\n    }\r\n    validateAppend(len);\r\n    // No room for all, need to copy part(s):\r\n    if (max \u003e 0) {\r\n        System.arraycopy(c, start, curr, _currentSize, max);\r\n        start +\u003d max;\r\n        len -\u003d max;\r\n    }\r\n    // And then allocate new segment; we are guaranteed to now\r\n    // have enough room in segment.\r\n    do {\r\n        expand();\r\n        int amount \u003d Math.min(_currentSegment.length, len);\r\n        System.arraycopy(c, start, _currentSegment, 0, amount);\r\n        _currentSize +\u003d amount;\r\n        start +\u003d amount;\r\n        len -\u003d amount;\r\n    } while (len \u003e 0);\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($i7 \u003c i9) → B3 | else → B4",
      "B4 : If($i7 \u003c\u003d 0) → B5 | else → B6",
      "B6 : If($i14 \u003e 0) → B7 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  r1 :\u003d @parameter0: char[]\n  i8 :\u003d @parameter1: int\n  i9 :\u003d @parameter2: int\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.unshare(i9)\n}",
      "B2 {\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i2 \u003d lengthof $r2\n  $i1 \u003d TextBuffer: int _currentSize\u003e\n  $i7 \u003d $i2 - $i1\n  if ($i7 \u003c i9) goto B3 else B4\n}",
      "B3 {\n  $i4 \u003d TextBuffer: int _currentSize\u003e\n  System.arraycopy(r1, i8, $r2, $i4, i9)\n  $i5 \u003d TextBuffer: int _currentSize\u003e\n  $i6 \u003d $i5 + i9\n  TextBuffer: int _currentSize\u003e \u003d $i6\n  return\n}",
      "B4 {\n  r0.validateAppend(i9)\n  if ($i7 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i3 \u003d TextBuffer: int _currentSize\u003e\n  System.arraycopy(r1, i8, $r2, $i3, $i7)\n  i8 \u003d i8 + $i7\n  i9 \u003d i9 - $i7\n}",
      "B6 {\n  r0.expand()\n  $r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i10 \u003d lengthof $r3\n  $i11 \u003d Math.min($i10, i9)\n  $r4 \u003d TextBuffer: char[] _currentSegment\u003e\n  System.arraycopy(r1, i8, $r4, 0, $i11)\n  $i12 \u003d TextBuffer: int _currentSize\u003e\n  $i13 \u003d $i12 + $i11\n  TextBuffer: int _currentSize\u003e \u003d $i13\n  i8 \u003d i8 + $i11\n  $i14 \u003d i9 - $i11\n  i9 \u003d $i14\n  if ($i14 \u003e 0) goto B7 else B6\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B6",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#validateAppend(...1)",
        "body": "{\r\n    int newTotalLength \u003d _segmentSize + _currentSize + toAppend;\r\n    // guard against overflow\r\n    if (newTotalLength \u003c 0) {\r\n        newTotalLength \u003d Integer.MAX_VALUE;\r\n    }\r\n    validateStringLength(newTotalLength);\r\n}"
      },
      {
        "name": "TextBuffer#expand(...0)",
        "body": "{\r\n    // First, let\u0027s move current segment to segment list:\r\n    if (_segments \u003d\u003d null) {\r\n        _segments \u003d new ArrayList\u003c\u003e();\r\n    }\r\n    char[] curr \u003d _currentSegment;\r\n    _hasSegments \u003d true;\r\n    _segments.add(curr);\r\n    _segmentSize +\u003d curr.length;\r\n    if (_segmentSize \u003c 0) {\r\n        _reportBufferOverflow(_segmentSize - curr.length, curr.length);\r\n    }\r\n    _currentSize \u003d 0;\r\n    int oldLen \u003d curr.length;\r\n    // Let\u0027s grow segments by 50% minimum\r\n    int newLen \u003d oldLen + (oldLen \u003e\u003e 1);\r\n    if (newLen \u003c MIN_SEGMENT_LEN) {\r\n        newLen \u003d MIN_SEGMENT_LEN;\r\n    } else if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d MAX_SEGMENT_LEN;\r\n    }\r\n    _currentSegment \u003d carr(newLen);\r\n}"
      },
      {
        "name": "TextBuffer#unshare(...1)",
        "body": "{\r\n    int sharedLen \u003d _inputLen;\r\n    _inputLen \u003d 0;\r\n    char[] inputBuf \u003d _inputBuffer;\r\n    _inputBuffer \u003d null;\r\n    int start \u003d _inputStart;\r\n    _inputStart \u003d -1;\r\n    // Is buffer big enough, or do we need to reallocate?\r\n    int needed \u003d sharedLen + needExtra;\r\n    if (_currentSegment \u003d\u003d null || needed \u003e _currentSegment.length) {\r\n        _currentSegment \u003d buf(needed);\r\n    }\r\n    if (sharedLen \u003e 0) {\r\n        System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\r\n    }\r\n    _segmentSize \u003d 0;\r\n    _currentSize \u003d sharedLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "append",
    "signature": "void append(java.lang.String,int,int)",
    "visibility": "public",
    "body": "{\r\n    // Can\u0027t append to shared buf (sanity check)\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(len);\r\n    }\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // Room in current segment?\r\n    char[] curr \u003d _currentSegment;\r\n    int max \u003d curr.length - _currentSize;\r\n    if (max \u003e\u003d len) {\r\n        str.getChars(offset, offset + len, curr, _currentSize);\r\n        _currentSize +\u003d len;\r\n        return;\r\n    }\r\n    validateAppend(len);\r\n    // No room for all, need to copy part(s):\r\n    if (max \u003e 0) {\r\n        str.getChars(offset, offset + max, curr, _currentSize);\r\n        len -\u003d max;\r\n        offset +\u003d max;\r\n    }\r\n    // And then allocate new segment; we are guaranteed to now\r\n    // have enough room in segment.\r\n    do {\r\n        expand();\r\n        int amount \u003d Math.min(_currentSegment.length, len);\r\n        str.getChars(offset, offset + amount, _currentSegment, 0);\r\n        _currentSize +\u003d amount;\r\n        offset +\u003d amount;\r\n        len -\u003d amount;\r\n    } while (len \u003e 0);\r\n}",
    "nodes": 8,
    "edges": 10,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If($i9 \u003c i11) → B3 | else → B4",
      "B4 : If($i9 \u003c\u003d 0) → B5 | else → B6",
      "B6 : If($i17 \u003e 0) → B7 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  String\n  i10 :\u003d @parameter1: int\n  i11 :\u003d @parameter2: int\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.unshare(i11)\n}",
      "B2 {\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i2 \u003d lengthof $r2\n  $i1 \u003d TextBuffer: int _currentSize\u003e\n  $i9 \u003d $i2 - $i1\n  if ($i9 \u003c i11) goto B3 else B4\n}",
      "B3 {\n  $i6 \u003d i10 + i11\n  $i5 \u003d TextBuffer: int _currentSize\u003e\n  r1.getChars(i10, $i6, $r2, $i5)\n  $i7 \u003d TextBuffer: int _currentSize\u003e\n  $i8 \u003d $i7 + i11\n  TextBuffer: int _currentSize\u003e \u003d $i8\n  return\n}",
      "B4 {\n  r0.validateAppend(i11)\n  if ($i9 \u003c\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $i4 \u003d i10 + $i9\n  $i3 \u003d TextBuffer: int _currentSize\u003e\n  r1.getChars(i10, $i4, $r2, $i3)\n  i11 \u003d i11 - $i9\n  i10 \u003d i10 + $i9\n}",
      "B6 {\n  r0.expand()\n  $r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i12 \u003d lengthof $r3\n  $i13 \u003d Math.min($i12, i11)\n  $i14 \u003d i10 + $i13\n  $r4 \u003d TextBuffer: char[] _currentSegment\u003e\n  r1.getChars(i10, $i14, $r4, 0)\n  $i15 \u003d TextBuffer: int _currentSize\u003e\n  $i16 \u003d $i15 + $i13\n  TextBuffer: int _currentSize\u003e \u003d $i16\n  i10 \u003d i10 + $i13\n  $i17 \u003d i11 - $i13\n  i11 \u003d $i17\n  if ($i17 \u003e 0) goto B7 else B6\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B6",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#validateAppend(...1)",
        "body": "{\r\n    int newTotalLength \u003d _segmentSize + _currentSize + toAppend;\r\n    // guard against overflow\r\n    if (newTotalLength \u003c 0) {\r\n        newTotalLength \u003d Integer.MAX_VALUE;\r\n    }\r\n    validateStringLength(newTotalLength);\r\n}"
      },
      {
        "name": "TextBuffer#expand(...0)",
        "body": "{\r\n    // First, let\u0027s move current segment to segment list:\r\n    if (_segments \u003d\u003d null) {\r\n        _segments \u003d new ArrayList\u003c\u003e();\r\n    }\r\n    char[] curr \u003d _currentSegment;\r\n    _hasSegments \u003d true;\r\n    _segments.add(curr);\r\n    _segmentSize +\u003d curr.length;\r\n    if (_segmentSize \u003c 0) {\r\n        _reportBufferOverflow(_segmentSize - curr.length, curr.length);\r\n    }\r\n    _currentSize \u003d 0;\r\n    int oldLen \u003d curr.length;\r\n    // Let\u0027s grow segments by 50% minimum\r\n    int newLen \u003d oldLen + (oldLen \u003e\u003e 1);\r\n    if (newLen \u003c MIN_SEGMENT_LEN) {\r\n        newLen \u003d MIN_SEGMENT_LEN;\r\n    } else if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d MAX_SEGMENT_LEN;\r\n    }\r\n    _currentSegment \u003d carr(newLen);\r\n}"
      },
      {
        "name": "TextBuffer#unshare(...1)",
        "body": "{\r\n    int sharedLen \u003d _inputLen;\r\n    _inputLen \u003d 0;\r\n    char[] inputBuf \u003d _inputBuffer;\r\n    _inputBuffer \u003d null;\r\n    int start \u003d _inputStart;\r\n    _inputStart \u003d -1;\r\n    // Is buffer big enough, or do we need to reallocate?\r\n    int needed \u003d sharedLen + needExtra;\r\n    if (_currentSegment \u003d\u003d null || needed \u003e _currentSegment.length) {\r\n        _currentSegment \u003d buf(needed);\r\n    }\r\n    if (sharedLen \u003e 0) {\r\n        System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\r\n    }\r\n    _segmentSize \u003d 0;\r\n    _currentSize \u003d sharedLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "getCurrentSegment",
    "signature": "char[] getCurrentSegment()",
    "visibility": "public",
    "body": "{\r\n    /* Since the intention of the caller is to directly add stuff into\r\n         * buffers, we should NOT have anything in shared buffer... ie. may\r\n         * need to unshare contents.\r\n         */\r\n    if (_inputStart \u003e\u003d 0) {\r\n        unshare(1);\r\n    } else {\r\n        char[] curr \u003d _currentSegment;\r\n        if (curr \u003d\u003d null) {\r\n            _currentSegment \u003d buf(0);\r\n        } else if (_currentSize \u003e\u003d curr.length) {\r\n            // Plus, we better have room for at least one more char\r\n            expand();\r\n        }\r\n    }\r\n    return _currentSegment;\r\n}",
    "nodes": 7,
    "edges": 9,
    "cc": 4,
    "flowSummary": [
      "B0 : If($i0 \u003c 0) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B4",
      "B4 : If($i2 \u003c $i1) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i0 \u003d TextBuffer: int _inputStart\u003e\n  if ($i0 \u003c 0) goto B1 else B2\n}",
      "B1 {\n  r0.unshare(1)\n  goto B6\n}",
      "B2 {\n  r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  if (r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d r0.buf(0)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r2\n  goto B6\n}",
      "B4 {\n  $i2 \u003d TextBuffer: int _currentSize\u003e\n  $i1 \u003d lengthof r1\n  if ($i2 \u003c $i1) goto B5 else B6\n}",
      "B5 {\n  r0.expand()\n}",
      "B6 {\n  $r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B6",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#buf(...1)",
        "body": "{\r\n    if (_allocator !\u003d null) {\r\n        return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\r\n    }\r\n    return new char[Math.max(needed, MIN_SEGMENT_LEN)];\r\n}"
      },
      {
        "name": "TextBuffer#expand(...0)",
        "body": "{\r\n    // First, let\u0027s move current segment to segment list:\r\n    if (_segments \u003d\u003d null) {\r\n        _segments \u003d new ArrayList\u003c\u003e();\r\n    }\r\n    char[] curr \u003d _currentSegment;\r\n    _hasSegments \u003d true;\r\n    _segments.add(curr);\r\n    _segmentSize +\u003d curr.length;\r\n    if (_segmentSize \u003c 0) {\r\n        _reportBufferOverflow(_segmentSize - curr.length, curr.length);\r\n    }\r\n    _currentSize \u003d 0;\r\n    int oldLen \u003d curr.length;\r\n    // Let\u0027s grow segments by 50% minimum\r\n    int newLen \u003d oldLen + (oldLen \u003e\u003e 1);\r\n    if (newLen \u003c MIN_SEGMENT_LEN) {\r\n        newLen \u003d MIN_SEGMENT_LEN;\r\n    } else if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d MAX_SEGMENT_LEN;\r\n    }\r\n    _currentSegment \u003d carr(newLen);\r\n}"
      },
      {
        "name": "TextBuffer#unshare(...1)",
        "body": "{\r\n    int sharedLen \u003d _inputLen;\r\n    _inputLen \u003d 0;\r\n    char[] inputBuf \u003d _inputBuffer;\r\n    _inputBuffer \u003d null;\r\n    int start \u003d _inputStart;\r\n    _inputStart \u003d -1;\r\n    // Is buffer big enough, or do we need to reallocate?\r\n    int needed \u003d sharedLen + needExtra;\r\n    if (_currentSegment \u003d\u003d null || needed \u003e _currentSegment.length) {\r\n        _currentSegment \u003d buf(needed);\r\n    }\r\n    if (sharedLen \u003e 0) {\r\n        System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\r\n    }\r\n    _segmentSize \u003d 0;\r\n    _currentSize \u003d sharedLen;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "emptyAndGetCurrentSegment",
    "signature": "char[] emptyAndGetCurrentSegment()",
    "visibility": "public",
    "body": "{\r\n    // inlined \u0027resetWithEmpty()\u0027\r\n    // indicates shared buffer not used\r\n    _inputStart \u003d -1;\r\n    _currentSize \u003d 0;\r\n    _inputLen \u003d 0;\r\n    _inputBuffer \u003d null;\r\n    _resultString \u003d null;\r\n    _resultArray \u003d null;\r\n    // And then reset internal input buffers, if necessary:\r\n    if (_hasSegments) {\r\n        clearSegments();\r\n    }\r\n    char[] curr \u003d _currentSegment;\r\n    if (curr \u003d\u003d null) {\r\n        _currentSegment \u003d curr \u003d buf(0);\r\n    }\r\n    return curr;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($r2 !\u003d null) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $i1 \u003d (int) -1\n  TextBuffer: int _inputStart\u003e \u003d $i1\n  TextBuffer: int _currentSize\u003e \u003d 0\n  TextBuffer: int _inputLen\u003e \u003d 0\n  TextBuffer: char[] _inputBuffer\u003e \u003d null\n  String _resultString\u003e \u003d null\n  TextBuffer: char[] _resultArray\u003e \u003d null\n  $z0 \u003d TextBuffer: boolean _hasSegments\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r0.clearSegments()\n}",
      "B2 {\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  r3 \u003d $r2\n  if ($r2 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r1 \u003d r0.buf(0)\n  r3 \u003d $r1\n  TextBuffer: char[] _currentSegment\u003e \u003d $r1\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#buf(...1)",
        "body": "{\r\n    if (_allocator !\u003d null) {\r\n        return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\r\n    }\r\n    return new char[Math.max(needed, MIN_SEGMENT_LEN)];\r\n}"
      },
      {
        "name": "TextBuffer#clearSegments(...0)",
        "body": "{\r\n    _hasSegments \u003d false;\r\n    // Let\u0027s start using _last_ segment from list; for one, it\u0027s\r\n    // the biggest one, and it\u0027s also most likely to be cached\r\n    // 28-Aug-2009, tatu: Actually, the current segment should\r\n    //   be the biggest one, already\r\n    //_currentSegment \u003d _segments.get(_segments.size() - 1);\r\n    _segments.clear();\r\n    _currentSize \u003d _segmentSize \u003d 0;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "setCurrentAndReturn",
    "signature": "java.lang.String setCurrentAndReturn(int)",
    "visibility": "public",
    "body": "{\r\n    _currentSize \u003d len;\r\n    // We can simplify handling here compared to full `contentsAsString()`:\r\n    if (_segmentSize \u003e 0) {\r\n        // longer text; call main method\r\n        return contentsAsString();\r\n    }\r\n    // more common case: single segment\r\n    int currLen \u003d _currentSize;\r\n    validateStringLength(currLen);\r\n    String str \u003d (currLen \u003d\u003d 0) ? \"\" : new String(_currentSegment, 0, currLen);\r\n    _resultString \u003d str;\r\n    return str;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i1 \u003c\u003d 0) → B1 | else → B2",
      "B2 : If(i2 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  i0 :\u003d @parameter0: int\n  TextBuffer: int _currentSize\u003e \u003d i0\n  $i1 \u003d TextBuffer: int _segmentSize\u003e\n  if ($i1 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.contentsAsString()\n  return\n}",
      "B2 {\n  i2 \u003d TextBuffer: int _currentSize\u003e\n  r0.validateStringLength(i2)\n  if (i2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d \"\"\n  goto B5\n}",
      "B4 {\n  $r3 \u003d String\n  $r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  new String($r1, 0, i2)\n}",
      "B5 {\n  String _resultString\u003e \u003d $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#contentsAsString(...0)",
        "body": "{\r\n    if (_resultString \u003d\u003d null) {\r\n        // Has array been requested? Can make a shortcut, if so:\r\n        if (_resultArray !\u003d null) {\r\n            // _resultArray length should already be validated, no need to check again\r\n            _resultString \u003d new String(_resultArray);\r\n        } else {\r\n            // Do we use shared array?\r\n            if (_inputStart \u003e\u003d 0) {\r\n                if (_inputLen \u003c 1) {\r\n                    return (_resultString \u003d \"\");\r\n                }\r\n                validateStringLength(_inputLen);\r\n                _resultString \u003d new String(_inputBuffer, _inputStart, _inputLen);\r\n            } else {\r\n                // nope... need to copy\r\n                // But first, let\u0027s see if we have just one buffer\r\n                int segLen \u003d _segmentSize;\r\n                int currLen \u003d _currentSize;\r\n                if (segLen \u003d\u003d 0) {\r\n                    // yup\r\n                    if (currLen \u003d\u003d 0) {\r\n                        _resultString \u003d \"\";\r\n                    } else {\r\n                        validateStringLength(currLen);\r\n                        _resultString \u003d new String(_currentSegment, 0, currLen);\r\n                    }\r\n                } else {\r\n                    // no, need to combine\r\n                    final int builderLen \u003d segLen + currLen;\r\n                    if (builderLen \u003c 0) {\r\n                        _reportBufferOverflow(segLen, currLen);\r\n                    }\r\n                    validateStringLength(builderLen);\r\n                    StringBuilder sb \u003d new StringBuilder(builderLen);\r\n                    // First stored segments\r\n                    if (_segments !\u003d null) {\r\n                        for (int i \u003d 0, len \u003d _segments.size(); i \u003c len; ++i) {\r\n                            char[] curr \u003d _segments.get(i);\r\n                            sb.append(curr, 0, curr.length);\r\n                        }\r\n                    }\r\n                    // And finally, current segment:\r\n                    sb.append(_currentSegment, 0, _currentSize);\r\n                    _resultString \u003d sb.toString();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _resultString;\r\n}"
      },
      {
        "name": "TextBuffer#validateStringLength(...1)",
        "body": "{\r\n    // no-op\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "finishCurrentSegment",
    "signature": "char[] finishCurrentSegment()",
    "visibility": "public",
    "body": "{\r\n    if (_segments \u003d\u003d null) {\r\n        _segments \u003d new ArrayList\u003c\u003e();\r\n    }\r\n    _hasSegments \u003d true;\r\n    _segments.add(_currentSegment);\r\n    int oldLen \u003d _currentSegment.length;\r\n    _segmentSize +\u003d oldLen;\r\n    if (_segmentSize \u003c 0) {\r\n        _reportBufferOverflow(_segmentSize - oldLen, oldLen);\r\n    }\r\n    _currentSize \u003d 0;\r\n    validateStringLength(_segmentSize);\r\n    // Let\u0027s grow segments by 50%\r\n    int newLen \u003d oldLen + (oldLen \u003e\u003e 1);\r\n    if (newLen \u003c MIN_SEGMENT_LEN) {\r\n        newLen \u003d MIN_SEGMENT_LEN;\r\n    } else if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d MAX_SEGMENT_LEN;\r\n    }\r\n    char[] curr \u003d carr(newLen);\r\n    _currentSegment \u003d curr;\r\n    return curr;\r\n}",
    "nodes": 9,
    "edges": 12,
    "cc": 5,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($i2 \u003e\u003d 0) → B3 | else → B4",
      "B4 : If($i7 \u003e\u003d 500) → B5 | else → B6",
      "B6 : If($i7 \u003c\u003d 65536) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  $r1 \u003d ArrayList _segments\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d ArrayList\n  new ArrayList()\n  ArrayList _segments\u003e \u003d $r5\n}",
      "B2 {\n  TextBuffer: boolean _hasSegments\u003e \u003d 1\n  $r3 \u003d ArrayList _segments\u003e\n  $r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $r3.add($r2)\n  $r4 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i8 \u003d lengthof $r4\n  $i0 \u003d TextBuffer: int _segmentSize\u003e\n  $i1 \u003d $i0 + $i8\n  TextBuffer: int _segmentSize\u003e \u003d $i1\n  $i2 \u003d TextBuffer: int _segmentSize\u003e\n  if ($i2 \u003e\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $i5 \u003d TextBuffer: int _segmentSize\u003e\n  $i6 \u003d $i5 - $i8\n  r0._reportBufferOverflow($i6, $i8)\n}",
      "B4 {\n  TextBuffer: int _currentSize\u003e \u003d 0\n  $i3 \u003d TextBuffer: int _segmentSize\u003e\n  r0.validateStringLength($i3)\n  $i4 \u003d $i8 \u003e\u003e 1\n  $i7 \u003d $i8 + $i4\n  i9 \u003d $i7\n  if ($i7 \u003e\u003d 500) goto B5 else B6\n}",
      "B5 {\n  i9 \u003d 500\n  goto B8\n}",
      "B6 {\n  if ($i7 \u003c\u003d 65536) goto B7 else B8\n}",
      "B7 {\n  i9 \u003d 65536\n}",
      "B8 {\n  $r6 \u003d r0.carr(i9)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B8",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#carr(...1)",
        "body": "{\r\n    return new char[len];\r\n}"
      },
      {
        "name": "TextBuffer#_reportBufferOverflow(...2)",
        "body": "{\r\n    long newSize \u003d (long) prev + (long) curr;\r\n    throw new IllegalStateException(\"TextBuffer overrun: size reached (\" + newSize + \") exceeds maximum of \" + Integer.MAX_VALUE);\r\n}"
      },
      {
        "name": "TextBuffer#validateStringLength(...1)",
        "body": "{\r\n    // no-op\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "finishAndReturn",
    "signature": "java.lang.String finishAndReturn(int,boolean)",
    "visibility": "public",
    "body": "{\r\n    if (trimTrailingSpaces) {\r\n        // First, see if it\u0027s enough to trim end of current segment:\r\n        int ptr \u003d lastSegmentEnd - 1;\r\n        if (ptr \u003c 0 || _currentSegment[ptr] \u003c\u003d 0x0020) {\r\n            return _doTrim(ptr);\r\n        }\r\n    }\r\n    _currentSize \u003d lastSegmentEnd;\r\n    return contentsAsString();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B4",
      "B1 : If(i1 \u003c 0) → B2 | else → B3",
      "B2 : If($i3 \u003e 32) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  i0 :\u003d @parameter0: int\n  z0 :\u003d @parameter1: boolean\n  if (z0 \u003d\u003d false) goto B1 else B4\n}",
      "B1 {\n  i1 \u003d i0 - 1\n  if (i1 \u003c 0) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d TextBuffer: char[] _currentSegment\u003e\n  $c2 \u003d $r3[i1]\n  $i3 \u003d (int) $c2\n  if ($i3 \u003e 32) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d r0._doTrim(i1)\n  return\n}",
      "B4 {\n  TextBuffer: int _currentSize\u003e \u003d i0\n  $r1 \u003d r0.contentsAsString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TextBuffer#contentsAsString(...0)",
        "body": "{\r\n    if (_resultString \u003d\u003d null) {\r\n        // Has array been requested? Can make a shortcut, if so:\r\n        if (_resultArray !\u003d null) {\r\n            // _resultArray length should already be validated, no need to check again\r\n            _resultString \u003d new String(_resultArray);\r\n        } else {\r\n            // Do we use shared array?\r\n            if (_inputStart \u003e\u003d 0) {\r\n                if (_inputLen \u003c 1) {\r\n                    return (_resultString \u003d \"\");\r\n                }\r\n                validateStringLength(_inputLen);\r\n                _resultString \u003d new String(_inputBuffer, _inputStart, _inputLen);\r\n            } else {\r\n                // nope... need to copy\r\n                // But first, let\u0027s see if we have just one buffer\r\n                int segLen \u003d _segmentSize;\r\n                int currLen \u003d _currentSize;\r\n                if (segLen \u003d\u003d 0) {\r\n                    // yup\r\n                    if (currLen \u003d\u003d 0) {\r\n                        _resultString \u003d \"\";\r\n                    } else {\r\n                        validateStringLength(currLen);\r\n                        _resultString \u003d new String(_currentSegment, 0, currLen);\r\n                    }\r\n                } else {\r\n                    // no, need to combine\r\n                    final int builderLen \u003d segLen + currLen;\r\n                    if (builderLen \u003c 0) {\r\n                        _reportBufferOverflow(segLen, currLen);\r\n                    }\r\n                    validateStringLength(builderLen);\r\n                    StringBuilder sb \u003d new StringBuilder(builderLen);\r\n                    // First stored segments\r\n                    if (_segments !\u003d null) {\r\n                        for (int i \u003d 0, len \u003d _segments.size(); i \u003c len; ++i) {\r\n                            char[] curr \u003d _segments.get(i);\r\n                            sb.append(curr, 0, curr.length);\r\n                        }\r\n                    }\r\n                    // And finally, current segment:\r\n                    sb.append(_currentSegment, 0, _currentSize);\r\n                    _resultString \u003d sb.toString();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _resultString;\r\n}"
      },
      {
        "name": "TextBuffer#_doTrim(...1)",
        "body": "{\r\n    while (true) {\r\n        final char[] curr \u003d _currentSegment;\r\n        while (--ptr \u003e\u003d 0) {\r\n            if (curr[ptr] \u003e 0x0020) {\r\n                // found the ending non-space char, all done:\r\n                _currentSize \u003d ptr + 1;\r\n                return contentsAsString();\r\n            }\r\n        }\r\n        // nope: need to handle previous segment; if there is one:\r\n        if (_segments \u003d\u003d null || _segments.isEmpty()) {\r\n            break;\r\n        }\r\n        _currentSegment \u003d _segments.remove(_segments.size() - 1);\r\n        ptr \u003d _currentSegment.length;\r\n    }\r\n    // we get here if everything was trimmed, so:\r\n    _currentSize \u003d 0;\r\n    _hasSegments \u003d false;\r\n    return contentsAsString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "expandCurrentSegment",
    "signature": "char[] expandCurrentSegment()",
    "visibility": "public",
    "body": "{\r\n    final char[] curr \u003d _currentSegment;\r\n    // Let\u0027s grow by 50% by default\r\n    final int len \u003d curr.length;\r\n    int newLen \u003d len + (len \u003e\u003e 1);\r\n    // but above intended maximum, slow to increase by 25%\r\n    if (newLen \u003e MAX_SEGMENT_LEN) {\r\n        newLen \u003d len + (len \u003e\u003e 2);\r\n    }\r\n    return (_currentSegment \u003d Arrays.copyOf(curr, newLen));\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i3 \u003c\u003d 65536) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  r1 \u003d TextBuffer: char[] _currentSegment\u003e\n  i0 \u003d lengthof r1\n  $i1 \u003d i0 \u003e\u003e 1\n  i3 \u003d i0 + $i1\n  if (i3 \u003c\u003d 65536) goto B1 else B2\n}",
      "B1 {\n  $i2 \u003d i0 \u003e\u003e 2\n  i3 \u003d i0 + $i2\n}",
      "B2 {\n  $r2 \u003d Arrays.copyOf(r1, i3)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r2\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.TextBuffer",
    "methodName": "expandCurrentSegment",
    "signature": "char[] expandCurrentSegment(int)",
    "visibility": "public",
    "body": "{\r\n    char[] curr \u003d _currentSegment;\r\n    if (curr.length \u003e\u003d minSize)\r\n        return curr;\r\n    _currentSegment \u003d curr \u003d Arrays.copyOf(curr, minSize);\r\n    return curr;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i1 \u003c i0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TextBuffer\n  i0 :\u003d @parameter0: int\n  r2 \u003d TextBuffer: char[] _currentSegment\u003e\n  $i1 \u003d lengthof r2\n  if ($i1 \u003c i0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d Arrays.copyOf(r2, i0)\n  TextBuffer: char[] _currentSegment\u003e \u003d $r1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.VersionUtil",
    "methodName": "versionFor",
    "signature": "com.fasterxml.jackson.core.Version versionFor(java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    Version v \u003d null;\r\n    try {\r\n        String versionInfoClassName \u003d cls.getPackage().getName() + \".PackageVersion\";\r\n        Class\u003c?\u003e vClass \u003d Class.forName(versionInfoClassName, true, cls.getClassLoader());\r\n        // However, if class exists, it better work correctly, no swallowing exceptions\r\n        try {\r\n            v \u003d ((Versioned) vClass.getDeclaredConstructor().newInstance()).version();\r\n        } catch (Exception e) {\r\n            throw new IllegalArgumentException(\"Failed to get Versioned out of \" + vClass);\r\n        }\r\n    } catch (Exception e) {\r\n        // ok to be missing (not good but acceptable)\r\n        ;\r\n    }\r\n    return (v \u003d\u003d null) ? Version.unknownVersion() : v;\r\n}",
    "nodes": 8,
    "edges": 7,
    "cc": 1,
    "flowSummary": [
      "B4 : If(r15 !\u003d null) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  Class\n  r15 \u003d null\n  $r1 \u003d r0.getPackage()\n  $r2 \u003d $r1.getName()\n  r16 \u003d dynInvoke makeConcatWithConstants($r2)\n  $r3 \u003d r0.getClassLoader()\n  r4 \u003d Class.forName(r16, 1, $r3)\n  $r5 \u003d Class)[0]\n  $r7 \u003d r4.getDeclaredConstructor($r5)\n  $r6 \u003d Object)[0]\n  $r8 \u003d $r7.newInstance($r6)\n  $r9 \u003d Versioned) $r8\n  r15 \u003d $r9.version()\n  goto B2\n}",
      "B1 {\n  $r11 :\u003d @caughtexception\n  $r12 \u003d IllegalArgumentException\n  $r13 \u003d String.valueOf(r4)\n  $r14 \u003d dynInvoke makeConcatWithConstants($r13)\n  new IllegalArgumentException($r14)\n  throw $r12\n}",
      "B2 {\n  goto B4\n}",
      "B3 {\n  $r10 :\u003d @caughtexception\n}",
      "B4 {\n  if (r15 !\u003d null) goto B5 else B6\n}",
      "B5 {\n  $r17 \u003d Version.unknownVersion()\n  goto B7\n}",
      "B6 {\n  $r17 \u003d r15\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.util.VersionUtil",
    "methodName": "parseVersion",
    "signature": "com.fasterxml.jackson.core.Version parseVersion(java.lang.String,java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (s !\u003d null \u0026\u0026 (s \u003d s.trim()).length() \u003e 0) {\r\n        String[] parts \u003d V_SEP.split(s);\r\n        return new Version(parseVersionPart(parts[0]), (parts.length \u003e 1) ? parseVersionPart(parts[1]) : 0, (parts.length \u003e 2) ? parseVersionPart(parts[2]) : 0, (parts.length \u003e 3) ? parts[3] : null, groupId, artifactId);\r\n    }\r\n    return Version.unknownVersion();\r\n}",
    "nodes": 13,
    "edges": 16,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r9 \u003d\u003d null) → B1 | else → B12",
      "B1 : If($i0 \u003c\u003d 0) → B2 | else → B12",
      "B2 : If($i1 \u003c\u003d 1) → B3 | else → B4",
      "B5 : If($i2 \u003c\u003d 2) → B6 | else → B7",
      "B8 : If($i6 \u003c\u003d 3) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  String\n  String\n  String\n  if (r9 \u003d\u003d null) goto B1 else B12\n}",
      "B1 {\n  $r1 \u003d r9.trim()\n  $i0 \u003d $r1.length()\n  if ($i0 \u003c\u003d 0) goto B2 else B12\n}",
      "B2 {\n  $r2 \u003d Pattern V_SEP\u003e\n  r3 \u003d $r2.split($r1)\n  $r10 \u003d Version\n  $r4 \u003d r3[0]\n  $i3 \u003d VersionUtil.parseVersionPart($r4)\n  $i1 \u003d lengthof r3\n  if ($i1 \u003c\u003d 1) goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d r3[1]\n  $i4 \u003d VersionUtil.parseVersionPart($r8)\n  goto B5\n}",
      "B4 {\n  $i4 \u003d 0\n}",
      "B5 {\n  $i2 \u003d lengthof r3\n  if ($i2 \u003c\u003d 2) goto B6 else B7\n}",
      "B6 {\n  $r7 \u003d r3[2]\n  $i5 \u003d VersionUtil.parseVersionPart($r7)\n  goto B8\n}",
      "B7 {\n  $i5 \u003d 0\n}",
      "B8 {\n  $i6 \u003d lengthof r3\n  if ($i6 \u003c\u003d 3) goto B9 else B10\n}",
      "B9 {\n  $r11 \u003d r3[3]\n  goto B11\n}",
      "B10 {\n  $r11 \u003d null\n}",
      "B11 {\n  new Version($i3, $i4, $i5, $r11, r5, r6)\n  return\n}",
      "B12 {\n  $r0 \u003d Version.unknownVersion()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B12",
      "B1 --\u003e B2",
      "B1 --\u003e B12",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "VersionUtil#parseVersionPart(...1)",
        "body": "{\r\n    int number \u003d 0;\r\n    for (int i \u003d 0, len \u003d s.length(); i \u003c len; ++i) {\r\n        char c \u003d s.charAt(i);\r\n        if (c \u003e \u00279\u0027 || c \u003c \u00270\u0027)\r\n            break;\r\n        number \u003d (number * 10) + (c - \u00270\u0027);\r\n    }\r\n    return number;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Version",
    "methodName": "isUnknownVersion",
    "signature": "boolean isUnknownVersion()",
    "visibility": "public",
    "body": "{\r\n    return (this \u003d\u003d UNKNOWN_VERSION);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Version\n  $r1 \u003d Version UNKNOWN_VERSION\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Version",
    "methodName": "isSnapshot",
    "signature": "boolean isSnapshot()",
    "visibility": "public",
    "body": "{\r\n    return (_snapshotInfo !\u003d null) \u0026\u0026 !_snapshotInfo.isEmpty();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B3",
      "B1 : If($z0 !\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Version\n  $r1 \u003d String _snapshotInfo\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B3\n}",
      "B1 {\n  $r2 \u003d String _snapshotInfo\u003e\n  $z0 \u003d $r2.isEmpty()\n  if ($z0 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z1 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z1 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.fasterxml.jackson.core.Version",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    StringBuilder sb \u003d new StringBuilder();\r\n    sb.append(_majorVersion).append(\u0027.\u0027);\r\n    sb.append(_minorVersion).append(\u0027.\u0027);\r\n    sb.append(_patchLevel);\r\n    if (isSnapshot()) {\r\n        sb.append(\u0027-\u0027).append(_snapshotInfo);\r\n    }\r\n    return sb.toString();\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Version\n  $r0 \u003d StringBuilder\n  new StringBuilder()\n  $i0 \u003d Version: int _majorVersion\u003e\n  $r2 \u003d $r0.append($i0)\n  $r2.append(46)\n  $i1 \u003d Version: int _minorVersion\u003e\n  $r3 \u003d $r0.append($i1)\n  $r3.append(46)\n  $i2 \u003d Version: int _patchLevel\u003e\n  $r0.append($i2)\n  $z0 \u003d r1.isSnapshot()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d $r0.append(45)\n  $r5 \u003d String _snapshotInfo\u003e\n  $r6.append($r5)\n}",
      "B2 {\n  $r4 \u003d $r0.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Version#isSnapshot(...0)",
        "body": "{\r\n    return (_snapshotInfo !\u003d null) \u0026\u0026 !_snapshotInfo.isEmpty();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Version",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (o \u003d\u003d this)\r\n        return true;\r\n    if (o \u003d\u003d null)\r\n        return false;\r\n    if (o.getClass() !\u003d getClass())\r\n        return false;\r\n    Version other \u003d (Version) o;\r\n    return (other._majorVersion \u003d\u003d _majorVersion) \u0026\u0026 (other._minorVersion \u003d\u003d _minorVersion) \u0026\u0026 (other._patchLevel \u003d\u003d _patchLevel) \u0026\u0026 Objects.equals(other._snapshotInfo, _snapshotInfo) \u0026\u0026 other._artifactId.equals(_artifactId) \u0026\u0026 other._groupId.equals(_groupId);\r\n}",
    "nodes": 15,
    "edges": 20,
    "cc": 7,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d null) → B3 | else → B4",
      "B4 : If($r3 \u003d\u003d $r2) → B5 | else → B6",
      "B6 : If($i1 !\u003d $i0) → B7 | else → B13",
      "B7 : If($i3 !\u003d $i2) → B8 | else → B13",
      "B8 : If($i5 !\u003d $i4) → B9 | else → B13",
      "B9 : If($z0 \u003d\u003d false) → B10 | else → B13",
      "B10 : If($z1 \u003d\u003d false) → B11 | else → B13",
      "B11 : If($z2 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Version\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r0 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r4 \u003d Version) r0\n  $i1 \u003d Version: int _majorVersion\u003e\n  $i0 \u003d Version: int _majorVersion\u003e\n  if ($i1 !\u003d $i0) goto B7 else B13\n}",
      "B7 {\n  $i3 \u003d Version: int _minorVersion\u003e\n  $i2 \u003d Version: int _minorVersion\u003e\n  if ($i3 !\u003d $i2) goto B8 else B13\n}",
      "B8 {\n  $i5 \u003d Version: int _patchLevel\u003e\n  $i4 \u003d Version: int _patchLevel\u003e\n  if ($i5 !\u003d $i4) goto B9 else B13\n}",
      "B9 {\n  $r6 \u003d String _snapshotInfo\u003e\n  $r5 \u003d String _snapshotInfo\u003e\n  $z0 \u003d Objects.equals($r6, $r5)\n  if ($z0 \u003d\u003d false) goto B10 else B13\n}",
      "B10 {\n  $r8 \u003d String _artifactId\u003e\n  $r7 \u003d String _artifactId\u003e\n  $z1 \u003d $r8.equals($r7)\n  if ($z1 \u003d\u003d false) goto B11 else B13\n}",
      "B11 {\n  $r10 \u003d String _groupId\u003e\n  $r9 \u003d String _groupId\u003e\n  $z2 \u003d $r10.equals($r9)\n  if ($z2 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $z3 \u003d 1\n  goto B14\n}",
      "B13 {\n  $z3 \u003d 0\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B13",
      "B7 --\u003e B8",
      "B7 --\u003e B13",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B13",
      "B10 --\u003e B11",
      "B10 --\u003e B13",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Version#getClass(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.fasterxml.jackson.core.Version",
    "methodName": "compareTo",
    "signature": "int compareTo(com.fasterxml.jackson.core.Version)",
    "visibility": "public",
    "body": "{\r\n    if (other \u003d\u003d this)\r\n        return 0;\r\n    int diff \u003d _groupId.compareTo(other._groupId);\r\n    if (diff \u003d\u003d 0) {\r\n        diff \u003d _artifactId.compareTo(other._artifactId);\r\n        if (diff \u003d\u003d 0) {\r\n            diff \u003d _majorVersion - other._majorVersion;\r\n            if (diff \u003d\u003d 0) {\r\n                diff \u003d _minorVersion - other._minorVersion;\r\n                if (diff \u003d\u003d 0) {\r\n                    diff \u003d _patchLevel - other._patchLevel;\r\n                    if (diff \u003d\u003d 0) {\r\n                        // Snapshot: non-snapshot AFTER snapshot, otherwise alphabetical\r\n                        if (isSnapshot()) {\r\n                            if (other.isSnapshot()) {\r\n                                diff \u003d _snapshotInfo.compareTo(other._snapshotInfo);\r\n                            } else {\r\n                                diff \u003d -1;\r\n                            }\r\n                        } else if (other.isSnapshot()) {\r\n                            diff \u003d 1;\r\n                        } else {\r\n                            diff \u003d 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return diff;\r\n}",
    "nodes": 15,
    "edges": 22,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(i6 !\u003d 0) → B3 | else → B14",
      "B3 : If(i6 !\u003d 0) → B4 | else → B14",
      "B4 : If(i6 !\u003d 0) → B5 | else → B14",
      "B5 : If(i6 !\u003d 0) → B6 | else → B14",
      "B6 : If(i6 !\u003d 0) → B7 | else → B14",
      "B7 : If($z0 \u003d\u003d false) → B8 | else → B11",
      "B8 : If($z2 \u003d\u003d false) → B9 | else → B10",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  Version\n  Version\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r3 \u003d String _groupId\u003e\n  $r2 \u003d String _groupId\u003e\n  i6 \u003d $r3.compareTo($r2)\n  if (i6 !\u003d 0) goto B3 else B14\n}",
      "B3 {\n  $r5 \u003d String _artifactId\u003e\n  $r4 \u003d String _artifactId\u003e\n  i6 \u003d $r5.compareTo($r4)\n  if (i6 !\u003d 0) goto B4 else B14\n}",
      "B4 {\n  $i1 \u003d Version: int _majorVersion\u003e\n  $i0 \u003d Version: int _majorVersion\u003e\n  i6 \u003d $i1 - $i0\n  if (i6 !\u003d 0) goto B5 else B14\n}",
      "B5 {\n  $i3 \u003d Version: int _minorVersion\u003e\n  $i2 \u003d Version: int _minorVersion\u003e\n  i6 \u003d $i3 - $i2\n  if (i6 !\u003d 0) goto B6 else B14\n}",
      "B6 {\n  $i5 \u003d Version: int _patchLevel\u003e\n  $i4 \u003d Version: int _patchLevel\u003e\n  i6 \u003d $i5 - $i4\n  if (i6 !\u003d 0) goto B7 else B14\n}",
      "B7 {\n  $z0 \u003d r1.isSnapshot()\n  if ($z0 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  $z2 \u003d r0.isSnapshot()\n  if ($z2 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r7 \u003d String _snapshotInfo\u003e\n  $r6 \u003d String _snapshotInfo\u003e\n  i6 \u003d $r7.compareTo($r6)\n  goto B14\n}",
      "B10 {\n  $i8 \u003d (int) -1\n  i6 \u003d $i8\n  goto B14\n}",
      "B11 {\n  $z1 \u003d r0.isSnapshot()\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  i6 \u003d 1\n  goto B14\n}",
      "B13 {\n  i6 \u003d 0\n}",
      "B14 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B14",
      "B3 --\u003e B4",
      "B3 --\u003e B14",
      "B4 --\u003e B5",
      "B4 --\u003e B14",
      "B5 --\u003e B6",
      "B5 --\u003e B14",
      "B6 --\u003e B7",
      "B6 --\u003e B14",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B14",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Version#isSnapshot(...0)",
        "body": "{\r\n    return (_snapshotInfo !\u003d null) \u0026\u0026 !_snapshotInfo.isEmpty();\r\n}"
      }
    ]
  },
  {
    "clazz": "MethodAnalysisToJson",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 72,
    "edges": 101,
    "cc": 31,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B67",
      "B3 : If($z16 \u003d\u003d false) → B4 | else → B66",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B8 : If(i1 \u003d\u003d false) → B9 | else → B3",
      "B9 : If(i2 !\u003d 0) → B10 | else → B11",
      "B11 : If(i4 \u003e 0) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i13 \u003c\u003d 0) → B16 | else → B17",
      "B19 : If($z17 \u003d\u003d false) → B20 | else → B28",
      "B20 : If($i10 \u003e\u003d 2) → B21 | else → B22",
      "B22 : If($z13 \u003d\u003d false) → B23 | else → B24",
      "B24 : If($z14 !\u003d 0) → B25 | else → B26",
      "B25 : If($z15 \u003d\u003d false) → B26 | else → B19",
      "B28 : If(r140 \u003d\u003d null) → B29 | else → B32",
      "B29 : If($z11 \u003d\u003d false) → B30 | else → B32",
      "B30 : If($z12 \u003d\u003d false) → B31 | else → B32",
      "B32 : If($z18 \u003d\u003d false) → B33 | else → B36",
      "B33 : If(i11 \u003e\u003d i12) → B34 | else → B36",
      "B36 : If(r140 \u003d\u003d null) → B37 | else → B39",
      "B37 : If($z10 \u003d\u003d false) → B38 | else → B39",
      "B40 : If($z19 \u003d\u003d false) → B41 | else → B56",
      "B41 : If($z6 \u003d\u003d false) → B42 | else → B43",
      "B44 : If($z7 \u003d\u003d false) → B45 | else → B46",
      "B47 : If($z8 !\u003d 0) → B48 | else → B49",
      "B49 : If($z9 \u003d\u003d false) → B50 | else → B51",
      "B52 : If($r74 \u003d\u003d null) → B53 | else → B54",
      "B57 : If($z3 \u003d\u003d false) → B58 | else → B65",
      "B58 : If(r151 \u003d\u003d null) → B59 | else → B60",
      "B60 : If($z4 \u003d\u003d false) → B61 | else → B64",
      "B61 : If(r59 \u003d\u003d null) → B62 | else → B64",
      "B62 : If($z5 \u003d\u003d false) → B63 | else → B64"
    ],
    "blockList": [
      "B0 {\n  String[]\n  G.reset()\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r1 \u003d Options.v()\n  $r1.set_allow_phantom_refs(1)\n  $r3 \u003d Options.v()\n  $r2 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-core-jackson-core-2.19.1\\\\target\\\\classes\")\n  $r3.set_process_dir($r2)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r9 \u003d Options.v()\n  $r6 \u003d String pathSeparator\u003e\n  $r5 \u003d CharSequence)[2]\n  $r5[0] \u003d 1\\\\target\\\\classes\"\n  $r7 \u003d System.getProperty(\"java.class.path\")\n  $r5[1] \u003d $r7\n  $r8 \u003d String.join($r6, $r5)\n  $r9.set_soot_classpath($r8)\n  $r10 \u003d Scene.v()\n  $r10.loadNecessaryClasses()\n  $r11 \u003d HashMap\n  new HashMap()\n  $r13 \u003d Path SOURCE_ROOT\u003e\n  $r12 \u003d FileVisitOption)[0]\n  $r15 \u003d Files.walk($r13, $r12)\n  $r14 \u003d MethodAnalysisToJson$lambda_main_2__1.bootstrap$()\n  $r17 \u003d $r15.filter($r14)\n  $r16 \u003d MethodAnalysisToJson$lambda_main_3__2.bootstrap$($r11)\n  $r17.forEach($r16)\n  $r18 \u003d ArrayList\n  new ArrayList()\n  $r19 \u003d HashMap\n  new HashMap()\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  r119 \u003d $r20.iterator()\n}",
      "B1 {\n  $z0 \u003d r119.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B67\n}",
      "B2 {\n  $r28 \u003d r119.next()\n  r120 \u003d SootClass) $r28\n  $r29 \u003d ArrayList\n  $r30 \u003d r120.getMethods()\n  new ArrayList($r30)\n  r121 \u003d $r29.iterator()\n}",
      "B3 {\n  $z16 \u003d r121.hasNext()\n  if ($z16 \u003d\u003d false) goto B4 else B66\n}",
      "B4 {\n  $r31 \u003d r121.next()\n  r122 \u003d SootMethod) $r31\n  $z1 \u003d MethodAnalysisToJson.isEligible(r120, r122)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r32 \u003d r122.retrieveActiveBody()\n  goto B8\n}",
      "B7 {\n  $r117 :\u003d @caughtexception\n  goto B3\n}",
      "B8 {\n  $r33 \u003d BriefBlockGraph\n  new BriefBlockGraph(r32)\n  i1 \u003d $r33.size()\n  $r34 \u003d $r33.getBlocks()\n  $r36 \u003d $r34.stream()\n  $r35 \u003d MethodAnalysisToJson$lambda_main_4__3.bootstrap$($r33)\n  $r37 \u003d $r36.mapToInt($r35)\n  i2 \u003d $r37.sum()\n  $i3 \u003d i2 - i1\n  i4 \u003d $i3 + 2\n  if (i1 \u003d\u003d false) goto B9 else B3\n}",
      "B9 {\n  if (i2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  goto B3\n}",
      "B11 {\n  if (i4 \u003e 0) goto B12 else B13\n}",
      "B12 {\n  goto B3\n}",
      "B13 {\n  i11 \u003d 2147483647\n  i12 \u003d -2147483648\n  $r38 \u003d r32.getUnits()\n  r123 \u003d $r38.iterator()\n}",
      "B14 {\n  $z2 \u003d r123.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r113 \u003d r123.next()\n  r124 \u003d Unit) $r113\n  i13 \u003d r124.getJavaSourceStartLineNumber()\n  if (i13 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i11 \u003d Math.min(i11, i13)\n  i12 \u003d Math.max(i12, i13)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  $r39 \u003d ArrayList\n  new ArrayList()\n  r125 \u003d $r33.iterator()\n}",
      "B19 {\n  $z17 \u003d r125.hasNext()\n  if ($z17 \u003d\u003d false) goto B20 else B28\n}",
      "B20 {\n  $r105 \u003d r125.next()\n  r126 \u003d Block) $r105\n  r127 \u003d $r33.getSuccsOf(r126)\n  $i10 \u003d r127.size()\n  if ($i10 \u003e\u003d 2) goto B21 else B22\n}",
      "B21 {\n  goto B19\n}",
      "B22 {\n  r128 \u003d r126.getTail()\n  $z13 \u003d IfStmt\n  if ($z13 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r111 \u003d IfStmt) r128\n  $r112 \u003d $r111.getCondition()\n  r129 \u003d $r112.toString()\n  goto B27\n}",
      "B24 {\n  $z14 \u003d LookupSwitchStmt\n  if ($z14 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  $z15 \u003d TableSwitchStmt\n  if ($z15 \u003d\u003d false) goto B26 else B19\n}",
      "B26 {\n  $r106 \u003d r128.getUseBoxes()\n  $r107 \u003d $r106.get(0)\n  $r108 \u003d ValueBox) $r107\n  $r109 \u003d $r108.getValue()\n  $r110 \u003d String.valueOf($r109)\n  r129 \u003d dynInvoke makeConcatWithConstants($r110)\n}",
      "B27 {\n  $r130 \u003d Object)[4]\n  $i14 \u003d r126.getIndexInMethod()\n  $r131 \u003d Integer.valueOf($i14)\n  $r130[0] \u003d $r131\n  $r130[1] \u003d r129\n  $r132 \u003d r127.get(0)\n  $r133 \u003d Block) $r132\n  $i15 \u003d $r133.getIndexInMethod()\n  $r134 \u003d Integer.valueOf($i15)\n  $r130[2] \u003d $r134\n  $r135 \u003d r127.get(1)\n  $r136 \u003d Block) $r135\n  $i16 \u003d $r136.getIndexInMethod()\n  $r137 \u003d Integer.valueOf($i16)\n  $r130[3] \u003d $r137\n  $r138 \u003d String.format(\"B%d : If(%s) \\u2192 B%d | else \\u2192 B%d\", $r130)\n  $r39.add($r138)\n  goto B19\n}",
      "B28 {\n  r139 \u003d r120.getName()\n  $r40 \u003d MethodAnalysisToJson$lambda_main_5__4.bootstrap$()\n  $r41 \u003d $r19.computeIfAbsent(r139, $r40)\n  r140 \u003d CompilationUnit) $r41\n  r141 \u003d \"(source not found)\"\n  r142 \u003d r122.getSubSignature()\n  MethodAnalysisToJson.toSimpleSig(r142)\n  if (r140 \u003d\u003d null) goto B29 else B32\n}",
      "B29 {\n  $r92 \u003d r120.getShortName()\n  r143 \u003d r140.getClassByName($r92)\n  $z11 \u003d r143.isPresent()\n  if ($z11 \u003d\u003d false) goto B30 else B32\n}",
      "B30 {\n  $r93 \u003d r143.get()\n  $r94 \u003d ClassOrInterfaceDeclaration) $r93\n  $r95 \u003d $r94.getMethods()\n  $r97 \u003d $r95.stream()\n  $r96 \u003d MethodAnalysisToJson$lambda_main_6__7.bootstrap$(r122)\n  $r98 \u003d $r97.filter($r96)\n  r144 \u003d $r98.findFirst()\n  $z12 \u003d r144.isPresent()\n  if ($z12 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  $r99 \u003d r144.get()\n  $r100 \u003d MethodDeclaration) $r99\n  $r102 \u003d $r100.getBody()\n  $r101 \u003d MethodAnalysisToJson$toString__8.bootstrap$()\n  $r103 \u003d $r102.map($r101)\n  $r104 \u003d $r103.orElse(\"(no body)\")\n  r141 \u003d String) $r104\n}",
      "B32 {\n  $r145 \u003d \"(source not found)\"\n  $z18 \u003d $r145.equals(r141)\n  if ($z18 \u003d\u003d false) goto B33 else B36\n}",
      "B33 {\n  if (i11 \u003e\u003d i12) goto B34 else B36\n}",
      "B34 {\n  $r87 \u003d Path SOURCE_ROOT\u003e\n  $r88 \u003d r139.replace(46, 47)\n  $r89 \u003d dynInvoke makeConcatWithConstants($r88)\n  r146 \u003d $r87.resolve($r89)\n  r147 \u003d Files.readAllLines(r146)\n  $r91 \u003d System.lineSeparator()\n  $i9 \u003d i11 - 1\n  $i7 \u003d r147.size()\n  $i8 \u003d Math.min(i12, $i7)\n  $r90 \u003d r147.subList($i9, $i8)\n  r141 \u003d String.join($r91, $r90)\n  goto B36\n}",
      "B35 {\n  $r116 :\u003d @caughtexception\n}",
      "B36 {\n  $r148 \u003d MethodAnalysisToJson.buildPrettyCFG(r32)\n  $r149 \u003d HashSet\n  new HashSet()\n  $r150 \u003d HashSet\n  new HashSet()\n  r151 \u003d null\n  if (r140 \u003d\u003d null) goto B37 else B39\n}",
      "B37 {\n  $r77 \u003d r120.getShortName()\n  r152 \u003d r140.getClassByName($r77)\n  $z10 \u003d r152.isPresent()\n  if ($z10 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r78 \u003d r152.get()\n  r151 \u003d ClassOrInterfaceDeclaration) $r78\n  $r79 \u003d r152.get()\n  $r80 \u003d ClassOrInterfaceDeclaration) $r79\n  $r81 \u003d $r80.getMethods()\n  $r83 \u003d $r81.stream()\n  $r82 \u003d MethodAnalysisToJson$lambda_main_7__5.bootstrap$(r122)\n  $r84 \u003d $r83.filter($r82)\n  $r86 \u003d $r84.findFirst()\n  $r85 \u003d MethodAnalysisToJson$lambda_main_8__6.bootstrap$(r120, $r149, $r150)\n  $r86.ifPresent($r85)\n}",
      "B39 {\n  $r153 \u003d new MethodInfo\n  new MethodInfo()\n  $r154 \u003d $r149.iterator()\n}",
      "B40 {\n  $z19 \u003d $r154.hasNext()\n  if ($z19 \u003d\u003d false) goto B41 else B56\n}",
      "B41 {\n  $r66 \u003d $r154.next()\n  r155 \u003d String) $r66\n  $z6 \u003d r155.contains(\".\")\n  if ($z6 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $i5 \u003d r155.lastIndexOf(46)\n  $i6 \u003d $i5 + 1\n  $r156 \u003d r155.substring($i6)\n  goto B44\n}",
      "B43 {\n  $r156 \u003d r155\n}",
      "B44 {\n  r157 \u003d $r156\n  $z7 \u003d r155.contains(\".\")\n  if ($z7 \u003d\u003d false) goto B45 else B46\n}",
      "B45 {\n  $r158 \u003d r155\n  goto B47\n}",
      "B46 {\n  $r67 \u003d r120.getPackageName()\n  $r158 \u003d dynInvoke makeConcatWithConstants($r67, $r156)\n}",
      "B47 {\n  r159 \u003d $r158\n  $r68 \u003d Path SOURCE_ROOT\u003e\n  $r69 \u003d $r158.replace(46, 47)\n  $r70 \u003d dynInvoke makeConcatWithConstants($r69)\n  $r76 \u003d $r68.resolve($r70)\n  r160 \u003d $r76\n  $r71 \u003d LinkOption)[0]\n  $z8 \u003d Files.exists($r76, $r71)\n  if ($z8 !\u003d 0) goto B48 else B49\n}",
      "B48 {\n  $r75 \u003d $r11.get(r157)\n  r160 \u003d Path) $r75\n}",
      "B49 {\n  $r72 \u003d new DependencyInfo\n  new DependencyInfo()\n  $z9 \u003d r159.contains(\".\")\n  if ($z9 \u003d\u003d false) goto B50 else B51\n}",
      "B50 {\n  $r161 \u003d r159\n  goto B52\n}",
      "B51 {\n  $r161 \u003d r157\n}",
      "B52 {\n  String name\u003e \u003d $r161\n  $r74 \u003d MethodAnalysisToJson.loadCU(r160, $r19)\n  if ($r74 \u003d\u003d null) goto B53 else B54\n}",
      "B53 {\n  $r162 \u003d $r74.toString()\n  goto B55\n}",
      "B54 {\n  $r162 \u003d \"(source not found)\"\n}",
      "B55 {\n  String body\u003e \u003d $r162\n  $r73 \u003d List depClasses\u003e\n  $r73.add($r72)\n  goto B40\n}",
      "B56 {\n  r163 \u003d $r150.iterator()\n}",
      "B57 {\n  $z3 \u003d r163.hasNext()\n  if ($z3 \u003d\u003d false) goto B58 else B65\n}",
      "B58 {\n  $r49 \u003d r163.next()\n  r164 \u003d List) $r49\n  $r50 \u003d r164.get(0)\n  r165 \u003d String) $r50\n  $r51 \u003d r164.get(1)\n  $r52 \u003d String) $r51\n  i17 \u003d Integer.parseInt($r52)\n  $r53 \u003d new DependencyInfo\n  new DependencyInfo()\n  $r54 \u003d r120.getShortName()\n  $r55 \u003d dynInvoke makeConcatWithConstants($r54, r165, i17)\n  String name\u003e \u003d $r55\n  r166 \u003d \"(source not found)\"\n  if (r151 \u003d\u003d null) goto B59 else B60\n}",
      "B59 {\n  $r65 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc(r151, r165, $r65)\n}",
      "B60 {\n  $r56 \u003d \"(source not found)\"\n  $z4 \u003d $r56.equals(r166)\n  if ($z4 \u003d\u003d false) goto B61 else B64\n}",
      "B61 {\n  $r57 \u003d r120.getShortName()\n  $r58 \u003d $r11.get($r57)\n  r167 \u003d Path) $r58\n  r59 \u003d MethodAnalysisToJson.loadCU(r167, $r19)\n  if (r59 \u003d\u003d null) goto B62 else B64\n}",
      "B62 {\n  $r60 \u003d r120.getShortName()\n  r61 \u003d r59.getClassByName($r60)\n  $z5 \u003d r61.isPresent()\n  if ($z5 \u003d\u003d false) goto B63 else B64\n}",
      "B63 {\n  $r62 \u003d r61.get()\n  $r64 \u003d ClassOrInterfaceDeclaration) $r62\n  $r63 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc($r64, r165, $r63)\n}",
      "B64 {\n  String body\u003e \u003d r166\n  $r168 \u003d List depMethods\u003e\n  $r168.add($r53)\n  goto B57\n}",
      "B65 {\n  String clazz\u003e \u003d r139\n  $r42 \u003d r122.getName()\n  String methodName\u003e \u003d $r42\n  $r43 \u003d r122.getSubSignature()\n  String signature\u003e \u003d $r43\n  $r44 \u003d MethodAnalysisToJson.vis(r122)\n  String visibility\u003e \u003d $r44\n  String body\u003e \u003d r141\n  \u003cMethodInfo: int nodes\u003e \u003d i1\n  \u003cMethodInfo: int edges\u003e \u003d i2\n  \u003cMethodInfo: int cc\u003e \u003d i4\n  List flowSummary\u003e \u003d $r39\n  $r45 \u003d $r148.get(\"blocks\")\n  $r46 \u003d List) $r45\n  List blockList\u003e \u003d $r46\n  $r47 \u003d $r148.get(\"edges\")\n  $r48 \u003d List) $r47\n  List blockEdges\u003e \u003d $r48\n  $r18.add($r153)\n  goto B3\n}",
      "B66 {\n  goto B1\n}",
      "B67 {\n  $r23 \u003d GsonBuilder\n  new GsonBuilder()\n  $r24 \u003d $r23.setPrettyPrinting()\n  r169 \u003d $r24.create()\n  $r25 \u003d FileWriter\n  new FileWriter(\"C:/Users/00000/Desktop/my/jcore_all_methods.json\")\n  r169.toJson($r18, $r25)\n  $r25.close()\n  goto B71\n}",
      "B68 {\n  $r115 :\u003d @caughtexception\n  $r25.close()\n  goto B70\n}",
      "B69 {\n  $r114 :\u003d @caughtexception\n  $r115.addSuppressed($r114)\n}",
      "B70 {\n  throw $r115\n}",
      "B71 {\n  $r26 \u003d PrintStream out\u003e\n  $i0 \u003d $r18.size()\n  $r27 \u003d dynInvoke makeConcatWithConstants($i0)\n  $r26.println($r27)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B67",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B66",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B8",
      "B7 --\u003e B3",
      "B8 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B3",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B19",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B27",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B19",
      "B26 --\u003e B27",
      "B27 --\u003e B19",
      "B28 --\u003e B29",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B32",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B36",
      "B33 --\u003e B34",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B36 --\u003e B39",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B40 --\u003e B41",
      "B40 --\u003e B56",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B55",
      "B54 --\u003e B55",
      "B55 --\u003e B40",
      "B56 --\u003e B57",
      "B57 --\u003e B58",
      "B57 --\u003e B65",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B64",
      "B61 --\u003e B62",
      "B61 --\u003e B64",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B57",
      "B65 --\u003e B3",
      "B66 --\u003e B1",
      "B67 --\u003e B71",
      "B68 --\u003e B70",
      "B69 --\u003e B70",
      "B70 --\u003e [EXIT]",
      "B71 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "SootCFGAnalysis",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    //        String targetDir \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\benchmark\\\\commons-collections4-4.5.0-M1-src\\\\commons-collections4-4.5.0-M1-src\\\\target\\\\classes\"; // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    //        String outputCsv \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\cfg_analysis_result.tsv\"; // 결과 저장할 CSV 파일 경로\r\n    // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    String targetDir \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-core-jackson-core-2.19.1\\\\target\\\\classes\";\r\n    // 결과 저장할 CSV 파일 경로\r\n    String outputCsv \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jcore.csv\";\r\n    if (System.getProperty(\"sun.boot.class.path\") \u003d\u003d null)\r\n        System.setProperty(\"sun.boot.class.path\", \"\");\r\n    if (System.getProperty(\"java.ext.dirs\") \u003d\u003d null)\r\n        System.setProperty(\"java.ext.dirs\", \"\");\r\n    // (1) 기본 Soot 설정\r\n    Options.v().set_prepend_classpath(true);\r\n    Options.v().set_process_dir(Collections.singletonList(targetDir));\r\n    Options.v().set_whole_program(true);\r\n    // 출력 없음\r\n    Options.v().set_output_format(Options.output_format_none);\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_allow_phantom_refs(true);\r\n    Options.v().set_keep_line_number(true);\r\n    // phantom 클래스에 바디 생성 안 함\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_process_dir(// 내 클래스만\r\n    Collections.singletonList(\"target/classes\"));\r\n    Options.v().set_src_prec(Options.src_prec_class);\r\n    Options.v().setPhaseOption(\"jb\", \"use-original-names:true\");\r\n    Scene.v().loadNecessaryClasses();\r\n    // (★) 이미 본 메서드 서명을 기억할 Set\r\n    Set\u003cString\u003e seen \u003d new HashSet\u003c\u003e();\r\n    // (2) 애플리케이션 클래스들 순회\r\n    try (CSVWriter writer \u003d new CSVWriter(new FileWriter(outputCsv))) {\r\n        // CSV 헤더 작성\r\n        writer.writeNext(new String[] { \"Class\", \"Method\", \"MethodSig\", \"Nodes\", \"Edges\", \"McCabe_CC\", \"StartLine\", \"EndLine\", \"LineCount\" });\r\n        List\u003cSootClass\u003e classes \u003d new ArrayList\u003c\u003e(Scene.v().getApplicationClasses());\r\n        for (SootClass cls : classes) {\r\n            for (SootMethod method : cls.getMethods()) {\r\n                if (!method.isConcrete())\r\n                    continue;\r\n                try {\r\n                    Body body \u003d method.retrieveActiveBody();\r\n                    // 기본 블록 단위\r\n                    BlockGraph cfg \u003d new BriefBlockGraph(body);\r\n                    int nodeCount \u003d cfg.size();\r\n                    int edgeCount \u003d 0;\r\n                    for (Block b : cfg) edgeCount +\u003d cfg.getSuccsOf(b).size();\r\n                    int cc \u003d edgeCount - nodeCount + 2;\r\n                    int startLine \u003d Integer.MAX_VALUE;\r\n                    int endLine \u003d Integer.MIN_VALUE;\r\n                    for (Unit unit : body.getUnits()) {\r\n                        int line \u003d unit.getJavaSourceStartLineNumber();\r\n                        if (line \u003e 0) {\r\n                            startLine \u003d Math.min(startLine, line);\r\n                            endLine \u003d Math.max(endLine, line);\r\n                        }\r\n                    }\r\n                    int lineCount \u003d (startLine \u003c\u003d endLine) ? (endLine - startLine + 1) : 0;\r\n                    if (!isTopLevelPublic(cls) || !isRealMethod(method))\r\n                        continue;\r\n                    if (nodeCount \u003d\u003d 0 || edgeCount \u003d\u003d 0)\r\n                        continue;\r\n                    if (cc \u003c\u003d 0)\r\n                        continue;\r\n                    String methodSig \u003d method.getSubSignature();\r\n                    String uniqueKey \u003d method.getSignature();\r\n                    // (★) 이미 기록된 서명이라면 건너뛰기\r\n                    if (!seen.add(uniqueKey))\r\n                        continue;\r\n                    // 결과를 CSV로 저장\r\n                    String[] row \u003d { cls.getName(), method.getName(), uniqueKey, String.valueOf(nodeCount), String.valueOf(edgeCount), String.valueOf(cc), String.valueOf(startLine), String.valueOf(endLine), String.valueOf(lineCount) };\r\n                    writer.writeNext(row);\r\n                } catch (Exception e) {\r\n                    System.out.printf(\"[⚠️ 오류] %s.%s: %s\\n\", cls.getName(), method.getName(), e.getMessage());\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"✅ 분석 완료: \" + outputCsv + \"에 저장됨\");\r\n    } catch (IOException e) {\r\n        System.err.println(\"❌ CSV 저장 중 오류: \" + e.getMessage());\r\n    }\r\n}",
    "nodes": 42,
    "edges": 55,
    "cc": 15,
    "flowSummary": [
      "B0 : If($r0 !\u003d null) → B1 | else → B2",
      "B2 : If($r1 !\u003d null) → B3 | else → B4",
      "B5 : If($z6 \u003d\u003d false) → B6 | else → B35",
      "B7 : If($z7 \u003d\u003d false) → B8 | else → B34",
      "B8 : If($z0 !\u003d 0) → B9 | else → B10",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i8 \u003c\u003d 0) → B16 | else → B17",
      "B18 : If(i6 \u003e i7) → B19 | else → B20",
      "B21 : If($z3 \u003d\u003d false) → B22 | else → B23",
      "B22 : If($z4 !\u003d 0) → B23 | else → B24",
      "B24 : If(i0 \u003d\u003d false) → B25 | else → B26",
      "B25 : If(i4 !\u003d 0) → B26 | else → B27",
      "B27 : If(i5 \u003e 0) → B28 | else → B29",
      "B29 : If($z5 !\u003d 0) → B30 | else → B31"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $r0 \u003d System.getProperty(\"sun.boot.class.path\")\n  if ($r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  System.setProperty(\"sun.boot.class.path\", \"\")\n}",
      "B2 {\n  $r1 \u003d System.getProperty(\"java.ext.dirs\")\n  if ($r1 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  System.setProperty(\"java.ext.dirs\", \"\")\n}",
      "B4 {\n  $r2 \u003d Options.v()\n  $r2.set_prepend_classpath(1)\n  $r4 \u003d Options.v()\n  $r3 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\jackson-core-jackson-core-2.19.1\\\\target\\\\classes\")\n  $r4.set_process_dir($r3)\n  $r5 \u003d Options.v()\n  $r5.set_whole_program(1)\n  $r6 \u003d Options.v()\n  $r6.set_output_format(12)\n  $r7 \u003d Options.v()\n  $r7.set_no_bodies_for_excluded(1)\n  $r8 \u003d Options.v()\n  $r8.set_allow_phantom_refs(1)\n  $r9 \u003d Options.v()\n  $r9.set_keep_line_number(1)\n  $r10 \u003d Options.v()\n  $r10.set_no_bodies_for_excluded(1)\n  $r12 \u003d Options.v()\n  $r11 \u003d Collections.singletonList(\"target/classes\")\n  $r12.set_process_dir($r11)\n  $r13 \u003d Options.v()\n  $r13.set_src_prec(1)\n  $r14 \u003d Options.v()\n  $r14.setPhaseOption(\"jb\", \"use-original-names:true\")\n  $r15 \u003d Scene.v()\n  $r15.loadNecessaryClasses()\n  $r16 \u003d HashSet\n  new HashSet()\n  $r17 \u003d CSVWriter\n  $r18 \u003d FileWriter\n  new FileWriter(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jcore.csv\")\n  new CSVWriter($r18)\n  $r19 \u003d String)[9]\n  $r19[0] \u003d \"Class\"\n  $r19[1] \u003d \"Method\"\n  $r19[2] \u003d \"MethodSig\"\n  $r19[3] \u003d \"Nodes\"\n  $r19[4] \u003d \"Edges\"\n  $r19[5] \u003d \"McCabe_CC\"\n  $r19[6] \u003d \"StartLine\"\n  $r19[7] \u003d \"EndLine\"\n  $r19[8] \u003d \"LineCount\"\n  $r17.writeNext($r19)\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  $r45 \u003d $r20.iterator()\n}",
      "B5 {\n  $z6 \u003d $r45.hasNext()\n  if ($z6 \u003d\u003d false) goto B6 else B35\n}",
      "B6 {\n  $r25 \u003d $r45.next()\n  r26 \u003d SootClass) $r25\n  $r27 \u003d r26.getMethods()\n  r28 \u003d $r27.iterator()\n}",
      "B7 {\n  $z7 \u003d r28.hasNext()\n  if ($z7 \u003d\u003d false) goto B8 else B34\n}",
      "B8 {\n  $r29 \u003d r28.next()\n  r30 \u003d SootMethod) $r29\n  $z0 \u003d r30.isConcrete()\n  if ($z0 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  goto B7\n}",
      "B10 {\n  r59 \u003d r30.retrieveActiveBody()\n  $r31 \u003d BriefBlockGraph\n  new BriefBlockGraph(r59)\n  i0 \u003d $r31.size()\n  i4 \u003d 0\n  r60 \u003d $r31.iterator()\n}",
      "B11 {\n  $z1 \u003d r60.hasNext()\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r43 \u003d r60.next()\n  r61 \u003d Block) $r43\n  $r44 \u003d $r31.getSuccsOf(r61)\n  $i3 \u003d $r44.size()\n  i4 \u003d i4 + $i3\n  goto B11\n}",
      "B13 {\n  $i1 \u003d i4 - i0\n  i5 \u003d $i1 + 2\n  i6 \u003d 2147483647\n  i7 \u003d -2147483648\n  $r32 \u003d r59.getUnits()\n  r62 \u003d $r32.iterator()\n}",
      "B14 {\n  $z2 \u003d r62.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r42 \u003d r62.next()\n  r63 \u003d Unit) $r42\n  i8 \u003d r63.getJavaSourceStartLineNumber()\n  if (i8 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i6 \u003d Math.min(i6, i8)\n  i7 \u003d Math.max(i7, i8)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  if (i6 \u003e i7) goto B19 else B20\n}",
      "B19 {\n  $i2 \u003d i7 - i6\n  $i9 \u003d $i2 + 1\n  goto B21\n}",
      "B20 {\n  $i9 \u003d 0\n}",
      "B21 {\n  $z3 \u003d SootCFGAnalysis.isTopLevelPublic(r26)\n  if ($z3 \u003d\u003d false) goto B22 else B23\n}",
      "B22 {\n  $z4 \u003d SootCFGAnalysis.isRealMethod(r30)\n  if ($z4 !\u003d 0) goto B23 else B24\n}",
      "B23 {\n  goto B7\n}",
      "B24 {\n  if (i0 \u003d\u003d false) goto B25 else B26\n}",
      "B25 {\n  if (i4 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B7\n}",
      "B27 {\n  if (i5 \u003e 0) goto B28 else B29\n}",
      "B28 {\n  goto B7\n}",
      "B29 {\n  r30.getSubSignature()\n  r64 \u003d r30.getSignature()\n  $z5 \u003d $r16.add(r64)\n  if ($z5 !\u003d 0) goto B30 else B31\n}",
      "B30 {\n  goto B7\n}",
      "B31 {\n  $r33 \u003d String)[9]\n  $r34 \u003d r26.getName()\n  $r33[0] \u003d $r34\n  $r35 \u003d r30.getName()\n  $r33[1] \u003d $r35\n  $r33[2] \u003d r64\n  $r36 \u003d String.valueOf(i0)\n  $r33[3] \u003d $r36\n  $r37 \u003d String.valueOf(i4)\n  $r33[4] \u003d $r37\n  $r38 \u003d String.valueOf(i5)\n  $r33[5] \u003d $r38\n  $r39 \u003d String.valueOf(i6)\n  $r33[6] \u003d $r39\n  $r40 \u003d String.valueOf(i7)\n  $r33[7] \u003d $r40\n  $r41 \u003d String.valueOf($i9)\n  $r33[8] \u003d $r41\n  $r17.writeNext($r33)\n  goto B33\n}",
      "B32 {\n  $r52 :\u003d @caughtexception\n  $r54 \u003d PrintStream out\u003e\n  $r53 \u003d Object)[3]\n  $r55 \u003d r26.getName()\n  $r53[0] \u003d $r55\n  $r56 \u003d r30.getName()\n  $r53[1] \u003d $r56\n  $r57 \u003d $r52.getMessage()\n  $r53[2] \u003d $r57\n  $r54.printf(\"\\u26a0\\ufe0f \\uc624\\ub958 %s.%s: %s\\n\", $r53)\n}",
      "B33 {\n  goto B7\n}",
      "B34 {\n  goto B5\n}",
      "B35 {\n  $r23 \u003d PrintStream out\u003e\n  $r24 \u003d dynInvoke makeConcatWithConstants(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_jcore.csv\")\n  $r23.println($r24)\n  $r17.close()\n  goto B39\n}",
      "B36 {\n  $r51 :\u003d @caughtexception\n  $r17.close()\n  goto B38\n}",
      "B37 {\n  $r50 :\u003d @caughtexception\n  $r51.addSuppressed($r50)\n}",
      "B38 {\n  throw $r51\n}",
      "B39 {\n  goto B41\n}",
      "B40 {\n  $r46 :\u003d @caughtexception\n  $r47 \u003d PrintStream err\u003e\n  $r48 \u003d $r46.getMessage()\n  $r49 \u003d dynInvoke makeConcatWithConstants($r48)\n  $r47.println($r49)\n}",
      "B41 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B35",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B34",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B7",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B11",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B21",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B7",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B7",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B7",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B7",
      "B31 --\u003e B33",
      "B32 --\u003e B33",
      "B33 --\u003e B7",
      "B34 --\u003e B5",
      "B35 --\u003e B39",
      "B36 --\u003e B38",
      "B37 --\u003e B38",
      "B38 --\u003e [EXIT]",
      "B39 --\u003e B41",
      "B40 --\u003e B41",
      "B41 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SootCFGAnalysis#isTopLevelPublic(...1)",
        "body": "{\r\n    return c.isPublic() \u0026\u0026 !c.getName().contains(\"$\") \u0026\u0026 !c.isInterface() \u0026\u0026 !c.isAbstract();\r\n}"
      },
      {
        "name": "SootCFGAnalysis#isRealMethod(...1)",
        "body": "{\r\n    // (1) 바디 없는 메서드는 제외\r\n    if (!m.isConcrete())\r\n        return false;\r\n    // (2) 생성자/클래스 초기화자 제외\r\n    if (m.isConstructor() || m.isStaticInitializer())\r\n        return false;\r\n    // (3) 컴파일러 생성 메서드 제외 (synthetic, bridge)\r\n    final int ACC_BRIDGE \u003d 0x0040;\r\n    final int ACC_SYNTHETIC \u003d 0x1000;\r\n    int mod \u003d m.getModifiers();\r\n    // (4) public 이 아닌 메서드 제외\r\n    if (!Modifier.isPublic(mod))\r\n        return false;\r\n    return (mod \u0026 ACC_BRIDGE) \u003d\u003d 0 \u0026\u0026 (mod \u0026 ACC_SYNTHETIC) \u003d\u003d 0;\r\n}"
      }
    ]
  }
]