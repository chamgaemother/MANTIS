[
  {
    "clazz": "com.google.gson.FieldAttributes",
    "methodName": "hasModifier",
    "signature": "boolean hasModifier(int)",
    "visibility": "public",
    "body": "{\r\n    return (field.getModifiers() \u0026 modifier) !\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  FieldAttributes\n  i0 :\u003d @parameter0: int\n  $r1 \u003d Field field\u003e\n  $i1 \u003d $r1.getModifiers()\n  $i2 \u003d $i1 \u0026 i0\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "getAdapter",
    "signature": "com.google.gson.TypeAdapter getAdapter(com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(type, \"type must not be null\");\r\n    TypeAdapter\u003c?\u003e cached \u003d typeTokenCache.get(type);\r\n    if (cached !\u003d null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) cached;\r\n        return adapter;\r\n    }\r\n    Map\u003cTypeToken\u003c?\u003e, TypeAdapter\u003c?\u003e\u003e threadCalls \u003d threadLocalAdapterResults.get();\r\n    boolean isInitialAdapterRequest \u003d false;\r\n    if (threadCalls \u003d\u003d null) {\r\n        threadCalls \u003d new HashMap\u003c\u003e();\r\n        threadLocalAdapterResults.set(threadCalls);\r\n        isInitialAdapterRequest \u003d true;\r\n    } else {\r\n        // the key and value type parameters always agree\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e ongoingCall \u003d (TypeAdapter\u003cT\u003e) threadCalls.get(type);\r\n        if (ongoingCall !\u003d null) {\r\n            return ongoingCall;\r\n        }\r\n    }\r\n    TypeAdapter\u003cT\u003e candidate \u003d null;\r\n    try {\r\n        FutureTypeAdapter\u003cT\u003e call \u003d new FutureTypeAdapter\u003c\u003e();\r\n        threadCalls.put(type, call);\r\n        for (TypeAdapterFactory factory : factories) {\r\n            candidate \u003d factory.create(this, type);\r\n            if (candidate !\u003d null) {\r\n                call.setDelegate(candidate);\r\n                // Replace future adapter with actual adapter\r\n                threadCalls.put(type, candidate);\r\n                break;\r\n            }\r\n        }\r\n    } finally {\r\n        if (isInitialAdapterRequest) {\r\n            threadLocalAdapterResults.remove();\r\n        }\r\n    }\r\n    if (candidate \u003d\u003d null) {\r\n        throw new IllegalArgumentException(\"GSON (\" + GsonBuildConfig.VERSION + \") cannot handle \" + type);\r\n    }\r\n    if (isInitialAdapterRequest) {\r\n        /*\r\n       * Publish resolved adapters to all threads\r\n       * Can only do this for the initial request because cyclic dependency TypeA -\u003e TypeB -\u003e TypeA\r\n       * would otherwise publish adapter for TypeB which uses not yet resolved adapter for TypeA\r\n       * See https://github.com/google/gson/issues/625\r\n       */\r\n        typeTokenCache.putAll(threadCalls);\r\n    }\r\n    return candidate;\r\n}",
    "nodes": 21,
    "edges": 25,
    "cc": 6,
    "flowSummary": [
      "B0 : If(r4 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r22 !\u003d null) → B3 | else → B4",
      "B4 : If(r23 \u003d\u003d null) → B5 | else → B6",
      "B7 : If($z1 \u003d\u003d false) → B8 | else → B11",
      "B8 : If(r24 \u003d\u003d null) → B9 | else → B10",
      "B11 : If(z3 \u003d\u003d false) → B12 | else → B16",
      "B13 : If(z4 \u003d\u003d false) → B14 | else → B15",
      "B16 : If(r24 !\u003d null) → B17 | else → B18",
      "B18 : If(z2 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  Gson\n  TypeToken\n  Objects.requireNonNull(r0, \"type must not be null\")\n  $r2 \u003d ConcurrentMap typeTokenCache\u003e\n  $r3 \u003d $r2.get(r0)\n  r4 \u003d TypeAdapter) $r3\n  if (r4 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r5 \u003d ThreadLocal threadLocalAdapterResults\u003e\n  $r6 \u003d $r5.get()\n  r22 \u003d Map) $r6\n  z0 \u003d 0\n  z4 \u003d 0\n  z3 \u003d 0\n  z2 \u003d 0\n  if (r22 !\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r17 \u003d HashMap\n  new HashMap()\n  r22 \u003d $r17\n  $r18 \u003d ThreadLocal threadLocalAdapterResults\u003e\n  $r18.set($r17)\n  z0 \u003d 1\n  z4 \u003d 1\n  z3 \u003d 1\n  z2 \u003d 1\n  goto B6\n}",
      "B4 {\n  $r7 \u003d r22.get(r0)\n  r23 \u003d TypeAdapter) $r7\n  if (r23 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  r24 \u003d null\n  $r8 \u003d Gson$FutureTypeAdapter\n  new Gson$FutureTypeAdapter()\n  r22.put(r0, $r8)\n  $r9 \u003d List factories\u003e\n  $r19 \u003d $r9.iterator()\n}",
      "B7 {\n  $z1 \u003d $r19.hasNext()\n  if ($z1 \u003d\u003d false) goto B8 else B11\n}",
      "B8 {\n  $r15 \u003d $r19.next()\n  r16 \u003d TypeAdapterFactory) $r15\n  r24 \u003d r16.create(r1, r0)\n  if (r24 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  $r8.setDelegate(r24)\n  r22.put(r0, r24)\n  goto B11\n}",
      "B10 {\n  goto B7\n}",
      "B11 {\n  if (z3 \u003d\u003d false) goto B12 else B16\n}",
      "B12 {\n  $r14 \u003d ThreadLocal threadLocalAdapterResults\u003e\n  $r14.remove()\n  goto B16\n}",
      "B13 {\n  $r20 :\u003d @caughtexception\n  if (z4 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r21 \u003d ThreadLocal threadLocalAdapterResults\u003e\n  $r21.remove()\n}",
      "B15 {\n  throw $r20\n}",
      "B16 {\n  if (r24 !\u003d null) goto B17 else B18\n}",
      "B17 {\n  $r11 \u003d IllegalArgumentException\n  $r12 \u003d String.valueOf(r0)\n  $r13 \u003d dynInvoke makeConcatWithConstants($r12)\n  new IllegalArgumentException($r13)\n  throw $r11\n}",
      "B18 {\n  if (z2 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r10 \u003d ConcurrentMap typeTokenCache\u003e\n  $r10.putAll(r22)\n}",
      "B20 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B7",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B16",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "getDelegateAdapter",
    "signature": "com.google.gson.TypeAdapter getDelegateAdapter(com.google.gson.TypeAdapterFactory,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    // Hack. If the skipPast factory isn\u0027t registered, assume the factory is being requested via\r\n    // our @JsonAdapter annotation.\r\n    if (!factories.contains(skipPast)) {\r\n        skipPast \u003d jsonAdapterFactory;\r\n    }\r\n    boolean skipPastFound \u003d false;\r\n    for (TypeAdapterFactory factory : factories) {\r\n        if (!skipPastFound) {\r\n            if (factory \u003d\u003d skipPast) {\r\n                skipPastFound \u003d true;\r\n            }\r\n            continue;\r\n        }\r\n        TypeAdapter\u003cT\u003e candidate \u003d factory.create(this, type);\r\n        if (candidate !\u003d null) {\r\n            return candidate;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B3 : If($z2 \u003d\u003d false) → B4 | else → B10",
      "B4 : If(z1 !\u003d 0) → B5 | else → B7",
      "B5 : If(r8 !\u003d r11) → B6 | else → B3",
      "B7 : If(r9 \u003d\u003d null) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  Gson\n  TypeAdapterFactory\n  TypeToken\n  $r1 \u003d List factories\u003e\n  $z0 \u003d $r1.contains(r11)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  r11 \u003d JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory\u003e\n}",
      "B2 {\n  z1 \u003d 0\n  $r2 \u003d List factories\u003e\n  $r10 \u003d $r2.iterator()\n}",
      "B3 {\n  $z2 \u003d $r10.hasNext()\n  if ($z2 \u003d\u003d false) goto B4 else B10\n}",
      "B4 {\n  $r7 \u003d $r10.next()\n  r8 \u003d TypeAdapterFactory) $r7\n  if (z1 !\u003d 0) goto B5 else B7\n}",
      "B5 {\n  if (r8 !\u003d r11) goto B6 else B3\n}",
      "B6 {\n  z1 \u003d 1\n  goto B3\n}",
      "B7 {\n  r9 \u003d r8.create(r0, r4)\n  if (r9 \u003d\u003d null) goto B8 else B9\n}",
      "B8 {\n  return\n}",
      "B9 {\n  goto B3\n}",
      "B10 {\n  $r3 \u003d IllegalArgumentException\n  $r5 \u003d String.valueOf(r4)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IllegalArgumentException($r6)\n  throw $r3\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B10",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B3",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e B3",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "toJsonTree",
    "signature": "com.google.gson.JsonElement toJsonTree(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (src \u003d\u003d null) {\r\n        return JsonNull.INSTANCE;\r\n    }\r\n    return toJsonTree(src, src.getClass());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Gson\n  Object\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonNull INSTANCE\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getClass()\n  $r3 \u003d r1.toJsonTree(r0, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Gson#toJsonTree(...2)",
        "body": "{\r\n    JsonTreeWriter writer \u003d new JsonTreeWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.get();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "toJson",
    "signature": "java.lang.String toJson(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (src \u003d\u003d null) {\r\n        return toJson(JsonNull.INSTANCE);\r\n    }\r\n    return toJson(src, src.getClass());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Gson\n  Object\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonNull INSTANCE\u003e\n  $r5 \u003d r1.toJson($r4)\n  return\n}",
      "B2 {\n  $r2 \u003d r0.getClass()\n  $r3 \u003d r1.toJson(r0, $r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Gson#toJson(...2)",
        "body": "{\r\n    StringWriter writer \u003d new StringWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.toString();\r\n}"
      },
      {
        "name": "Gson#toJson(...1)",
        "body": "{\r\n    if (src \u003d\u003d null) {\r\n        return toJson(JsonNull.INSTANCE);\r\n    }\r\n    return toJson(src, src.getClass());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "toJson",
    "signature": "void toJson(java.lang.Object,java.lang.Appendable)",
    "visibility": "public",
    "body": "{\r\n    if (src !\u003d null) {\r\n        toJson(src, src.getClass(), writer);\r\n    } else {\r\n        toJson(JsonNull.INSTANCE, writer);\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Gson\n  Object\n  Appendable\n  if (r0 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d r0.getClass()\n  r1.toJson(r0, $r4, r2)\n  goto B3\n}",
      "B2 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  r1.toJson($r3, r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Gson#toJson(...3)",
        "body": "{\r\n    try {\r\n        JsonWriter jsonWriter \u003d newJsonWriter(Streams.writerForAppendable(writer));\r\n        toJson(src, typeOfSrc, jsonWriter);\r\n    } catch (IOException e) {\r\n        throw new JsonIOException(e);\r\n    }\r\n}"
      },
      {
        "name": "Gson#toJson(...2)",
        "body": "{\r\n    StringWriter writer \u003d new StringWriter();\r\n    toJson(src, typeOfSrc, writer);\r\n    return writer.toString();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "newJsonWriter",
    "signature": "com.google.gson.stream.JsonWriter newJsonWriter(java.io.Writer)",
    "visibility": "public",
    "body": "{\r\n    if (generateNonExecutableJson) {\r\n        writer.write(JSON_NON_EXECUTABLE_PREFIX);\r\n    }\r\n    JsonWriter jsonWriter \u003d new JsonWriter(writer);\r\n    if (prettyPrinting) {\r\n        jsonWriter.setIndent(\"  \");\r\n    }\r\n    jsonWriter.setHtmlSafe(htmlSafe);\r\n    jsonWriter.setLenient(lenient);\r\n    jsonWriter.setSerializeNulls(serializeNulls);\r\n    return jsonWriter;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Gson\n  Writer\n  $z0 \u003d Gson: boolean generateNonExecutableJson\u003e\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  r2.write(\")}\\\u0027\\n\")\n}",
      "B2 {\n  $r1 \u003d JsonWriter\n  new JsonWriter(r2)\n  $z1 \u003d Gson: boolean prettyPrinting\u003e\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r1.setIndent(\"  \")\n}",
      "B4 {\n  $z2 \u003d Gson: boolean htmlSafe\u003e\n  $r1.setHtmlSafe($z2)\n  $z3 \u003d Gson: boolean lenient\u003e\n  $r1.setLenient($z3)\n  $z4 \u003d Gson: boolean serializeNulls\u003e\n  $r1.setSerializeNulls($z4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "fromJson",
    "signature": "java.lang.Object fromJson(java.lang.String,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    StringReader reader \u003d new StringReader(json);\r\n    return fromJson(reader, typeOfT);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Gson\n  String\n  TypeToken\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r1 \u003d StringReader\n  new StringReader(r0)\n  $r4 \u003d r2.fromJson($r1, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Gson#fromJson(...2)",
        "body": "{\r\n    T object \u003d fromJson(json, TypeToken.get(classOfT));\r\n    return Primitives.wrap(classOfT).cast(object);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.Gson",
    "methodName": "fromJson",
    "signature": "java.lang.Object fromJson(com.google.gson.JsonElement,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    if (json \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return fromJson(new JsonTreeReader(json), typeOfT);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Gson\n  JsonElement\n  TypeToken\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d JsonTreeReader\n  new JsonTreeReader(r0)\n  $r4 \u003d r1.fromJson($r2, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Gson#fromJson(...2)",
        "body": "{\r\n    T object \u003d fromJson(json, TypeToken.get(classOfT));\r\n    return Primitives.wrap(classOfT).cast(object);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.GsonBuilder",
    "methodName": "setVersion",
    "signature": "com.google.gson.GsonBuilder setVersion(double)",
    "visibility": "public",
    "body": "{\r\n    if (Double.isNaN(version) || version \u003c 0.0) {\r\n        throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n    }\r\n    excluder \u003d excluder.withVersion(version);\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($i1 \u003e\u003d 0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  GsonBuilder\n  d0 :\u003d @parameter0: double\n  $z0 \u003d Double.isNaN(d0)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $b0 \u003d 0\n  $i1 \u003d (int) $b0\n  if ($i1 \u003e\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d IllegalArgumentException\n  $r1 \u003d dynInvoke makeConcatWithConstants(d0)\n  new IllegalArgumentException($r1)\n  throw $r5\n}",
      "B3 {\n  $r3 \u003d Excluder excluder\u003e\n  $r4 \u003d $r3.withVersion(d0)\n  Excluder excluder\u003e \u003d $r4\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.GsonBuilder",
    "methodName": "setExclusionStrategies",
    "signature": "com.google.gson.GsonBuilder setExclusionStrategies(com.google.gson.ExclusionStrategy[])",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(strategies);\r\n    for (ExclusionStrategy strategy : strategies) {\r\n        excluder \u003d excluder.withExclusionStrategy(strategy, true, true);\r\n    }\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i1 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  GsonBuilder\n  ExclusionStrategy[]\n  Objects.requireNonNull(r0)\n  i0 \u003d lengthof r0\n  i1 \u003d 0\n}",
      "B1 {\n  if (i1 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  r2 \u003d r0[i1]\n  $r3 \u003d Excluder excluder\u003e\n  $r4 \u003d $r3.withExclusionStrategy(r2, 1, 1)\n  Excluder excluder\u003e \u003d $r4\n  i1 \u003d i1 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.GsonBuilder",
    "methodName": "registerTypeAdapter",
    "signature": "com.google.gson.GsonBuilder registerTypeAdapter(java.lang.reflect.Type,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(type);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof InstanceCreator\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (typeAdapter instanceof InstanceCreator\u003c?\u003e) {\r\n        instanceCreators.put(type, (InstanceCreator\u003c?\u003e) typeAdapter);\r\n    }\r\n    if (typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e) {\r\n        TypeToken\u003c?\u003e typeToken \u003d TypeToken.get(type);\r\n        factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "nodes": 14,
    "edges": 21,
    "cc": 9,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z4 !\u003d 0) → B2 | else → B4",
      "B2 : If($z5 !\u003d 0) → B3 | else → B4",
      "B3 : If($z6 \u003d\u003d false) → B4 | else → B5",
      "B6 : If($z1 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z2 !\u003d 0) → B9 | else → B10",
      "B9 : If($z3 \u003d\u003d false) → B10 | else → B11",
      "B11 : If($z8 \u003d\u003d false) → B12 | else → B13"
    ],
    "blockList": [
      "B0 {\n  GsonBuilder\n  Type\n  Object\n  Objects.requireNonNull(r0)\n  $z0 \u003d JsonSerializer\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z4 \u003d JsonDeserializer\n  if ($z4 !\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $z5 \u003d InstanceCreator\n  if ($z5 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z6 \u003d TypeAdapter\n  if ($z6 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z7 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z7 \u003d 0\n}",
      "B6 {\n  $Gson$Preconditions.checkArgument($z7)\n  $z1 \u003d InstanceCreator\n  if ($z1 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r10 \u003d Map instanceCreators\u003e\n  $r9 \u003d InstanceCreator) r1\n  $r10.put(r0, $r9)\n}",
      "B8 {\n  $z2 \u003d JsonSerializer\n  if ($z2 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $z3 \u003d JsonDeserializer\n  if ($z3 \u003d\u003d false) goto B10 else B11\n}",
      "B10 {\n  $r8 \u003d TypeToken.get(r0)\n  $r3 \u003d List factories\u003e\n  $r4 \u003d TreeTypeAdapter.newFactoryWithMatchRawType($r8, r1)\n  $r3.add($r4)\n}",
      "B11 {\n  $z8 \u003d TypeAdapter\n  if ($z8 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r6 \u003d TypeToken.get(r0)\n  $r5 \u003d TypeAdapter) r1\n  r11 \u003d TypeAdapters.newFactory($r6, $r5)\n  $r7 \u003d List factories\u003e\n  $r7.add(r11)\n}",
      "B13 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.GsonBuilder",
    "methodName": "registerTypeHierarchyAdapter",
    "signature": "com.google.gson.GsonBuilder registerTypeHierarchyAdapter(java.lang.Class,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(baseType);\r\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\u003c?\u003e || typeAdapter instanceof JsonDeserializer\u003c?\u003e || typeAdapter instanceof TypeAdapter\u003c?\u003e);\r\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n        hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter\u003c?\u003e) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory \u003d TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "nodes": 11,
    "edges": 16,
    "cc": 7,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B3",
      "B1 : If($z3 !\u003d 0) → B2 | else → B3",
      "B2 : If($z4 \u003d\u003d false) → B3 | else → B4",
      "B5 : If($z1 !\u003d 0) → B6 | else → B7",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z6 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  GsonBuilder\n  Class\n  Object\n  Objects.requireNonNull(r0)\n  $z0 \u003d JsonSerializer\n  if ($z0 !\u003d 0) goto B1 else B3\n}",
      "B1 {\n  $z3 \u003d JsonDeserializer\n  if ($z3 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z4 \u003d TypeAdapter\n  if ($z4 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $z5 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z5 \u003d 0\n}",
      "B5 {\n  $Gson$Preconditions.checkArgument($z5)\n  $z1 \u003d JsonDeserializer\n  if ($z1 !\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $z2 \u003d JsonSerializer\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r3 \u003d List hierarchyFactories\u003e\n  $r4 \u003d TreeTypeAdapter.newTypeHierarchyFactory(r0, r1)\n  $r3.add($r4)\n}",
      "B8 {\n  $z6 \u003d TypeAdapter\n  if ($z6 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $r5 \u003d TypeAdapter) r1\n  r6 \u003d TypeAdapters.newTypeHierarchyFactory(r0, $r5)\n  $r7 \u003d List factories\u003e\n  $r7.add(r6)\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "methodName": "read",
    "signature": "java.lang.Object read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    ArrayList\u003cE\u003e list \u003d new ArrayList\u003c\u003e();\r\n    in.beginArray();\r\n    while (in.hasNext()) {\r\n        E instance \u003d componentTypeAdapter.read(in);\r\n        list.add(instance);\r\n    }\r\n    in.endArray();\r\n    int size \u003d list.size();\r\n    // Have to copy primitives one by one to primitive array\r\n    if (componentType.isPrimitive()) {\r\n        Object array \u003d Array.newInstance(componentType, size);\r\n        for (int i \u003d 0; i \u003c size; i++) {\r\n            Array.set(array, i, list.get(i));\r\n        }\r\n        return array;\r\n    } else // But for Object[] can use ArrayList.toArray\r\n    {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E[] array \u003d (E[]) Array.newInstance(componentType, size);\r\n        return list.toArray(array);\r\n    }\r\n}",
    "nodes": 11,
    "edges": 12,
    "cc": 3,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2",
      "B3 : If($z0 \u003d\u003d false) → B4 | else → B5",
      "B5 : If($z1 \u003d\u003d false) → B6 | else → B10",
      "B7 : If(i1 \u003e\u003d i0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  ArrayTypeAdapter\n  JsonReader\n  $r2 \u003d r0.peek()\n  $r1 \u003d JsonToken NULL\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0.nextNull()\n  return\n}",
      "B2 {\n  $r3 \u003d ArrayList\n  new ArrayList()\n  r0.beginArray()\n}",
      "B3 {\n  $z0 \u003d r0.hasNext()\n  if ($z0 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r11 \u003d TypeAdapter componentTypeAdapter\u003e\n  r12 \u003d $r11.read(r0)\n  $r3.add(r12)\n  goto B3\n}",
      "B5 {\n  r0.endArray()\n  i0 \u003d $r3.size()\n  $r5 \u003d Class componentType\u003e\n  $z1 \u003d $r5.isPrimitive()\n  if ($z1 \u003d\u003d false) goto B6 else B10\n}",
      "B6 {\n  $r9 \u003d Class componentType\u003e\n  r13 \u003d Array.newInstance($r9, i0)\n  i1 \u003d 0\n}",
      "B7 {\n  if (i1 \u003e\u003d i0) goto B8 else B9\n}",
      "B8 {\n  $r10 \u003d $r3.get(i1)\n  Array.set(r13, i1, $r10)\n  i1 \u003d i1 + 1\n  goto B7\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r6 \u003d Class componentType\u003e\n  $r7 \u003d Array.newInstance($r6, i0)\n  r14 \u003d Object[]) $r7\n  $r8 \u003d $r3.toArray(r14)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "methodName": "write",
    "signature": "void write(com.google.gson.stream.JsonWriter,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (array \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    out.beginArray();\r\n    for (int i \u003d 0, length \u003d Array.getLength(array); i \u003c length; i++) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        E value \u003d (E) Array.get(array, i);\r\n        componentTypeAdapter.write(out, value);\r\n    }\r\n    out.endArray();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B3 : If(i1 \u003e\u003d i0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  ArrayTypeAdapter\n  JsonWriter\n  Object\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r1.nullValue()\n  return\n}",
      "B2 {\n  r1.beginArray()\n  i1 \u003d 0\n  i0 \u003d Array.getLength(r0)\n}",
      "B3 {\n  if (i1 \u003e\u003d i0) goto B4 else B5\n}",
      "B4 {\n  r2 \u003d Array.get(r0, i1)\n  $r4 \u003d TypeAdapter componentTypeAdapter\u003e\n  $r4.write(r1, r2)\n  i1 \u003d i1 + 1\n  goto B3\n}",
      "B5 {\n  r1.endArray()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B3",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "methodName": "create",
    "signature": "com.google.gson.TypeAdapter create(com.google.gson.Gson,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Collection.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type elementType \u003d $Gson$Types.getCollectionElementType(type, rawType);\r\n    TypeAdapter\u003c?\u003e elementTypeAdapter \u003d gson.getAdapter(TypeToken.get(elementType));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    // create() doesn\u0027t define a type parameter\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e result \u003d new Adapter(gson, elementType, elementTypeAdapter, constructor);\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  CollectionTypeAdapterFactory\n  Gson\n  TypeToken\n  r1 \u003d r0.getType()\n  r2 \u003d r0.getRawType()\n  $r3 \u003d class \"Ljava/util/Collection;\"\n  $z0 \u003d $r3.isAssignableFrom(r2)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d $Gson$Types.getCollectionElementType(r1, r2)\n  $r6 \u003d TypeToken.get(r4)\n  r7 \u003d r5.getAdapter($r6)\n  $r9 \u003d ConstructorConstructor constructorConstructor\u003e\n  r10 \u003d $r9.get(r0)\n  $r11 \u003d CollectionTypeAdapterFactory$Adapter\n  new CollectionTypeAdapterFactory$Adapter(r5, r4, r7, r10)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.DateTypeAdapter",
    "methodName": "read",
    "signature": "java.util.Date read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    return deserializeToDate(in);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DateTypeAdapter\n  JsonReader\n  $r2 \u003d r0.peek()\n  $r1 \u003d JsonToken NULL\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0.nextNull()\n  return\n}",
      "B2 {\n  $r4 \u003d r3.deserializeToDate(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DateTypeAdapter#deserializeToDate(...1)",
        "body": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
    "methodName": "read",
    "signature": "java.util.Date read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    if (in.peek() \u003d\u003d JsonToken.NULL) {\r\n        in.nextNull();\r\n        return null;\r\n    }\r\n    Date date \u003d deserializeToDate(in);\r\n    return dateType.deserialize(date);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultDateTypeAdapter\n  JsonReader\n  $r2 \u003d r0.peek()\n  $r1 \u003d JsonToken NULL\u003e\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  r0.nextNull()\n  return\n}",
      "B2 {\n  r4 \u003d r3.deserializeToDate(r0)\n  $r5 \u003d DefaultDateTypeAdapter$DateType dateType\u003e\n  $r6 \u003d $r5.deserialize(r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "DefaultDateTypeAdapter#deserializeToDate(...1)",
        "body": "{\r\n    String s \u003d in.nextString();\r\n    synchronized (dateFormats) {\r\n        for (DateFormat dateFormat : dateFormats) {\r\n            try {\r\n                return dateFormat.parse(s);\r\n            } catch (ParseException ignored) {\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        return ISO8601Utils.parse(s, new ParsePosition(0));\r\n    } catch (ParseException e) {\r\n        throw new JsonSyntaxException(\"Failed parsing \u0027\" + s + \"\u0027 as Date; at path \" + in.getPreviousPath(), e);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
    "methodName": "toString",
    "signature": "java.lang.String toString()",
    "visibility": "public",
    "body": "{\r\n    DateFormat defaultFormat \u003d dateFormats.get(0);\r\n    if (defaultFormat instanceof SimpleDateFormat) {\r\n        return SIMPLE_NAME + \u0027(\u0027 + ((SimpleDateFormat) defaultFormat).toPattern() + \u0027)\u0027;\r\n    } else {\r\n        return SIMPLE_NAME + \u0027(\u0027 + defaultFormat.getClass().getSimpleName() + \u0027)\u0027;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  DefaultDateTypeAdapter\n  $r1 \u003d List dateFormats\u003e\n  $r2 \u003d $r1.get(0)\n  r3 \u003d DateFormat) $r2\n  $z0 \u003d SimpleDateFormat\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d SimpleDateFormat) r3\n  $r8 \u003d $r7.toPattern()\n  $r9 \u003d dynInvoke makeConcatWithConstants($r8)\n  return\n}",
      "B2 {\n  $r4 \u003d r3.getClass()\n  $r5 \u003d $r4.getSimpleName()\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "methodName": "create",
    "signature": "com.google.gson.TypeAdapter create(com.google.gson.Gson,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Class\u003c? super T\u003e rawType \u003d targetType.getRawType();\r\n    JsonAdapter annotation \u003d rawType.getAnnotation(JsonAdapter.class);\r\n    if (annotation \u003d\u003d null) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter\u003cT\u003e) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r3 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonAdapterAnnotationTypeAdapterFactory\n  Gson\n  TypeToken\n  r1 \u003d r0.getRawType()\n  $r2 \u003d r1.getAnnotation(class \"Lcom/google/gson/annotations/JsonAdapter;\")\n  r3 \u003d JsonAdapter) $r2\n  if (r3 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r6 \u003d ConstructorConstructor constructorConstructor\u003e\n  $r7 \u003d r4.getTypeAdapter($r6, r5, r0, r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonAdapterAnnotationTypeAdapterFactory#getTypeAdapter(...4)",
        "body": "{\r\n    Object instance \u003d constructorConstructor.get(TypeToken.get(annotation.value())).construct();\r\n    TypeAdapter\u003c?\u003e typeAdapter;\r\n    boolean nullSafe \u003d annotation.nullSafe();\r\n    if (instance instanceof TypeAdapter) {\r\n        typeAdapter \u003d (TypeAdapter\u003c?\u003e) instance;\r\n    } else if (instance instanceof TypeAdapterFactory) {\r\n        typeAdapter \u003d ((TypeAdapterFactory) instance).create(gson, type);\r\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n        JsonSerializer\u003c?\u003e serializer \u003d instance instanceof JsonSerializer ? (JsonSerializer\u003c?\u003e) instance : null;\r\n        JsonDeserializer\u003c?\u003e deserializer \u003d instance instanceof JsonDeserializer ? (JsonDeserializer\u003c?\u003e) instance : null;\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapter\u003c?\u003e tempAdapter \u003d new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\r\n        typeAdapter \u003d tempAdapter;\r\n        nullSafe \u003d false;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n    }\r\n    if (typeAdapter !\u003d null \u0026\u0026 nullSafe) {\r\n        typeAdapter \u003d typeAdapter.nullSafe();\r\n    }\r\n    return typeAdapter;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "endArray",
    "signature": "void endArray()",
    "visibility": "public",
    "body": "{\r\n    expect(JsonToken.END_ARRAY);\r\n    // empty iterator\r\n    popStack();\r\n    // array\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  $r1 \u003d JsonToken END_ARRAY\u003e\n  r0.expect($r1)\n  r0.popStack()\n  r0.popStack()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r2[$i2]\n  $i4 \u003d $i3 + 1\n  $r2[$i2] \u003d $i4\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#expect(...1)",
        "body": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "endObject",
    "signature": "void endObject()",
    "visibility": "public",
    "body": "{\r\n    expect(JsonToken.END_OBJECT);\r\n    // Free the last path name so that it can be garbage collected\r\n    pathNames[stackSize - 1] \u003d null;\r\n    // empty iterator\r\n    popStack();\r\n    // object\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i2 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  $r1 \u003d JsonToken END_OBJECT\u003e\n  r0.expect($r1)\n  $r2 \u003d String[] pathNames\u003e\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  $r2[$i1] \u003d null\n  r0.popStack()\n  r0.popStack()\n  $i2 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i2 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i3 \u003d JsonTreeReader: int stackSize\u003e\n  $i4 \u003d $i3 - 1\n  $i5 \u003d $r3[$i4]\n  $i6 \u003d $i5 + 1\n  $r3[$i4] \u003d $i6\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#expect(...1)",
        "body": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "hasNext",
    "signature": "boolean hasNext()",
    "visibility": "public",
    "body": "{\r\n    JsonToken token \u003d peek();\r\n    return token !\u003d JsonToken.END_OBJECT \u0026\u0026 token !\u003d JsonToken.END_ARRAY \u0026\u0026 token !\u003d JsonToken.END_DOCUMENT;\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B4",
      "B1 : If(r1 \u003d\u003d $r3) → B2 | else → B4",
      "B2 : If(r1 \u003d\u003d $r4) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonToken END_OBJECT\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B4\n}",
      "B1 {\n  $r3 \u003d JsonToken END_ARRAY\u003e\n  if (r1 \u003d\u003d $r3) goto B2 else B4\n}",
      "B2 {\n  $r4 \u003d JsonToken END_DOCUMENT\u003e\n  if (r1 \u003d\u003d $r4) goto B3 else B4\n}",
      "B3 {\n  $z0 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z0 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "peek",
    "signature": "com.google.gson.stream.JsonToken peek()",
    "visibility": "public",
    "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}",
    "nodes": 28,
    "edges": 28,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B11",
      "B3 : If($z8 \u003d\u003d false) → B4 | else → B7",
      "B4 : If(z9 \u003d\u003d false) → B5 | else → B6",
      "B7 : If(z9 \u003d\u003d false) → B8 | else → B9",
      "B11 : If($z1 \u003d\u003d false) → B12 | else → B13",
      "B13 : If($z2 \u003d\u003d false) → B14 | else → B15",
      "B15 : If($z3 \u003d\u003d false) → B16 | else → B23",
      "B16 : If($z5 \u003d\u003d false) → B17 | else → B18",
      "B18 : If($z6 \u003d\u003d false) → B19 | else → B20",
      "B20 : If($z7 \u003d\u003d false) → B21 | else → B22",
      "B23 : If($z4 \u003d\u003d false) → B24 | else → B25",
      "B25 : If(r1 !\u003d $r2) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r21 \u003d JsonToken END_DOCUMENT\u003e\n  return\n}",
      "B2 {\n  r1 \u003d r0.peekStack()\n  $z0 \u003d Iterator\n  if ($z0 \u003d\u003d false) goto B3 else B11\n}",
      "B3 {\n  $r15 \u003d Object[] stack\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 2\n  $r16 \u003d $r15[$i2]\n  z9 \u003d JsonObject\n  r17 \u003d Iterator) r1\n  $z8 \u003d r17.hasNext()\n  if ($z8 \u003d\u003d false) goto B4 else B7\n}",
      "B4 {\n  if (z9 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r20 \u003d JsonToken NAME\u003e\n  return\n}",
      "B6 {\n  $r18 \u003d r17.next()\n  r0.push($r18)\n  $r19 \u003d r0.peek()\n  return\n}",
      "B7 {\n  if (z9 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r22 \u003d JsonToken END_OBJECT\u003e\n  goto B10\n}",
      "B9 {\n  $r22 \u003d JsonToken END_ARRAY\u003e\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $z1 \u003d JsonObject\n  if ($z1 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  $r14 \u003d JsonToken BEGIN_OBJECT\u003e\n  return\n}",
      "B13 {\n  $z2 \u003d JsonArray\n  if ($z2 \u003d\u003d false) goto B14 else B15\n}",
      "B14 {\n  $r13 \u003d JsonToken BEGIN_ARRAY\u003e\n  return\n}",
      "B15 {\n  $z3 \u003d JsonPrimitive\n  if ($z3 \u003d\u003d false) goto B16 else B23\n}",
      "B16 {\n  r23 \u003d JsonPrimitive) r1\n  $z5 \u003d r23.isString()\n  if ($z5 \u003d\u003d false) goto B17 else B18\n}",
      "B17 {\n  $r12 \u003d JsonToken STRING\u003e\n  return\n}",
      "B18 {\n  $z6 \u003d r23.isBoolean()\n  if ($z6 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r11 \u003d JsonToken BOOLEAN\u003e\n  return\n}",
      "B20 {\n  $z7 \u003d r23.isNumber()\n  if ($z7 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  $r10 \u003d JsonToken NUMBER\u003e\n  return\n}",
      "B22 {\n  $r9 \u003d AssertionError\n  new AssertionError()\n  throw $r9\n}",
      "B23 {\n  $z4 \u003d JsonNull\n  if ($z4 \u003d\u003d false) goto B24 else B25\n}",
      "B24 {\n  $r8 \u003d JsonToken NULL\u003e\n  return\n}",
      "B25 {\n  $r2 \u003d Object SENTINEL_CLOSED\u003e\n  if (r1 !\u003d $r2) goto B26 else B27\n}",
      "B26 {\n  $r7 \u003d IllegalStateException\n  new IllegalStateException(\"JsonReader is closed\")\n  throw $r7\n}",
      "B27 {\n  $r3 \u003d MalformedJsonException\n  $r4 \u003d r1.getClass()\n  $r5 \u003d $r4.getName()\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new MalformedJsonException($r6)\n  throw $r3\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B11",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e B16",
      "B15 --\u003e B23",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e [EXIT]",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e [EXIT]",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#peekStack(...0)",
        "body": "{\r\n    return stack[stackSize - 1];\r\n}"
      },
      {
        "name": "JsonTreeReader#push(...1)",
        "body": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextString",
    "signature": "java.lang.String nextString()",
    "visibility": "public",
    "body": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.STRING \u0026\u0026 token !\u003d JsonToken.NUMBER) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\r\n    }\r\n    String result \u003d ((JsonPrimitive) popStack()).getAsString();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r1 \u003d\u003d $r6) → B2 | else → B3",
      "B3 : If($i0 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonToken STRING\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  $r6 \u003d JsonToken NUMBER\u003e\n  if (r1 \u003d\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $r8 \u003d IllegalStateException\n  $r9 \u003d JsonToken STRING\u003e\n  $r12 \u003d String.valueOf($r9)\n  $r11 \u003d String.valueOf(r1)\n  $r10 \u003d r0.locationString()\n  $r13 \u003d dynInvoke makeConcatWithConstants($r12, $r11, $r10)\n  new IllegalStateException($r13)\n  throw $r8\n}",
      "B3 {\n  $r3 \u003d r0.popStack()\n  $r4 \u003d JsonPrimitive) $r3\n  $r7 \u003d $r4.getAsString()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r5[$i2]\n  $i4 \u003d $i3 + 1\n  $r5[$i2] \u003d $i4\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#locationString(...0)",
        "body": "{\r\n    return \" at path \" + getPath();\r\n}"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextBoolean",
    "signature": "boolean nextBoolean()",
    "visibility": "public",
    "body": "{\r\n    expect(JsonToken.BOOLEAN);\r\n    boolean result \u003d ((JsonPrimitive) popStack()).getAsBoolean();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  $r1 \u003d JsonToken BOOLEAN\u003e\n  r0.expect($r1)\n  $r2 \u003d r0.popStack()\n  $r3 \u003d JsonPrimitive) $r2\n  z0 \u003d $r3.getAsBoolean()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r4[$i2]\n  $i4 \u003d $i3 + 1\n  $r4[$i2] \u003d $i4\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#expect(...1)",
        "body": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextNull",
    "signature": "void nextNull()",
    "visibility": "public",
    "body": "{\r\n    expect(JsonToken.NULL);\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  $r1 \u003d JsonToken NULL\u003e\n  r0.expect($r1)\n  r0.popStack()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r2[$i2]\n  $i4 \u003d $i3 + 1\n  $r2[$i2] \u003d $i4\n}",
      "B2 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#expect(...1)",
        "body": "{\r\n    if (peek() !\u003d expected) {\r\n        throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString());\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextDouble",
    "signature": "double nextDouble()",
    "visibility": "public",
    "body": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    double result \u003d ((JsonPrimitive) peekStack()).getAsDouble();\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nodes": 10,
    "edges": 13,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r1 \u003d\u003d $r8) → B2 | else → B3",
      "B3 : If($z0 !\u003d 0) → B4 | else → B7",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B5 : If($z2 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($i0 \u003c\u003d 0) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonToken NUMBER\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  $r8 \u003d JsonToken STRING\u003e\n  if (r1 \u003d\u003d $r8) goto B2 else B3\n}",
      "B2 {\n  $r9 \u003d IllegalStateException\n  $r10 \u003d JsonToken NUMBER\u003e\n  $r13 \u003d String.valueOf($r10)\n  $r12 \u003d String.valueOf(r1)\n  $r11 \u003d r0.locationString()\n  $r14 \u003d dynInvoke makeConcatWithConstants($r13, $r12, $r11)\n  new IllegalStateException($r14)\n  throw $r9\n}",
      "B3 {\n  $r3 \u003d r0.peekStack()\n  $r4 \u003d JsonPrimitive) $r3\n  $d0 \u003d $r4.getAsDouble()\n  $z0 \u003d r0.isLenient()\n  if ($z0 !\u003d 0) goto B4 else B7\n}",
      "B4 {\n  $z1 \u003d Double.isNaN($d0)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z2 \u003d Double.isInfinite($d0)\n  if ($z2 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $r6 \u003d MalformedJsonException\n  $r7 \u003d dynInvoke makeConcatWithConstants($d0)\n  new MalformedJsonException($r7)\n  throw $r6\n}",
      "B7 {\n  r0.popStack()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r5[$i2]\n  $i4 \u003d $i3 + 1\n  $r5[$i2] \u003d $i4\n}",
      "B9 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#peekStack(...0)",
        "body": "{\r\n    return stack[stackSize - 1];\r\n}"
      },
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#locationString(...0)",
        "body": "{\r\n    return \" at path \" + getPath();\r\n}"
      },
      {
        "name": "JsonTreeReader#isLenient(...0)",
        "body": "(source not found)"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextLong",
    "signature": "long nextLong()",
    "visibility": "public",
    "body": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    long result \u003d ((JsonPrimitive) peekStack()).getAsLong();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r1 \u003d\u003d $r6) → B2 | else → B3",
      "B3 : If($i0 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonToken NUMBER\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  $r6 \u003d JsonToken STRING\u003e\n  if (r1 \u003d\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d IllegalStateException\n  $r8 \u003d JsonToken NUMBER\u003e\n  $r11 \u003d String.valueOf($r8)\n  $r10 \u003d String.valueOf(r1)\n  $r9 \u003d r0.locationString()\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11, $r10, $r9)\n  new IllegalStateException($r12)\n  throw $r7\n}",
      "B3 {\n  $r3 \u003d r0.peekStack()\n  $r4 \u003d JsonPrimitive) $r3\n  $l5 \u003d $r4.getAsLong()\n  r0.popStack()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r5[$i2]\n  $i4 \u003d $i3 + 1\n  $r5[$i2] \u003d $i4\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#peekStack(...0)",
        "body": "{\r\n    return stack[stackSize - 1];\r\n}"
      },
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#locationString(...0)",
        "body": "{\r\n    return \" at path \" + getPath();\r\n}"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "nextInt",
    "signature": "int nextInt()",
    "visibility": "public",
    "body": "{\r\n    JsonToken token \u003d peek();\r\n    if (token !\u003d JsonToken.NUMBER \u0026\u0026 token !\u003d JsonToken.STRING) {\r\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\r\n    }\r\n    int result \u003d ((JsonPrimitive) peekStack()).getAsInt();\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n    return result;\r\n}",
    "nodes": 6,
    "edges": 7,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d $r2) → B1 | else → B3",
      "B1 : If(r1 \u003d\u003d $r6) → B2 | else → B3",
      "B3 : If($i0 \u003c\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonToken NUMBER\u003e\n  if (r1 \u003d\u003d $r2) goto B1 else B3\n}",
      "B1 {\n  $r6 \u003d JsonToken STRING\u003e\n  if (r1 \u003d\u003d $r6) goto B2 else B3\n}",
      "B2 {\n  $r7 \u003d IllegalStateException\n  $r8 \u003d JsonToken NUMBER\u003e\n  $r11 \u003d String.valueOf($r8)\n  $r10 \u003d String.valueOf(r1)\n  $r9 \u003d r0.locationString()\n  $r12 \u003d dynInvoke makeConcatWithConstants($r11, $r10, $r9)\n  new IllegalStateException($r12)\n  throw $r7\n}",
      "B3 {\n  $r3 \u003d r0.peekStack()\n  $r4 \u003d JsonPrimitive) $r3\n  $i5 \u003d $r4.getAsInt()\n  r0.popStack()\n  $i0 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i0 \u003c\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i1 \u003d JsonTreeReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $i3 \u003d $r5[$i2]\n  $i4 \u003d $i3 + 1\n  $r5[$i2] \u003d $i4\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#peekStack(...0)",
        "body": "{\r\n    return stack[stackSize - 1];\r\n}"
      },
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#locationString(...0)",
        "body": "{\r\n    return \" at path \" + getPath();\r\n}"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeReader",
    "methodName": "skipValue",
    "signature": "void skipValue()",
    "visibility": "public",
    "body": "{\r\n    JsonToken peeked \u003d peek();\r\n    switch(peeked) {\r\n        case NAME:\r\n            @SuppressWarnings(\"unused\")\r\n            String unused \u003d nextName(true);\r\n            break;\r\n        case END_ARRAY:\r\n            endArray();\r\n            break;\r\n        case END_OBJECT:\r\n            endObject();\r\n            break;\r\n        case END_DOCUMENT:\r\n            // Do nothing\r\n            break;\r\n        default:\r\n            popStack();\r\n            if (stackSize \u003e 0) {\r\n                pathIndices[stackSize - 1]++;\r\n            }\r\n            break;\r\n    }\r\n}",
    "nodes": 8,
    "edges": 12,
    "cc": 6,
    "flowSummary": [
      "B0 : If(switch-on $i1) → B1 | else → B2",
      "B5 : If($i2 \u003c\u003d 0) → B6 | else → B7"
    ],
    "blockList": [
      "B0 {\n  JsonTreeReader\n  r1 \u003d r0.peek()\n  $r2 \u003d JsonTreeReader$2: int[] $SwitchMap$com$google$gson$stream$JsonToken\u003e\n  $i0 \u003d r1.ordinal()\n  $i1 \u003d $r2[$i0]\n  Object popStack()\u003e(); }\n}",
      "B1 {\n  r0.nextName(1)\n  goto B7\n}",
      "B2 {\n  r0.endArray()\n  goto B7\n}",
      "B3 {\n  r0.endObject()\n  goto B7\n}",
      "B4 {\n  goto B7\n}",
      "B5 {\n  r0.popStack()\n  $i2 \u003d JsonTreeReader: int stackSize\u003e\n  if ($i2 \u003c\u003d 0) goto B6 else B7\n}",
      "B6 {\n  $r3 \u003d JsonTreeReader: int[] pathIndices\u003e\n  $i3 \u003d JsonTreeReader: int stackSize\u003e\n  $i4 \u003d $i3 - 1\n  $i5 \u003d $r3[$i4]\n  $i6 \u003d $i5 + 1\n  $r3[$i4] \u003d $i6\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B0 --\u003e B4",
      "B0 --\u003e B5",
      "B1 --\u003e B7",
      "B2 --\u003e B7",
      "B3 --\u003e B7",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeReader#nextName(...1)",
        "body": "{\r\n    expect(JsonToken.NAME);\r\n    Iterator\u003c?\u003e i \u003d (Iterator\u003c?\u003e) peekStack();\r\n    Map.Entry\u003c?, ?\u003e entry \u003d (Map.Entry\u003c?, ?\u003e) i.next();\r\n    String result \u003d (String) entry.getKey();\r\n    pathNames[stackSize - 1] \u003d skipName ? \"\u003cskipped\u003e\" : result;\r\n    push(entry.getValue());\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#endArray(...0)",
        "body": "{\r\n    expect(JsonToken.END_ARRAY);\r\n    // empty iterator\r\n    popStack();\r\n    // array\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeReader#endObject(...0)",
        "body": "{\r\n    expect(JsonToken.END_OBJECT);\r\n    // Free the last path name so that it can be garbage collected\r\n    pathNames[stackSize - 1] \u003d null;\r\n    // empty iterator\r\n    popStack();\r\n    // object\r\n    popStack();\r\n    if (stackSize \u003e 0) {\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeReader#popStack(...0)",
        "body": "{\r\n    Object result \u003d stack[--stackSize];\r\n    stack[stackSize] \u003d null;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonTreeReader#peek(...0)",
        "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o \u003d peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject \u003d stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator\u003c?\u003e iterator \u003d (Iterator\u003c?\u003e) o;\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive \u003d (JsonPrimitive) o;\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o \u003d\u003d SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException(\"Custom JsonElement subclass \" + o.getClass().getName() + \" is not supported\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "get",
    "signature": "com.google.gson.JsonElement get()",
    "visibility": "public",
    "body": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\r\n    }\r\n    return product;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  $r1 \u003d List stack\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d IllegalStateException\n  $r4 \u003d List stack\u003e\n  $r5 \u003d String.valueOf($r4)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new IllegalStateException($r6)\n  throw $r3\n}",
      "B2 {\n  $r2 \u003d JsonElement product\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "endArray",
    "signature": "com.google.gson.stream.JsonWriter endArray()",
    "visibility": "public",
    "body": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonArray) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  $r1 \u003d List stack\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d String pendingName\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r2\n}",
      "B3 {\n  r4 \u003d r0.peek()\n  $z1 \u003d JsonArray\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r7 \u003d List stack\u003e\n  $r6 \u003d List stack\u003e\n  $i0 \u003d $r6.size()\n  $i1 \u003d $i0 - 1\n  $r7.remove($i1)\n  return\n}",
      "B5 {\n  $r5 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#peek(...0)",
        "body": "{\r\n    return stack.get(stack.size() - 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "endObject",
    "signature": "com.google.gson.stream.JsonWriter endObject()",
    "visibility": "public",
    "body": "{\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        stack.remove(stack.size() - 1);\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($r3 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  $r1 \u003d List stack\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d String pendingName\u003e\n  if ($r3 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r2 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r2\n}",
      "B3 {\n  r4 \u003d r0.peek()\n  $z1 \u003d JsonObject\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r7 \u003d List stack\u003e\n  $r6 \u003d List stack\u003e\n  $i0 \u003d $r6.size()\n  $i1 \u003d $i0 - 1\n  $r7.remove($i1)\n  return\n}",
      "B5 {\n  $r5 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r5\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#peek(...0)",
        "body": "{\r\n    return stack.get(stack.size() - 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "name",
    "signature": "com.google.gson.stream.JsonWriter name(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (stack.isEmpty() || pendingName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    JsonElement element \u003d peek();\r\n    if (element instanceof JsonObject) {\r\n        pendingName \u003d name;\r\n        return this;\r\n    }\r\n    throw new IllegalStateException();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($r4 \u003d\u003d null) → B2 | else → B3",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  String\n  Objects.requireNonNull(r0, \"name \u003d\u003d null\")\n  $r2 \u003d List stack\u003e\n  $z0 \u003d $r2.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d String pendingName\u003e\n  if ($r4 \u003d\u003d null) goto B2 else B3\n}",
      "B2 {\n  $r3 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r3\n}",
      "B3 {\n  r5 \u003d r1.peek()\n  $z1 \u003d JsonObject\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  String pendingName\u003e \u003d r0\n  return\n}",
      "B5 {\n  $r6 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r6\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#peek(...0)",
        "body": "{\r\n    return stack.get(stack.size() - 1);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  $r2 \u003d JsonPrimitive\n  new JsonPrimitive(r0)\n  r1.put($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#put(...1)",
        "body": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeWriter#nullValue(...0)",
        "body": "{\r\n    put(JsonNull.INSTANCE);\r\n    return this;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.Boolean)",
    "visibility": "public",
    "body": "{\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  Boolean\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  $r2 \u003d JsonPrimitive\n  new JsonPrimitive(r0)\n  r1.put($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#put(...1)",
        "body": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(float)",
    "visibility": "public",
    "body": "{\r\n    if (!isLenient() \u0026\u0026 (Float.isNaN(value) || Float.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  f0 :\u003d @parameter0: float\n  $z0 \u003d r0.isLenient()\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d Float.isNaN(f0)\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d Float.isInfinite(f0)\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(f0)\n  new IllegalArgumentException($r4)\n  throw $r3\n}",
      "B4 {\n  $r1 \u003d JsonPrimitive\n  $r2 \u003d Float.valueOf(f0)\n  new JsonPrimitive($r2)\n  r0.put($r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#put(...1)",
        "body": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeWriter#isLenient(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(double)",
    "visibility": "public",
    "body": "{\r\n    if (!isLenient() \u0026\u0026 (Double.isNaN(value) || Double.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  d0 :\u003d @parameter0: double\n  $z0 \u003d r0.isLenient()\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d Double.isNaN(d0)\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d Double.isInfinite(d0)\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(d0)\n  new IllegalArgumentException($r4)\n  throw $r3\n}",
      "B4 {\n  $r1 \u003d JsonPrimitive\n  $r2 \u003d Double.valueOf(d0)\n  new JsonPrimitive($r2)\n  r0.put($r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#put(...1)",
        "body": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeWriter#isLenient(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.Number)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    if (!isLenient()) {\r\n        double d \u003d value.doubleValue();\r\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\r\n            throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\r\n        }\r\n    }\r\n    put(new JsonPrimitive(value));\r\n    return this;\r\n}",
    "nodes": 7,
    "edges": 8,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B6",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  Number\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  $z0 \u003d r1.isLenient()\n  if ($z0 !\u003d 0) goto B3 else B6\n}",
      "B3 {\n  d0 \u003d r0.doubleValue()\n  $z1 \u003d Double.isNaN(d0)\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $z2 \u003d Double.isInfinite(d0)\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d String.valueOf(r0)\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4)\n  new IllegalArgumentException($r5)\n  throw $r3\n}",
      "B6 {\n  $r2 \u003d JsonPrimitive\n  new JsonPrimitive(r0)\n  r1.put($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonTreeWriter#put(...1)",
        "body": "{\r\n    if (pendingName !\u003d null) {\r\n        if (!value.isJsonNull() || getSerializeNulls()) {\r\n            JsonObject object \u003d (JsonObject) peek();\r\n            object.add(pendingName, value);\r\n        }\r\n        pendingName \u003d null;\r\n    } else if (stack.isEmpty()) {\r\n        product \u003d value;\r\n    } else {\r\n        JsonElement element \u003d peek();\r\n        if (element instanceof JsonArray) {\r\n            ((JsonArray) element).add(value);\r\n        } else {\r\n            throw new IllegalStateException();\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonTreeWriter#nullValue(...0)",
        "body": "{\r\n    put(JsonNull.INSTANCE);\r\n    return this;\r\n}"
      },
      {
        "name": "JsonTreeWriter#isLenient(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.JsonTreeWriter",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    if (!stack.isEmpty()) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stack.add(SENTINEL_CLOSED);\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonTreeWriter\n  $r1 \u003d List stack\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IOException\n  new IOException(\"Incomplete document\")\n  throw $r4\n}",
      "B2 {\n  $r3 \u003d List stack\u003e\n  $r2 \u003d JsonPrimitive SENTINEL_CLOSED\u003e\n  $r3.add($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "methodName": "create",
    "signature": "com.google.gson.TypeAdapter create(com.google.gson.Gson,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Type type \u003d typeToken.getType();\r\n    Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    if (!Map.class.isAssignableFrom(rawType)) {\r\n        return null;\r\n    }\r\n    Type[] keyAndValueTypes \u003d $Gson$Types.getMapKeyAndValueTypes(type, rawType);\r\n    TypeAdapter\u003c?\u003e keyAdapter \u003d getKeyAdapter(gson, keyAndValueTypes[0]);\r\n    TypeAdapter\u003c?\u003e valueAdapter \u003d gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(typeToken);\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    TypeAdapter\u003cT\u003e // we don\u0027t define a type parameter for the key or value types\r\n    result \u003d new Adapter(gson, keyAndValueTypes[0], keyAdapter, keyAndValueTypes[1], valueAdapter, constructor);\r\n    return result;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  MapTypeAdapterFactory\n  Gson\n  TypeToken\n  r1 \u003d r0.getType()\n  r2 \u003d r0.getRawType()\n  $r3 \u003d class \"Ljava/util/Map;\"\n  $z0 \u003d $r3.isAssignableFrom(r2)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  r4 \u003d $Gson$Types.getMapKeyAndValueTypes(r1, r2)\n  $r7 \u003d r4[0]\n  r8 \u003d r5.getKeyAdapter(r6, $r7)\n  $r9 \u003d r4[1]\n  $r10 \u003d TypeToken.get($r9)\n  r11 \u003d r6.getAdapter($r10)\n  $r12 \u003d ConstructorConstructor constructorConstructor\u003e\n  r13 \u003d $r12.get(r0)\n  $r14 \u003d MapTypeAdapterFactory$Adapter\n  $r16 \u003d r4[0]\n  $r15 \u003d r4[1]\n  new MapTypeAdapterFactory$Adapter(r5, r6, $r16, r8, $r15, r11, r13)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "MapTypeAdapterFactory#getKeyAdapter(...2)",
        "body": "{\r\n    return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter(TypeToken.get(keyType));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.NumberTypeAdapter",
    "methodName": "getFactory",
    "signature": "com.google.gson.TypeAdapterFactory getFactory(com.google.gson.ToNumberStrategy)",
    "visibility": "public",
    "body": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.LAZILY_PARSED_NUMBER) {\r\n        return LAZILY_PARSED_NUMBER_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToNumberStrategy\n  $r1 \u003d ToNumberPolicy LAZILY_PARSED_NUMBER\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d TypeAdapterFactory LAZILY_PARSED_NUMBER_FACTORY\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d NumberTypeAdapter.newFactory(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "NumberTypeAdapter#newFactory(...1)",
        "body": "{\r\n    final NumberTypeAdapter adapter \u003d new NumberTypeAdapter(toNumberStrategy);\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            return type.getRawType() \u003d\u003d Number.class ? (TypeAdapter\u003cT\u003e) adapter : null;\r\n        }\r\n    };\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.NumberTypeAdapter",
    "methodName": "read",
    "signature": "java.lang.Number read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    JsonToken jsonToken \u003d in.peek();\r\n    switch(jsonToken) {\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        case NUMBER:\r\n        case STRING:\r\n            return toNumberStrategy.readNumber(in);\r\n        default:\r\n            throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken + \"; at path \" + in.getPath());\r\n    }\r\n}",
    "nodes": 4,
    "edges": 3,
    "cc": 1,
    "flowSummary": [
      "B0 : If(switch-on $i1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  NumberTypeAdapter\n  JsonReader\n  r1 \u003d r0.peek()\n  $r2 \u003d NumberTypeAdapter$2: int[] $SwitchMap$com$google$gson$stream$JsonToken\u003e\n  $i0 \u003d r1.ordinal()\n  $i1 \u003d $r2[$i0]\n  JsonSyntaxException; }\n}",
      "B1 {\n  r0.nextNull()\n  return\n}",
      "B2 {\n  $r4 \u003d ToNumberStrategy toNumberStrategy\u003e\n  $r5 \u003d $r4.readNumber(r0)\n  return\n}",
      "B3 {\n  $r6 \u003d JsonSyntaxException\n  $r8 \u003d String.valueOf(r1)\n  $r7 \u003d r0.getPath()\n  $r9 \u003d dynInvoke makeConcatWithConstants($r8, $r7)\n  new JsonSyntaxException($r9)\n  throw $r6\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B0 --\u003e B3",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "methodName": "getFactory",
    "signature": "com.google.gson.TypeAdapterFactory getFactory(com.google.gson.ToNumberStrategy)",
    "visibility": "public",
    "body": "{\r\n    if (toNumberStrategy \u003d\u003d ToNumberPolicy.DOUBLE) {\r\n        return DOUBLE_FACTORY;\r\n    } else {\r\n        return newFactory(toNumberStrategy);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  ToNumberStrategy\n  $r1 \u003d ToNumberPolicy DOUBLE\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d TypeAdapterFactory DOUBLE_FACTORY\u003e\n  return\n}",
      "B2 {\n  $r2 \u003d ObjectTypeAdapter.newFactory(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ObjectTypeAdapter#newFactory(...1)",
        "body": "{\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public \u003cT\u003e TypeAdapter\u003cT\u003e create(Gson gson, TypeToken\u003cT\u003e type) {\r\n            if (type.getRawType() \u003d\u003d Object.class) {\r\n                return (TypeAdapter\u003cT\u003e) new ObjectTypeAdapter(gson, toNumberStrategy);\r\n            }\r\n            return null;\r\n        }\r\n    };\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "methodName": "read",
    "signature": "java.lang.Object read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    // Either List or Map\r\n    Object current;\r\n    JsonToken peeked \u003d in.peek();\r\n    current \u003d tryBeginNesting(in, peeked);\r\n    if (current \u003d\u003d null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque\u003cObject\u003e stack \u003d new ArrayDeque\u003c\u003e();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name \u003d null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof Map) {\r\n                name \u003d in.nextName();\r\n            }\r\n            peeked \u003d in.peek();\r\n            Object value \u003d tryBeginNesting(in, peeked);\r\n            boolean isNesting \u003d value !\u003d null;\r\n            if (value \u003d\u003d null) {\r\n                value \u003d readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof List) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List\u003cObject\u003e list \u003d (List\u003cObject\u003e) current;\r\n                list.add(value);\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Map\u003cString, Object\u003e map \u003d (Map\u003cString, Object\u003e) current;\r\n                map.put(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current \u003d value;\r\n            }\r\n        }\r\n        // End current element\r\n        if (current instanceof List) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current \u003d stack.removeLast();\r\n        }\r\n    }\r\n}",
    "nodes": 23,
    "edges": 30,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r7 !\u003d null) → B1 | else → B2",
      "B3 : If($z5 \u003d\u003d false) → B4 | else → B17",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($r4 \u003d\u003d null) → B7 | else → B8",
      "B9 : If($r4 !\u003d null) → B10 | else → B11",
      "B11 : If($z4 \u003d\u003d false) → B12 | else → B13",
      "B14 : If(z3 \u003d\u003d false) → B15 | else → B16",
      "B17 : If($z0 \u003d\u003d false) → B18 | else → B19",
      "B20 : If($z1 \u003d\u003d false) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  ObjectTypeAdapter\n  JsonReader\n  r6 \u003d r0.peek()\n  r7 \u003d r1.tryBeginNesting(r0, r6)\n  if (r7 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d r1.readTerminal(r0, r6)\n  return\n}",
      "B2 {\n  $r2 \u003d ArrayDeque\n  new ArrayDeque()\n}",
      "B3 {\n  $z5 \u003d r0.hasNext()\n  if ($z5 \u003d\u003d false) goto B4 else B17\n}",
      "B4 {\n  r8 \u003d null\n  $z2 \u003d Map\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  r8 \u003d r0.nextName()\n}",
      "B6 {\n  $r3 \u003d r0.peek()\n  $r4 \u003d r1.tryBeginNesting(r0, $r3)\n  r9 \u003d $r4\n  if ($r4 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  $z6 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z6 \u003d 0\n}",
      "B9 {\n  z3 \u003d $z6\n  if ($r4 !\u003d null) goto B10 else B11\n}",
      "B10 {\n  r9 \u003d r1.readTerminal(r0, $r3)\n}",
      "B11 {\n  $z4 \u003d List\n  if ($z4 \u003d\u003d false) goto B12 else B13\n}",
      "B12 {\n  r10 \u003d List) r7\n  r10.add(r9)\n  goto B14\n}",
      "B13 {\n  r11 \u003d Map) r7\n  r11.put(r8, r9)\n}",
      "B14 {\n  if (z3 \u003d\u003d false) goto B15 else B16\n}",
      "B15 {\n  $r2.addLast(r7)\n  r7 \u003d r9\n}",
      "B16 {\n  goto B3\n}",
      "B17 {\n  $z0 \u003d List\n  if ($z0 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  r0.endArray()\n  goto B20\n}",
      "B19 {\n  r0.endObject()\n}",
      "B20 {\n  $z1 \u003d $r2.isEmpty()\n  if ($z1 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  return\n}",
      "B22 {\n  r7 \u003d $r2.removeLast()\n  goto B3\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B17",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B3",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B20",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e B3"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ObjectTypeAdapter#readTerminal(...2)",
        "body": "{\r\n    switch(peeked) {\r\n        case STRING:\r\n            return in.nextString();\r\n        case NUMBER:\r\n            return toNumberStrategy.readNumber(in);\r\n        case BOOLEAN:\r\n            return in.nextBoolean();\r\n        case NULL:\r\n            in.nextNull();\r\n            return null;\r\n        default:\r\n            // When read(JsonReader) is called with JsonReader in invalid state\r\n            throw new IllegalStateException(\"Unexpected token: \" + peeked);\r\n    }\r\n}"
      },
      {
        "name": "ObjectTypeAdapter#tryBeginNesting(...2)",
        "body": "{\r\n    switch(peeked) {\r\n        case BEGIN_ARRAY:\r\n            in.beginArray();\r\n            return new ArrayList\u003c\u003e();\r\n        case BEGIN_OBJECT:\r\n            in.beginObject();\r\n            return new LinkedTreeMap\u003c\u003e();\r\n        default:\r\n            return null;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "methodName": "write",
    "signature": "void write(com.google.gson.stream.JsonWriter,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        out.nullValue();\r\n        return;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter\u003cObject\u003e typeAdapter \u003d (TypeAdapter\u003cObject\u003e) gson.getAdapter(value.getClass());\r\n    if (typeAdapter instanceof ObjectTypeAdapter) {\r\n        out.beginObject();\r\n        out.endObject();\r\n        return;\r\n    }\r\n    typeAdapter.write(out, value);\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  ObjectTypeAdapter\n  JsonWriter\n  Object\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r5.nullValue()\n  return\n}",
      "B2 {\n  $r2 \u003d Gson gson\u003e\n  $r3 \u003d r0.getClass()\n  r4 \u003d $r2.getAdapter($r3)\n  $z0 \u003d ObjectTypeAdapter\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r5.beginObject()\n  r5.endObject()\n  return\n}",
      "B4 {\n  r4.write(r5, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "methodName": "create",
    "signature": "com.google.gson.TypeAdapter create(com.google.gson.Gson,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Class\u003c? super T\u003e raw \u003d type.getRawType();\r\n    if (!Object.class.isAssignableFrom(raw)) {\r\n        // it\u0027s a primitive!\r\n        return null;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n    if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n        throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    boolean blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n    // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will always be false\r\n    // on JVMs that do not support records.\r\n    if (ReflectionHelper.isRecord(raw)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter\u003cT\u003e adapter \u003d (TypeAdapter\u003cT\u003e) new RecordAdapter\u003c\u003e(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n        return adapter;\r\n    }\r\n    ObjectConstructor\u003cT\u003e constructor \u003d constructorConstructor.get(type);\r\n    return new FieldReflectionAdapter\u003c\u003e(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n}",
    "nodes": 10,
    "edges": 10,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(r5 !\u003d $r6) → B3 | else → B4",
      "B4 : If(r5 !\u003d $r7) → B5 | else → B6",
      "B7 : If($z1 \u003d\u003d false) → B8 | else → B9"
    ],
    "blockList": [
      "B0 {\n  ReflectiveTypeAdapterFactory\n  Gson\n  TypeToken\n  r1 \u003d r0.getRawType()\n  $r2 \u003d class \"Ljava/lang/Object;\"\n  $z0 \u003d $r2.isAssignableFrom(r1)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r4 \u003d List reflectionFilters\u003e\n  r5 \u003d ReflectionAccessFilterHelper.getFilterResult($r4, r1)\n  $r6 \u003d ReflectionAccessFilter$FilterResult BLOCK_ALL\u003e\n  if (r5 !\u003d $r6) goto B3 else B4\n}",
      "B3 {\n  $r14 \u003d JsonIOException\n  $r15 \u003d String.valueOf(r1)\n  $r16 \u003d dynInvoke makeConcatWithConstants($r15)\n  new JsonIOException($r16)\n  throw $r14\n}",
      "B4 {\n  $r7 \u003d ReflectionAccessFilter$FilterResult BLOCK_INACCESSIBLE\u003e\n  if (r5 !\u003d $r7) goto B5 else B6\n}",
      "B5 {\n  $z5 \u003d 1\n  $z4 \u003d 1\n  $z3 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z5 \u003d 0\n  $z4 \u003d 0\n  $z3 \u003d 0\n}",
      "B7 {\n  $z1 \u003d ReflectionHelper.isRecord(r1)\n  if ($z1 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r12 \u003d ReflectiveTypeAdapterFactory$RecordAdapter\n  $r13 \u003d r3.getBoundFields(r10, r0, r1, $z3, 1)\n  new ReflectiveTypeAdapterFactory$RecordAdapter(r1, $r13, $z4)\n  return\n}",
      "B9 {\n  $r8 \u003d ConstructorConstructor constructorConstructor\u003e\n  r17 \u003d $r8.get(r0)\n  $r9 \u003d ReflectiveTypeAdapterFactory$FieldReflectionAdapter\n  $r11 \u003d r3.getBoundFields(r10, r0, r1, $z5, 0)\n  new ReflectiveTypeAdapterFactory$FieldReflectionAdapter(r17, $r11)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReflectiveTypeAdapterFactory#getBoundFields(...5)",
        "body": "{\r\n    Map\u003cString, BoundField\u003e result \u003d new LinkedHashMap\u003c\u003e();\r\n    if (raw.isInterface()) {\r\n        return result;\r\n    }\r\n    Class\u003c?\u003e originalRaw \u003d raw;\r\n    while (raw !\u003d Object.class) {\r\n        Field[] fields \u003d raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if (raw !\u003d originalRaw \u0026\u0026 fields.length \u003e 0) {\r\n            FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult \u003d\u003d FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\" + \" or adjust the access filter.\");\r\n            }\r\n            blockInaccessible \u003d filterResult \u003d\u003d FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize \u003d includeField(field, true);\r\n            boolean deserialize \u003d includeField(field, false);\r\n            if (!serialize \u0026\u0026 !deserialize) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out values\r\n            // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n            Method accessor \u003d null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize \u003d false;\r\n                } else {\r\n                    accessor \u003d ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if accessor method\r\n                    // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                    if (accessor.getAnnotation(SerializedName.class) !\u003d null \u0026\u0026 field.getAnnotation(SerializedName.class) \u003d\u003d null) {\r\n                        String methodDescription \u003d ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if (!blockInaccessible \u0026\u0026 accessor \u003d\u003d null) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType \u003d $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n            List\u003cString\u003e fieldNames \u003d getFieldNames(field);\r\n            BoundField previous \u003d null;\r\n            for (int i \u003d 0, size \u003d fieldNames.size(); i \u003c size; ++i) {\r\n                String name \u003d fieldNames.get(i);\r\n                // only serialize the default name\r\n                if (i !\u003d 0)\r\n                    serialize \u003d false;\r\n                BoundField boundField \u003d createBoundField(context, field, accessor, name, TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\r\n                BoundField replaced \u003d result.put(name, boundField);\r\n                if (previous \u003d\u003d null)\r\n                    previous \u003d replaced;\r\n            }\r\n            if (previous !\u003d null) {\r\n                throw new IllegalArgumentException(\"Class \" + originalRaw.getName() + \" declares multiple JSON fields named \u0027\" + previous.name + \"\u0027; conflict is caused\" + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field));\r\n            }\r\n        }\r\n        type \u003d TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw \u003d type.getRawType();\r\n    }\r\n    return result;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.TreeTypeAdapter",
    "methodName": "read",
    "signature": "java.lang.Object read(com.google.gson.stream.JsonReader)",
    "visibility": "public",
    "body": "{\r\n    if (deserializer \u003d\u003d null) {\r\n        return delegate().read(in);\r\n    }\r\n    JsonElement value \u003d Streams.parse(in);\r\n    if (nullSafe \u0026\u0026 value.isJsonNull()) {\r\n        return null;\r\n    }\r\n    return deserializer.deserialize(value, typeToken.getType(), context);\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z1 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  TreeTypeAdapter\n  JsonReader\n  $r1 \u003d JsonDeserializer deserializer\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d r0.delegate()\n  $r10 \u003d $r9.read(r2)\n  return\n}",
      "B2 {\n  r3 \u003d Streams.parse(r2)\n  $z0 \u003d TreeTypeAdapter: boolean nullSafe\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $z1 \u003d r3.isJsonNull()\n  if ($z1 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r5 \u003d JsonDeserializer deserializer\u003e\n  $r4 \u003d TypeToken typeToken\u003e\n  $r7 \u003d $r4.getType()\n  $r6 \u003d TreeTypeAdapter$GsonContextImpl context\u003e\n  $r8 \u003d $r5.deserialize(r3, $r7, $r6)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TreeTypeAdapter#delegate(...0)",
        "body": "{\r\n    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(skipPast, typeToken));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.TreeTypeAdapter",
    "methodName": "write",
    "signature": "void write(com.google.gson.stream.JsonWriter,java.lang.Object)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B5",
      "B3 : If(r2 !\u003d null) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  TreeTypeAdapter\n  JsonWriter\n  Object\n  $r1 \u003d JsonSerializer serializer\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d r0.delegate()\n  $r9.write(r7, r2)\n  return\n}",
      "B2 {\n  $z0 \u003d TreeTypeAdapter: boolean nullSafe\u003e\n  if ($z0 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  if (r2 !\u003d null) goto B4 else B5\n}",
      "B4 {\n  r7.nullValue()\n  return\n}",
      "B5 {\n  $r4 \u003d JsonSerializer serializer\u003e\n  $r3 \u003d TypeToken typeToken\u003e\n  $r6 \u003d $r3.getType()\n  $r5 \u003d TreeTypeAdapter$GsonContextImpl context\u003e\n  $r8 \u003d $r4.serialize(r2, $r6, $r5)\n  Streams.write($r8, r7)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.TreeTypeAdapter",
    "methodName": "getSerializationDelegate",
    "signature": "com.google.gson.TypeAdapter getSerializationDelegate()",
    "visibility": "public",
    "body": "{\r\n    return serializer !\u003d null ? this : delegate();\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TreeTypeAdapter\n  $r1 \u003d JsonSerializer serializer\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d r0.delegate()\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TreeTypeAdapter#delegate(...0)",
        "body": "{\r\n    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick\r\n    TypeAdapter\u003cT\u003e d \u003d delegate;\r\n    return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(skipPast, typeToken));\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.TreeTypeAdapter",
    "methodName": "newFactoryWithMatchRawType",
    "signature": "com.google.gson.TypeAdapterFactory newFactoryWithMatchRawType(com.google.gson.reflect.TypeToken,java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    // only bother matching raw types if exact type is a raw type\r\n    boolean matchRawType \u003d exactType.getType() \u003d\u003d exactType.getRawType();\r\n    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 !\u003d $r1) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  TypeToken\n  Object\n  $r2 \u003d r0.getType()\n  $r1 \u003d r0.getRawType()\n  if ($r2 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  $r3 \u003d TreeTypeAdapter$SingleTypeFactory\n  new TreeTypeAdapter$SingleTypeFactory(r4, r0, $z0, null)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.bind.util.ISO8601Utils",
    "methodName": "format",
    "signature": "java.lang.String format(java.util.Date,boolean,java.util.TimeZone)",
    "visibility": "public",
    "body": "{\r\n    Calendar calendar \u003d new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that\u0027s pedantic ;)\r\n    int capacity \u003d \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity +\u003d millis ? \".sss\".length() : 0;\r\n    capacity +\u003d tz.getRawOffset() \u003d\u003d 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted \u003d new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append(\u0027-\u0027);\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append(\u0027T\u0027);\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(\u0027:\u0027);\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append(\u0027.\u0027);\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset \u003d tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset !\u003d 0) {\r\n        int hours \u003d Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes \u003d Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset \u003c 0 ? \u0027-\u0027 : \u0027+\u0027);\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(\u0027:\u0027);\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append(\u0027Z\u0027);\r\n    }\r\n    return formatted.toString();\r\n}",
    "nodes": 15,
    "edges": 19,
    "cc": 6,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B3 : If($i0 !\u003d 0) → B4 | else → B5",
      "B6 : If(z0 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($i25 \u003d\u003d false) → B9 | else → B13",
      "B9 : If($i25 \u003e\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  Date\n  z0 :\u003d @parameter1: boolean\n  TimeZone\n  $r19 \u003d GregorianCalendar\n  $r2 \u003d Locale US\u003e\n  new GregorianCalendar(r1, $r2)\n  $r19.setTime(r3)\n  $r4 \u003d \"yyyy-MM-ddThh:mm:ss\"\n  i28 \u003d $r4.length()\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r18 \u003d sss\"\n  $i29 \u003d $r18.length()\n  goto B3\n}",
      "B2 {\n  $i29 \u003d 0\n}",
      "B3 {\n  $i27 \u003d i28 + $i29\n  $i0 \u003d r1.getRawOffset()\n  if ($i0 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r17 \u003d \"Z\"\n  $i30 \u003d $r17.length()\n  goto B6\n}",
      "B5 {\n  $r5 \u003d \"+hh:mm\"\n  $i30 \u003d $r5.length()\n}",
      "B6 {\n  $i26 \u003d $i27 + $i30\n  $r20 \u003d StringBuilder\n  new StringBuilder($i26)\n  $i2 \u003d $r19.get(1)\n  $r7 \u003d \"yyyy\"\n  $i1 \u003d $r7.length()\n  ISO8601Utils.padInt($r20, $i2, $i1)\n  $r20.append(45)\n  $i3 \u003d $r19.get(2)\n  $i5 \u003d $i3 + 1\n  $r8 \u003d \"MM\"\n  $i4 \u003d $r8.length()\n  ISO8601Utils.padInt($r20, $i5, $i4)\n  $r20.append(45)\n  $i7 \u003d $r19.get(5)\n  $r9 \u003d \"dd\"\n  $i6 \u003d $r9.length()\n  ISO8601Utils.padInt($r20, $i7, $i6)\n  $r20.append(84)\n  $i9 \u003d $r19.get(11)\n  $r10 \u003d \"hh\"\n  $i8 \u003d $r10.length()\n  ISO8601Utils.padInt($r20, $i9, $i8)\n  $r20.append(58)\n  $i11 \u003d $r19.get(12)\n  $r11 \u003d \"mm\"\n  $i10 \u003d $r11.length()\n  ISO8601Utils.padInt($r20, $i11, $i10)\n  $r20.append(58)\n  $i13 \u003d $r19.get(13)\n  $r12 \u003d \"ss\"\n  $i12 \u003d $r12.length()\n  ISO8601Utils.padInt($r20, $i13, $i12)\n  if (z0 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r20.append(46)\n  $i24 \u003d $r19.get(14)\n  $r16 \u003d \"sss\"\n  $i23 \u003d $r16.length()\n  ISO8601Utils.padInt($r20, $i24, $i23)\n}",
      "B8 {\n  $l14 \u003d $r19.getTimeInMillis()\n  $i25 \u003d r1.getOffset($l14)\n  if ($i25 \u003d\u003d false) goto B9 else B13\n}",
      "B9 {\n  $i33 \u003d (int) 60000\n  $i15 \u003d $i25 / $i33\n  $i16 \u003d $i15 / 60\n  i17 \u003d Math.abs($i16)\n  $i35 \u003d (int) 60000\n  $i18 \u003d $i25 / $i35\n  $i19 \u003d $i18 % 60\n  i20 \u003d Math.abs($i19)\n  if ($i25 \u003e\u003d 0) goto B10 else B11\n}",
      "B10 {\n  $c31 \u003d 45\n  goto B12\n}",
      "B11 {\n  $c31 \u003d 43\n}",
      "B12 {\n  $r20.append($c31)\n  $r14 \u003d \"hh\"\n  $i21 \u003d $r14.length()\n  ISO8601Utils.padInt($r20, i17, $i21)\n  $r20.append(58)\n  $r15 \u003d \"mm\"\n  $i22 \u003d $r15.length()\n  ISO8601Utils.padInt($r20, i20, $i22)\n  goto B14\n}",
      "B13 {\n  $r20.append(90)\n}",
      "B14 {\n  $r13 \u003d $r20.toString()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISO8601Utils#padInt(...3)",
        "body": "{\r\n    String strValue \u003d Integer.toString(value);\r\n    for (int i \u003d length - strValue.length(); i \u003e 0; i--) {\r\n        buffer.append(\u00270\u0027);\r\n    }\r\n    buffer.append(strValue);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.bind.util.ISO8601Utils",
    "methodName": "parse",
    "signature": "java.util.Date parse(java.lang.String,java.text.ParsePosition)",
    "visibility": "public",
    "body": "{\r\n    Exception fail \u003d null;\r\n    try {\r\n        int offset \u003d pos.getIndex();\r\n        // extract year\r\n        int year \u003d parseInt(date, offset, offset +\u003d 4);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract month\r\n        int month \u003d parseInt(date, offset, offset +\u003d 2);\r\n        if (checkOffset(date, offset, \u0027-\u0027)) {\r\n            offset +\u003d 1;\r\n        }\r\n        // extract day\r\n        int day \u003d parseInt(date, offset, offset +\u003d 2);\r\n        // default time value\r\n        int hour \u003d 0;\r\n        int minutes \u003d 0;\r\n        int seconds \u003d 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds \u003d 0;\r\n        // if the value has no time component (and no time zone), we are done\r\n        boolean hasT \u003d checkOffset(date, offset, \u0027T\u0027);\r\n        if (!hasT \u0026\u0026 (date.length() \u003c\u003d offset)) {\r\n            Calendar calendar \u003d new GregorianCalendar(year, month - 1, day);\r\n            calendar.setLenient(false);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n        }\r\n        if (hasT) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour \u003d parseInt(date, offset +\u003d 1, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            minutes \u003d parseInt(date, offset, offset +\u003d 2);\r\n            if (checkOffset(date, offset, \u0027:\u0027)) {\r\n                offset +\u003d 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() \u003e offset) {\r\n                char c \u003d date.charAt(offset);\r\n                if (c !\u003d \u0027Z\u0027 \u0026\u0026 c !\u003d \u0027+\u0027 \u0026\u0026 c !\u003d \u0027-\u0027) {\r\n                    seconds \u003d parseInt(date, offset, offset +\u003d 2);\r\n                    // truncate up to 3 leap seconds\r\n                    if (seconds \u003e 59 \u0026\u0026 seconds \u003c 63)\r\n                        seconds \u003d 59;\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, \u0027.\u0027)) {\r\n                        offset +\u003d 1;\r\n                        // assume at least one digit\r\n                        int endOffset \u003d indexOfNonDigit(date, offset + 1);\r\n                        // parse up to 3 digits\r\n                        int parseEndOffset \u003d Math.min(endOffset, offset + 3);\r\n                        int fraction \u003d parseInt(date, offset, parseEndOffset);\r\n                        // compensate for \"missing\" digits\r\n                        switch(// number of digits parsed\r\n                        parseEndOffset - offset) {\r\n                            case 2:\r\n                                milliseconds \u003d fraction * 10;\r\n                                break;\r\n                            case 1:\r\n                                milliseconds \u003d fraction * 100;\r\n                                break;\r\n                            default:\r\n                                milliseconds \u003d fraction;\r\n                        }\r\n                        offset \u003d endOffset;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        if (date.length() \u003c\u003d offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        TimeZone timezone \u003d null;\r\n        char timezoneIndicator \u003d date.charAt(offset);\r\n        if (timezoneIndicator \u003d\u003d \u0027Z\u0027) {\r\n            timezone \u003d TIMEZONE_UTC;\r\n            offset +\u003d 1;\r\n        } else if (timezoneIndicator \u003d\u003d \u0027+\u0027 || timezoneIndicator \u003d\u003d \u0027-\u0027) {\r\n            String timezoneOffset \u003d date.substring(offset);\r\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\r\n            timezoneOffset \u003d timezoneOffset.length() \u003e\u003d 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n            offset +\u003d timezoneOffset.length();\r\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\r\n                timezone \u003d TIMEZONE_UTC;\r\n            } else {\r\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                //    not sure why, but that\u0027s the way it looks. Further, Javadocs for\r\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                //    custom timezones... odd.\r\n                String timezoneId \u003d \"GMT\" + timezoneOffset;\r\n                //                    String timezoneId \u003d \"UTC\" + timezoneOffset;\r\n                timezone \u003d TimeZone.getTimeZone(timezoneId);\r\n                String act \u003d timezone.getID();\r\n                if (!act.equals(timezoneId)) {\r\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n                         *    one without. If so, don\u0027t sweat.\r\n                         *   Yes, very inefficient. Hopefully not hit often.\r\n                         *   If it becomes a perf problem, add \u0027loose\u0027 comparison instead.\r\n                         */\r\n                    String cleaned \u003d act.replace(\":\", \"\");\r\n                    if (!cleaned.equals(timezoneId)) {\r\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator \u0027\" + timezoneIndicator + \"\u0027\");\r\n        }\r\n        Calendar calendar \u003d new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it\u0027ll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException e) {\r\n        fail \u003d e;\r\n    } catch (NumberFormatException e) {\r\n        fail \u003d e;\r\n    } catch (IllegalArgumentException e) {\r\n        fail \u003d e;\r\n    }\r\n    String input \u003d (date \u003d\u003d null) ? null : (\u0027\"\u0027 + date + \u0027\"\u0027);\r\n    String msg \u003d fail.getMessage();\r\n    if (msg \u003d\u003d null || msg.isEmpty()) {\r\n        msg \u003d \"(\" + fail.getClass().getName() + \")\";\r\n    }\r\n    ParseException ex \u003d new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n    ex.initCause(fail);\r\n    throw ex;\r\n}",
    "nodes": 53,
    "edges": 75,
    "cc": 24,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z8 !\u003d 0) → B5 | else → B7",
      "B5 : If($i8 \u003e i16) → B6 | else → B7",
      "B7 : If($z8 \u003d\u003d false) → B8 | else → B25",
      "B8 : If($z6 \u003d\u003d false) → B9 | else → B10",
      "B10 : If($z7 \u003d\u003d false) → B11 | else → B12",
      "B12 : If($i3 \u003c\u003d i16) → B13 | else → B25",
      "B13 : If($i32 \u003d\u003d 90) → B14 | else → B25",
      "B14 : If($i33 \u003d\u003d 43) → B15 | else → B25",
      "B15 : If($i34 \u003d\u003d 45) → B16 | else → B25",
      "B16 : If(i19 \u003c\u003d 59) → B17 | else → B19",
      "B17 : If(i19 \u003e\u003d 63) → B18 | else → B19",
      "B19 : If($z10 \u003d\u003d false) → B20 | else → B25",
      "B20 : If(switch-on $i7) → B22 | else → B21",
      "B25 : If($i28 \u003e i16) → B26 | else → B27",
      "B27 : If($i35 !\u003d 90) → B28 | else → B29",
      "B29 : If($i36 \u003d\u003d 43) → B30 | else → B31",
      "B30 : If($i37 !\u003d 45) → B31 | else → B41",
      "B31 : If($i0 \u003c 5) → B32 | else → B33",
      "B34 : If($z2 !\u003d 0) → B35 | else → B36",
      "B35 : If($z3 \u003d\u003d false) → B36 | else → B37",
      "B37 : If($z4 !\u003d 0) → B38 | else → B40",
      "B38 : If($z5 !\u003d 0) → B39 | else → B40",
      "B46 : If(r1 !\u003d null) → B47 | else → B48",
      "B49 : If($r20 \u003d\u003d null) → B50 | else → B51",
      "B50 : If($z9 \u003d\u003d false) → B51 | else → B52"
    ],
    "blockList": [
      "B0 {\n  String\n  ParsePosition\n  i12 \u003d r0.getIndex()\n  i13 \u003d i12 + 4\n  i14 \u003d ISO8601Utils.parseInt(r1, i12, i13)\n  $z0 \u003d ISO8601Utils.checkOffset(r1, i13, 45)\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  i13 \u003d i13 + 1\n}",
      "B2 {\n  i15 \u003d i13 + 2\n  $i11 \u003d ISO8601Utils.parseInt(r1, i13, i15)\n  $z1 \u003d ISO8601Utils.checkOffset(r1, i15, 45)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  i15 \u003d i15 + 1\n}",
      "B4 {\n  i16 \u003d i15 + 2\n  $i10 \u003d ISO8601Utils.parseInt(r1, i15, i16)\n  i17 \u003d 0\n  i18 \u003d 0\n  i19 \u003d 0\n  i20 \u003d 0\n  $z8 \u003d ISO8601Utils.checkOffset(r1, i16, 84)\n  if ($z8 !\u003d 0) goto B5 else B7\n}",
      "B5 {\n  $i8 \u003d r1.length()\n  if ($i8 \u003e i16) goto B6 else B7\n}",
      "B6 {\n  $r32 \u003d GregorianCalendar\n  $i9 \u003d $i11 - 1\n  new GregorianCalendar(i14, $i9, $i10)\n  $r32.setLenient(0)\n  r0.setIndex(i16)\n  $r16 \u003d $r32.getTime()\n  return\n}",
      "B7 {\n  if ($z8 \u003d\u003d false) goto B8 else B25\n}",
      "B8 {\n  i21 \u003d i16 + 1\n  i22 \u003d i21 + 2\n  i17 \u003d ISO8601Utils.parseInt(r1, i21, i22)\n  $z6 \u003d ISO8601Utils.checkOffset(r1, i22, 58)\n  if ($z6 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  i22 \u003d i22 + 1\n}",
      "B10 {\n  i16 \u003d i22 + 2\n  i18 \u003d ISO8601Utils.parseInt(r1, i22, i16)\n  $z7 \u003d ISO8601Utils.checkOffset(r1, i16, 58)\n  if ($z7 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  i16 \u003d i16 + 1\n}",
      "B12 {\n  $i3 \u003d r1.length()\n  if ($i3 \u003c\u003d i16) goto B13 else B25\n}",
      "B13 {\n  c23 \u003d r1.charAt(i16)\n  $i32 \u003d (int) c23\n  if ($i32 \u003d\u003d 90) goto B14 else B25\n}",
      "B14 {\n  $i33 \u003d (int) c23\n  if ($i33 \u003d\u003d 43) goto B15 else B25\n}",
      "B15 {\n  $i34 \u003d (int) c23\n  if ($i34 \u003d\u003d 45) goto B16 else B25\n}",
      "B16 {\n  $i4 \u003d i16\n  i16 \u003d i16 + 2\n  i19 \u003d ISO8601Utils.parseInt(r1, $i4, i16)\n  if (i19 \u003c\u003d 59) goto B17 else B19\n}",
      "B17 {\n  if (i19 \u003e\u003d 63) goto B18 else B19\n}",
      "B18 {\n  i19 \u003d 59\n}",
      "B19 {\n  $z10 \u003d ISO8601Utils.checkOffset(r1, i16, 46)\n  if ($z10 \u003d\u003d false) goto B20 else B25\n}",
      "B20 {\n  i24 \u003d i16 + 1\n  $i5 \u003d i24 + 1\n  i25 \u003d ISO8601Utils.indexOfNonDigit(r1, $i5)\n  $i6 \u003d i24 + 3\n  i26 \u003d Math.min(i25, $i6)\n  i27 \u003d ISO8601Utils.parseInt(r1, i24, i26)\n  $i7 \u003d i26 - i24\n  lookupswitch($i7) {     case 1: goto i20 \u003d i27 * 100;     case 2: goto i20 \u003d i27 * 10;     default: goto i20 \u003d i27; }\n}",
      "B21 {\n  i20 \u003d i27 * 10\n  goto B24\n}",
      "B22 {\n  i20 \u003d i27 * 100\n  goto B24\n}",
      "B23 {\n  i20 \u003d i27\n}",
      "B24 {\n  i16 \u003d i25\n}",
      "B25 {\n  $i28 \u003d r1.length()\n  if ($i28 \u003e i16) goto B26 else B27\n}",
      "B26 {\n  $r33 \u003d IllegalArgumentException\n  new IllegalArgumentException(\"No time zone indicator\")\n  throw $r33\n}",
      "B27 {\n  c29 \u003d r1.charAt(i16)\n  $i35 \u003d (int) c29\n  if ($i35 !\u003d 90) goto B28 else B29\n}",
      "B28 {\n  r23 \u003d TimeZone TIMEZONE_UTC\u003e\n  i30 \u003d i16 + 1\n  goto B42\n}",
      "B29 {\n  $i36 \u003d (int) c29\n  if ($i36 \u003d\u003d 43) goto B30 else B31\n}",
      "B30 {\n  $i37 \u003d (int) c29\n  if ($i37 !\u003d 45) goto B31 else B41\n}",
      "B31 {\n  $r13 \u003d r1.substring(i16)\n  $i0 \u003d $r13.length()\n  if ($i0 \u003c 5) goto B32 else B33\n}",
      "B32 {\n  $r24 \u003d $r13\n  goto B34\n}",
      "B33 {\n  $r24 \u003d dynInvoke makeConcatWithConstants($r13)\n}",
      "B34 {\n  $i1 \u003d $r24.length()\n  i30 \u003d i16 + $i1\n  $r2 \u003d \"+0000\"\n  $z2 \u003d $r2.equals($r24)\n  if ($z2 !\u003d 0) goto B35 else B36\n}",
      "B35 {\n  $r5 \u003d \"+00:00\"\n  $z3 \u003d $r5.equals($r24)\n  if ($z3 \u003d\u003d false) goto B36 else B37\n}",
      "B36 {\n  r23 \u003d TimeZone TIMEZONE_UTC\u003e\n  goto B40\n}",
      "B37 {\n  r25 \u003d dynInvoke makeConcatWithConstants($r24)\n  r23 \u003d TimeZone.getTimeZone(r25)\n  r6 \u003d r23.getID()\n  $z4 \u003d r6.equals(r25)\n  if ($z4 !\u003d 0) goto B38 else B40\n}",
      "B38 {\n  r7 \u003d r6.replace(\":\", \"\")\n  $z5 \u003d r7.equals(r25)\n  if ($z5 !\u003d 0) goto B39 else B40\n}",
      "B39 {\n  $r34 \u003d IndexOutOfBoundsException\n  $r9 \u003d r23.getID()\n  $r10 \u003d dynInvoke makeConcatWithConstants(r25, $r9)\n  new IndexOutOfBoundsException($r10)\n  throw $r34\n}",
      "B40 {\n  goto B42\n}",
      "B41 {\n  $r35 \u003d IndexOutOfBoundsException\n  $r12 \u003d dynInvoke makeConcatWithConstants(c29)\n  new IndexOutOfBoundsException($r12)\n  throw $r35\n}",
      "B42 {\n  $r36 \u003d GregorianCalendar\n  new GregorianCalendar(r23)\n  $r36.setLenient(0)\n  $r36.set(1, i14)\n  $i2 \u003d $i11 - 1\n  $r36.set(2, $i2)\n  $r36.set(5, $i10)\n  $r36.set(11, i17)\n  $r36.set(12, i18)\n  $r36.set(13, i19)\n  $r36.set(14, i20)\n  r0.setIndex(i30)\n  $r4 \u003d $r36.getTime()\n  return\n}",
      "B43 {\n  $r22 :\u003d @caughtexception\n  r26 \u003d $r22\n  goto B46\n}",
      "B44 {\n  $r21 :\u003d @caughtexception\n  r26 \u003d $r21\n  goto B46\n}",
      "B45 {\n  $r17 :\u003d @caughtexception\n  r26 \u003d $r17\n}",
      "B46 {\n  if (r1 !\u003d null) goto B47 else B48\n}",
      "B47 {\n  $r27 \u003d null\n  goto B49\n}",
      "B48 {\n  $r27 \u003d dynInvoke makeConcatWithConstants(r1)\n}",
      "B49 {\n  r28 \u003d $r27\n  $r20 \u003d r26.getMessage()\n  r29 \u003d $r20\n  if ($r20 \u003d\u003d null) goto B50 else B51\n}",
      "B50 {\n  $z9 \u003d $r20.isEmpty()\n  if ($z9 \u003d\u003d false) goto B51 else B52\n}",
      "B51 {\n  $r18 \u003d r26.getClass()\n  $r19 \u003d $r18.getName()\n  r29 \u003d dynInvoke makeConcatWithConstants($r19)\n}",
      "B52 {\n  $r37 \u003d ParseException\n  $r31 \u003d dynInvoke makeConcatWithConstants(r28, r29)\n  $i31 \u003d r0.getIndex()\n  new ParseException($r31, $i31)\n  $r37.initCause(r26)\n  throw $r37\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B25",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B12",
      "B12 --\u003e B13",
      "B12 --\u003e B25",
      "B13 --\u003e B14",
      "B13 --\u003e B25",
      "B14 --\u003e B15",
      "B14 --\u003e B25",
      "B15 --\u003e B16",
      "B15 --\u003e B25",
      "B16 --\u003e B17",
      "B16 --\u003e B19",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B25",
      "B20 --\u003e B22",
      "B20 --\u003e B21",
      "B20 --\u003e B23",
      "B21 --\u003e B24",
      "B22 --\u003e B24",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B28",
      "B27 --\u003e B29",
      "B28 --\u003e B42",
      "B29 --\u003e B30",
      "B29 --\u003e B31",
      "B30 --\u003e B31",
      "B30 --\u003e B41",
      "B31 --\u003e B32",
      "B31 --\u003e B33",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e B35",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B35 --\u003e B37",
      "B36 --\u003e B40",
      "B37 --\u003e B38",
      "B37 --\u003e B40",
      "B38 --\u003e B39",
      "B38 --\u003e B40",
      "B39 --\u003e [EXIT]",
      "B40 --\u003e B42",
      "B41 --\u003e [EXIT]",
      "B42 --\u003e [EXIT]",
      "B43 --\u003e B46",
      "B44 --\u003e B46",
      "B45 --\u003e B46",
      "B46 --\u003e B47",
      "B46 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ISO8601Utils#parseInt(...3)",
        "body": "{\r\n    if (beginIndex \u003c 0 || endIndex \u003e value.length() || beginIndex \u003e endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we\u0027re not supporting negative values\r\n    int i \u003d beginIndex;\r\n    int result \u003d 0;\r\n    int digit;\r\n    if (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result \u003d -digit;\r\n    }\r\n    while (i \u003c endIndex) {\r\n        digit \u003d Character.digit(value.charAt(i++), 10);\r\n        if (digit \u003c 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *\u003d 10;\r\n        result -\u003d digit;\r\n    }\r\n    return -result;\r\n}"
      },
      {
        "name": "ISO8601Utils#indexOfNonDigit(...2)",
        "body": "{\r\n    for (int i \u003d offset; i \u003c string.length(); i++) {\r\n        char c \u003d string.charAt(i);\r\n        if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027)\r\n            return i;\r\n    }\r\n    return string.length();\r\n}"
      },
      {
        "name": "ISO8601Utils#checkOffset(...3)",
        "body": "{\r\n    return (offset \u003c value.length()) \u0026\u0026 (value.charAt(offset) \u003d\u003d expected);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.ConstructorConstructor",
    "methodName": "get",
    "signature": "com.google.gson.internal.ObjectConstructor get(com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    final Type type \u003d typeToken.getType();\r\n    final Class\u003c? super T\u003e rawType \u003d typeToken.getRawType();\r\n    // first try an instance creator\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e typeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(type);\r\n    if (typeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return typeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // Next try raw type match for instance creators\r\n    // types must agree\r\n    @SuppressWarnings(\"unchecked\")\r\n    final InstanceCreator\u003cT\u003e rawTypeCreator \u003d (InstanceCreator\u003cT\u003e) instanceCreators.get(rawType);\r\n    if (rawTypeCreator !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                return rawTypeCreator.createInstance(type);\r\n            }\r\n        };\r\n    }\r\n    // First consider special constructors before checking for no-args constructors\r\n    // below to avoid matching internal no-args constructors which might be added in\r\n    // future JDK versions\r\n    ObjectConstructor\u003cT\u003e specialConstructor \u003d newSpecialCollectionConstructor(type, rawType);\r\n    if (specialConstructor !\u003d null) {\r\n        return specialConstructor;\r\n    }\r\n    FilterResult filterResult \u003d ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, rawType);\r\n    ObjectConstructor\u003cT\u003e defaultConstructor \u003d newDefaultConstructor(rawType, filterResult);\r\n    if (defaultConstructor !\u003d null) {\r\n        return defaultConstructor;\r\n    }\r\n    ObjectConstructor\u003cT\u003e defaultImplementation \u003d newDefaultImplementationConstructor(type, rawType);\r\n    if (defaultImplementation !\u003d null) {\r\n        return defaultImplementation;\r\n    }\r\n    // Check whether type is instantiable; otherwise ReflectionAccessFilter recommendation\r\n    // of adjusting filter suggested below is irrelevant since it would not solve the problem\r\n    final String exceptionMessage \u003d checkInstantiable(rawType);\r\n    if (exceptionMessage !\u003d null) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessage);\r\n            }\r\n        };\r\n    }\r\n    // Consider usage of Unsafe as reflection, so don\u0027t use if BLOCK_ALL\r\n    // Additionally, since it is not calling any constructor at all, don\u0027t use if BLOCK_INACCESSIBLE\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        // finally try unsafe\r\n        return newUnsafeAllocator(rawType);\r\n    } else {\r\n        final String message \u003d \"Unable to create instance of \" + rawType + \"; ReflectionAccessFilter \" + \"does not permit using reflection or Unsafe. Register an InstanceCreator or a TypeAdapter \" + \"for this type or adjust the access filter to allow using reflection.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n}",
    "nodes": 15,
    "edges": 14,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r6 \u003d\u003d null) → B1 | else → B2",
      "B2 : If(r9 \u003d\u003d null) → B3 | else → B4",
      "B4 : If(r10 \u003d\u003d null) → B5 | else → B6",
      "B6 : If(r13 \u003d\u003d null) → B7 | else → B8",
      "B8 : If(r14 \u003d\u003d null) → B9 | else → B10",
      "B10 : If(r15 \u003d\u003d null) → B11 | else → B12",
      "B12 : If(r12 !\u003d $r16) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  ConstructorConstructor\n  TypeToken\n  r1 \u003d r0.getType()\n  r2 \u003d r0.getRawType()\n  $r4 \u003d Map instanceCreators\u003e\n  $r5 \u003d $r4.get(r1)\n  r6 \u003d InstanceCreator) $r5\n  if (r6 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r23 \u003d ConstructorConstructor$1\n  new ConstructorConstructor$1(r3, r6, r1)\n  return\n}",
      "B2 {\n  $r7 \u003d Map instanceCreators\u003e\n  $r8 \u003d $r7.get(r2)\n  r9 \u003d InstanceCreator) $r8\n  if (r9 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r22 \u003d ConstructorConstructor$2\n  new ConstructorConstructor$2(r3, r9, r1)\n  return\n}",
      "B4 {\n  r10 \u003d ConstructorConstructor.newSpecialCollectionConstructor(r1, r2)\n  if (r10 \u003d\u003d null) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r11 \u003d List reflectionFilters\u003e\n  r12 \u003d ReflectionAccessFilterHelper.getFilterResult($r11, r2)\n  r13 \u003d ConstructorConstructor.newDefaultConstructor(r2, r12)\n  if (r13 \u003d\u003d null) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  r14 \u003d ConstructorConstructor.newDefaultImplementationConstructor(r1, r2)\n  if (r14 \u003d\u003d null) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  r15 \u003d ConstructorConstructor.checkInstantiable(r2)\n  if (r15 \u003d\u003d null) goto B11 else B12\n}",
      "B11 {\n  $r21 \u003d ConstructorConstructor$3\n  new ConstructorConstructor$3(r3, r15)\n  return\n}",
      "B12 {\n  $r16 \u003d ReflectionAccessFilter$FilterResult ALLOW\u003e\n  if (r12 !\u003d $r16) goto B13 else B14\n}",
      "B13 {\n  $r20 \u003d r3.newUnsafeAllocator(r2)\n  return\n}",
      "B14 {\n  $r17 \u003d String.valueOf(r2)\n  r18 \u003d dynInvoke makeConcatWithConstants($r17)\n  $r19 \u003d ConstructorConstructor$4\n  new ConstructorConstructor$4(r3, r18)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ConstructorConstructor#newDefaultConstructor(...2)",
        "body": "{\r\n    // Cannot invoke constructor of abstract class\r\n    if (Modifier.isAbstract(rawType.getModifiers())) {\r\n        return null;\r\n    }\r\n    final Constructor\u003c? super T\u003e constructor;\r\n    try {\r\n        constructor \u003d rawType.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n    boolean canAccess \u003d filterResult \u003d\u003d FilterResult.ALLOW || (ReflectionAccessFilterHelper.canAccess(constructor, null) \u0026\u0026 // Be a bit more lenient here for BLOCK_ALL; if constructor is accessible and public then allow calling it\r\n    (filterResult !\u003d FilterResult.BLOCK_ALL || Modifier.isPublic(constructor.getModifiers())));\r\n    if (!canAccess) {\r\n        final String message \u003d \"Unable to invoke no-args constructor of \" + rawType + \"; \" + \"constructor is not accessible and ReflectionAccessFilter does not permit making \" + \"it accessible. Register an InstanceCreator or a TypeAdapter for this type, change \" + \"the visibility of the constructor or adjust the access filter.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(message);\r\n            }\r\n        };\r\n    }\r\n    // Only try to make accessible if allowed; in all other cases checks above should\r\n    // have verified that constructor is accessible\r\n    if (filterResult \u003d\u003d FilterResult.ALLOW) {\r\n        final String exceptionMessage \u003d ReflectionHelper.tryMakeAccessible(constructor);\r\n        if (exceptionMessage !\u003d null) {\r\n            /*\r\n         * Create ObjectConstructor which throws exception.\r\n         * This keeps backward compatibility (compared to returning `null` which\r\n         * would then choose another way of creating object).\r\n         * And it supports types which are only serialized but not deserialized\r\n         * (compared to directly throwing exception here), e.g. when runtime type\r\n         * of object is inaccessible, but compile-time type is accessible.\r\n         */\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    // New exception is created every time to avoid keeping reference\r\n                    // to exception with potentially long stack trace, causing a\r\n                    // memory leak\r\n                    throw new JsonIOException(exceptionMessage);\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return new ObjectConstructor\u003cT\u003e() {\r\n\r\n        @Override\r\n        public T construct() {\r\n            try {\r\n                // T is the same raw type as is requested\r\n                @SuppressWarnings(\"unchecked\")\r\n                T newInstance \u003d (T) constructor.newInstance();\r\n                return newInstance;\r\n            }// Note: InstantiationException should be impossible because check at start of method made sure\r\n            //   that class is not abstract\r\n             catch (InstantiationException e) {\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e);\r\n            } catch (InvocationTargetException e) {\r\n                // TODO: don\u0027t wrap if cause is unchecked?\r\n                // TODO: JsonParseException ?\r\n                throw new RuntimeException(\"Failed to invoke constructor \u0027\" + ReflectionHelper.constructorToString(constructor) + \"\u0027\" + \" with no args\", e.getCause());\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n        }\r\n    };\r\n}"
      },
      {
        "name": "ConstructorConstructor#newUnsafeAllocator(...1)",
        "body": "{\r\n    if (useJdkUnsafe) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                try {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    T newInstance \u003d (T) UnsafeAllocator.INSTANCE.newInstance(rawType);\r\n                    return newInstance;\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException((\"Unable to create instance of \" + rawType + \". \" + \"Registering an InstanceCreator or a TypeAdapter for this type, or adding a no-args \" + \"constructor may fix this problem.\"), e);\r\n                }\r\n            }\r\n        };\r\n    } else {\r\n        final String exceptionMessage \u003d \"Unable to create instance of \" + rawType + \"; usage of JDK Unsafe \" + \"is disabled. Registering an InstanceCreator or a TypeAdapter for this type, adding a no-args \" + \"constructor, or enabling usage of JDK Unsafe may fix this problem.\";\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                throw new JsonIOException(exceptionMessage);\r\n            }\r\n        };\r\n    }\r\n}"
      },
      {
        "name": "ConstructorConstructor#newSpecialCollectionConstructor(...2)",
        "body": "{\r\n    if (EnumSet.class.isAssignableFrom(rawType)) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T set \u003d (T) EnumSet.noneOf((Class) elementType);\r\n                        return set;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    } else // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\r\n    // and constructor parameter might have completely different meaning\r\n    if (rawType \u003d\u003d EnumMap.class) {\r\n        return new ObjectConstructor\u003cT\u003e() {\r\n\r\n            @Override\r\n            public T construct() {\r\n                if (type instanceof ParameterizedType) {\r\n                    Type elementType \u003d ((ParameterizedType) type).getActualTypeArguments()[0];\r\n                    if (elementType instanceof Class) {\r\n                        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n                        T map \u003d (T) new EnumMap((Class) elementType);\r\n                        return map;\r\n                    } else {\r\n                        throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                    }\r\n                } else {\r\n                    throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "ConstructorConstructor#newDefaultImplementationConstructor(...2)",
        "body": "{\r\n    /*\r\n     * IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n     * For classes with special constructors / factory methods (e.g. EnumSet)\r\n     * `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n     * constructor check (which is called before this method) detecting internal no-args\r\n     * constructors which might be added in a future JDK version\r\n     */\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashSet\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayDeque\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ArrayList\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentSkipListMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new ConcurrentHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new TreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedHashMap\u003c\u003e();\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor\u003cT\u003e() {\r\n\r\n                @Override\r\n                public T construct() {\r\n                    return (T) new LinkedTreeMap\u003c\u003e();\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}"
      },
      {
        "name": "ConstructorConstructor#checkInstantiable(...1)",
        "body": "{\r\n    int modifiers \u003d c.getModifiers();\r\n    if (Modifier.isInterface(modifiers)) {\r\n        return \"Interfaces can\u0027t be instantiated! Register an InstanceCreator \" + \"or a TypeAdapter for this type. Interface name: \" + c.getName();\r\n    }\r\n    if (Modifier.isAbstract(modifiers)) {\r\n        return \"Abstract classes can\u0027t be instantiated! Register an InstanceCreator \" + \"or a TypeAdapter for this type. Class name: \" + c.getName();\r\n    }\r\n    return null;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.Excluder",
    "methodName": "withModifiers",
    "signature": "com.google.gson.internal.Excluder withModifiers(int[])",
    "visibility": "public",
    "body": "{\r\n    Excluder result \u003d clone();\r\n    result.modifiers \u003d 0;\r\n    for (int modifier : modifiers) {\r\n        result.modifiers |\u003d modifier;\r\n    }\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If(i4 \u003e\u003d i0) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Excluder\n  r2 :\u003d @parameter0: int[]\n  r1 \u003d r0.clone()\n  Excluder: int modifiers\u003e \u003d 0\n  i0 \u003d lengthof r2\n  i4 \u003d 0\n}",
      "B1 {\n  if (i4 \u003e\u003d i0) goto B2 else B3\n}",
      "B2 {\n  i1 \u003d r2[i4]\n  $i2 \u003d Excluder: int modifiers\u003e\n  $i3 \u003d $i2 | i1\n  Excluder: int modifiers\u003e \u003d $i3\n  i4 \u003d i4 + 1\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Excluder#clone(...0)",
        "body": "{\r\n    try {\r\n        return (Excluder) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.Excluder",
    "methodName": "withExclusionStrategy",
    "signature": "com.google.gson.internal.Excluder withExclusionStrategy(com.google.gson.ExclusionStrategy,boolean,boolean)",
    "visibility": "public",
    "body": "{\r\n    Excluder result \u003d clone();\r\n    if (serialization) {\r\n        result.serializationStrategies \u003d new ArrayList\u003c\u003e(serializationStrategies);\r\n        result.serializationStrategies.add(exclusionStrategy);\r\n    }\r\n    if (deserialization) {\r\n        result.deserializationStrategies \u003d new ArrayList\u003c\u003e(deserializationStrategies);\r\n        result.deserializationStrategies.add(exclusionStrategy);\r\n    }\r\n    return result;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If(z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  Excluder\n  ExclusionStrategy\n  z0 :\u003d @parameter1: boolean\n  z1 :\u003d @parameter2: boolean\n  r1 \u003d r0.clone()\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d ArrayList\n  $r7 \u003d List serializationStrategies\u003e\n  new ArrayList($r7)\n  List serializationStrategies\u003e \u003d $r6\n  $r8 \u003d List serializationStrategies\u003e\n  $r8.add(r4)\n}",
      "B2 {\n  if (z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d ArrayList\n  $r3 \u003d List deserializationStrategies\u003e\n  new ArrayList($r3)\n  List deserializationStrategies\u003e \u003d $r2\n  $r5 \u003d List deserializationStrategies\u003e\n  $r5.add(r4)\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Excluder#clone(...0)",
        "body": "{\r\n    try {\r\n        return (Excluder) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.Excluder",
    "methodName": "create",
    "signature": "com.google.gson.TypeAdapter create(com.google.gson.Gson,com.google.gson.reflect.TypeToken)",
    "visibility": "public",
    "body": "{\r\n    Class\u003c?\u003e rawType \u003d type.getRawType();\r\n    boolean excludeClass \u003d excludeClassChecks(rawType);\r\n    final boolean skipSerialize \u003d excludeClass || excludeClassInStrategy(rawType, true);\r\n    final boolean skipDeserialize \u003d excludeClass || excludeClassInStrategy(rawType, false);\r\n    if (!skipSerialize \u0026\u0026 !skipDeserialize) {\r\n        return null;\r\n    }\r\n    return new TypeAdapter\u003cT\u003e() {\r\n\r\n        /**\r\n         * The delegate is lazily created because it may not be needed, and creating it may fail.\r\n         */\r\n        private TypeAdapter\u003cT\u003e delegate;\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (skipDeserialize) {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n            return delegate().read(in);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (skipSerialize) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            delegate().write(out, value);\r\n        }\r\n\r\n        private TypeAdapter\u003cT\u003e delegate() {\r\n            TypeAdapter\u003cT\u003e d \u003d delegate;\r\n            return d !\u003d null ? d : (delegate \u003d gson.getDelegateAdapter(Excluder.this, type));\r\n        }\r\n    };\r\n}",
    "nodes": 12,
    "edges": 16,
    "cc": 6,
    "flowSummary": [
      "B0 : If(z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z4 \u003d\u003d false) → B2 | else → B3",
      "B4 : If(z0 !\u003d 0) → B5 | else → B6",
      "B5 : If($z3 \u003d\u003d false) → B6 | else → B7",
      "B8 : If(z1 !\u003d 0) → B9 | else → B11",
      "B9 : If($z7 !\u003d 0) → B10 | else → B11"
    ],
    "blockList": [
      "B0 {\n  Excluder\n  Gson\n  TypeToken\n  r1 \u003d r0.getRawType()\n  z0 \u003d r2.excludeClassChecks(r1)\n  if (z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z4 \u003d r2.excludeClassInStrategy(r1, 1)\n  if ($z4 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z5 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z5 \u003d 0\n}",
      "B4 {\n  z1 \u003d $z5\n  if (z0 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  $z3 \u003d r2.excludeClassInStrategy(r1, 0)\n  if ($z3 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  $z8 \u003d 1\n  $z7 \u003d 1\n  goto B8\n}",
      "B7 {\n  $z8 \u003d 0\n  $z7 \u003d 0\n}",
      "B8 {\n  z2 \u003d $z8\n  if (z1 !\u003d 0) goto B9 else B11\n}",
      "B9 {\n  if ($z7 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  return\n}",
      "B11 {\n  $r3 \u003d Excluder$1\n  new Excluder$1(r2, z2, z1, r4, r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Excluder#excludeClassChecks(...1)",
        "body": "{\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\r\n        return true;\r\n    }\r\n    return isAnonymousOrNonStaticLocal(clazz);\r\n}"
      },
      {
        "name": "Excluder#excludeClassInStrategy(...2)",
        "body": "{\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    for (ExclusionStrategy exclusionStrategy : list) {\r\n        if (exclusionStrategy.shouldSkipClass(clazz)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "Excluder#delegate(...0)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.Excluder",
    "methodName": "excludeField",
    "signature": "boolean excludeField(java.lang.reflect.Field,boolean)",
    "visibility": "public",
    "body": "{\r\n    if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\r\n        return true;\r\n    }\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (field.isSynthetic()) {\r\n        return true;\r\n    }\r\n    if (requireExpose) {\r\n        Expose annotation \u003d field.getAnnotation(Expose.class);\r\n        if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\r\n        return true;\r\n    }\r\n    if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n        return true;\r\n    }\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    if (!list.isEmpty()) {\r\n        FieldAttributes fieldAttributes \u003d new FieldAttributes(field);\r\n        for (ExclusionStrategy exclusionStrategy : list) {\r\n            if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "nodes": 29,
    "edges": 37,
    "cc": 10,
    "flowSummary": [
      "B0 : If($i2 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($b3 \u003d\u003d false) → B3 | else → B5",
      "B3 : If($z10 !\u003d 0) → B4 | else → B5",
      "B5 : If($z0 \u003d\u003d false) → B6 | else → B7",
      "B7 : If($z1 \u003d\u003d false) → B8 | else → B14",
      "B8 : If(r13 \u003d\u003d null) → B9 | else → B13",
      "B9 : If(z3 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($z9 !\u003d 0) → B11 | else → B14",
      "B12 : If($z8 !\u003d 0) → B13 | else → B14",
      "B14 : If($z11 !\u003d 0) → B15 | else → B17",
      "B15 : If($z7 \u003d\u003d false) → B16 | else → B17",
      "B17 : If($z2 \u003d\u003d false) → B18 | else → B19",
      "B19 : If(z3 \u003d\u003d false) → B20 | else → B21",
      "B22 : If($z4 !\u003d 0) → B23 | else → B28",
      "B24 : If($z5 \u003d\u003d false) → B25 | else → B28",
      "B25 : If($z6 \u003d\u003d false) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  Excluder\n  Field\n  z3 :\u003d @parameter1: boolean\n  $i0 \u003d Excluder: int modifiers\u003e\n  $i1 \u003d r1.getModifiers()\n  $i2 \u003d $i0 \u0026 $i1\n  if ($i2 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $d0 \u003d Excluder: double version\u003e\n  $b3 \u003d 0\n  if ($b3 \u003d\u003d false) goto B3 else B5\n}",
      "B3 {\n  $r9 \u003d r1.getAnnotation(class \"Lcom/google/gson/annotations/Since;\")\n  $r12 \u003d Since) $r9\n  $r10 \u003d r1.getAnnotation(class \"Lcom/google/gson/annotations/Until;\")\n  $r11 \u003d Until) $r10\n  $z10 \u003d r0.isValidVersion($r12, $r11)\n  if ($z10 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $z0 \u003d r1.isSynthetic()\n  if ($z0 \u003d\u003d false) goto B6 else B7\n}",
      "B6 {\n  return\n}",
      "B7 {\n  $z1 \u003d Excluder: boolean requireExpose\u003e\n  if ($z1 \u003d\u003d false) goto B8 else B14\n}",
      "B8 {\n  $r8 \u003d r1.getAnnotation(class \"Lcom/google/gson/annotations/Expose;\")\n  r13 \u003d Expose) $r8\n  if (r13 \u003d\u003d null) goto B9 else B13\n}",
      "B9 {\n  if (z3 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $z9 \u003d r13.serialize()\n  if ($z9 !\u003d 0) goto B11 else B14\n}",
      "B11 {\n  goto B13\n}",
      "B12 {\n  $z8 \u003d r13.deserialize()\n  if ($z8 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $z11 \u003d Excluder: boolean serializeInnerClasses\u003e\n  if ($z11 !\u003d 0) goto B15 else B17\n}",
      "B15 {\n  $r7 \u003d r1.getType()\n  $z7 \u003d r0.isInnerClass($r7)\n  if ($z7 \u003d\u003d false) goto B16 else B17\n}",
      "B16 {\n  return\n}",
      "B17 {\n  $r2 \u003d r1.getType()\n  $z2 \u003d r0.isAnonymousOrNonStaticLocal($r2)\n  if ($z2 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  return\n}",
      "B19 {\n  if (z3 \u003d\u003d false) goto B20 else B21\n}",
      "B20 {\n  $r14 \u003d List serializationStrategies\u003e\n  goto B22\n}",
      "B21 {\n  $r14 \u003d List deserializationStrategies\u003e\n}",
      "B22 {\n  $z4 \u003d $r14.isEmpty()\n  if ($z4 !\u003d 0) goto B23 else B28\n}",
      "B23 {\n  $r3 \u003d FieldAttributes\n  new FieldAttributes(r1)\n  r4 \u003d $r14.iterator()\n}",
      "B24 {\n  $z5 \u003d r4.hasNext()\n  if ($z5 \u003d\u003d false) goto B25 else B28\n}",
      "B25 {\n  $r5 \u003d r4.next()\n  r6 \u003d ExclusionStrategy) $r5\n  $z6 \u003d r6.shouldSkipField($r3)\n  if ($z6 \u003d\u003d false) goto B26 else B27\n}",
      "B26 {\n  return\n}",
      "B27 {\n  goto B24\n}",
      "B28 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B14",
      "B8 --\u003e B9",
      "B8 --\u003e B13",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B17",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e [EXIT]",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e [EXIT]",
      "B19 --\u003e B20",
      "B19 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B22 --\u003e B23",
      "B22 --\u003e B28",
      "B23 --\u003e B24",
      "B24 --\u003e B25",
      "B24 --\u003e B28",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e [EXIT]",
      "B27 --\u003e B24",
      "B28 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Excluder#isAnonymousOrNonStaticLocal(...1)",
        "body": "{\r\n    return !Enum.class.isAssignableFrom(clazz) \u0026\u0026 !isStatic(clazz) \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\r\n}"
      },
      {
        "name": "Excluder#isValidVersion(...2)",
        "body": "{\r\n    return isValidSince(since) \u0026\u0026 isValidUntil(until);\r\n}"
      },
      {
        "name": "Excluder#isInnerClass(...1)",
        "body": "{\r\n    return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.Excluder",
    "methodName": "excludeClass",
    "signature": "boolean excludeClass(java.lang.Class,boolean)",
    "visibility": "public",
    "body": "{\r\n    return excludeClassChecks(clazz) || excludeClassInStrategy(clazz, serialize);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B1 : If($z2 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Excluder\n  Class\n  z1 :\u003d @parameter1: boolean\n  $z0 \u003d r0.excludeClassChecks(r1)\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z2 \u003d r0.excludeClassInStrategy(r1, z1)\n  if ($z2 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z3 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z3 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "Excluder#excludeClassChecks(...1)",
        "body": "{\r\n    if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\r\n        return true;\r\n    }\r\n    if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\r\n        return true;\r\n    }\r\n    return isAnonymousOrNonStaticLocal(clazz);\r\n}"
      },
      {
        "name": "Excluder#excludeClassInStrategy(...2)",
        "body": "{\r\n    List\u003cExclusionStrategy\u003e list \u003d serialize ? serializationStrategies : deserializationStrategies;\r\n    for (ExclusionStrategy exclusionStrategy : list) {\r\n        if (exclusionStrategy.shouldSkipClass(clazz)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.JavaVersion",
    "methodName": "isJava9OrLater",
    "signature": "boolean isJava9OrLater()",
    "visibility": "public",
    "body": "{\r\n    return majorJavaVersion \u003e\u003d 9;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 \u003c 9) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  $i0 \u003d JavaVersion: int majorJavaVersion\u003e\n  if ($i0 \u003c 9) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.LazilyParsedNumber",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj instanceof LazilyParsedNumber) {\r\n        LazilyParsedNumber other \u003d (LazilyParsedNumber) obj;\r\n        return value \u003d\u003d other.value || value.equals(other.value);\r\n    }\r\n    return false;\r\n}",
    "nodes": 9,
    "edges": 10,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B8",
      "B3 : If($r4 \u003d\u003d $r3) → B4 | else → B5",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  LazilyParsedNumber\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d LazilyParsedNumber\n  if ($z0 \u003d\u003d false) goto B3 else B8\n}",
      "B3 {\n  r2 \u003d LazilyParsedNumber) r1\n  $r4 \u003d String value\u003e\n  $r3 \u003d String value\u003e\n  if ($r4 \u003d\u003d $r3) goto B4 else B5\n}",
      "B4 {\n  $r6 \u003d String value\u003e\n  $r5 \u003d String value\u003e\n  $z1 \u003d $r6.equals($r5)\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $z2 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z2 \u003d 0\n}",
      "B7 {\n  return\n}",
      "B8 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B8",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "get",
    "signature": "java.lang.Object get(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  Object\n  r2 \u003d r0.findByObject(r1)\n  if (r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Object value\u003e\n  goto B3\n}",
      "B2 {\n  $r3 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LinkedTreeMap#findByObject(...1)",
        "body": "{\r\n    try {\r\n        return key !\u003d null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "containsKey",
    "signature": "boolean containsKey(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return findByObject(key) !\u003d null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  Object\n  $r2 \u003d r0.findByObject(r1)\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LinkedTreeMap#findByObject(...1)",
        "body": "{\r\n    try {\r\n        return key !\u003d null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "put",
    "signature": "java.lang.Object put(java.lang.Object,java.lang.Object)",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If(r1 !\u003d null) → B3 | else → B5",
      "B3 : If($z0 !\u003d 0) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  Object\n  Object\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r6 \u003d NullPointerException\n  new NullPointerException(\"key \u003d\u003d null\")\n  throw $r6\n}",
      "B2 {\n  if (r1 !\u003d null) goto B3 else B5\n}",
      "B3 {\n  $z0 \u003d LinkedTreeMap: boolean allowNullValues\u003e\n  if ($z0 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $r5 \u003d NullPointerException\n  new NullPointerException(\"value \u003d\u003d null\")\n  throw $r5\n}",
      "B5 {\n  $r3 \u003d r2.find(r0, 1)\n  $r4 \u003d Object value\u003e\n  Object value\u003e \u003d r1\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "remove",
    "signature": "java.lang.Object remove(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    Node\u003cK, V\u003e node \u003d removeInternalByKey(key);\r\n    return node !\u003d null ? node.value : null;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  Object\n  r2 \u003d r0.removeInternalByKey(r1)\n  if (r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Object value\u003e\n  goto B3\n}",
      "B2 {\n  $r3 \u003d null\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "LinkedTreeMap#removeInternalByKey(...1)",
        "body": "{\r\n    Node\u003cK, V\u003e node \u003d findByObject(key);\r\n    if (node !\u003d null) {\r\n        removeInternal(node, true);\r\n    }\r\n    return node;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "entrySet",
    "signature": "java.util.Set entrySet()",
    "visibility": "public",
    "body": "{\r\n    EntrySet result \u003d entrySet;\r\n    return result !\u003d null ? result : (entrySet \u003d new EntrySet());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  r1 \u003d LinkedTreeMap$EntrySet entrySet\u003e\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d LinkedTreeMap$EntrySet\n  new LinkedTreeMap$EntrySet(r0)\n  LinkedTreeMap$EntrySet entrySet\u003e \u003d $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.LinkedTreeMap",
    "methodName": "keySet",
    "signature": "java.util.Set keySet()",
    "visibility": "public",
    "body": "{\r\n    KeySet result \u003d keySet;\r\n    return result !\u003d null ? result : (keySet \u003d new KeySet());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 \u003d\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  LinkedTreeMap\n  r1 \u003d LinkedTreeMap$KeySet keySet\u003e\n  if (r1 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1\n  goto B3\n}",
      "B2 {\n  $r2 \u003d LinkedTreeMap$KeySet\n  new LinkedTreeMap$KeySet(r0)\n  LinkedTreeMap$KeySet keySet\u003e \u003d $r2\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.Primitives",
    "methodName": "isPrimitive",
    "signature": "boolean isPrimitive(java.lang.reflect.Type)",
    "visibility": "public",
    "body": "{\r\n    return type instanceof Class\u003c?\u003e \u0026\u0026 ((Class\u003c?\u003e) type).isPrimitive();\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  Type\n  $z0 \u003d Class\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r1 \u003d Class) r0\n  $z1 \u003d $r1.isPrimitive()\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.Primitives",
    "methodName": "isWrapperType",
    "signature": "boolean isWrapperType(java.lang.reflect.Type)",
    "visibility": "public",
    "body": "{\r\n    return type \u003d\u003d Integer.class || type \u003d\u003d Float.class || type \u003d\u003d Byte.class || type \u003d\u003d Double.class || type \u003d\u003d Long.class || type \u003d\u003d Character.class || type \u003d\u003d Boolean.class || type \u003d\u003d Short.class || type \u003d\u003d Void.class;\r\n}",
    "nodes": 12,
    "edges": 20,
    "cc": 10,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d class \"Ljava/lang/Integer;\") → B1 | else → B9",
      "B1 : If(r0 \u003d\u003d class \"Ljava/lang/Float;\") → B2 | else → B9",
      "B2 : If(r0 \u003d\u003d class \"Ljava/lang/Byte;\") → B3 | else → B9",
      "B3 : If(r0 \u003d\u003d class \"Ljava/lang/Double;\") → B4 | else → B9",
      "B4 : If(r0 \u003d\u003d class \"Ljava/lang/Long;\") → B5 | else → B9",
      "B5 : If(r0 \u003d\u003d class \"Ljava/lang/Character;\") → B6 | else → B9",
      "B6 : If(r0 \u003d\u003d class \"Ljava/lang/Boolean;\") → B7 | else → B9",
      "B7 : If(r0 \u003d\u003d class \"Ljava/lang/Short;\") → B8 | else → B9",
      "B8 : If(r0 !\u003d class \"Ljava/lang/Void;\") → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  Type\n  if (r0 \u003d\u003d class \"Ljava/lang/Integer;\") goto B1 else B9\n}",
      "B1 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Float;\") goto B2 else B9\n}",
      "B2 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Byte;\") goto B3 else B9\n}",
      "B3 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Double;\") goto B4 else B9\n}",
      "B4 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Long;\") goto B5 else B9\n}",
      "B5 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Character;\") goto B6 else B9\n}",
      "B6 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Boolean;\") goto B7 else B9\n}",
      "B7 {\n  if (r0 \u003d\u003d class \"Ljava/lang/Short;\") goto B8 else B9\n}",
      "B8 {\n  if (r0 !\u003d class \"Ljava/lang/Void;\") goto B9 else B10\n}",
      "B9 {\n  $z0 \u003d 1\n  goto B11\n}",
      "B10 {\n  $z0 \u003d 0\n}",
      "B11 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B9",
      "B1 --\u003e B2",
      "B1 --\u003e B9",
      "B2 --\u003e B3",
      "B2 --\u003e B9",
      "B3 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B9",
      "B5 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.Primitives",
    "methodName": "wrap",
    "signature": "java.lang.Class wrap(java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d int.class)\r\n        return (Class\u003cT\u003e) Integer.class;\r\n    if (type \u003d\u003d float.class)\r\n        return (Class\u003cT\u003e) Float.class;\r\n    if (type \u003d\u003d byte.class)\r\n        return (Class\u003cT\u003e) Byte.class;\r\n    if (type \u003d\u003d double.class)\r\n        return (Class\u003cT\u003e) Double.class;\r\n    if (type \u003d\u003d long.class)\r\n        return (Class\u003cT\u003e) Long.class;\r\n    if (type \u003d\u003d char.class)\r\n        return (Class\u003cT\u003e) Character.class;\r\n    if (type \u003d\u003d boolean.class)\r\n        return (Class\u003cT\u003e) Boolean.class;\r\n    if (type \u003d\u003d short.class)\r\n        return (Class\u003cT\u003e) Short.class;\r\n    if (type \u003d\u003d void.class)\r\n        return (Class\u003cT\u003e) Void.class;\r\n    return type;\r\n}",
    "nodes": 19,
    "edges": 18,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d $r1) → B1 | else → B2",
      "B2 : If(r0 !\u003d $r2) → B3 | else → B4",
      "B4 : If(r0 !\u003d $r3) → B5 | else → B6",
      "B6 : If(r0 !\u003d $r4) → B7 | else → B8",
      "B8 : If(r0 !\u003d $r5) → B9 | else → B10",
      "B10 : If(r0 !\u003d $r6) → B11 | else → B12",
      "B12 : If(r0 !\u003d $r7) → B13 | else → B14",
      "B14 : If(r0 !\u003d $r8) → B15 | else → B16",
      "B16 : If(r0 !\u003d $r9) → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  Class\n  $r1 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r2) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r3) goto B5 else B6\n}",
      "B5 {\n  return\n}",
      "B6 {\n  $r4 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r4) goto B7 else B8\n}",
      "B7 {\n  return\n}",
      "B8 {\n  $r5 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r5) goto B9 else B10\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $r6 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r6) goto B11 else B12\n}",
      "B11 {\n  return\n}",
      "B12 {\n  $r7 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r7) goto B13 else B14\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $r8 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r8) goto B15 else B16\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $r9 \u003d Class TYPE\u003e\n  if (r0 !\u003d $r9) goto B17 else B18\n}",
      "B17 {\n  return\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.Primitives",
    "methodName": "unwrap",
    "signature": "java.lang.Class unwrap(java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    if (type \u003d\u003d Integer.class)\r\n        return (Class\u003cT\u003e) int.class;\r\n    if (type \u003d\u003d Float.class)\r\n        return (Class\u003cT\u003e) float.class;\r\n    if (type \u003d\u003d Byte.class)\r\n        return (Class\u003cT\u003e) byte.class;\r\n    if (type \u003d\u003d Double.class)\r\n        return (Class\u003cT\u003e) double.class;\r\n    if (type \u003d\u003d Long.class)\r\n        return (Class\u003cT\u003e) long.class;\r\n    if (type \u003d\u003d Character.class)\r\n        return (Class\u003cT\u003e) char.class;\r\n    if (type \u003d\u003d Boolean.class)\r\n        return (Class\u003cT\u003e) boolean.class;\r\n    if (type \u003d\u003d Short.class)\r\n        return (Class\u003cT\u003e) short.class;\r\n    if (type \u003d\u003d Void.class)\r\n        return (Class\u003cT\u003e) void.class;\r\n    return type;\r\n}",
    "nodes": 19,
    "edges": 18,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d class \"Ljava/lang/Integer;\") → B1 | else → B2",
      "B2 : If(r0 !\u003d class \"Ljava/lang/Float;\") → B3 | else → B4",
      "B4 : If(r0 !\u003d class \"Ljava/lang/Byte;\") → B5 | else → B6",
      "B6 : If(r0 !\u003d class \"Ljava/lang/Double;\") → B7 | else → B8",
      "B8 : If(r0 !\u003d class \"Ljava/lang/Long;\") → B9 | else → B10",
      "B10 : If(r0 !\u003d class \"Ljava/lang/Character;\") → B11 | else → B12",
      "B12 : If(r0 !\u003d class \"Ljava/lang/Boolean;\") → B13 | else → B14",
      "B14 : If(r0 !\u003d class \"Ljava/lang/Short;\") → B15 | else → B16",
      "B16 : If(r0 !\u003d class \"Ljava/lang/Void;\") → B17 | else → B18"
    ],
    "blockList": [
      "B0 {\n  Class\n  if (r0 !\u003d class \"Ljava/lang/Integer;\") goto B1 else B2\n}",
      "B1 {\n  $r9 \u003d Class TYPE\u003e\n  return\n}",
      "B2 {\n  if (r0 !\u003d class \"Ljava/lang/Float;\") goto B3 else B4\n}",
      "B3 {\n  $r8 \u003d Class TYPE\u003e\n  return\n}",
      "B4 {\n  if (r0 !\u003d class \"Ljava/lang/Byte;\") goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d Class TYPE\u003e\n  return\n}",
      "B6 {\n  if (r0 !\u003d class \"Ljava/lang/Double;\") goto B7 else B8\n}",
      "B7 {\n  $r6 \u003d Class TYPE\u003e\n  return\n}",
      "B8 {\n  if (r0 !\u003d class \"Ljava/lang/Long;\") goto B9 else B10\n}",
      "B9 {\n  $r5 \u003d Class TYPE\u003e\n  return\n}",
      "B10 {\n  if (r0 !\u003d class \"Ljava/lang/Character;\") goto B11 else B12\n}",
      "B11 {\n  $r4 \u003d Class TYPE\u003e\n  return\n}",
      "B12 {\n  if (r0 !\u003d class \"Ljava/lang/Boolean;\") goto B13 else B14\n}",
      "B13 {\n  $r3 \u003d Class TYPE\u003e\n  return\n}",
      "B14 {\n  if (r0 !\u003d class \"Ljava/lang/Short;\") goto B15 else B16\n}",
      "B15 {\n  $r2 \u003d Class TYPE\u003e\n  return\n}",
      "B16 {\n  if (r0 !\u003d class \"Ljava/lang/Void;\") goto B17 else B18\n}",
      "B17 {\n  $r1 \u003d Class TYPE\u003e\n  return\n}",
      "B18 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.reflect.ReflectionHelper",
    "methodName": "getAccessibleObjectDescription",
    "signature": "java.lang.String getAccessibleObjectDescription(java.lang.reflect.AccessibleObject,boolean)",
    "visibility": "public",
    "body": "{\r\n    String description;\r\n    if (object instanceof Field) {\r\n        description \u003d \"field \u0027\" + fieldToString((Field) object) + \"\u0027\";\r\n    } else if (object instanceof Method) {\r\n        Method method \u003d (Method) object;\r\n        StringBuilder methodSignatureBuilder \u003d new StringBuilder(method.getName());\r\n        appendExecutableParameters(method, methodSignatureBuilder);\r\n        String methodSignature \u003d methodSignatureBuilder.toString();\r\n        description \u003d \"method \u0027\" + method.getDeclaringClass().getName() + \"#\" + methodSignature + \"\u0027\";\r\n    } else if (object instanceof Constructor) {\r\n        description \u003d \"constructor \u0027\" + constructorToString((Constructor\u003c?\u003e) object) + \"\u0027\";\r\n    } else {\r\n        description \u003d \"\u003cunknown AccessibleObject\u003e \" + object.toString();\r\n    }\r\n    if (uppercaseFirstLetter \u0026\u0026 Character.isLowerCase(description.charAt(0))) {\r\n        description \u003d Character.toUpperCase(description.charAt(0)) + description.substring(1);\r\n    }\r\n    return description;\r\n}",
    "nodes": 11,
    "edges": 15,
    "cc": 6,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6",
      "B7 : If(z3 \u003d\u003d false) → B8 | else → B10",
      "B8 : If($z4 \u003d\u003d false) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  AccessibleObject\n  z3 :\u003d @parameter1: boolean\n  $z0 \u003d Field\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d Field) r0\n  $r12 \u003d ReflectionHelper.fieldToString($r11)\n  r13 \u003d dynInvoke makeConcatWithConstants($r12)\n  goto B7\n}",
      "B2 {\n  $z1 \u003d Method\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  r5 \u003d Method) r0\n  $r6 \u003d StringBuilder\n  $r7 \u003d r5.getName()\n  new StringBuilder($r7)\n  ReflectionHelper.appendExecutableParameters(r5, $r6)\n  r8 \u003d $r6.toString()\n  $r9 \u003d r5.getDeclaringClass()\n  $r10 \u003d $r9.getName()\n  r13 \u003d dynInvoke makeConcatWithConstants($r10, r8)\n  goto B7\n}",
      "B4 {\n  $z2 \u003d Constructor\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r3 \u003d Constructor) r0\n  $r4 \u003d ReflectionHelper.constructorToString($r3)\n  r13 \u003d dynInvoke makeConcatWithConstants($r4)\n  goto B7\n}",
      "B6 {\n  $r1 \u003d r0.toString()\n  r13 \u003d dynInvoke makeConcatWithConstants($r1)\n}",
      "B7 {\n  if (z3 \u003d\u003d false) goto B8 else B10\n}",
      "B8 {\n  $c0 \u003d r13.charAt(0)\n  $z4 \u003d Character.isLowerCase($c0)\n  if ($z4 \u003d\u003d false) goto B9 else B10\n}",
      "B9 {\n  $c1 \u003d r13.charAt(0)\n  $c2 \u003d Character.toUpperCase($c1)\n  $r2 \u003d r13.substring(1)\n  r13 \u003d dynInvoke makeConcatWithConstants($c2, $r2)\n}",
      "B10 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B7",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B7",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B10",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReflectionHelper#constructorToString(...1)",
        "body": "{\r\n    StringBuilder stringBuilder \u003d new StringBuilder(constructor.getDeclaringClass().getName());\r\n    appendExecutableParameters(constructor, stringBuilder);\r\n    return stringBuilder.toString();\r\n}"
      },
      {
        "name": "ReflectionHelper#appendExecutableParameters(...2)",
        "body": "{\r\n    stringBuilder.append(\u0027(\u0027);\r\n    Class\u003c?\u003e[] parameters \u003d (executable instanceof Method) ? ((Method) executable).getParameterTypes() : ((Constructor\u003c?\u003e) executable).getParameterTypes();\r\n    for (int i \u003d 0; i \u003c parameters.length; i++) {\r\n        if (i \u003e 0) {\r\n            stringBuilder.append(\", \");\r\n        }\r\n        stringBuilder.append(parameters[i].getSimpleName());\r\n    }\r\n    stringBuilder.append(\u0027)\u0027);\r\n}"
      },
      {
        "name": "ReflectionHelper#fieldToString(...1)",
        "body": "{\r\n    return field.getDeclaringClass().getName() + \"#\" + field.getName();\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.ReflectionAccessFilterHelper",
    "methodName": "isAnyPlatformType",
    "signature": "boolean isAnyPlatformType(java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    String className \u003d c.getName();\r\n    return // Covers Android and Java\r\n    isAndroidType(className) || className.startsWith(\"kotlin.\") || className.startsWith(\"kotlinx.\") || className.startsWith(\"scala.\");\r\n}",
    "nodes": 7,
    "edges": 10,
    "cc": 5,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B4",
      "B2 : If($z2 !\u003d 0) → B3 | else → B4",
      "B3 : If($z3 \u003d\u003d false) → B4 | else → B5"
    ],
    "blockList": [
      "B0 {\n  Class\n  r1 \u003d r0.getName()\n  $z0 \u003d ReflectionAccessFilterHelper.isAndroidType(r1)\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d r1.startsWith(\"kotlin.\")\n  if ($z1 !\u003d 0) goto B2 else B4\n}",
      "B2 {\n  $z2 \u003d r1.startsWith(\"kotlinx.\")\n  if ($z2 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $z3 \u003d r1.startsWith(\"scala.\")\n  if ($z3 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $z4 \u003d 1\n  goto B6\n}",
      "B5 {\n  $z4 \u003d 0\n}",
      "B6 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B6",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "ReflectionAccessFilterHelper#isAndroidType(...1)",
        "body": "{\r\n    return isAndroidType(c.getName());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.internal.ReflectionAccessFilterHelper",
    "methodName": "getFilterResult",
    "signature": "com.google.gson.ReflectionAccessFilter$FilterResult getFilterResult(java.util.List,java.lang.Class)",
    "visibility": "public",
    "body": "{\r\n    for (ReflectionAccessFilter filter : reflectionFilters) {\r\n        FilterResult result \u003d filter.check(c);\r\n        if (result !\u003d FilterResult.INDECISIVE) {\r\n            return result;\r\n        }\r\n    }\r\n    return FilterResult.ALLOW;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B5",
      "B2 : If(r6 \u003d\u003d $r7) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  List\n  Class\n  r1 \u003d r0.iterator()\n}",
      "B1 {\n  $z0 \u003d r1.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B5\n}",
      "B2 {\n  $r3 \u003d r1.next()\n  r4 \u003d ReflectionAccessFilter) $r3\n  r6 \u003d r4.check(r5)\n  $r7 \u003d ReflectionAccessFilter$FilterResult INDECISIVE\u003e\n  if (r6 \u003d\u003d $r7) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  goto B1\n}",
      "B5 {\n  $r2 \u003d ReflectionAccessFilter$FilterResult ALLOW\u003e\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B5",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B1",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.internal.Streams",
    "methodName": "writerForAppendable",
    "signature": "java.io.Writer writerForAppendable(java.lang.Appendable)",
    "visibility": "public",
    "body": "{\r\n    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  Appendable\n  $z0 \u003d Writer\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r1 \u003d Writer) r0\n  goto B3\n}",
      "B2 {\n  $r2 \u003d Streams$AppendableWriter\n  $r1 \u003d $r2\n  new Streams$AppendableWriter(r0)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "deepCopy",
    "signature": "com.google.gson.JsonArray deepCopy()",
    "visibility": "public",
    "body": "{\r\n    if (!elements.isEmpty()) {\r\n        JsonArray result \u003d new JsonArray(elements.size());\r\n        for (JsonElement element : elements) {\r\n            result.add(element.deepCopy());\r\n        }\r\n        return result;\r\n    }\r\n    return new JsonArray();\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B5",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  $r1 \u003d ArrayList elements\u003e\n  $z0 \u003d $r1.isEmpty()\n  if ($z0 !\u003d 0) goto B1 else B5\n}",
      "B1 {\n  $r3 \u003d JsonArray\n  $r4 \u003d ArrayList elements\u003e\n  $i0 \u003d $r4.size()\n  new JsonArray($i0)\n  $r5 \u003d ArrayList elements\u003e\n  r6 \u003d $r5.iterator()\n}",
      "B2 {\n  $z1 \u003d r6.hasNext()\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r7 \u003d r6.next()\n  r8 \u003d JsonElement) $r7\n  $r9 \u003d r8.deepCopy()\n  $r3.add($r9)\n  goto B2\n}",
      "B4 {\n  return\n}",
      "B5 {\n  $r2 \u003d JsonArray\n  new JsonArray()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B5",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B2",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "add",
    "signature": "void add(java.lang.Boolean)",
    "visibility": "public",
    "body": "{\r\n    elements.add(bool \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(bool));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  Boolean\n  $r2 \u003d ArrayList elements\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r1)\n}",
      "B3 {\n  $r2.add($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "add",
    "signature": "void add(java.lang.Character)",
    "visibility": "public",
    "body": "{\r\n    elements.add(character \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(character));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  Character\n  $r2 \u003d ArrayList elements\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r1)\n}",
      "B3 {\n  $r2.add($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "add",
    "signature": "void add(java.lang.Number)",
    "visibility": "public",
    "body": "{\r\n    elements.add(number \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(number));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  Number\n  $r2 \u003d ArrayList elements\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r1)\n}",
      "B3 {\n  $r2.add($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "add",
    "signature": "void add(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    elements.add(string \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(string));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  String\n  $r2 \u003d ArrayList elements\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r1)\n}",
      "B3 {\n  $r2.add($r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "add",
    "signature": "void add(com.google.gson.JsonElement)",
    "visibility": "public",
    "body": "{\r\n    if (element \u003d\u003d null) {\r\n        element \u003d JsonNull.INSTANCE;\r\n    }\r\n    elements.add(element);\r\n}",
    "nodes": 3,
    "edges": 3,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  JsonElement\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  r2 \u003d JsonNull INSTANCE\u003e\n}",
      "B2 {\n  $r1 \u003d ArrayList elements\u003e\n  $r1.add(r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "set",
    "signature": "com.google.gson.JsonElement set(int,com.google.gson.JsonElement)",
    "visibility": "public",
    "body": "{\r\n    return elements.set(index, element \u003d\u003d null ? JsonNull.INSTANCE : element);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r1 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  i0 :\u003d @parameter0: int\n  JsonElement\n  $r2 \u003d ArrayList elements\u003e\n  if (r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r5 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r5 \u003d r1\n}",
      "B3 {\n  $r3 \u003d $r2.set(i0, $r5)\n  $r4 \u003d JsonElement) $r3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonArray",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonArray \u0026\u0026 ((JsonArray) o).elements.equals(elements));\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d r1) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonArray\n  Object\n  if (r0 \u003d\u003d r1) goto B1 else B3\n}",
      "B1 {\n  $z0 \u003d JsonArray\n  if ($z0 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r2 \u003d JsonArray) r0\n  $r4 \u003d ArrayList elements\u003e\n  $r3 \u003d ArrayList elements\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $z2 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z2 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "deepCopy",
    "signature": "com.google.gson.JsonObject deepCopy()",
    "visibility": "public",
    "body": "{\r\n    JsonObject result \u003d new JsonObject();\r\n    for (Map.Entry\u003cString, JsonElement\u003e entry : members.entrySet()) {\r\n        result.add(entry.getKey(), entry.getValue().deepCopy());\r\n    }\r\n    return result;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  $r0 \u003d JsonObject\n  new JsonObject()\n  $r2 \u003d LinkedTreeMap members\u003e\n  $r3 \u003d $r2.entrySet()\n  r4 \u003d $r3.iterator()\n}",
      "B1 {\n  $z0 \u003d r4.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $r5 \u003d r4.next()\n  r6 \u003d Map$Entry) $r5\n  $r7 \u003d r6.getKey()\n  $r11 \u003d String) $r7\n  $r8 \u003d r6.getValue()\n  $r9 \u003d JsonElement) $r8\n  $r10 \u003d $r9.deepCopy()\n  $r0.add($r11, $r10)\n  goto B1\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B1",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "add",
    "signature": "void add(java.lang.String,com.google.gson.JsonElement)",
    "visibility": "public",
    "body": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  String\n  JsonElement\n  $r3 \u003d LinkedTreeMap members\u003e\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d r2\n}",
      "B3 {\n  $r3.put(r1, $r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "addProperty",
    "signature": "void addProperty(java.lang.String,java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  String\n  String\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r2)\n}",
      "B3 {\n  r0.add(r1, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonObject#add(...2)",
        "body": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "addProperty",
    "signature": "void addProperty(java.lang.String,java.lang.Number)",
    "visibility": "public",
    "body": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  String\n  Number\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r2)\n}",
      "B3 {\n  r0.add(r1, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonObject#add(...2)",
        "body": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "addProperty",
    "signature": "void addProperty(java.lang.String,java.lang.Boolean)",
    "visibility": "public",
    "body": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  String\n  Boolean\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r2)\n}",
      "B3 {\n  r0.add(r1, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonObject#add(...2)",
        "body": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "addProperty",
    "signature": "void addProperty(java.lang.String,java.lang.Character)",
    "visibility": "public",
    "body": "{\r\n    add(property, value \u003d\u003d null ? JsonNull.INSTANCE : new JsonPrimitive(value));\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r2 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  String\n  Character\n  if (r2 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d JsonNull INSTANCE\u003e\n  goto B3\n}",
      "B2 {\n  $r4 \u003d JsonPrimitive\n  $r3 \u003d $r4\n  new JsonPrimitive(r2)\n}",
      "B3 {\n  r0.add(r1, $r3)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonObject#add(...2)",
        "body": "{\r\n    members.put(property, value \u003d\u003d null ? JsonNull.INSTANCE : value);\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "isEmpty",
    "signature": "boolean isEmpty()",
    "visibility": "public",
    "body": "{\r\n    return members.size() \u003d\u003d 0;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  $r1 \u003d LinkedTreeMap members\u003e\n  $i0 \u003d $r1.size()\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $z0 \u003d 1\n  goto B3\n}",
      "B2 {\n  $z0 \u003d 0\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonObject",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return (o \u003d\u003d this) || (o instanceof JsonObject \u0026\u0026 ((JsonObject) o).members.equals(members));\r\n}",
    "nodes": 6,
    "edges": 8,
    "cc": 4,
    "flowSummary": [
      "B0 : If(r0 \u003d\u003d r1) → B1 | else → B3",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B4",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonObject\n  Object\n  if (r0 \u003d\u003d r1) goto B1 else B3\n}",
      "B1 {\n  $z0 \u003d JsonObject\n  if ($z0 \u003d\u003d false) goto B2 else B4\n}",
      "B2 {\n  $r2 \u003d JsonObject) r0\n  $r4 \u003d LinkedTreeMap members\u003e\n  $r3 \u003d LinkedTreeMap members\u003e\n  $z1 \u003d $r4.equals($r3)\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $z2 \u003d 1\n  goto B5\n}",
      "B4 {\n  $z2 \u003d 0\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsBoolean",
    "signature": "boolean getAsBoolean()",
    "visibility": "public",
    "body": "{\r\n    if (isBoolean()) {\r\n        return (Boolean) value;\r\n    }\r\n    // Check to see if the value as a String is \"true\" in any case.\r\n    return Boolean.parseBoolean(getAsString());\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isBoolean()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d Object value\u003e\n  $r3 \u003d Boolean) $r2\n  $z2 \u003d $r3.booleanValue()\n  return\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $z1 \u003d Boolean.parseBoolean($r1)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isBoolean(...0)",
        "body": "{\r\n    return value instanceof Boolean;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsNumber",
    "signature": "java.lang.Number getAsNumber()",
    "visibility": "public",
    "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $r1 \u003d Object value\u003e\n  $z0 \u003d Number\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r7 \u003d Object value\u003e\n  $r8 \u003d Number) $r7\n  return\n}",
      "B2 {\n  $r2 \u003d Object value\u003e\n  $z1 \u003d String\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d LazilyParsedNumber\n  $r5 \u003d Object value\u003e\n  $r6 \u003d String) $r5\n  new LazilyParsedNumber($r6)\n  return\n}",
      "B4 {\n  $r3 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"Primitive is neither a number nor a string\")\n  throw $r3\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsString",
    "signature": "java.lang.String getAsString()",
    "visibility": "public",
    "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2",
      "B2 : If($z1 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $r1 \u003d Object value\u003e\n  $z0 \u003d String\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r12 \u003d Object value\u003e\n  $r13 \u003d String) $r12\n  return\n}",
      "B2 {\n  $z1 \u003d r0.isNumber()\n  if ($z1 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r10 \u003d r0.getAsNumber()\n  $r11 \u003d $r10.toString()\n  return\n}",
      "B4 {\n  $z2 \u003d r0.isBoolean()\n  if ($z2 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r7 \u003d Object value\u003e\n  $r8 \u003d Boolean) $r7\n  $r9 \u003d $r8.toString()\n  return\n}",
      "B6 {\n  $r2 \u003d AssertionError\n  $r3 \u003d Object value\u003e\n  $r4 \u003d $r3.getClass()\n  $r5 \u003d String.valueOf($r4)\n  $r6 \u003d dynInvoke makeConcatWithConstants($r5)\n  new AssertionError($r6)\n  throw $r2\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#isBoolean(...0)",
        "body": "{\r\n    return value instanceof Boolean;\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsDouble",
    "signature": "double getAsDouble()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $d0 \u003d $r2.doubleValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $d0 \u003d Double.parseDouble($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsBigDecimal",
    "signature": "java.math.BigDecimal getAsBigDecimal()",
    "visibility": "public",
    "body": "{\r\n    return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $r1 \u003d Object value\u003e\n  $z0 \u003d BigDecimal\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Object value\u003e\n  $r4 \u003d BigDecimal) $r3\n  goto B3\n}",
      "B2 {\n  $r4 \u003d BigDecimal\n  $r2 \u003d r0.getAsString()\n  new BigDecimal($r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsBigInteger",
    "signature": "java.math.BigInteger getAsBigInteger()",
    "visibility": "public",
    "body": "{\r\n    return value instanceof BigInteger ? (BigInteger) value : new BigInteger(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $r1 \u003d Object value\u003e\n  $z0 \u003d BigInteger\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d Object value\u003e\n  $r4 \u003d BigInteger) $r3\n  goto B3\n}",
      "B2 {\n  $r4 \u003d BigInteger\n  $r2 \u003d r0.getAsString()\n  new BigInteger($r2)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsFloat",
    "signature": "float getAsFloat()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().floatValue() : Float.parseFloat(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $f0 \u003d $r2.floatValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $f0 \u003d Float.parseFloat($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsLong",
    "signature": "long getAsLong()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().longValue() : Long.parseLong(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $l0 \u003d $r2.longValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $l0 \u003d Long.parseLong($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsShort",
    "signature": "short getAsShort()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().shortValue() : Short.parseShort(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $s0 \u003d $r2.shortValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $s0 \u003d Short.parseShort($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsInt",
    "signature": "int getAsInt()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $i0 \u003d $r2.intValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $i0 \u003d Integer.parseInt($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsByte",
    "signature": "byte getAsByte()",
    "visibility": "public",
    "body": "{\r\n    return isNumber() ? getAsNumber().byteValue() : Byte.parseByte(getAsString());\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $z0 \u003d r0.isNumber()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r0.getAsNumber()\n  $b0 \u003d $r2.byteValue()\n  goto B3\n}",
      "B2 {\n  $r1 \u003d r0.getAsString()\n  $b0 \u003d Byte.parseByte($r1)\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      },
      {
        "name": "JsonPrimitive#isNumber(...0)",
        "body": "{\r\n    return value instanceof Number;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "getAsCharacter",
    "signature": "char getAsCharacter()",
    "visibility": "public",
    "body": "{\r\n    String s \u003d getAsString();\r\n    if (s.isEmpty()) {\r\n        throw new UnsupportedOperationException(\"String value is empty\");\r\n    } else {\r\n        return s.charAt(0);\r\n    }\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  r1 \u003d r0.getAsString()\n  $z0 \u003d r1.isEmpty()\n  if ($z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d UnsupportedOperationException\n  new UnsupportedOperationException(\"String value is empty\")\n  throw $r2\n}",
      "B2 {\n  $c0 \u003d r1.charAt(0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#getAsString(...0)",
        "body": "{\r\n    if (value instanceof String) {\r\n        return (String) value;\r\n    } else if (isNumber()) {\r\n        return getAsNumber().toString();\r\n    } else if (isBoolean()) {\r\n        return ((Boolean) value).toString();\r\n    }\r\n    throw new AssertionError(\"Unexpected value type: \" + value.getClass());\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "hashCode",
    "signature": "int hashCode()",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return 31;\r\n    }\r\n    // Using recommended hashing algorithm from Effective Java for longs and doubles\r\n    if (isIntegral(this)) {\r\n        long value \u003d getAsNumber().longValue();\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    if (value instanceof Number) {\r\n        long value \u003d Double.doubleToLongBits(getAsNumber().doubleValue());\r\n        return (int) (value ^ (value \u003e\u003e\u003e 32));\r\n    }\r\n    return value.hashCode();\r\n}",
    "nodes": 7,
    "edges": 6,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r1 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  $r1 \u003d Object value\u003e\n  if ($r1 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $z0 \u003d JsonPrimitive.isIntegral(r0)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r5 \u003d r0.getAsNumber()\n  l7 \u003d $r5.longValue()\n  $l4 \u003d l7 \u003e\u003e\u003e 32\n  $l5 \u003d l7 ^ $l4\n  $i6 \u003d (int) $l5\n  return\n}",
      "B4 {\n  $r2 \u003d Object value\u003e\n  $z1 \u003d Number\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r4 \u003d r0.getAsNumber()\n  $d0 \u003d $r4.doubleValue()\n  l8 \u003d Double.doubleToLongBits($d0)\n  $l1 \u003d l8 \u003e\u003e\u003e 32\n  $l2 \u003d l8 ^ $l1\n  $i3 \u003d (int) $l2\n  return\n}",
      "B6 {\n  $r3 \u003d Object value\u003e\n  $i0 \u003d $r3.hashCode()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#isIntegral(...1)",
        "body": "{\r\n    if (primitive.value instanceof Number) {\r\n        Number number \u003d (Number) primitive.value;\r\n        return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.JsonPrimitive",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    if (this \u003d\u003d obj) {\r\n        return true;\r\n    }\r\n    if (obj \u003d\u003d null || getClass() !\u003d obj.getClass()) {\r\n        return false;\r\n    }\r\n    JsonPrimitive other \u003d (JsonPrimitive) obj;\r\n    if (value \u003d\u003d null) {\r\n        return other.value \u003d\u003d null;\r\n    }\r\n    if (isIntegral(this) \u0026\u0026 isIntegral(other)) {\r\n        return getAsNumber().longValue() \u003d\u003d other.getAsNumber().longValue();\r\n    }\r\n    if (value instanceof Number \u0026\u0026 other.value instanceof Number) {\r\n        double a \u003d getAsNumber().doubleValue();\r\n        // Java standard types other than double return true for two NaN. So, need\r\n        // special handling for double.\r\n        double b \u003d other.getAsNumber().doubleValue();\r\n        return a \u003d\u003d b || (Double.isNaN(a) \u0026\u0026 Double.isNaN(b));\r\n    }\r\n    return value.equals(other.value);\r\n}",
    "nodes": 25,
    "edges": 32,
    "cc": 9,
    "flowSummary": [
      "B0 : If(r0 !\u003d r1) → B1 | else → B2",
      "B2 : If(r1 \u003d\u003d null) → B3 | else → B4",
      "B3 : If($r3 \u003d\u003d $r2) → B4 | else → B5",
      "B5 : If($r5 !\u003d null) → B6 | else → B10",
      "B6 : If($r14 !\u003d null) → B7 | else → B8",
      "B10 : If($z0 \u003d\u003d false) → B11 | else → B16",
      "B11 : If($z6 \u003d\u003d false) → B12 | else → B16",
      "B12 : If($b3 !\u003d 0) → B13 | else → B14",
      "B16 : If($z1 \u003d\u003d false) → B17 | else → B24",
      "B17 : If($z3 \u003d\u003d false) → B18 | else → B24",
      "B18 : If($b0 \u003d\u003d false) → B19 | else → B21",
      "B19 : If($z4 \u003d\u003d false) → B20 | else → B22",
      "B20 : If($z5 \u003d\u003d false) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  JsonPrimitive\n  Object\n  if (r0 !\u003d r1) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  if (r1 \u003d\u003d null) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d r0.getClass()\n  $r2 \u003d r1.getClass()\n  if ($r3 \u003d\u003d $r2) goto B4 else B5\n}",
      "B4 {\n  return\n}",
      "B5 {\n  r4 \u003d JsonPrimitive) r1\n  $r5 \u003d Object value\u003e\n  if ($r5 !\u003d null) goto B6 else B10\n}",
      "B6 {\n  $r14 \u003d Object value\u003e\n  if ($r14 !\u003d null) goto B7 else B8\n}",
      "B7 {\n  $z7 \u003d 1\n  goto B9\n}",
      "B8 {\n  $z7 \u003d 0\n}",
      "B9 {\n  return\n}",
      "B10 {\n  $z0 \u003d JsonPrimitive.isIntegral(r0)\n  if ($z0 \u003d\u003d false) goto B11 else B16\n}",
      "B11 {\n  $z6 \u003d JsonPrimitive.isIntegral(r4)\n  if ($z6 \u003d\u003d false) goto B12 else B16\n}",
      "B12 {\n  $r12 \u003d r0.getAsNumber()\n  $l2 \u003d $r12.longValue()\n  $r13 \u003d r4.getAsNumber()\n  $l1 \u003d $r13.longValue()\n  $b3 \u003d $l2 cmp $l1\n  if ($b3 !\u003d 0) goto B13 else B14\n}",
      "B13 {\n  $z8 \u003d 1\n  goto B15\n}",
      "B14 {\n  $z8 \u003d 0\n}",
      "B15 {\n  return\n}",
      "B16 {\n  $r6 \u003d Object value\u003e\n  $z1 \u003d Number\n  if ($z1 \u003d\u003d false) goto B17 else B24\n}",
      "B17 {\n  $r9 \u003d Object value\u003e\n  $z3 \u003d Number\n  if ($z3 \u003d\u003d false) goto B18 else B24\n}",
      "B18 {\n  $r10 \u003d r0.getAsNumber()\n  d0 \u003d $r10.doubleValue()\n  $r11 \u003d r4.getAsNumber()\n  d1 \u003d $r11.doubleValue()\n  $b0 \u003d d0 cmpl d1\n  if ($b0 \u003d\u003d false) goto B19 else B21\n}",
      "B19 {\n  $z4 \u003d Double.isNaN(d0)\n  if ($z4 \u003d\u003d false) goto B20 else B22\n}",
      "B20 {\n  $z5 \u003d Double.isNaN(d1)\n  if ($z5 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  $z9 \u003d 1\n  goto B23\n}",
      "B22 {\n  $z9 \u003d 0\n}",
      "B23 {\n  return\n}",
      "B24 {\n  $r8 \u003d Object value\u003e\n  $r7 \u003d Object value\u003e\n  $z2 \u003d $r8.equals($r7)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B11",
      "B10 --\u003e B16",
      "B11 --\u003e B12",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B24",
      "B17 --\u003e B18",
      "B17 --\u003e B24",
      "B18 --\u003e B19",
      "B18 --\u003e B21",
      "B19 --\u003e B20",
      "B19 --\u003e B22",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B23",
      "B23 --\u003e [EXIT]",
      "B24 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonPrimitive#isIntegral(...1)",
        "body": "{\r\n    if (primitive.value instanceof Number) {\r\n        Number number \u003d (Number) primitive.value;\r\n        return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte;\r\n    }\r\n    return false;\r\n}"
      },
      {
        "name": "JsonPrimitive#getClass(...0)",
        "body": "(source not found)"
      },
      {
        "name": "JsonPrimitive#getAsNumber(...0)",
        "body": "{\r\n    if (value instanceof Number) {\r\n        return (Number) value;\r\n    } else if (value instanceof String) {\r\n        return new LazilyParsedNumber((String) value);\r\n    }\r\n    throw new UnsupportedOperationException(\"Primitive is neither a number nor a string\");\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.reflect.TypeToken",
    "methodName": "isAssignableFrom",
    "signature": "boolean isAssignableFrom(java.lang.reflect.Type)",
    "visibility": "public",
    "body": "{\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (type.equals(from)) {\r\n        return true;\r\n    }\r\n    if (type instanceof Class\u003c?\u003e) {\r\n        return rawType.isAssignableFrom($Gson$Types.getRawType(from));\r\n    } else if (type instanceof ParameterizedType) {\r\n        return isAssignableFrom(from, (ParameterizedType) type, new HashMap\u003cString, Type\u003e());\r\n    } else if (type instanceof GenericArrayType) {\r\n        return rawType.isAssignableFrom($Gson$Types.getRawType(from)) \u0026\u0026 isAssignableFrom(from, (GenericArrayType) type);\r\n    } else {\r\n        throw buildUnexpectedTypeError(type, Class.class, ParameterizedType.class, GenericArrayType.class);\r\n    }\r\n}",
    "nodes": 15,
    "edges": 16,
    "cc": 3,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4",
      "B4 : If($z1 \u003d\u003d false) → B5 | else → B6",
      "B6 : If($z2 \u003d\u003d false) → B7 | else → B8",
      "B8 : If($z3 \u003d\u003d false) → B9 | else → B14",
      "B9 : If($z4 \u003d\u003d false) → B10 | else → B12",
      "B10 : If($z5 \u003d\u003d false) → B11 | else → B12"
    ],
    "blockList": [
      "B0 {\n  TypeToken\n  Type\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  return\n}",
      "B2 {\n  $r2 \u003d Type type\u003e\n  $z0 \u003d $r2.equals(r0)\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  return\n}",
      "B4 {\n  $r3 \u003d Type type\u003e\n  $z1 \u003d Class\n  if ($z1 \u003d\u003d false) goto B5 else B6\n}",
      "B5 {\n  $r16 \u003d Class rawType\u003e\n  $r17 \u003d $Gson$Types.getRawType(r0)\n  $z7 \u003d $r16.isAssignableFrom($r17)\n  return\n}",
      "B6 {\n  $r4 \u003d Type type\u003e\n  $z2 \u003d ParameterizedType\n  if ($z2 \u003d\u003d false) goto B7 else B8\n}",
      "B7 {\n  $r13 \u003d Type type\u003e\n  $r15 \u003d ParameterizedType) $r13\n  $r14 \u003d HashMap\n  new HashMap()\n  $z6 \u003d TypeToken.isAssignableFrom(r0, $r15, $r14)\n  return\n}",
      "B8 {\n  $r5 \u003d Type type\u003e\n  $z3 \u003d GenericArrayType\n  if ($z3 \u003d\u003d false) goto B9 else B14\n}",
      "B9 {\n  $r9 \u003d Class rawType\u003e\n  $r10 \u003d $Gson$Types.getRawType(r0)\n  $z4 \u003d $r9.isAssignableFrom($r10)\n  if ($z4 \u003d\u003d false) goto B10 else B12\n}",
      "B10 {\n  $r11 \u003d Type type\u003e\n  $r12 \u003d GenericArrayType) $r11\n  $z5 \u003d TypeToken.isAssignableFrom(r0, $r12)\n  if ($z5 \u003d\u003d false) goto B11 else B12\n}",
      "B11 {\n  $z8 \u003d 1\n  goto B13\n}",
      "B12 {\n  $z8 \u003d 0\n}",
      "B13 {\n  return\n}",
      "B14 {\n  $r7 \u003d Type type\u003e\n  $r6 \u003d Class)[3]\n  $r6[0] \u003d class \"Ljava/lang/Class;\"\n  $r6[1] \u003d class \"Ljava/lang/reflect/ParameterizedType;\"\n  $r6[2] \u003d class \"Ljava/lang/reflect/GenericArrayType;\"\n  $r8 \u003d TypeToken.buildUnexpectedTypeError($r7, $r6)\n  throw $r8\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e B9",
      "B8 --\u003e B14",
      "B9 --\u003e B10",
      "B9 --\u003e B12",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e [EXIT]",
      "B14 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "TypeToken#isAssignableFrom(...3)",
        "body": "{\r\n    if (from \u003d\u003d null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class\u003c?\u003e clazz \u003d $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype \u003d null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype \u003d (ParameterizedType) from;\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype !\u003d null) {\r\n        Type[] tArgs \u003d ptype.getActualTypeArguments();\r\n        TypeVariable\u003c?\u003e[] tParams \u003d clazz.getTypeParameters();\r\n        for (int i \u003d 0; i \u003c tArgs.length; i++) {\r\n            Type arg \u003d tArgs[i];\r\n            TypeVariable\u003c?\u003e var \u003d tParams[i];\r\n            while (arg instanceof TypeVariable\u003c?\u003e) {\r\n                TypeVariable\u003c?\u003e v \u003d (TypeVariable\u003c?\u003e) arg;\r\n                arg \u003d typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap\u003c\u003e(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn\u0027t work, try the superclass.\r\n    Type sType \u003d clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap\u003c\u003e(typeVarMap));\r\n}"
      },
      {
        "name": "TypeToken#isAssignableFrom(...2)",
        "body": "{\r\n    Type toGenericComponentType \u003d to.getGenericComponentType();\r\n    if (toGenericComponentType instanceof ParameterizedType) {\r\n        Type t \u003d from;\r\n        if (from instanceof GenericArrayType) {\r\n            t \u003d ((GenericArrayType) from).getGenericComponentType();\r\n        } else if (from instanceof Class\u003c?\u003e) {\r\n            Class\u003c?\u003e classType \u003d (Class\u003c?\u003e) from;\r\n            while (classType.isArray()) {\r\n                classType \u003d classType.getComponentType();\r\n            }\r\n            t \u003d classType;\r\n        }\r\n        return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap\u003cString, Type\u003e());\r\n    }\r\n    // No generic defined on \"to\"; therefore, return true and let other\r\n    // checks determine assignability\r\n    return true;\r\n}"
      },
      {
        "name": "TypeToken#buildUnexpectedTypeError(...4)",
        "body": "(source not found)"
      }
    ]
  },
  {
    "clazz": "com.google.gson.reflect.TypeToken",
    "methodName": "equals",
    "signature": "boolean equals(java.lang.Object)",
    "visibility": "public",
    "body": "{\r\n    return o instanceof TypeToken\u003c?\u003e \u0026\u0026 $Gson$Types.equals(type, ((TypeToken\u003c?\u003e) o).type);\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 \u003d\u003d false) → B1 | else → B3",
      "B1 : If($z1 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  TypeToken\n  Object\n  $z0 \u003d TypeToken\n  if ($z0 \u003d\u003d false) goto B1 else B3\n}",
      "B1 {\n  $r4 \u003d Type type\u003e\n  $r2 \u003d TypeToken) r0\n  $r3 \u003d Type type\u003e\n  $z1 \u003d $Gson$Types.equals($r4, $r3)\n  if ($z1 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d 1\n  goto B4\n}",
      "B3 {\n  $z2 \u003d 0\n}",
      "B4 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B4",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.reflect.TypeToken",
    "methodName": "getParameterized",
    "signature": "com.google.gson.reflect.TypeToken getParameterized(java.lang.reflect.Type,java.lang.reflect.Type[])",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(rawType);\r\n    Objects.requireNonNull(typeArguments);\r\n    // Perform basic validation here because this is the only public API where users\r\n    // can create malformed parameterized types\r\n    if (!(rawType instanceof Class)) {\r\n        // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n        throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n    }\r\n    Class\u003c?\u003e rawClass \u003d (Class\u003c?\u003e) rawType;\r\n    TypeVariable\u003c?\u003e[] typeVariables \u003d rawClass.getTypeParameters();\r\n    int expectedArgsCount \u003d typeVariables.length;\r\n    int actualArgsCount \u003d typeArguments.length;\r\n    if (actualArgsCount !\u003d expectedArgsCount) {\r\n        throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n    }\r\n    for (int i \u003d 0; i \u003c expectedArgsCount; i++) {\r\n        Type typeArgument \u003d typeArguments[i];\r\n        Class\u003c?\u003e rawTypeArgument \u003d $Gson$Types.getRawType(typeArgument);\r\n        TypeVariable\u003c?\u003e typeVariable \u003d typeVariables[i];\r\n        for (Type bound : typeVariable.getBounds()) {\r\n            Class\u003c?\u003e rawBound \u003d $Gson$Types.getRawType(bound);\r\n            if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds \" + \"for type variable \" + typeVariable + \" declared by \" + rawType);\r\n            }\r\n        }\r\n    }\r\n    return new TypeToken\u003c\u003e($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));\r\n}",
    "nodes": 13,
    "edges": 14,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i1 \u003d\u003d i0) → B3 | else → B4",
      "B5 : If(i3 \u003e\u003d i0) → B6 | else → B12",
      "B7 : If(i4 \u003e\u003d i2) → B8 | else → B11",
      "B8 : If($z1 !\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  Type\n  Type[]\n  Objects.requireNonNull(r0)\n  Objects.requireNonNull(r1)\n  $z0 \u003d Class\n  if ($z0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r20 \u003d IllegalArgumentException\n  $r21 \u003d String.valueOf(r0)\n  $r22 \u003d dynInvoke makeConcatWithConstants($r21)\n  new IllegalArgumentException($r22)\n  throw $r20\n}",
      "B2 {\n  r2 \u003d Class) r0\n  r3 \u003d r2.getTypeParameters()\n  i0 \u003d lengthof r3\n  i1 \u003d lengthof r1\n  if (i1 \u003d\u003d i0) goto B3 else B4\n}",
      "B3 {\n  $r17 \u003d IllegalArgumentException\n  $r18 \u003d r2.getName()\n  $r19 \u003d dynInvoke makeConcatWithConstants($r18, i0, i1)\n  new IllegalArgumentException($r19)\n  throw $r17\n}",
      "B4 {\n  i3 \u003d 0\n}",
      "B5 {\n  if (i3 \u003e\u003d i0) goto B6 else B12\n}",
      "B6 {\n  r6 \u003d r1[i3]\n  r7 \u003d $Gson$Types.getRawType(r6)\n  r8 \u003d r3[i3]\n  r9 \u003d r8.getBounds()\n  i2 \u003d lengthof r9\n  i4 \u003d 0\n}",
      "B7 {\n  if (i4 \u003e\u003d i2) goto B8 else B11\n}",
      "B8 {\n  r10 \u003d r9[i4]\n  r11 \u003d $Gson$Types.getRawType(r10)\n  $z1 \u003d r11.isAssignableFrom(r7)\n  if ($z1 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $r12 \u003d IllegalArgumentException\n  $r15 \u003d String.valueOf(r6)\n  $r14 \u003d String.valueOf(r8)\n  $r13 \u003d String.valueOf(r0)\n  $r16 \u003d dynInvoke makeConcatWithConstants($r15, $r14, $r13)\n  new IllegalArgumentException($r16)\n  throw $r12\n}",
      "B10 {\n  i4 \u003d i4 + 1\n  goto B7\n}",
      "B11 {\n  i3 \u003d i3 + 1\n  goto B5\n}",
      "B12 {\n  $r4 \u003d TypeToken\n  $r5 \u003d $Gson$Types.newParameterizedTypeWithOwner(null, r0, r1)\n  new TypeToken($r5)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B5 --\u003e B6",
      "B5 --\u003e B12",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B11",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e B7",
      "B11 --\u003e B5",
      "B12 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "beginArray",
    "signature": "void beginArray()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] \u003d 0;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i2 !\u003d 0) → B1 | else → B2",
      "B2 : If(i2 !\u003d 3) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i2 \u003d JsonReader: int peeked\u003e\n  if (i2 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i2 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i2 !\u003d 3) goto B3 else B4\n}",
      "B3 {\n  r0.push(1)\n  $r6 \u003d JsonReader: int[] pathIndices\u003e\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  $r6[$i1] \u003d 0\n  JsonReader: int peeked\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#push(...1)",
        "body": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "endArray",
    "signature": "void endArray()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i6 !\u003d 0) → B1 | else → B2",
      "B2 : If(i6 !\u003d 4) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i6 \u003d JsonReader: int peeked\u003e\n  if (i6 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i6 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i6 !\u003d 4) goto B3 else B4\n}",
      "B3 {\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  JsonReader: int stackSize\u003e \u003d $i1\n  $r6 \u003d JsonReader: int[] pathIndices\u003e\n  $i2 \u003d JsonReader: int stackSize\u003e\n  $i3 \u003d $i2 - 1\n  $i4 \u003d $r6[$i3]\n  $i5 \u003d $i4 + 1\n  $r6[$i3] \u003d $i5\n  JsonReader: int peeked\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "beginObject",
    "signature": "void beginObject()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 !\u003d 1) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i0 \u003d JsonReader: int peeked\u003e\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i0 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i0 !\u003d 1) goto B3 else B4\n}",
      "B3 {\n  r0.push(3)\n  JsonReader: int peeked\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#push(...1)",
        "body": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "endObject",
    "signature": "void endObject()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        // Free the last path name so that it can be garbage collected!\r\n        pathNames[stackSize] \u003d null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked \u003d PEEKED_NONE;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i7 !\u003d 0) → B1 | else → B2",
      "B2 : If(i7 !\u003d 2) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i7 \u003d JsonReader: int peeked\u003e\n  if (i7 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i7 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i7 !\u003d 2) goto B3 else B4\n}",
      "B3 {\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  JsonReader: int stackSize\u003e \u003d $i1\n  $r6 \u003d String[] pathNames\u003e\n  $i2 \u003d JsonReader: int stackSize\u003e\n  $r6[$i2] \u003d null\n  $r7 \u003d JsonReader: int[] pathIndices\u003e\n  $i3 \u003d JsonReader: int stackSize\u003e\n  $i4 \u003d $i3 - 1\n  $i5 \u003d $r7[$i4]\n  $i6 \u003d $i5 + 1\n  $r7[$i4] \u003d $i6\n  JsonReader: int peeked\u003e \u003d 0\n  goto B5\n}",
      "B4 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "hasNext",
    "signature": "boolean hasNext()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY \u0026\u0026 p !\u003d PEEKED_EOF;\r\n}",
    "nodes": 8,
    "edges": 11,
    "cc": 5,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 \u003d\u003d 2) → B3 | else → B6",
      "B3 : If(i0 \u003d\u003d 4) → B4 | else → B6",
      "B4 : If(i0 \u003d\u003d 17) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i0 \u003d JsonReader: int peeked\u003e\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i0 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i0 \u003d\u003d 2) goto B3 else B6\n}",
      "B3 {\n  if (i0 \u003d\u003d 4) goto B4 else B6\n}",
      "B4 {\n  if (i0 \u003d\u003d 17) goto B5 else B6\n}",
      "B5 {\n  $z0 \u003d 1\n  goto B7\n}",
      "B6 {\n  $z0 \u003d 0\n}",
      "B7 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B7",
      "B6 --\u003e B7",
      "B7 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "peek",
    "signature": "com.google.gson.stream.JsonToken peek()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "nodes": 14,
    "edges": 14,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(switch-on i0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i0 \u003d JsonReader: int peeked\u003e\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i0 \u003d r0.doPeek()\n}",
      "B2 {\n  AssertionError; }\n}",
      "B3 {\n  $r10 \u003d JsonToken BEGIN_OBJECT\u003e\n  return\n}",
      "B4 {\n  $r9 \u003d JsonToken END_OBJECT\u003e\n  return\n}",
      "B5 {\n  $r8 \u003d JsonToken BEGIN_ARRAY\u003e\n  return\n}",
      "B6 {\n  $r7 \u003d JsonToken END_ARRAY\u003e\n  return\n}",
      "B7 {\n  $r3 \u003d JsonToken NAME\u003e\n  return\n}",
      "B8 {\n  $r6 \u003d JsonToken BOOLEAN\u003e\n  return\n}",
      "B9 {\n  $r5 \u003d JsonToken NULL\u003e\n  return\n}",
      "B10 {\n  $r4 \u003d JsonToken STRING\u003e\n  return\n}",
      "B11 {\n  $r2 \u003d JsonToken NUMBER\u003e\n  return\n}",
      "B12 {\n  $r1 \u003d JsonToken END_DOCUMENT\u003e\n  return\n}",
      "B13 {\n  $r11 \u003d AssertionError\n  new AssertionError()\n  throw $r11\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B2 --\u003e B5",
      "B2 --\u003e B6",
      "B2 --\u003e B8",
      "B2 --\u003e B9",
      "B2 --\u003e B10",
      "B2 --\u003e B7",
      "B2 --\u003e B11",
      "B2 --\u003e B12",
      "B2 --\u003e B13",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e [EXIT]",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]",
      "B11 --\u003e [EXIT]",
      "B12 --\u003e [EXIT]",
      "B13 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextName",
    "signature": "java.lang.String nextName()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else {\r\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathNames[stackSize - 1] \u003d result;\r\n    return result;\r\n}",
    "nodes": 10,
    "edges": 12,
    "cc": 4,
    "flowSummary": [
      "B0 : If(i0 !\u003d 0) → B1 | else → B2",
      "B2 : If(i0 !\u003d 14) → B3 | else → B4",
      "B4 : If(i0 !\u003d 12) → B5 | else → B6",
      "B6 : If(i0 !\u003d 13) → B7 | else → B8"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i0 \u003d JsonReader: int peeked\u003e\n  if (i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i0 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i0 !\u003d 14) goto B3 else B4\n}",
      "B3 {\n  r6 \u003d r0.nextUnquotedValue()\n  goto B9\n}",
      "B4 {\n  if (i0 !\u003d 12) goto B5 else B6\n}",
      "B5 {\n  r6 \u003d r0.nextQuotedValue(39)\n  goto B9\n}",
      "B6 {\n  if (i0 !\u003d 13) goto B7 else B8\n}",
      "B7 {\n  r6 \u003d r0.nextQuotedValue(34)\n  goto B9\n}",
      "B8 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B9 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r7 \u003d String[] pathNames\u003e\n  $i1 \u003d JsonReader: int stackSize\u003e\n  $i2 \u003d $i1 - 1\n  $r7[$i2] \u003d r6\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B9",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B9",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e [EXIT]",
      "B9 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#nextQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#nextUnquotedValue(...0)",
        "body": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextString",
    "signature": "java.lang.String nextString()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    String result;\r\n    if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        result \u003d nextUnquotedValue();\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\\\u0027\u0027);\r\n    } else if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        result \u003d nextQuotedValue(\u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_BUFFERED) {\r\n        result \u003d peekedString;\r\n        peekedString \u003d null;\r\n    } else if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d Long.toString(peekedLong);\r\n    } else if (p \u003d\u003d PEEKED_NUMBER) {\r\n        result \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\r\n    }\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nodes": 16,
    "edges": 21,
    "cc": 7,
    "flowSummary": [
      "B0 : If(i6 !\u003d 0) → B1 | else → B2",
      "B2 : If(i6 !\u003d 10) → B3 | else → B4",
      "B4 : If(i6 !\u003d 8) → B5 | else → B6",
      "B6 : If(i6 !\u003d 9) → B7 | else → B8",
      "B8 : If(i6 !\u003d 11) → B9 | else → B10",
      "B10 : If(i6 !\u003d 15) → B11 | else → B12",
      "B12 : If(i6 !\u003d 16) → B13 | else → B14"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i6 \u003d JsonReader: int peeked\u003e\n  if (i6 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i6 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i6 !\u003d 10) goto B3 else B4\n}",
      "B3 {\n  r8 \u003d r0.nextUnquotedValue()\n  goto B15\n}",
      "B4 {\n  if (i6 !\u003d 8) goto B5 else B6\n}",
      "B5 {\n  r8 \u003d r0.nextQuotedValue(39)\n  goto B15\n}",
      "B6 {\n  if (i6 !\u003d 9) goto B7 else B8\n}",
      "B7 {\n  r8 \u003d r0.nextQuotedValue(34)\n  goto B15\n}",
      "B8 {\n  if (i6 !\u003d 11) goto B9 else B10\n}",
      "B9 {\n  r8 \u003d String peekedString\u003e\n  String peekedString\u003e \u003d null\n  goto B15\n}",
      "B10 {\n  if (i6 !\u003d 15) goto B11 else B12\n}",
      "B11 {\n  $l5 \u003d JsonReader: long peekedLong\u003e\n  r8 \u003d Long.toString($l5)\n  goto B15\n}",
      "B12 {\n  if (i6 !\u003d 16) goto B13 else B14\n}",
      "B13 {\n  $r6 \u003d String\n  $r7 \u003d JsonReader: char[] buffer\u003e\n  $i1 \u003d JsonReader: int pos\u003e\n  $i0 \u003d JsonReader: int peekedNumberLength\u003e\n  new String($r7, $i1, $i0)\n  r8 \u003d $r6\n  $i3 \u003d JsonReader: int pos\u003e\n  $i2 \u003d JsonReader: int peekedNumberLength\u003e\n  $i4 \u003d $i3 + $i2\n  JsonReader: int pos\u003e \u003d $i4\n  goto B15\n}",
      "B14 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B15 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r9 \u003d JsonReader: int[] pathIndices\u003e\n  $i7 \u003d JsonReader: int stackSize\u003e\n  $i8 \u003d $i7 - 1\n  $i9 \u003d $r9[$i8]\n  $i10 \u003d $i9 + 1\n  $r9[$i8] \u003d $i10\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B15",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B15",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B15",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B15",
      "B10 --\u003e B11",
      "B10 --\u003e B12",
      "B11 --\u003e B15",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e [EXIT]",
      "B15 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#nextQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#nextUnquotedValue(...0)",
        "body": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextBoolean",
    "signature": "boolean nextBoolean()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_TRUE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return true;\r\n    } else if (p \u003d\u003d PEEKED_FALSE) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return false;\r\n    }\r\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\r\n}",
    "nodes": 7,
    "edges": 7,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i8 !\u003d 0) → B1 | else → B2",
      "B2 : If(i8 !\u003d 5) → B3 | else → B4",
      "B4 : If(i8 !\u003d 6) → B5 | else → B6"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i8 \u003d JsonReader: int peeked\u003e\n  if (i8 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i8 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i8 !\u003d 5) goto B3 else B4\n}",
      "B3 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r7 \u003d JsonReader: int[] pathIndices\u003e\n  $i4 \u003d JsonReader: int stackSize\u003e\n  $i5 \u003d $i4 - 1\n  $i6 \u003d $r7[$i5]\n  $i7 \u003d $i6 + 1\n  $r7[$i5] \u003d $i7\n  return\n}",
      "B4 {\n  if (i8 !\u003d 6) goto B5 else B6\n}",
      "B5 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r6 \u003d JsonReader: int[] pathIndices\u003e\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  $i2 \u003d $r6[$i1]\n  $i3 \u003d $i2 + 1\n  $r6[$i1] \u003d $i3\n  return\n}",
      "B6 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextNull",
    "signature": "void nextNull()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_NULL) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\r\n    }\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(i4 !\u003d 0) → B1 | else → B2",
      "B2 : If(i4 !\u003d 7) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i4 \u003d JsonReader: int peeked\u003e\n  if (i4 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i4 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i4 !\u003d 7) goto B3 else B4\n}",
      "B3 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r6 \u003d JsonReader: int[] pathIndices\u003e\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  $i2 \u003d $r6[$i1]\n  $i3 \u003d $i2 + 1\n  $r6[$i1] \u003d $i3\n  goto B5\n}",
      "B4 {\n  $r1 \u003d IllegalStateException\n  $r2 \u003d r0.peek()\n  $r4 \u003d String.valueOf($r2)\n  $r3 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($r4, $r3)\n  new IllegalStateException($r5)\n  throw $r1\n}",
      "B5 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextDouble",
    "signature": "double nextDouble()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return (double) peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\r\n        peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n    } else if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n        peekedString \u003d nextUnquotedValue();\r\n    } else if (p !\u003d PEEKED_BUFFERED) {\r\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double result \u003d Double.parseDouble(peekedString);\r\n    if (!lenient \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nodes": 21,
    "edges": 28,
    "cc": 9,
    "flowSummary": [
      "B0 : If(i14 !\u003d 0) → B1 | else → B2",
      "B2 : If(i14 !\u003d 15) → B3 | else → B4",
      "B4 : If(i14 !\u003d 16) → B5 | else → B6",
      "B6 : If(i14 \u003d\u003d 8) → B7 | else → B8",
      "B7 : If(i14 !\u003d 9) → B8 | else → B12",
      "B8 : If(i14 !\u003d 8) → B9 | else → B10",
      "B12 : If(i14 !\u003d 10) → B13 | else → B14",
      "B14 : If(i14 \u003d\u003d 11) → B15 | else → B16",
      "B16 : If($z2 !\u003d 0) → B17 | else → B20",
      "B17 : If($z0 !\u003d 0) → B18 | else → B19",
      "B18 : If($z1 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i14 \u003d JsonReader: int peeked\u003e\n  if (i14 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i14 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i14 !\u003d 15) goto B3 else B4\n}",
      "B3 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r14 \u003d JsonReader: int[] pathIndices\u003e\n  $i9 \u003d JsonReader: int stackSize\u003e\n  $i10 \u003d $i9 - 1\n  $i11 \u003d $r14[$i10]\n  $i12 \u003d $i11 + 1\n  $r14[$i10] \u003d $i12\n  $l13 \u003d JsonReader: long peekedLong\u003e\n  $d0 \u003d (double) $l13\n  return\n}",
      "B4 {\n  if (i14 !\u003d 16) goto B5 else B6\n}",
      "B5 {\n  $r12 \u003d String\n  $r13 \u003d JsonReader: char[] buffer\u003e\n  $i5 \u003d JsonReader: int pos\u003e\n  $i4 \u003d JsonReader: int peekedNumberLength\u003e\n  new String($r13, $i5, $i4)\n  String peekedString\u003e \u003d $r12\n  $i7 \u003d JsonReader: int pos\u003e\n  $i6 \u003d JsonReader: int peekedNumberLength\u003e\n  $i8 \u003d $i7 + $i6\n  JsonReader: int pos\u003e \u003d $i8\n  goto B16\n}",
      "B6 {\n  if (i14 \u003d\u003d 8) goto B7 else B8\n}",
      "B7 {\n  if (i14 !\u003d 9) goto B8 else B12\n}",
      "B8 {\n  if (i14 !\u003d 8) goto B9 else B10\n}",
      "B9 {\n  $c15 \u003d 39\n  goto B11\n}",
      "B10 {\n  $c15 \u003d 34\n}",
      "B11 {\n  $r1 \u003d r0.nextQuotedValue($c15)\n  String peekedString\u003e \u003d $r1\n  goto B16\n}",
      "B12 {\n  if (i14 !\u003d 10) goto B13 else B14\n}",
      "B13 {\n  $r11 \u003d r0.nextUnquotedValue()\n  String peekedString\u003e \u003d $r11\n  goto B16\n}",
      "B14 {\n  if (i14 \u003d\u003d 11) goto B15 else B16\n}",
      "B15 {\n  $r6 \u003d IllegalStateException\n  $r7 \u003d r0.peek()\n  $r9 \u003d String.valueOf($r7)\n  $r8 \u003d r0.locationString()\n  $r10 \u003d dynInvoke makeConcatWithConstants($r9, $r8)\n  new IllegalStateException($r10)\n  throw $r6\n}",
      "B16 {\n  JsonReader: int peeked\u003e \u003d 11\n  $r15 \u003d String peekedString\u003e\n  $d1 \u003d Double.parseDouble($r15)\n  $z2 \u003d JsonReader: boolean lenient\u003e\n  if ($z2 !\u003d 0) goto B17 else B20\n}",
      "B17 {\n  $z0 \u003d Double.isNaN($d1)\n  if ($z0 !\u003d 0) goto B18 else B19\n}",
      "B18 {\n  $z1 \u003d Double.isInfinite($d1)\n  if ($z1 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r3 \u003d MalformedJsonException\n  $r4 \u003d r0.locationString()\n  $r5 \u003d dynInvoke makeConcatWithConstants($d1, $r4)\n  new MalformedJsonException($r5)\n  throw $r3\n}",
      "B20 {\n  String peekedString\u003e \u003d null\n  JsonReader: int peeked\u003e \u003d 0\n  $r2 \u003d JsonReader: int[] pathIndices\u003e\n  $i0 \u003d JsonReader: int stackSize\u003e\n  $i1 \u003d $i0 - 1\n  $i2 \u003d $r2[$i1]\n  $i3 \u003d $i2 + 1\n  $r2[$i1] \u003d $i3\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B16",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B8",
      "B7 --\u003e B12",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B11 --\u003e B16",
      "B12 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B16",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B17",
      "B16 --\u003e B20",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#nextQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#nextUnquotedValue(...0)",
        "body": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextLong",
    "signature": "long nextLong()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return peekedLong;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            long result \u003d Long.parseLong(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    long result \u003d (long) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027long\u0027.\r\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nodes": 21,
    "edges": 25,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i16 !\u003d 0) → B1 | else → B2",
      "B2 : If(i16 !\u003d 15) → B3 | else → B4",
      "B4 : If(i16 !\u003d 16) → B5 | else → B6",
      "B6 : If(i16 \u003d\u003d 8) → B7 | else → B9",
      "B7 : If(i16 \u003d\u003d 9) → B8 | else → B9",
      "B8 : If(i16 !\u003d 10) → B9 | else → B17",
      "B9 : If(i16 !\u003d 10) → B10 | else → B11",
      "B11 : If(i16 !\u003d 8) → B12 | else → B13",
      "B18 : If($b5 \u003d\u003d false) → B19 | else → B20"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i16 \u003d JsonReader: int peeked\u003e\n  if (i16 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i16 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i16 !\u003d 15) goto B3 else B4\n}",
      "B3 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r16 \u003d JsonReader: int[] pathIndices\u003e\n  $i10 \u003d JsonReader: int stackSize\u003e\n  $i11 \u003d $i10 - 1\n  $i12 \u003d $r16[$i11]\n  $i13 \u003d $i12 + 1\n  $r16[$i11] \u003d $i13\n  $l14 \u003d JsonReader: long peekedLong\u003e\n  return\n}",
      "B4 {\n  if (i16 !\u003d 16) goto B5 else B6\n}",
      "B5 {\n  $r8 \u003d String\n  $r9 \u003d JsonReader: char[] buffer\u003e\n  $i1 \u003d JsonReader: int pos\u003e\n  $i0 \u003d JsonReader: int peekedNumberLength\u003e\n  new String($r9, $i1, $i0)\n  String peekedString\u003e \u003d $r8\n  $i3 \u003d JsonReader: int pos\u003e\n  $i2 \u003d JsonReader: int peekedNumberLength\u003e\n  $i4 \u003d $i3 + $i2\n  JsonReader: int pos\u003e \u003d $i4\n  goto B18\n}",
      "B6 {\n  if (i16 \u003d\u003d 8) goto B7 else B9\n}",
      "B7 {\n  if (i16 \u003d\u003d 9) goto B8 else B9\n}",
      "B8 {\n  if (i16 !\u003d 10) goto B9 else B17\n}",
      "B9 {\n  if (i16 !\u003d 10) goto B10 else B11\n}",
      "B10 {\n  $r2 \u003d r0.nextUnquotedValue()\n  String peekedString\u003e \u003d $r2\n  goto B15\n}",
      "B11 {\n  if (i16 !\u003d 8) goto B12 else B13\n}",
      "B12 {\n  $c17 \u003d 39\n  goto B14\n}",
      "B13 {\n  $c17 \u003d 34\n}",
      "B14 {\n  $r1 \u003d r0.nextQuotedValue($c17)\n  String peekedString\u003e \u003d $r1\n}",
      "B15 {\n  $r18 \u003d String peekedString\u003e\n  $l18 \u003d Long.parseLong($r18)\n  JsonReader: int peeked\u003e \u003d 0\n  $r19 \u003d JsonReader: int[] pathIndices\u003e\n  $i19 \u003d JsonReader: int stackSize\u003e\n  $i20 \u003d $i19 - 1\n  $i21 \u003d $r19[$i20]\n  $i22 \u003d $i21 + 1\n  $r19[$i20] \u003d $i22\n  return\n}",
      "B16 {\n  $r17 :\u003d @caughtexception\n  goto B18\n}",
      "B17 {\n  $r3 \u003d IllegalStateException\n  $r4 \u003d r0.peek()\n  $r6 \u003d String.valueOf($r4)\n  $r5 \u003d r0.locationString()\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6, $r5)\n  new IllegalStateException($r7)\n  throw $r3\n}",
      "B18 {\n  JsonReader: int peeked\u003e \u003d 11\n  $r10 \u003d String peekedString\u003e\n  $d1 \u003d Double.parseDouble($r10)\n  $l15 \u003d (long) $d1\n  $d0 \u003d (double) $l15\n  $b5 \u003d $d0 cmpl $d1\n  if ($b5 \u003d\u003d false) goto B19 else B20\n}",
      "B19 {\n  $r12 \u003d NumberFormatException\n  $r13 \u003d String peekedString\u003e\n  $r14 \u003d r0.locationString()\n  $r15 \u003d dynInvoke makeConcatWithConstants($r13, $r14)\n  new NumberFormatException($r15)\n  throw $r12\n}",
      "B20 {\n  String peekedString\u003e \u003d null\n  JsonReader: int peeked\u003e \u003d 0\n  $r11 \u003d JsonReader: int[] pathIndices\u003e\n  $i6 \u003d JsonReader: int stackSize\u003e\n  $i7 \u003d $i6 - 1\n  $i8 \u003d $r11[$i7]\n  $i9 \u003d $i8 + 1\n  $r11[$i7] \u003d $i9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B18",
      "B6 --\u003e B7",
      "B6 --\u003e B9",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B8 --\u003e B17",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B15",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B14",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B15 --\u003e [EXIT]",
      "B16 --\u003e B18",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#nextQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#nextUnquotedValue(...0)",
        "body": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "nextInt",
    "signature": "int nextInt()",
    "visibility": "public",
    "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    int result;\r\n    if (p \u003d\u003d PEEKED_LONG) {\r\n        result \u003d (int) peekedLong;\r\n        if (peekedLong !\u003d result) {\r\n            // Make sure no precision was lost casting to \u0027int\u0027.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n    if (p \u003d\u003d PEEKED_NUMBER) {\r\n        peekedString \u003d new String(buffer, pos, peekedNumberLength);\r\n        pos +\u003d peekedNumberLength;\r\n    } else if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_UNQUOTED) {\r\n        if (p \u003d\u003d PEEKED_UNQUOTED) {\r\n            peekedString \u003d nextUnquotedValue();\r\n        } else {\r\n            peekedString \u003d nextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\r\n        }\r\n        try {\r\n            result \u003d Integer.parseInt(peekedString);\r\n            peeked \u003d PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\r\n    }\r\n    peeked \u003d PEEKED_BUFFERED;\r\n    // don\u0027t catch this NumberFormatException.\r\n    double asDouble \u003d Double.parseDouble(peekedString);\r\n    result \u003d (int) asDouble;\r\n    if (result !\u003d asDouble) {\r\n        // Make sure no precision was lost casting to \u0027int\u0027.\r\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n    }\r\n    peekedString \u003d null;\r\n    peeked \u003d PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "nodes": 23,
    "edges": 27,
    "cc": 6,
    "flowSummary": [
      "B0 : If(i20 !\u003d 0) → B1 | else → B2",
      "B2 : If(i20 !\u003d 15) → B3 | else → B6",
      "B3 : If($b13 \u003d\u003d false) → B4 | else → B5",
      "B6 : If(i20 !\u003d 16) → B7 | else → B8",
      "B8 : If(i20 \u003d\u003d 8) → B9 | else → B11",
      "B9 : If(i20 \u003d\u003d 9) → B10 | else → B11",
      "B10 : If(i20 !\u003d 10) → B11 | else → B19",
      "B11 : If(i20 !\u003d 10) → B12 | else → B13",
      "B13 : If(i20 !\u003d 8) → B14 | else → B15",
      "B20 : If($b5 \u003d\u003d false) → B21 | else → B22"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i20 \u003d JsonReader: int peeked\u003e\n  if (i20 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  i20 \u003d r0.doPeek()\n}",
      "B2 {\n  if (i20 !\u003d 15) goto B3 else B6\n}",
      "B3 {\n  $l10 \u003d JsonReader: long peekedLong\u003e\n  i21 \u003d (int) $l10\n  $l12 \u003d JsonReader: long peekedLong\u003e\n  $l11 \u003d (long) i21\n  $b13 \u003d $l12 cmp $l11\n  if ($b13 \u003d\u003d false) goto B4 else B5\n}",
      "B4 {\n  $r17 \u003d NumberFormatException\n  $l18 \u003d JsonReader: long peekedLong\u003e\n  $r18 \u003d r0.locationString()\n  $r19 \u003d dynInvoke makeConcatWithConstants($l18, $r18)\n  new NumberFormatException($r19)\n  throw $r17\n}",
      "B5 {\n  JsonReader: int peeked\u003e \u003d 0\n  $r16 \u003d JsonReader: int[] pathIndices\u003e\n  $i14 \u003d JsonReader: int stackSize\u003e\n  $i15 \u003d $i14 - 1\n  $i16 \u003d $r16[$i15]\n  $i17 \u003d $i16 + 1\n  $r16[$i15] \u003d $i17\n  return\n}",
      "B6 {\n  if (i20 !\u003d 16) goto B7 else B8\n}",
      "B7 {\n  $r8 \u003d String\n  $r9 \u003d JsonReader: char[] buffer\u003e\n  $i1 \u003d JsonReader: int pos\u003e\n  $i0 \u003d JsonReader: int peekedNumberLength\u003e\n  new String($r9, $i1, $i0)\n  String peekedString\u003e \u003d $r8\n  $i3 \u003d JsonReader: int pos\u003e\n  $i2 \u003d JsonReader: int peekedNumberLength\u003e\n  $i4 \u003d $i3 + $i2\n  JsonReader: int pos\u003e \u003d $i4\n  goto B20\n}",
      "B8 {\n  if (i20 \u003d\u003d 8) goto B9 else B11\n}",
      "B9 {\n  if (i20 \u003d\u003d 9) goto B10 else B11\n}",
      "B10 {\n  if (i20 !\u003d 10) goto B11 else B19\n}",
      "B11 {\n  if (i20 !\u003d 10) goto B12 else B13\n}",
      "B12 {\n  $r2 \u003d r0.nextUnquotedValue()\n  String peekedString\u003e \u003d $r2\n  goto B17\n}",
      "B13 {\n  if (i20 !\u003d 8) goto B14 else B15\n}",
      "B14 {\n  $c22 \u003d 39\n  goto B16\n}",
      "B15 {\n  $c22 \u003d 34\n}",
      "B16 {\n  $r1 \u003d r0.nextQuotedValue($c22)\n  String peekedString\u003e \u003d $r1\n}",
      "B17 {\n  $r21 \u003d String peekedString\u003e\n  $i23 \u003d Integer.parseInt($r21)\n  JsonReader: int peeked\u003e \u003d 0\n  $r22 \u003d JsonReader: int[] pathIndices\u003e\n  $i24 \u003d JsonReader: int stackSize\u003e\n  $i25 \u003d $i24 - 1\n  $i26 \u003d $r22[$i25]\n  $i27 \u003d $i26 + 1\n  $r22[$i25] \u003d $i27\n  return\n}",
      "B18 {\n  $r20 :\u003d @caughtexception\n  goto B20\n}",
      "B19 {\n  $r3 \u003d IllegalStateException\n  $r4 \u003d r0.peek()\n  $r6 \u003d String.valueOf($r4)\n  $r5 \u003d r0.locationString()\n  $r7 \u003d dynInvoke makeConcatWithConstants($r6, $r5)\n  new IllegalStateException($r7)\n  throw $r3\n}",
      "B20 {\n  JsonReader: int peeked\u003e \u003d 11\n  $r10 \u003d String peekedString\u003e\n  $d1 \u003d Double.parseDouble($r10)\n  $i19 \u003d (int) $d1\n  $d0 \u003d (double) $i19\n  $b5 \u003d $d0 cmpl $d1\n  if ($b5 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  $r12 \u003d NumberFormatException\n  $r13 \u003d String peekedString\u003e\n  $r14 \u003d r0.locationString()\n  $r15 \u003d dynInvoke makeConcatWithConstants($r13, $r14)\n  new NumberFormatException($r15)\n  throw $r12\n}",
      "B22 {\n  String peekedString\u003e \u003d null\n  JsonReader: int peeked\u003e \u003d 0\n  $r11 \u003d JsonReader: int[] pathIndices\u003e\n  $i6 \u003d JsonReader: int stackSize\u003e\n  $i7 \u003d $i6 - 1\n  $i8 \u003d $r11[$i7]\n  $i9 \u003d $i8 + 1\n  $r11[$i7] \u003d $i9\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B2",
      "B2 --\u003e B3",
      "B2 --\u003e B6",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e [EXIT]",
      "B5 --\u003e [EXIT]",
      "B6 --\u003e B7",
      "B6 --\u003e B8",
      "B7 --\u003e B20",
      "B8 --\u003e B9",
      "B8 --\u003e B11",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B11",
      "B10 --\u003e B19",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B17",
      "B13 --\u003e B14",
      "B13 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B16",
      "B16 --\u003e B17",
      "B17 --\u003e [EXIT]",
      "B18 --\u003e B20",
      "B19 --\u003e [EXIT]",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e [EXIT]",
      "B22 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#nextQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    StringBuilder builder \u003d null;\r\n    while (true) {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start \u003d p;\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                int len \u003d p - start - 1;\r\n                if (builder \u003d\u003d null) {\r\n                    int estimatedLength \u003d (len + 1) * 2;\r\n                    builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n                start \u003d p;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        if (builder \u003d\u003d null) {\r\n            int estimatedLength \u003d (p - start) * 2;\r\n            builder \u003d new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos \u003d p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}"
      },
      {
        "name": "JsonReader#locationString(...0)",
        "body": "{\r\n    int line \u003d lineNumber + 1;\r\n    int column \u003d pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}"
      },
      {
        "name": "JsonReader#nextUnquotedValue(...0)",
        "body": "{\r\n    StringBuilder builder \u003d null;\r\n    int i \u003d 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i \u003c buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder \u003d\u003d null) {\r\n            builder \u003d new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos +\u003d i;\r\n        i \u003d 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result \u003d (null \u003d\u003d builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos +\u003d i;\r\n    return result;\r\n}"
      },
      {
        "name": "JsonReader#peek(...0)",
        "body": "{\r\n    int p \u003d peeked;\r\n    if (p \u003d\u003d PEEKED_NONE) {\r\n        p \u003d doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonReader",
    "methodName": "skipValue",
    "signature": "void skipValue()",
    "visibility": "public",
    "body": "{\r\n    int count \u003d 0;\r\n    do {\r\n        int p \u003d peeked;\r\n        if (p \u003d\u003d PEEKED_NONE) {\r\n            p \u003d doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_ARRAY:\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT:\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY:\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT:\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    // Free the last path name so that it can be garbage collected\r\n                    pathNames[stackSize - 1] \u003d null;\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED:\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME:\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\\\u0027\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n                skipQuotedValue(\u0027\"\u0027);\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count \u003d\u003d 0) {\r\n                    pathNames[stackSize - 1] \u003d \"\u003cskipped\u003e\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER:\r\n                pos +\u003d peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF:\r\n                // Do nothing\r\n                return;\r\n        }\r\n        peeked \u003d PEEKED_NONE;\r\n    } while (count \u003e 0);\r\n    pathIndices[stackSize - 1]++;\r\n}",
    "nodes": 23,
    "edges": 39,
    "cc": 18,
    "flowSummary": [
      "B1 : If($i3 !\u003d 0) → B2 | else → B3",
      "B3 : If(switch-on i21) → B5 | else → B7",
      "B7 : If(i20 !\u003d 0) → B8 | else → B9",
      "B13 : If(i20 !\u003d 0) → B14 | else → B21",
      "B15 : If(i20 !\u003d 0) → B16 | else → B21",
      "B17 : If(i20 !\u003d 0) → B18 | else → B21",
      "B21 : If(i20 \u003e 0) → B22 | else → B1"
    ],
    "blockList": [
      "B0 {\n  JsonReader\n  i20 \u003d 0\n}",
      "B1 {\n  $i3 \u003d JsonReader: int peeked\u003e\n  i21 \u003d $i3\n  if ($i3 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  i21 \u003d r0.doPeek()\n}",
      "B3 {\n  JsonReader: int peeked\u003e \u003d 0; }\n}",
      "B4 {\n  r0.push(1)\n  i20 \u003d i20 + 1\n  goto B21\n}",
      "B5 {\n  r0.push(3)\n  i20 \u003d i20 + 1\n  goto B21\n}",
      "B6 {\n  $i14 \u003d JsonReader: int stackSize\u003e\n  $i15 \u003d $i14 - 1\n  JsonReader: int stackSize\u003e \u003d $i15\n  $i23 \u003d (int) -1\n  i20 \u003d i20 + $i23\n  goto B21\n}",
      "B7 {\n  if (i20 !\u003d 0) goto B8 else B9\n}",
      "B8 {\n  $r5 \u003d String[] pathNames\u003e\n  $i18 \u003d JsonReader: int stackSize\u003e\n  $i19 \u003d $i18 - 1\n  $r5[$i19] \u003d null\n}",
      "B9 {\n  $i16 \u003d JsonReader: int stackSize\u003e\n  $i17 \u003d $i16 - 1\n  JsonReader: int stackSize\u003e \u003d $i17\n  $i25 \u003d (int) -1\n  i20 \u003d i20 + $i25\n  goto B21\n}",
      "B10 {\n  r0.skipUnquotedValue()\n  goto B21\n}",
      "B11 {\n  r0.skipQuotedValue(39)\n  goto B21\n}",
      "B12 {\n  r0.skipQuotedValue(34)\n  goto B21\n}",
      "B13 {\n  r0.skipUnquotedValue()\n  if (i20 !\u003d 0) goto B14 else B21\n}",
      "B14 {\n  $r2 \u003d String[] pathNames\u003e\n  $i8 \u003d JsonReader: int stackSize\u003e\n  $i9 \u003d $i8 - 1\n  $r2[$i9] \u003d \"\u003cskipped\u003e\"\n  goto B21\n}",
      "B15 {\n  r0.skipQuotedValue(39)\n  if (i20 !\u003d 0) goto B16 else B21\n}",
      "B16 {\n  $r4 \u003d String[] pathNames\u003e\n  $i12 \u003d JsonReader: int stackSize\u003e\n  $i13 \u003d $i12 - 1\n  $r4[$i13] \u003d \"\u003cskipped\u003e\"\n  goto B21\n}",
      "B17 {\n  r0.skipQuotedValue(34)\n  if (i20 !\u003d 0) goto B18 else B21\n}",
      "B18 {\n  $r3 \u003d String[] pathNames\u003e\n  $i10 \u003d JsonReader: int stackSize\u003e\n  $i11 \u003d $i10 - 1\n  $r3[$i11] \u003d \"\u003cskipped\u003e\"\n  goto B21\n}",
      "B19 {\n  $i1 \u003d JsonReader: int pos\u003e\n  $i0 \u003d JsonReader: int peekedNumberLength\u003e\n  $i2 \u003d $i1 + $i0\n  JsonReader: int pos\u003e \u003d $i2\n  goto B21\n}",
      "B20 {\n  return\n}",
      "B21 {\n  JsonReader: int peeked\u003e \u003d 0\n  if (i20 \u003e 0) goto B22 else B1\n}",
      "B22 {\n  $r1 \u003d JsonReader: int[] pathIndices\u003e\n  $i4 \u003d JsonReader: int stackSize\u003e\n  $i5 \u003d $i4 - 1\n  $i6 \u003d $r1[$i5]\n  $i7 \u003d $i6 + 1\n  $r1[$i5] \u003d $i7\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e B5",
      "B3 --\u003e B7",
      "B3 --\u003e B4",
      "B3 --\u003e B6",
      "B3 --\u003e B21",
      "B3 --\u003e B11",
      "B3 --\u003e B12",
      "B3 --\u003e B10",
      "B3 --\u003e B15",
      "B3 --\u003e B17",
      "B3 --\u003e B13",
      "B3 --\u003e B19",
      "B3 --\u003e B20",
      "B4 --\u003e B21",
      "B5 --\u003e B21",
      "B6 --\u003e B21",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B9",
      "B9 --\u003e B21",
      "B10 --\u003e B21",
      "B11 --\u003e B21",
      "B12 --\u003e B21",
      "B13 --\u003e B14",
      "B13 --\u003e B21",
      "B14 --\u003e B21",
      "B15 --\u003e B16",
      "B15 --\u003e B21",
      "B16 --\u003e B21",
      "B17 --\u003e B18",
      "B17 --\u003e B21",
      "B18 --\u003e B21",
      "B19 --\u003e B21",
      "B20 --\u003e [EXIT]",
      "B21 --\u003e B22",
      "B21 --\u003e B1",
      "B22 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonReader#doPeek(...0)",
        "body": "{\r\n    int peekStack \u003d stack[stackSize - 1];\r\n    if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027]\u0027:\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            case \u0027;\u0027:\r\n                // fall-through\r\n                checkLenient();\r\n            case \u0027,\u0027:\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] \u003d JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\r\n            int c \u003d nextNonWhitespace(true);\r\n            switch(c) {\r\n                case \u0027}\u0027:\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                case \u0027;\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027,\u0027:\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027\"\u0027:\r\n                return peeked \u003d PEEKED_DOUBLE_QUOTED_NAME;\r\n            case \u0027\\\u0027\u0027:\r\n                checkLenient();\r\n                return peeked \u003d PEEKED_SINGLE_QUOTED_NAME;\r\n            case \u0027}\u0027:\r\n                if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked \u003d PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don\u0027t consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    return peeked \u003d PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c \u003d nextNonWhitespace(true);\r\n        switch(c) {\r\n            case \u0027:\u0027:\r\n                break;\r\n            case \u0027\u003d\u0027:\r\n                checkLenient();\r\n                if ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected \u0027:\u0027\");\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] \u003d JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c \u003d nextNonWhitespace(false);\r\n        if (c \u003d\u003d -1) {\r\n            return peeked \u003d PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack \u003d\u003d JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c \u003d nextNonWhitespace(true);\r\n    switch(c) {\r\n        case \u0027]\u0027:\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\r\n                return peeked \u003d PEEKED_END_ARRAY;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case \u0027;\u0027:\r\n        case \u0027,\u0027:\r\n            // In lenient mode, a 0-length literal in an array means \u0027null\u0027.\r\n            if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked \u003d PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case \u0027\\\u0027\u0027:\r\n            checkLenient();\r\n            return peeked \u003d PEEKED_SINGLE_QUOTED;\r\n        case \u0027\"\u0027:\r\n            return peeked \u003d PEEKED_DOUBLE_QUOTED;\r\n        case \u0027[\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_ARRAY;\r\n        case \u0027{\u0027:\r\n            return peeked \u003d PEEKED_BEGIN_OBJECT;\r\n        default:\r\n            // Don\u0027t consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result \u003d peekKeyword();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result \u003d peekNumber();\r\n    if (result !\u003d PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked \u003d PEEKED_UNQUOTED;\r\n}"
      },
      {
        "name": "JsonReader#skipQuotedValue(...1)",
        "body": "{\r\n    // Like nextNonWhitespace, this uses locals \u0027p\u0027 and \u0027l\u0027 to save inner-loop field access.\r\n    char[] buffer \u003d this.buffer;\r\n    do {\r\n        int p \u003d pos;\r\n        int l \u003d limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        while (p \u003c l) {\r\n            int c \u003d buffer[p++];\r\n            if (c \u003d\u003d quote) {\r\n                pos \u003d p;\r\n                return;\r\n            } else if (c \u003d\u003d \u0027\\\\\u0027) {\r\n                pos \u003d p;\r\n                readEscapeCharacter();\r\n                p \u003d pos;\r\n                l \u003d limit;\r\n            } else if (c \u003d\u003d \u0027\\n\u0027) {\r\n                lineNumber++;\r\n                lineStart \u003d p;\r\n            }\r\n        }\r\n        pos \u003d p;\r\n    } while (fillBuffer(1));\r\n    throw syntaxError(\"Unterminated string\");\r\n}"
      },
      {
        "name": "JsonReader#skipUnquotedValue(...0)",
        "body": "{\r\n    do {\r\n        int i \u003d 0;\r\n        for (; pos + i \u003c limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case \u0027/\u0027:\r\n                case \u0027\\\\\u0027:\r\n                case \u0027;\u0027:\r\n                case \u0027#\u0027:\r\n                case \u0027\u003d\u0027:\r\n                    // fall-through\r\n                    checkLenient();\r\n                case \u0027{\u0027:\r\n                case \u0027}\u0027:\r\n                case \u0027[\u0027:\r\n                case \u0027]\u0027:\r\n                case \u0027:\u0027:\r\n                case \u0027,\u0027:\r\n                case \u0027 \u0027:\r\n                case \u0027\\t\u0027:\r\n                case \u0027\\f\u0027:\r\n                case \u0027\\r\u0027:\r\n                case \u0027\\n\u0027:\r\n                    pos +\u003d i;\r\n                    return;\r\n            }\r\n        }\r\n        pos +\u003d i;\r\n    } while (fillBuffer(1));\r\n}"
      },
      {
        "name": "JsonReader#push(...1)",
        "body": "{\r\n    if (stackSize \u003d\u003d stack.length) {\r\n        int newLength \u003d stackSize * 2;\r\n        stack \u003d Arrays.copyOf(stack, newLength);\r\n        pathIndices \u003d Arrays.copyOf(pathIndices, newLength);\r\n        pathNames \u003d Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] \u003d newTop;\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "setIndent",
    "signature": "void setIndent(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (indent.length() \u003d\u003d 0) {\r\n        this.indent \u003d null;\r\n        this.separator \u003d \":\";\r\n    } else {\r\n        this.indent \u003d indent;\r\n        this.separator \u003d \": \";\r\n    }\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  String\n  $i0 \u003d r0.length()\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  String indent\u003e \u003d null\n  String separator\u003e \u003d \":\"\n  goto B3\n}",
      "B2 {\n  String indent\u003e \u003d r0\n  String separator\u003e \u003d \": \"\n}",
      "B3 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "name",
    "signature": "com.google.gson.stream.JsonWriter name(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    Objects.requireNonNull(name, \"name \u003d\u003d null\");\r\n    if (deferredName !\u003d null) {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    deferredName \u003d name;\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 4,
    "cc": 1,
    "flowSummary": [
      "B0 : If($r2 \u003d\u003d null) → B1 | else → B2",
      "B2 : If($i0 !\u003d 0) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  String\n  Objects.requireNonNull(r0, \"name \u003d\u003d null\")\n  $r2 \u003d String deferredName\u003e\n  if ($r2 \u003d\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r4 \u003d IllegalStateException\n  new IllegalStateException()\n  throw $r4\n}",
      "B2 {\n  $i0 \u003d JsonWriter: int stackSize\u003e\n  if ($i0 !\u003d 0) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalStateException\n  new IllegalStateException(\"JsonWriter is closed.\")\n  throw $r3\n}",
      "B4 {\n  String deferredName\u003e \u003d r0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    string(value);\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  r1.writeDeferredName()\n  r1.beforeValue()\n  r1.string(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#string(...1)",
        "body": "{\r\n    String[] replacements \u003d htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n    out.write(\u0027\\\"\u0027);\r\n    int last \u003d 0;\r\n    int length \u003d value.length();\r\n    for (int i \u003d 0; i \u003c length; i++) {\r\n        char c \u003d value.charAt(i);\r\n        String replacement;\r\n        if (c \u003c 128) {\r\n            replacement \u003d replacements[c];\r\n            if (replacement \u003d\u003d null) {\r\n                continue;\r\n            }\r\n        } else if (c \u003d\u003d \u0027\\u2028\u0027) {\r\n            replacement \u003d \"\\\\u2028\";\r\n        } else if (c \u003d\u003d \u0027\\u2029\u0027) {\r\n            replacement \u003d \"\\\\u2029\";\r\n        } else {\r\n            continue;\r\n        }\r\n        if (last \u003c i) {\r\n            out.write(value, last, i - last);\r\n        }\r\n        out.write(replacement);\r\n        last \u003d i + 1;\r\n    }\r\n    if (last \u003c length) {\r\n        out.write(value, last, length - last);\r\n    }\r\n    out.write(\u0027\\\"\u0027);\r\n}"
      },
      {
        "name": "JsonWriter#nullValue(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}"
      },
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "jsonValue",
    "signature": "com.google.gson.stream.JsonWriter jsonValue(java.lang.String)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.append(value);\r\n    return this;\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  String\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  r1.writeDeferredName()\n  r1.beforeValue()\n  $r2 \u003d Writer out\u003e\n  $r2.append(r0)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#nullValue(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}"
      },
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "nullValue",
    "signature": "com.google.gson.stream.JsonWriter nullValue()",
    "visibility": "public",
    "body": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 5,
    "cc": 2,
    "flowSummary": [
      "B0 : If($r1 \u003d\u003d null) → B1 | else → B4",
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B3"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  $r1 \u003d String deferredName\u003e\n  if ($r1 \u003d\u003d null) goto B1 else B4\n}",
      "B1 {\n  $z0 \u003d JsonWriter: boolean serializeNulls\u003e\n  if ($z0 \u003d\u003d false) goto B2 else B3\n}",
      "B2 {\n  r0.writeDeferredName()\n  goto B4\n}",
      "B3 {\n  String deferredName\u003e \u003d null\n  return\n}",
      "B4 {\n  r0.beforeValue()\n  $r2 \u003d Writer out\u003e\n  $r2.write(\"null\")\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(boolean)",
    "visibility": "public",
    "body": "{\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "nodes": 4,
    "edges": 4,
    "cc": 2,
    "flowSummary": [
      "B0 : If(z0 \u003d\u003d false) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  z0 :\u003d @parameter0: boolean\n  r0.writeDeferredName()\n  r0.beforeValue()\n  $r1 \u003d Writer out\u003e\n  if (z0 \u003d\u003d false) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d \"true\"\n  goto B3\n}",
      "B2 {\n  $r2 \u003d \"false\"\n}",
      "B3 {\n  $r1.write($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B3 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.Boolean)",
    "visibility": "public",
    "body": "{\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "nodes": 6,
    "edges": 6,
    "cc": 2,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  Boolean\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r3 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  r1.writeDeferredName()\n  r1.beforeValue()\n  $r2 \u003d Writer out\u003e\n  $z0 \u003d r0.booleanValue()\n  if ($z0 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r4 \u003d \"true\"\n  goto B5\n}",
      "B4 {\n  $r4 \u003d \"false\"\n}",
      "B5 {\n  $r2.write($r4)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B5 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(float)",
    "visibility": "public",
    "body": "{\r\n    writeDeferredName();\r\n    if (!lenient \u0026\u0026 (Float.isNaN(value) || Float.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Float.toString(value));\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  f0 :\u003d @parameter0: float\n  r0.writeDeferredName()\n  $z0 \u003d JsonWriter: boolean lenient\u003e\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d Float.isNaN(f0)\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d Float.isInfinite(f0)\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(f0)\n  new IllegalArgumentException($r4)\n  throw $r3\n}",
      "B4 {\n  r0.beforeValue()\n  $r1 \u003d Writer out\u003e\n  $r2 \u003d Float.toString(f0)\n  $r1.append($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(double)",
    "visibility": "public",
    "body": "{\r\n    writeDeferredName();\r\n    if (!lenient \u0026\u0026 (Double.isNaN(value) || Double.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Double.toString(value));\r\n    return this;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If($z0 !\u003d 0) → B1 | else → B4",
      "B1 : If($z1 !\u003d 0) → B2 | else → B3",
      "B2 : If($z2 \u003d\u003d false) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  d0 :\u003d @parameter0: double\n  r0.writeDeferredName()\n  $z0 \u003d JsonWriter: boolean lenient\u003e\n  if ($z0 !\u003d 0) goto B1 else B4\n}",
      "B1 {\n  $z1 \u003d Double.isNaN(d0)\n  if ($z1 !\u003d 0) goto B2 else B3\n}",
      "B2 {\n  $z2 \u003d Double.isInfinite(d0)\n  if ($z2 \u003d\u003d false) goto B3 else B4\n}",
      "B3 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(d0)\n  new IllegalArgumentException($r4)\n  throw $r3\n}",
      "B4 {\n  r0.beforeValue()\n  $r1 \u003d Writer out\u003e\n  $r2 \u003d Double.toString(d0)\n  $r1.append($r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B4",
      "B1 --\u003e B2",
      "B1 --\u003e B3",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "value",
    "signature": "com.google.gson.stream.JsonWriter value(java.lang.Number)",
    "visibility": "public",
    "body": "{\r\n    if (value \u003d\u003d null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    String string \u003d value.toString();\r\n    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n        if (!lenient) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n        }\r\n    } else {\r\n        Class\u003c? extends Number\u003e numberClass \u003d value.getClass();\r\n        // Validate that string is valid before writing it directly to JSON output\r\n        if (!isTrustedNumberType(numberClass) \u0026\u0026 !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n            throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.append(string);\r\n    return this;\r\n}",
    "nodes": 11,
    "edges": 14,
    "cc": 5,
    "flowSummary": [
      "B0 : If(r0 !\u003d null) → B1 | else → B2",
      "B2 : If($z0 !\u003d 0) → B3 | else → B5",
      "B3 : If($z1 !\u003d 0) → B4 | else → B5",
      "B4 : If($z2 \u003d\u003d false) → B5 | else → B7",
      "B5 : If($z5 !\u003d 0) → B6 | else → B10",
      "B7 : If($z3 !\u003d 0) → B8 | else → B10",
      "B8 : If($z4 !\u003d 0) → B9 | else → B10"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  Number\n  if (r0 !\u003d null) goto B1 else B2\n}",
      "B1 {\n  $r11 \u003d r1.nullValue()\n  return\n}",
      "B2 {\n  r1.writeDeferredName()\n  r2 \u003d r0.toString()\n  $z0 \u003d r2.equals(\"-Infinity\")\n  if ($z0 !\u003d 0) goto B3 else B5\n}",
      "B3 {\n  $z1 \u003d r2.equals(\"Infinity\")\n  if ($z1 !\u003d 0) goto B4 else B5\n}",
      "B4 {\n  $z2 \u003d r2.equals(\"NaN\")\n  if ($z2 \u003d\u003d false) goto B5 else B7\n}",
      "B5 {\n  $z5 \u003d JsonWriter: boolean lenient\u003e\n  if ($z5 !\u003d 0) goto B6 else B10\n}",
      "B6 {\n  $r3 \u003d IllegalArgumentException\n  $r4 \u003d dynInvoke makeConcatWithConstants(r2)\n  new IllegalArgumentException($r4)\n  throw $r3\n}",
      "B7 {\n  r5 \u003d r0.getClass()\n  $z3 \u003d JsonWriter.isTrustedNumberType(r5)\n  if ($z3 !\u003d 0) goto B8 else B10\n}",
      "B8 {\n  $r6 \u003d Pattern VALID_JSON_NUMBER_PATTERN\u003e\n  $r7 \u003d $r6.matcher(r2)\n  $z4 \u003d $r7.matches()\n  if ($z4 !\u003d 0) goto B9 else B10\n}",
      "B9 {\n  $r8 \u003d IllegalArgumentException\n  $r9 \u003d String.valueOf(r5)\n  $r10 \u003d dynInvoke makeConcatWithConstants($r9, r2)\n  new IllegalArgumentException($r10)\n  throw $r8\n}",
      "B10 {\n  r1.beforeValue()\n  $r12 \u003d Writer out\u003e\n  $r12.append(r2)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e B3",
      "B2 --\u003e B5",
      "B3 --\u003e B4",
      "B3 --\u003e B5",
      "B4 --\u003e B5",
      "B4 --\u003e B7",
      "B5 --\u003e B6",
      "B5 --\u003e B10",
      "B6 --\u003e [EXIT]",
      "B7 --\u003e B8",
      "B7 --\u003e B10",
      "B8 --\u003e B9",
      "B8 --\u003e B10",
      "B9 --\u003e [EXIT]",
      "B10 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "JsonWriter#nullValue(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName \u003d null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}"
      },
      {
        "name": "JsonWriter#isTrustedNumberType(...1)",
        "body": "{\r\n    // Note: Don\u0027t consider LazilyParsedNumber trusted because it could contain\r\n    // an arbitrary malformed string\r\n    return c \u003d\u003d Integer.class || c \u003d\u003d Long.class || c \u003d\u003d Double.class || c \u003d\u003d Float.class || c \u003d\u003d Byte.class || c \u003d\u003d Short.class || c \u003d\u003d BigDecimal.class || c \u003d\u003d BigInteger.class || c \u003d\u003d AtomicInteger.class || c \u003d\u003d AtomicLong.class;\r\n}"
      },
      {
        "name": "JsonWriter#writeDeferredName(...0)",
        "body": "{\r\n    if (deferredName !\u003d null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName \u003d null;\r\n    }\r\n}"
      },
      {
        "name": "JsonWriter#beforeValue(...0)",
        "body": "{\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (!lenient) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(\u0027,\u0027);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(separator);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}"
      }
    ]
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "flush",
    "signature": "void flush()",
    "visibility": "public",
    "body": "{\r\n    if (stackSize \u003d\u003d 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    out.flush();\r\n}",
    "nodes": 3,
    "edges": 2,
    "cc": 1,
    "flowSummary": [
      "B0 : If($i0 !\u003d 0) → B1 | else → B2"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  $i0 \u003d JsonWriter: int stackSize\u003e\n  if ($i0 !\u003d 0) goto B1 else B2\n}",
      "B1 {\n  $r2 \u003d IllegalStateException\n  new IllegalStateException(\"JsonWriter is closed.\")\n  throw $r2\n}",
      "B2 {\n  $r1 \u003d Writer out\u003e\n  $r1.flush()\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B2",
      "B1 --\u003e [EXIT]",
      "B2 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "com.google.gson.stream.JsonWriter",
    "methodName": "close",
    "signature": "void close()",
    "visibility": "public",
    "body": "{\r\n    out.close();\r\n    int size \u003d stackSize;\r\n    if (size \u003e 1 || size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stackSize \u003d 0;\r\n}",
    "nodes": 5,
    "edges": 6,
    "cc": 3,
    "flowSummary": [
      "B0 : If(i0 \u003e 1) → B1 | else → B3",
      "B1 : If(i0 !\u003d 1) → B2 | else → B4",
      "B2 : If($i2 \u003d\u003d 7) → B3 | else → B4"
    ],
    "blockList": [
      "B0 {\n  JsonWriter\n  $r1 \u003d Writer out\u003e\n  $r1.close()\n  i0 \u003d JsonWriter: int stackSize\u003e\n  if (i0 \u003e 1) goto B1 else B3\n}",
      "B1 {\n  if (i0 !\u003d 1) goto B2 else B4\n}",
      "B2 {\n  $r3 \u003d JsonWriter: int[] stack\u003e\n  $i1 \u003d i0 - 1\n  $i2 \u003d $r3[$i1]\n  if ($i2 \u003d\u003d 7) goto B3 else B4\n}",
      "B3 {\n  $r2 \u003d IOException\n  new IOException(\"Incomplete document\")\n  throw $r2\n}",
      "B4 {\n  JsonWriter: int stackSize\u003e \u003d 0\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B0 --\u003e B3",
      "B1 --\u003e B2",
      "B1 --\u003e B4",
      "B2 --\u003e B3",
      "B2 --\u003e B4",
      "B3 --\u003e [EXIT]",
      "B4 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "MethodAnalysisToJson",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "(source not found)",
    "nodes": 72,
    "edges": 101,
    "cc": 31,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B67",
      "B3 : If($z16 \u003d\u003d false) → B4 | else → B66",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B8 : If(i1 \u003d\u003d false) → B9 | else → B3",
      "B9 : If(i2 !\u003d 0) → B10 | else → B11",
      "B11 : If(i4 \u003e 0) → B12 | else → B13",
      "B14 : If($z2 \u003d\u003d false) → B15 | else → B18",
      "B15 : If(i13 \u003c\u003d 0) → B16 | else → B17",
      "B19 : If($z17 \u003d\u003d false) → B20 | else → B28",
      "B20 : If($i10 \u003e\u003d 2) → B21 | else → B22",
      "B22 : If($z13 \u003d\u003d false) → B23 | else → B24",
      "B24 : If($z14 !\u003d 0) → B25 | else → B26",
      "B25 : If($z15 \u003d\u003d false) → B26 | else → B19",
      "B28 : If(r140 \u003d\u003d null) → B29 | else → B32",
      "B29 : If($z11 \u003d\u003d false) → B30 | else → B32",
      "B30 : If($z12 \u003d\u003d false) → B31 | else → B32",
      "B32 : If($z18 \u003d\u003d false) → B33 | else → B36",
      "B33 : If(i11 \u003e\u003d i12) → B34 | else → B36",
      "B36 : If(r140 \u003d\u003d null) → B37 | else → B39",
      "B37 : If($z10 \u003d\u003d false) → B38 | else → B39",
      "B40 : If($z19 \u003d\u003d false) → B41 | else → B56",
      "B41 : If($z6 \u003d\u003d false) → B42 | else → B43",
      "B44 : If($z7 \u003d\u003d false) → B45 | else → B46",
      "B47 : If($z8 !\u003d 0) → B48 | else → B49",
      "B49 : If($z9 \u003d\u003d false) → B50 | else → B51",
      "B52 : If($r74 \u003d\u003d null) → B53 | else → B54",
      "B57 : If($z3 \u003d\u003d false) → B58 | else → B65",
      "B58 : If(r151 \u003d\u003d null) → B59 | else → B60",
      "B60 : If($z4 \u003d\u003d false) → B61 | else → B64",
      "B61 : If(r59 \u003d\u003d null) → B62 | else → B64",
      "B62 : If($z5 \u003d\u003d false) → B63 | else → B64"
    ],
    "blockList": [
      "B0 {\n  String[]\n  G.reset()\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r1 \u003d Options.v()\n  $r1.set_allow_phantom_refs(1)\n  $r3 \u003d Options.v()\n  $r2 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\gson-gson-parent-2.10.1\\\\gson-gson-parent-2.10.1\\\\gson\\\\target\\\\classes\")\n  $r3.set_process_dir($r2)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r9 \u003d Options.v()\n  $r6 \u003d String pathSeparator\u003e\n  $r5 \u003d CharSequence)[2]\n  $r5[0] \u003d 1\\\\gson\\\\target\\\\classes\"\n  $r7 \u003d System.getProperty(\"java.class.path\")\n  $r5[1] \u003d $r7\n  $r8 \u003d String.join($r6, $r5)\n  $r9.set_soot_classpath($r8)\n  $r10 \u003d Scene.v()\n  $r10.loadNecessaryClasses()\n  $r11 \u003d HashMap\n  new HashMap()\n  $r13 \u003d Path SOURCE_ROOT\u003e\n  $r12 \u003d FileVisitOption)[0]\n  $r15 \u003d Files.walk($r13, $r12)\n  $r14 \u003d MethodAnalysisToJson$lambda_main_2__1.bootstrap$()\n  $r17 \u003d $r15.filter($r14)\n  $r16 \u003d MethodAnalysisToJson$lambda_main_3__2.bootstrap$($r11)\n  $r17.forEach($r16)\n  $r18 \u003d ArrayList\n  new ArrayList()\n  $r19 \u003d HashMap\n  new HashMap()\n  $r20 \u003d ArrayList\n  $r21 \u003d Scene.v()\n  $r22 \u003d $r21.getApplicationClasses()\n  new ArrayList($r22)\n  r119 \u003d $r20.iterator()\n}",
      "B1 {\n  $z0 \u003d r119.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B67\n}",
      "B2 {\n  $r28 \u003d r119.next()\n  r120 \u003d SootClass) $r28\n  $r29 \u003d ArrayList\n  $r30 \u003d r120.getMethods()\n  new ArrayList($r30)\n  r121 \u003d $r29.iterator()\n}",
      "B3 {\n  $z16 \u003d r121.hasNext()\n  if ($z16 \u003d\u003d false) goto B4 else B66\n}",
      "B4 {\n  $r31 \u003d r121.next()\n  r122 \u003d SootMethod) $r31\n  $z1 \u003d MethodAnalysisToJson.isEligible(r120, r122)\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r32 \u003d r122.retrieveActiveBody()\n  goto B8\n}",
      "B7 {\n  $r117 :\u003d @caughtexception\n  goto B3\n}",
      "B8 {\n  $r33 \u003d BriefBlockGraph\n  new BriefBlockGraph(r32)\n  i1 \u003d $r33.size()\n  $r34 \u003d $r33.getBlocks()\n  $r36 \u003d $r34.stream()\n  $r35 \u003d MethodAnalysisToJson$lambda_main_4__3.bootstrap$($r33)\n  $r37 \u003d $r36.mapToInt($r35)\n  i2 \u003d $r37.sum()\n  $i3 \u003d i2 - i1\n  i4 \u003d $i3 + 2\n  if (i1 \u003d\u003d false) goto B9 else B3\n}",
      "B9 {\n  if (i2 !\u003d 0) goto B10 else B11\n}",
      "B10 {\n  goto B3\n}",
      "B11 {\n  if (i4 \u003e 0) goto B12 else B13\n}",
      "B12 {\n  goto B3\n}",
      "B13 {\n  i11 \u003d 2147483647\n  i12 \u003d -2147483648\n  $r38 \u003d r32.getUnits()\n  r123 \u003d $r38.iterator()\n}",
      "B14 {\n  $z2 \u003d r123.hasNext()\n  if ($z2 \u003d\u003d false) goto B15 else B18\n}",
      "B15 {\n  $r113 \u003d r123.next()\n  r124 \u003d Unit) $r113\n  i13 \u003d r124.getJavaSourceStartLineNumber()\n  if (i13 \u003c\u003d 0) goto B16 else B17\n}",
      "B16 {\n  i11 \u003d Math.min(i11, i13)\n  i12 \u003d Math.max(i12, i13)\n}",
      "B17 {\n  goto B14\n}",
      "B18 {\n  $r39 \u003d ArrayList\n  new ArrayList()\n  r125 \u003d $r33.iterator()\n}",
      "B19 {\n  $z17 \u003d r125.hasNext()\n  if ($z17 \u003d\u003d false) goto B20 else B28\n}",
      "B20 {\n  $r105 \u003d r125.next()\n  r126 \u003d Block) $r105\n  r127 \u003d $r33.getSuccsOf(r126)\n  $i10 \u003d r127.size()\n  if ($i10 \u003e\u003d 2) goto B21 else B22\n}",
      "B21 {\n  goto B19\n}",
      "B22 {\n  r128 \u003d r126.getTail()\n  $z13 \u003d IfStmt\n  if ($z13 \u003d\u003d false) goto B23 else B24\n}",
      "B23 {\n  $r111 \u003d IfStmt) r128\n  $r112 \u003d $r111.getCondition()\n  r129 \u003d $r112.toString()\n  goto B27\n}",
      "B24 {\n  $z14 \u003d LookupSwitchStmt\n  if ($z14 !\u003d 0) goto B25 else B26\n}",
      "B25 {\n  $z15 \u003d TableSwitchStmt\n  if ($z15 \u003d\u003d false) goto B26 else B19\n}",
      "B26 {\n  $r106 \u003d r128.getUseBoxes()\n  $r107 \u003d $r106.get(0)\n  $r108 \u003d ValueBox) $r107\n  $r109 \u003d $r108.getValue()\n  $r110 \u003d String.valueOf($r109)\n  r129 \u003d dynInvoke makeConcatWithConstants($r110)\n}",
      "B27 {\n  $r130 \u003d Object)[4]\n  $i14 \u003d r126.getIndexInMethod()\n  $r131 \u003d Integer.valueOf($i14)\n  $r130[0] \u003d $r131\n  $r130[1] \u003d r129\n  $r132 \u003d r127.get(0)\n  $r133 \u003d Block) $r132\n  $i15 \u003d $r133.getIndexInMethod()\n  $r134 \u003d Integer.valueOf($i15)\n  $r130[2] \u003d $r134\n  $r135 \u003d r127.get(1)\n  $r136 \u003d Block) $r135\n  $i16 \u003d $r136.getIndexInMethod()\n  $r137 \u003d Integer.valueOf($i16)\n  $r130[3] \u003d $r137\n  $r138 \u003d String.format(\"B%d : If(%s) \\u2192 B%d | else \\u2192 B%d\", $r130)\n  $r39.add($r138)\n  goto B19\n}",
      "B28 {\n  r139 \u003d r120.getName()\n  $r40 \u003d MethodAnalysisToJson$lambda_main_5__4.bootstrap$()\n  $r41 \u003d $r19.computeIfAbsent(r139, $r40)\n  r140 \u003d CompilationUnit) $r41\n  r141 \u003d \"(source not found)\"\n  r142 \u003d r122.getSubSignature()\n  MethodAnalysisToJson.toSimpleSig(r142)\n  if (r140 \u003d\u003d null) goto B29 else B32\n}",
      "B29 {\n  $r92 \u003d r120.getShortName()\n  r143 \u003d r140.getClassByName($r92)\n  $z11 \u003d r143.isPresent()\n  if ($z11 \u003d\u003d false) goto B30 else B32\n}",
      "B30 {\n  $r93 \u003d r143.get()\n  $r94 \u003d ClassOrInterfaceDeclaration) $r93\n  $r95 \u003d $r94.getMethods()\n  $r97 \u003d $r95.stream()\n  $r96 \u003d MethodAnalysisToJson$lambda_main_6__7.bootstrap$(r122)\n  $r98 \u003d $r97.filter($r96)\n  r144 \u003d $r98.findFirst()\n  $z12 \u003d r144.isPresent()\n  if ($z12 \u003d\u003d false) goto B31 else B32\n}",
      "B31 {\n  $r99 \u003d r144.get()\n  $r100 \u003d MethodDeclaration) $r99\n  $r102 \u003d $r100.getBody()\n  $r101 \u003d MethodAnalysisToJson$toString__8.bootstrap$()\n  $r103 \u003d $r102.map($r101)\n  $r104 \u003d $r103.orElse(\"(no body)\")\n  r141 \u003d String) $r104\n}",
      "B32 {\n  $r145 \u003d \"(source not found)\"\n  $z18 \u003d $r145.equals(r141)\n  if ($z18 \u003d\u003d false) goto B33 else B36\n}",
      "B33 {\n  if (i11 \u003e\u003d i12) goto B34 else B36\n}",
      "B34 {\n  $r87 \u003d Path SOURCE_ROOT\u003e\n  $r88 \u003d r139.replace(46, 47)\n  $r89 \u003d dynInvoke makeConcatWithConstants($r88)\n  r146 \u003d $r87.resolve($r89)\n  r147 \u003d Files.readAllLines(r146)\n  $r91 \u003d System.lineSeparator()\n  $i9 \u003d i11 - 1\n  $i7 \u003d r147.size()\n  $i8 \u003d Math.min(i12, $i7)\n  $r90 \u003d r147.subList($i9, $i8)\n  r141 \u003d String.join($r91, $r90)\n  goto B36\n}",
      "B35 {\n  $r116 :\u003d @caughtexception\n}",
      "B36 {\n  $r148 \u003d MethodAnalysisToJson.buildPrettyCFG(r32)\n  $r149 \u003d HashSet\n  new HashSet()\n  $r150 \u003d HashSet\n  new HashSet()\n  r151 \u003d null\n  if (r140 \u003d\u003d null) goto B37 else B39\n}",
      "B37 {\n  $r77 \u003d r120.getShortName()\n  r152 \u003d r140.getClassByName($r77)\n  $z10 \u003d r152.isPresent()\n  if ($z10 \u003d\u003d false) goto B38 else B39\n}",
      "B38 {\n  $r78 \u003d r152.get()\n  r151 \u003d ClassOrInterfaceDeclaration) $r78\n  $r79 \u003d r152.get()\n  $r80 \u003d ClassOrInterfaceDeclaration) $r79\n  $r81 \u003d $r80.getMethods()\n  $r83 \u003d $r81.stream()\n  $r82 \u003d MethodAnalysisToJson$lambda_main_7__5.bootstrap$(r122)\n  $r84 \u003d $r83.filter($r82)\n  $r86 \u003d $r84.findFirst()\n  $r85 \u003d MethodAnalysisToJson$lambda_main_8__6.bootstrap$(r120, $r149, $r150)\n  $r86.ifPresent($r85)\n}",
      "B39 {\n  $r153 \u003d new MethodInfo\n  new MethodInfo()\n  $r154 \u003d $r149.iterator()\n}",
      "B40 {\n  $z19 \u003d $r154.hasNext()\n  if ($z19 \u003d\u003d false) goto B41 else B56\n}",
      "B41 {\n  $r66 \u003d $r154.next()\n  r155 \u003d String) $r66\n  $z6 \u003d r155.contains(\".\")\n  if ($z6 \u003d\u003d false) goto B42 else B43\n}",
      "B42 {\n  $i5 \u003d r155.lastIndexOf(46)\n  $i6 \u003d $i5 + 1\n  $r156 \u003d r155.substring($i6)\n  goto B44\n}",
      "B43 {\n  $r156 \u003d r155\n}",
      "B44 {\n  r157 \u003d $r156\n  $z7 \u003d r155.contains(\".\")\n  if ($z7 \u003d\u003d false) goto B45 else B46\n}",
      "B45 {\n  $r158 \u003d r155\n  goto B47\n}",
      "B46 {\n  $r67 \u003d r120.getPackageName()\n  $r158 \u003d dynInvoke makeConcatWithConstants($r67, $r156)\n}",
      "B47 {\n  r159 \u003d $r158\n  $r68 \u003d Path SOURCE_ROOT\u003e\n  $r69 \u003d $r158.replace(46, 47)\n  $r70 \u003d dynInvoke makeConcatWithConstants($r69)\n  $r76 \u003d $r68.resolve($r70)\n  r160 \u003d $r76\n  $r71 \u003d LinkOption)[0]\n  $z8 \u003d Files.exists($r76, $r71)\n  if ($z8 !\u003d 0) goto B48 else B49\n}",
      "B48 {\n  $r75 \u003d $r11.get(r157)\n  r160 \u003d Path) $r75\n}",
      "B49 {\n  $r72 \u003d new DependencyInfo\n  new DependencyInfo()\n  $z9 \u003d r159.contains(\".\")\n  if ($z9 \u003d\u003d false) goto B50 else B51\n}",
      "B50 {\n  $r161 \u003d r159\n  goto B52\n}",
      "B51 {\n  $r161 \u003d r157\n}",
      "B52 {\n  String name\u003e \u003d $r161\n  $r74 \u003d MethodAnalysisToJson.loadCU(r160, $r19)\n  if ($r74 \u003d\u003d null) goto B53 else B54\n}",
      "B53 {\n  $r162 \u003d $r74.toString()\n  goto B55\n}",
      "B54 {\n  $r162 \u003d \"(source not found)\"\n}",
      "B55 {\n  String body\u003e \u003d $r162\n  $r73 \u003d List depClasses\u003e\n  $r73.add($r72)\n  goto B40\n}",
      "B56 {\n  r163 \u003d $r150.iterator()\n}",
      "B57 {\n  $z3 \u003d r163.hasNext()\n  if ($z3 \u003d\u003d false) goto B58 else B65\n}",
      "B58 {\n  $r49 \u003d r163.next()\n  r164 \u003d List) $r49\n  $r50 \u003d r164.get(0)\n  r165 \u003d String) $r50\n  $r51 \u003d r164.get(1)\n  $r52 \u003d String) $r51\n  i17 \u003d Integer.parseInt($r52)\n  $r53 \u003d new DependencyInfo\n  new DependencyInfo()\n  $r54 \u003d r120.getShortName()\n  $r55 \u003d dynInvoke makeConcatWithConstants($r54, r165, i17)\n  String name\u003e \u003d $r55\n  r166 \u003d \"(source not found)\"\n  if (r151 \u003d\u003d null) goto B59 else B60\n}",
      "B59 {\n  $r65 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc(r151, r165, $r65)\n}",
      "B60 {\n  $r56 \u003d \"(source not found)\"\n  $z4 \u003d $r56.equals(r166)\n  if ($z4 \u003d\u003d false) goto B61 else B64\n}",
      "B61 {\n  $r57 \u003d r120.getShortName()\n  $r58 \u003d $r11.get($r57)\n  r167 \u003d Path) $r58\n  r59 \u003d MethodAnalysisToJson.loadCU(r167, $r19)\n  if (r59 \u003d\u003d null) goto B62 else B64\n}",
      "B62 {\n  $r60 \u003d r120.getShortName()\n  r61 \u003d r59.getClassByName($r60)\n  $z5 \u003d r61.isPresent()\n  if ($z5 \u003d\u003d false) goto B63 else B64\n}",
      "B63 {\n  $r62 \u003d r61.get()\n  $r64 \u003d ClassOrInterfaceDeclaration) $r62\n  $r63 \u003d Collections.nCopies(i17, \"\")\n  r166 \u003d MethodAnalysisToJson.findMethodBodySrc($r64, r165, $r63)\n}",
      "B64 {\n  String body\u003e \u003d r166\n  $r168 \u003d List depMethods\u003e\n  $r168.add($r53)\n  goto B57\n}",
      "B65 {\n  String clazz\u003e \u003d r139\n  $r42 \u003d r122.getName()\n  String methodName\u003e \u003d $r42\n  $r43 \u003d r122.getSubSignature()\n  String signature\u003e \u003d $r43\n  $r44 \u003d MethodAnalysisToJson.vis(r122)\n  String visibility\u003e \u003d $r44\n  String body\u003e \u003d r141\n  \u003cMethodInfo: int nodes\u003e \u003d i1\n  \u003cMethodInfo: int edges\u003e \u003d i2\n  \u003cMethodInfo: int cc\u003e \u003d i4\n  List flowSummary\u003e \u003d $r39\n  $r45 \u003d $r148.get(\"blocks\")\n  $r46 \u003d List) $r45\n  List blockList\u003e \u003d $r46\n  $r47 \u003d $r148.get(\"edges\")\n  $r48 \u003d List) $r47\n  List blockEdges\u003e \u003d $r48\n  $r18.add($r153)\n  goto B3\n}",
      "B66 {\n  goto B1\n}",
      "B67 {\n  $r23 \u003d GsonBuilder\n  new GsonBuilder()\n  $r24 \u003d $r23.setPrettyPrinting()\n  r169 \u003d $r24.create()\n  $r25 \u003d FileWriter\n  new FileWriter(\"C:/Users/00000/Desktop/my/gso_all_methods.json\")\n  r169.toJson($r18, $r25)\n  $r25.close()\n  goto B71\n}",
      "B68 {\n  $r115 :\u003d @caughtexception\n  $r25.close()\n  goto B70\n}",
      "B69 {\n  $r114 :\u003d @caughtexception\n  $r115.addSuppressed($r114)\n}",
      "B70 {\n  throw $r115\n}",
      "B71 {\n  $r26 \u003d PrintStream out\u003e\n  $i0 \u003d $r18.size()\n  $r27 \u003d dynInvoke makeConcatWithConstants($i0)\n  $r26.println($r27)\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B67",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B66",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B8",
      "B7 --\u003e B3",
      "B8 --\u003e B9",
      "B8 --\u003e B3",
      "B9 --\u003e B10",
      "B9 --\u003e B11",
      "B10 --\u003e B3",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B3",
      "B13 --\u003e B14",
      "B14 --\u003e B15",
      "B14 --\u003e B18",
      "B15 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B14",
      "B18 --\u003e B19",
      "B19 --\u003e B20",
      "B19 --\u003e B28",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B19",
      "B22 --\u003e B23",
      "B22 --\u003e B24",
      "B23 --\u003e B27",
      "B24 --\u003e B25",
      "B24 --\u003e B26",
      "B25 --\u003e B26",
      "B25 --\u003e B19",
      "B26 --\u003e B27",
      "B27 --\u003e B19",
      "B28 --\u003e B29",
      "B28 --\u003e B32",
      "B29 --\u003e B30",
      "B29 --\u003e B32",
      "B30 --\u003e B31",
      "B30 --\u003e B32",
      "B31 --\u003e B32",
      "B32 --\u003e B33",
      "B32 --\u003e B36",
      "B33 --\u003e B34",
      "B33 --\u003e B36",
      "B34 --\u003e B36",
      "B35 --\u003e B36",
      "B36 --\u003e B37",
      "B36 --\u003e B39",
      "B37 --\u003e B38",
      "B37 --\u003e B39",
      "B38 --\u003e B39",
      "B39 --\u003e B40",
      "B40 --\u003e B41",
      "B40 --\u003e B56",
      "B41 --\u003e B42",
      "B41 --\u003e B43",
      "B42 --\u003e B44",
      "B43 --\u003e B44",
      "B44 --\u003e B45",
      "B44 --\u003e B46",
      "B45 --\u003e B47",
      "B46 --\u003e B47",
      "B47 --\u003e B48",
      "B47 --\u003e B49",
      "B48 --\u003e B49",
      "B49 --\u003e B50",
      "B49 --\u003e B51",
      "B50 --\u003e B52",
      "B51 --\u003e B52",
      "B52 --\u003e B53",
      "B52 --\u003e B54",
      "B53 --\u003e B55",
      "B54 --\u003e B55",
      "B55 --\u003e B40",
      "B56 --\u003e B57",
      "B57 --\u003e B58",
      "B57 --\u003e B65",
      "B58 --\u003e B59",
      "B58 --\u003e B60",
      "B59 --\u003e B60",
      "B60 --\u003e B61",
      "B60 --\u003e B64",
      "B61 --\u003e B62",
      "B61 --\u003e B64",
      "B62 --\u003e B63",
      "B62 --\u003e B64",
      "B63 --\u003e B64",
      "B64 --\u003e B57",
      "B65 --\u003e B3",
      "B66 --\u003e B1",
      "B67 --\u003e B71",
      "B68 --\u003e B70",
      "B69 --\u003e B70",
      "B70 --\u003e [EXIT]",
      "B71 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": []
  },
  {
    "clazz": "SootCFGAnalysis",
    "methodName": "main",
    "signature": "void main(java.lang.String[])",
    "visibility": "public",
    "body": "{\r\n    //        String targetDir \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\benchmark\\\\commons-collections4-4.5.0-M1-src\\\\commons-collections4-4.5.0-M1-src\\\\target\\\\classes\"; // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    //        String outputCsv \u003d \"C:\\\\Users\\\\user\\\\Desktop\\\\agtTest\\\\cfg_analysis_result.tsv\"; // 결과 저장할 CSV 파일 경로\r\n    // 클래스 파일 경로 (.class로 컴파일된 폴더)\r\n    String targetDir \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\gson-gson-parent-2.10.1\\\\gson-gson-parent-2.10.1\\\\gson\\\\target\\\\classes\";\r\n    // 결과 저장할 CSV 파일 경로\r\n    String outputCsv \u003d \"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_gson.csv\";\r\n    // (1) 기본 Soot 설정\r\n    Options.v().set_prepend_classpath(true);\r\n    Options.v().set_process_dir(Collections.singletonList(targetDir));\r\n    Options.v().set_whole_program(true);\r\n    // 출력 없음\r\n    Options.v().set_output_format(Options.output_format_none);\r\n    Options.v().set_no_bodies_for_excluded(true);\r\n    Options.v().set_allow_phantom_refs(true);\r\n    Options.v().set_keep_line_number(true);\r\n    Options.v().setPhaseOption(\"jb\", \"use-original-names:true\");\r\n    Scene.v().loadNecessaryClasses();\r\n    // (★) 이미 본 메서드 서명을 기억할 Set\r\n    Set\u003cString\u003e seen \u003d new HashSet\u003c\u003e();\r\n    // (2) 애플리케이션 클래스들 순회\r\n    try (CSVWriter writer \u003d new CSVWriter(new FileWriter(outputCsv))) {\r\n        // CSV 헤더 작성\r\n        writer.writeNext(new String[] { \"Class\", \"Method\", \"MethodSig\", \"Nodes\", \"Edges\", \"McCabe_CC\", \"StartLine\", \"EndLine\", \"LineCount\" });\r\n        List\u003cSootClass\u003e classes \u003d new ArrayList\u003c\u003e(Scene.v().getApplicationClasses());\r\n        for (SootClass cls : classes) {\r\n            for (SootMethod method : cls.getMethods()) {\r\n                if (!method.isConcrete())\r\n                    continue;\r\n                try {\r\n                    Body body \u003d method.retrieveActiveBody();\r\n                    // 기본 블록 단위\r\n                    BlockGraph cfg \u003d new BriefBlockGraph(body);\r\n                    int nodeCount \u003d cfg.size();\r\n                    int edgeCount \u003d 0;\r\n                    for (Block b : cfg) edgeCount +\u003d cfg.getSuccsOf(b).size();\r\n                    int cc \u003d edgeCount - nodeCount + 2;\r\n                    int startLine \u003d Integer.MAX_VALUE;\r\n                    int endLine \u003d Integer.MIN_VALUE;\r\n                    for (Unit unit : body.getUnits()) {\r\n                        int line \u003d unit.getJavaSourceStartLineNumber();\r\n                        if (line \u003e 0) {\r\n                            startLine \u003d Math.min(startLine, line);\r\n                            endLine \u003d Math.max(endLine, line);\r\n                        }\r\n                    }\r\n                    int lineCount \u003d (startLine \u003c\u003d endLine) ? (endLine - startLine + 1) : 0;\r\n                    if (!isTopLevelPublic(cls) || !isRealMethod(method))\r\n                        continue;\r\n                    if (nodeCount \u003d\u003d 0 || edgeCount \u003d\u003d 0)\r\n                        continue;\r\n                    if (cc \u003c\u003d 0)\r\n                        continue;\r\n                    String methodSig \u003d method.getSubSignature();\r\n                    String uniqueKey \u003d method.getSignature();\r\n                    // (★) 이미 기록된 서명이라면 건너뛰기\r\n                    if (!seen.add(uniqueKey))\r\n                        continue;\r\n                    // 결과를 CSV로 저장\r\n                    String[] row \u003d { cls.getName(), method.getName(), uniqueKey, String.valueOf(nodeCount), String.valueOf(edgeCount), String.valueOf(cc), String.valueOf(startLine), String.valueOf(endLine), String.valueOf(lineCount) };\r\n                    writer.writeNext(row);\r\n                } catch (Exception e) {\r\n                    System.out.printf(\"[⚠️ 오류] %s.%s: %s\\n\", cls.getName(), method.getName(), e.getMessage());\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"✅ 분석 완료: \" + outputCsv + \"에 저장됨\");\r\n    } catch (IOException e) {\r\n        System.err.println(\"❌ CSV 저장 중 오류: \" + e.getMessage());\r\n    }\r\n}",
    "nodes": 38,
    "edges": 49,
    "cc": 13,
    "flowSummary": [
      "B1 : If($z0 \u003d\u003d false) → B2 | else → B31",
      "B3 : If($z7 \u003d\u003d false) → B4 | else → B30",
      "B4 : If($z1 !\u003d 0) → B5 | else → B6",
      "B7 : If($z2 \u003d\u003d false) → B8 | else → B9",
      "B10 : If($z3 \u003d\u003d false) → B11 | else → B14",
      "B11 : If(i8 \u003c\u003d 0) → B12 | else → B13",
      "B14 : If(i6 \u003e i7) → B15 | else → B16",
      "B17 : If($z4 \u003d\u003d false) → B18 | else → B19",
      "B18 : If($z5 !\u003d 0) → B19 | else → B20",
      "B20 : If(i0 \u003d\u003d false) → B21 | else → B22",
      "B21 : If(i4 !\u003d 0) → B22 | else → B23",
      "B23 : If(i5 \u003e 0) → B24 | else → B25",
      "B25 : If($z6 !\u003d 0) → B26 | else → B27"
    ],
    "blockList": [
      "B0 {\n  String[]\n  $r0 \u003d Options.v()\n  $r0.set_prepend_classpath(1)\n  $r2 \u003d Options.v()\n  $r1 \u003d Collections.singletonList(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\javaBenchmark\\\\gson-gson-parent-2.10.1\\\\gson-gson-parent-2.10.1\\\\gson\\\\target\\\\classes\")\n  $r2.set_process_dir($r1)\n  $r3 \u003d Options.v()\n  $r3.set_whole_program(1)\n  $r4 \u003d Options.v()\n  $r4.set_output_format(12)\n  $r5 \u003d Options.v()\n  $r5.set_no_bodies_for_excluded(1)\n  $r6 \u003d Options.v()\n  $r6.set_allow_phantom_refs(1)\n  $r7 \u003d Options.v()\n  $r7.set_keep_line_number(1)\n  $r8 \u003d Options.v()\n  $r8.setPhaseOption(\"jb\", \"use-original-names:true\")\n  $r9 \u003d Scene.v()\n  $r9.loadNecessaryClasses()\n  $r10 \u003d HashSet\n  new HashSet()\n  $r11 \u003d CSVWriter\n  $r12 \u003d FileWriter\n  new FileWriter(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_gson.csv\")\n  new CSVWriter($r12)\n  $r13 \u003d String)[9]\n  $r13[0] \u003d \"Class\"\n  $r13[1] \u003d \"Method\"\n  $r13[2] \u003d \"MethodSig\"\n  $r13[3] \u003d \"Nodes\"\n  $r13[4] \u003d \"Edges\"\n  $r13[5] \u003d \"McCabe_CC\"\n  $r13[6] \u003d \"StartLine\"\n  $r13[7] \u003d \"EndLine\"\n  $r13[8] \u003d \"LineCount\"\n  $r11.writeNext($r13)\n  $r14 \u003d ArrayList\n  $r15 \u003d Scene.v()\n  $r16 \u003d $r15.getApplicationClasses()\n  new ArrayList($r16)\n  r52 \u003d $r14.iterator()\n}",
      "B1 {\n  $z0 \u003d r52.hasNext()\n  if ($z0 \u003d\u003d false) goto B2 else B31\n}",
      "B2 {\n  $r19 \u003d r52.next()\n  r20 \u003d SootClass) $r19\n  $r21 \u003d r20.getMethods()\n  r22 \u003d $r21.iterator()\n}",
      "B3 {\n  $z7 \u003d r22.hasNext()\n  if ($z7 \u003d\u003d false) goto B4 else B30\n}",
      "B4 {\n  $r23 \u003d r22.next()\n  r24 \u003d SootMethod) $r23\n  $z1 \u003d r24.isConcrete()\n  if ($z1 !\u003d 0) goto B5 else B6\n}",
      "B5 {\n  goto B3\n}",
      "B6 {\n  r53 \u003d r24.retrieveActiveBody()\n  $r25 \u003d BriefBlockGraph\n  new BriefBlockGraph(r53)\n  i0 \u003d $r25.size()\n  i4 \u003d 0\n  r54 \u003d $r25.iterator()\n}",
      "B7 {\n  $z2 \u003d r54.hasNext()\n  if ($z2 \u003d\u003d false) goto B8 else B9\n}",
      "B8 {\n  $r37 \u003d r54.next()\n  r55 \u003d Block) $r37\n  $r38 \u003d $r25.getSuccsOf(r55)\n  $i3 \u003d $r38.size()\n  i4 \u003d i4 + $i3\n  goto B7\n}",
      "B9 {\n  $i1 \u003d i4 - i0\n  i5 \u003d $i1 + 2\n  i6 \u003d 2147483647\n  i7 \u003d -2147483648\n  $r26 \u003d r53.getUnits()\n  r56 \u003d $r26.iterator()\n}",
      "B10 {\n  $z3 \u003d r56.hasNext()\n  if ($z3 \u003d\u003d false) goto B11 else B14\n}",
      "B11 {\n  $r36 \u003d r56.next()\n  r57 \u003d Unit) $r36\n  i8 \u003d r57.getJavaSourceStartLineNumber()\n  if (i8 \u003c\u003d 0) goto B12 else B13\n}",
      "B12 {\n  i6 \u003d Math.min(i6, i8)\n  i7 \u003d Math.max(i7, i8)\n}",
      "B13 {\n  goto B10\n}",
      "B14 {\n  if (i6 \u003e i7) goto B15 else B16\n}",
      "B15 {\n  $i2 \u003d i7 - i6\n  $i9 \u003d $i2 + 1\n  goto B17\n}",
      "B16 {\n  $i9 \u003d 0\n}",
      "B17 {\n  $z4 \u003d SootCFGAnalysis.isTopLevelPublic(r20)\n  if ($z4 \u003d\u003d false) goto B18 else B19\n}",
      "B18 {\n  $z5 \u003d SootCFGAnalysis.isRealMethod(r24)\n  if ($z5 !\u003d 0) goto B19 else B20\n}",
      "B19 {\n  goto B3\n}",
      "B20 {\n  if (i0 \u003d\u003d false) goto B21 else B22\n}",
      "B21 {\n  if (i4 !\u003d 0) goto B22 else B23\n}",
      "B22 {\n  goto B3\n}",
      "B23 {\n  if (i5 \u003e 0) goto B24 else B25\n}",
      "B24 {\n  goto B3\n}",
      "B25 {\n  r24.getSubSignature()\n  r58 \u003d r24.getSignature()\n  $z6 \u003d $r10.add(r58)\n  if ($z6 !\u003d 0) goto B26 else B27\n}",
      "B26 {\n  goto B3\n}",
      "B27 {\n  $r27 \u003d String)[9]\n  $r28 \u003d r20.getName()\n  $r27[0] \u003d $r28\n  $r29 \u003d r24.getName()\n  $r27[1] \u003d $r29\n  $r27[2] \u003d r58\n  $r30 \u003d String.valueOf(i0)\n  $r27[3] \u003d $r30\n  $r31 \u003d String.valueOf(i4)\n  $r27[4] \u003d $r31\n  $r32 \u003d String.valueOf(i5)\n  $r27[5] \u003d $r32\n  $r33 \u003d String.valueOf(i6)\n  $r27[6] \u003d $r33\n  $r34 \u003d String.valueOf(i7)\n  $r27[7] \u003d $r34\n  $r35 \u003d String.valueOf($i9)\n  $r27[8] \u003d $r35\n  $r11.writeNext($r27)\n  goto B29\n}",
      "B28 {\n  $r45 :\u003d @caughtexception\n  $r47 \u003d PrintStream out\u003e\n  $r46 \u003d Object)[3]\n  $r48 \u003d r20.getName()\n  $r46[0] \u003d $r48\n  $r49 \u003d r24.getName()\n  $r46[1] \u003d $r49\n  $r50 \u003d $r45.getMessage()\n  $r46[2] \u003d $r50\n  $r47.printf(\"\\u26a0\\ufe0f \\uc624\\ub958 %s.%s: %s\\n\", $r46)\n}",
      "B29 {\n  goto B3\n}",
      "B30 {\n  goto B1\n}",
      "B31 {\n  $r17 \u003d PrintStream out\u003e\n  $r18 \u003d dynInvoke makeConcatWithConstants(\"C:\\\\Users\\\\00000\\\\Desktop\\\\my\\\\cfg_analysis_all_result_gson.csv\")\n  $r17.println($r18)\n  $r11.close()\n  goto B35\n}",
      "B32 {\n  $r44 :\u003d @caughtexception\n  $r11.close()\n  goto B34\n}",
      "B33 {\n  $r43 :\u003d @caughtexception\n  $r44.addSuppressed($r43)\n}",
      "B34 {\n  throw $r44\n}",
      "B35 {\n  goto B37\n}",
      "B36 {\n  $r39 :\u003d @caughtexception\n  $r40 \u003d PrintStream err\u003e\n  $r41 \u003d $r39.getMessage()\n  $r42 \u003d dynInvoke makeConcatWithConstants($r41)\n  $r40.println($r42)\n}",
      "B37 {\n  return\n}"
    ],
    "blockEdges": [
      "B0 --\u003e B1",
      "B1 --\u003e B2",
      "B1 --\u003e B31",
      "B2 --\u003e B3",
      "B3 --\u003e B4",
      "B3 --\u003e B30",
      "B4 --\u003e B5",
      "B4 --\u003e B6",
      "B5 --\u003e B3",
      "B6 --\u003e B7",
      "B7 --\u003e B8",
      "B7 --\u003e B9",
      "B8 --\u003e B7",
      "B9 --\u003e B10",
      "B10 --\u003e B11",
      "B10 --\u003e B14",
      "B11 --\u003e B12",
      "B11 --\u003e B13",
      "B12 --\u003e B13",
      "B13 --\u003e B10",
      "B14 --\u003e B15",
      "B14 --\u003e B16",
      "B15 --\u003e B17",
      "B16 --\u003e B17",
      "B17 --\u003e B18",
      "B17 --\u003e B19",
      "B18 --\u003e B19",
      "B18 --\u003e B20",
      "B19 --\u003e B3",
      "B20 --\u003e B21",
      "B20 --\u003e B22",
      "B21 --\u003e B22",
      "B21 --\u003e B23",
      "B22 --\u003e B3",
      "B23 --\u003e B24",
      "B23 --\u003e B25",
      "B24 --\u003e B3",
      "B25 --\u003e B26",
      "B25 --\u003e B27",
      "B26 --\u003e B3",
      "B27 --\u003e B29",
      "B28 --\u003e B29",
      "B29 --\u003e B3",
      "B30 --\u003e B1",
      "B31 --\u003e B35",
      "B32 --\u003e B34",
      "B33 --\u003e B34",
      "B34 --\u003e [EXIT]",
      "B35 --\u003e B37",
      "B36 --\u003e B37",
      "B37 --\u003e [EXIT]"
    ],
    "depClasses": [],
    "depMethods": [
      {
        "name": "SootCFGAnalysis#isTopLevelPublic(...1)",
        "body": "{\r\n    return c.isPublic() \u0026\u0026 !c.getName().contains(\"$\") \u0026\u0026 !c.isInterface() \u0026\u0026 !c.isAbstract();\r\n}"
      },
      {
        "name": "SootCFGAnalysis#isRealMethod(...1)",
        "body": "{\r\n    // (1) 바디 없는 메서드는 제외\r\n    if (!m.isConcrete())\r\n        return false;\r\n    // (2) 생성자/클래스 초기화자 제외\r\n    if (m.isConstructor() || m.isStaticInitializer())\r\n        return false;\r\n    // (3) 컴파일러 생성 메서드 제외 (synthetic, bridge)\r\n    final int ACC_BRIDGE \u003d 0x0040;\r\n    final int ACC_SYNTHETIC \u003d 0x1000;\r\n    int mod \u003d m.getModifiers();\r\n    // (4) public 이 아닌 메서드 제외\r\n    if (!Modifier.isPublic(mod))\r\n        return false;\r\n    return (mod \u0026 ACC_BRIDGE) \u003d\u003d 0 \u0026\u0026 (mod \u0026 ACC_SYNTHETIC) \u003d\u003d 0;\r\n}"
      }
    ]
  }
]